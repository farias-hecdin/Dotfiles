local a={}local b={}a.setup=function(c)_G.MiniSurround=a;c=b.setup_config(c)b.apply_config(c)b.create_default_hl()end;a.config={custom_surroundings=nil,highlight_duration=500,mappings={add='sa',delete='sd',find='sf',find_left='sF',highlight='sh',replace='sr',update_n_lines='sn',suffix_last='l',suffix_next='n'},n_lines=20,respect_selection_type=false,search_method='cover',silent=false}a.add=function(d)if b.is_disabled()then return'<Esc>'end;local e=b.get_marks_pos(d)local f;if d=='visual'then f=b.get_surround_spec('output',false)else f=b.get_surround_spec('output',true)end;if f==nil then return'<Esc>'end;if not f.did_count then local g=b.cache.count or vim.v.count1;f.left,f.right=f.left:rep(g),f.right:rep(g)f.did_count=true end;local h=b.get_config().respect_selection_type;if not h or e.selection_type=='charwise'then b.region_replace({from={line=e.second.line,col=e.second.col+1}},f.right)b.region_replace({from=e.first},f.left)b.set_cursor(e.first.line,e.first.col+f.left:len())return end;if e.selection_type=='linewise'then local i,j=e.first.line,e.second.line;local k=b.get_range_indent(i,j)b.shift_indent('>',i,j)b.set_cursor_nonblank(i)vim.fn.append(j,k..f.right)vim.fn.append(i-1,k..f.left)return end;if e.selection_type=='blockwise'then local l,m=e.first.col,e.second.col;l,m=math.min(l,m),math.max(l,m)for n=e.first.line,e.second.line do b.region_replace({from={line=n,col=m+1}},f.right)b.region_replace({from={line=n,col=l}},f.left)end;b.set_cursor(e.first.line,l+f.left:len())return end end;a.delete=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;b.region_replace(o.right,{})b.region_replace(o.left,{})local p=o.left.from;b.set_cursor(p.line,p.col)if not b.get_config().respect_selection_type then return end;local i,j=o.left.from.line,o.right.from.line;local q=i<j and b.is_line_blank(i)and b.is_line_blank(j)if q then b.shift_indent('<',i,j)b.set_cursor_nonblank(i+1)local r=vim.api.nvim_get_current_buf()vim.fn.deletebufline(r,j)vim.fn.deletebufline(r,i)end end;a.replace=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;local s=b.get_surround_spec('output',true)if s==nil then return'<Esc>'end;b.region_replace(o.right,s.right)b.region_replace(o.left,s.left)local p=o.left.from;b.set_cursor(p.line,p.col+s.left:len())end;a.find=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;local t=b.surr_to_pos_array(o)local u=b.cache.direction or'right'b.cursor_cycle(t,u)vim.cmd('normal! zv')end;a.highlight=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;local c=b.get_config()local r=vim.api.nvim_get_current_buf()b.region_highlight(r,o.left)b.region_highlight(r,o.right)vim.defer_fn(function()b.region_unhighlight(r,o.left)b.region_unhighlight(r,o.right)end,c.highlight_duration)end;a.update_n_lines=function()if b.is_disabled()then return'<Esc>'end;local v=a.user_input('New number of neighbor lines',a.config.n_lines)v=math.floor(tonumber(v)or a.config.n_lines)a.config.n_lines=v end;a.user_input=function(w,x)local y=vim.on_key or vim.register_keystroke_callback;local z=false;y(function(A)if A==vim.api.nvim_replace_termcodes('<Esc>',true,true,true)then z=true end end,b.ns_id.input)local B={prompt='(mini.surround) '..w..': ',default=x or''}vim.cmd('echohl Question')local C,D=pcall(vim.fn.input,B)vim.cmd([[echohl None | echo '' | redraw]])y(nil,b.ns_id.input)if not C or z then return end;return D end;a.gen_spec={input={},output={}}a.gen_spec.input.treesitter=function(E,B)B=vim.tbl_deep_extend('force',{use_nvim_treesitter=true},B or{})E=b.prepare_captures(E)return function()local F=pcall(require,'nvim-treesitter')and pcall(require,'nvim-treesitter.query')local G=F and B.use_nvim_treesitter and b.get_matched_node_pairs_plugin or b.get_matched_node_pairs_builtin;local H=G(E)return vim.tbl_map(function(I)local J,K,L,M=I.outer:range()local N={line=J+1,col=K+1}local O={line=L+1,col=M}local P,Q;if I.inner==nil then P=O;Q=b.pos_to_right(O)O=nil else local R,S,T,U=I.inner:range()P={line=R+1,col=S+1}Q={line=T+1,col=U}P,Q=b.pos_to_left(P),b.pos_to_right(Q)end;return{left={from=N,to=P},right={from=Q,to=O}}end,H)end end;b.default_config=vim.deepcopy(a.config)b.ns_id={highlight=vim.api.nvim_create_namespace('MiniSurroundHighlight'),input=vim.api.nvim_create_namespace('MiniSurroundInput')}b.builtin_surroundings={['(']={input={'%b()','^.%s*().-()%s*.$'},output={left='( ',right=' )'}},[')']={input={'%b()','^.().*().$'},output={left='(',right=')'}},['[']={input={'%b[]','^.%s*().-()%s*.$'},output={left='[ ',right=' ]'}},[']']={input={'%b[]','^.().*().$'},output={left='[',right=']'}},['{']={input={'%b{}','^.%s*().-()%s*.$'},output={left='{ ',right=' }'}},['}']={input={'%b{}','^.().*().$'},output={left='{',right='}'}},['<']={input={'%b<>','^.%s*().-()%s*.$'},output={left='< ',right=' >'}},['>']={input={'%b<>','^.().*().$'},output={left='<',right='>'}},['?']={input=function()local V=a.user_input('Left surrounding')if V==nil or V==''then return end;local W=a.user_input('Right surrounding')if W==nil or W==''then return end;return{vim.pesc(V)..'().-()'..vim.pesc(W)}end,output=function()local V=a.user_input('Left surrounding')if V==nil then return end;local W=a.user_input('Right surrounding')if W==nil then return end;return{left=V,right=W}end},['b']={input={{'%b()','%b[]','%b{}'},'^.().*().$'},output={left='(',right=')'}},['f']={input={'%f[%w_%.][%w_%.]+%b()','^.-%(().*()%)$'},output=function()local X=a.user_input('Function name')if X==nil then return nil end;return{left=('%s('):format(X),right=')'}end},['t']={input={'<(%w-)%f[^<%w][^<>]->.-</%1>','^<.->().*()</[^/]->$'},output=function()local Y=a.user_input('Tag')if Y==nil then return nil end;local Z=Y:match('^%S*')return{left='<'..Y..'>',right='</'..Z..'>'}end},['q']={input={{"'.-'",'".-"','`.-`'},'^.().*().$'},output={left='"',right='"'}}}b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({custom_surroundings={c.custom_surroundings,'table',true},highlight_duration={c.highlight_duration,'number'},mappings={c.mappings,'table'},n_lines={c.n_lines,'number'},respect_selection_type={c.respect_selection_type,'boolean'},search_method={c.search_method,b.is_search_method},silent={c.silent,'boolean'}})vim.validate({['mappings.add']={c.mappings.add,'string'},['mappings.delete']={c.mappings.delete,'string'},['mappings.find']={c.mappings.find,'string'},['mappings.find_left']={c.mappings.find_left,'string'},['mappings.highlight']={c.mappings.highlight,'string'},['mappings.replace']={c.mappings.replace,'string'},['mappings.update_n_lines']={c.mappings.update_n_lines,'string'},['mappings.suffix_last']={c.mappings.suffix_last,'string'},['mappings.suffix_next']={c.mappings.suffix_next,'string'}})return c end;b.apply_config=function(c)a.config=c;local _=function(a0,a1,a2)b.map('n',a0,a1,{expr=true,desc=a2})end;local a3=c.mappings;_(a3.add,b.make_operator('add',nil,nil,true),'Add surrounding')_(a3.delete,b.make_operator('delete'),'Delete surrounding')_(a3.replace,b.make_operator('replace'),'Replace surrounding')_(a3.find,b.make_operator('find','right'),'Find right surrounding')_(a3.find_left,b.make_operator('find','left'),'Find left surrounding')_(a3.highlight,b.make_operator('highlight'),'Highlight surrounding')b.map('n',a3.update_n_lines,a.update_n_lines,{desc='Update `MiniSurround.config.n_lines`'})b.map('x',a3.add,[[:<C-u>lua MiniSurround.add('visual')<CR>]],{desc='Add surrounding to selection'})local a4=function(a0,a5,a1,a2)if a0==''then return end;_(a0 ..a5,a1,a2)end;if a3.suffix_last~=''then local a6=function(a7,a8)return b.make_operator(a7,a8,'prev')end;local a9=a3.suffix_last;a4(a3.delete,a9,a6('delete'),'Delete previous surrounding')a4(a3.replace,a9,a6('replace'),'Replace previous surrounding')a4(a3.find,a9,a6('find','right'),'Find previous right surrounding')a4(a3.find_left,a9,a6('find','left'),'Find previous left surrounding')a4(a3.highlight,a9,a6('highlight'),'Highlight previous surrounding')end;if a3.suffix_next~=''then local aa=function(a7,a8)return b.make_operator(a7,a8,'next')end;local a9=a3.suffix_next;a4(a3.delete,a9,aa('delete'),'Delete next surrounding')a4(a3.replace,a9,aa('replace'),'Replace next surrounding')a4(a3.find,a9,aa('find','right'),'Find next right surrounding')a4(a3.find_left,a9,aa('find','left'),'Find next left surrounding')a4(a3.highlight,a9,aa('highlight'),'Highlight next surrounding')end end;b.create_default_hl=function()vim.api.nvim_set_hl(0,'MiniSurround',{default=true,link='IncSearch'})end;b.is_disabled=function()return vim.g.minisurround_disable==true or vim.b.minisurround_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minisurround_config or{},c or{})end;b.is_search_method=function(ab,ac)ab=ab or b.get_config().search_method;ac=ac or'`config.search_method`'local ad=vim.tbl_keys(b.span_compare_methods)if vim.tbl_contains(ad,ab)then return true end;table.sort(ad)local ae=table.concat(vim.tbl_map(vim.inspect,ad),', ')local af=([[%s should be one of %s.]]):format(ac,ae)return false,af end;b.validate_search_method=function(ab,ac)local ag,af=b.is_search_method(ab,ac)if not ag then b.error(af)end end;b.make_operator=function(ah,a8,ai,aj)return function()if b.is_disabled()then return[[\<Esc>]]end;b.cache={count=vim.v.count1,direction=a8,search_method=ai}vim.o.operatorfunc='v:lua.MiniSurround.'..ah;return'<Cmd>echon ""<CR>g@'..(aj and''or' ')end end;b.get_surround_spec=function(ak,al)local D;if al then D=b.cache[ak]if D~=nil then return D end else b.cache={}end;local am=b.user_surround_id(ak)if am==nil then return nil end;D=b.make_surrounding_table()[am][ak]if vim.is_callable(D)then D=D()end;if not b.is_surrounding_info(D,ak)then return nil end;if b.is_composed_pattern(D)then D=vim.tbl_map(b.wrap_callable_table,D)end;D=setmetatable(D,{__index={id=am}})if al then b.cache[ak]=D end;return D end;b.make_surrounding_table=function()local an=vim.tbl_deep_extend('force',b.builtin_surroundings,b.get_config().custom_surroundings or{})for am,ao in pairs(an)do local ap=b.get_default_surrounding_info(am)an[am]=vim.tbl_deep_extend('force',ap,ao)end;return setmetatable(an,{__index=function(aq,A)return b.get_default_surrounding_info(A)end})end;b.get_default_surrounding_info=function(am)local ar=vim.pesc(am)return{input={ar..'().-()'..ar},output={left=am,right=am}}end;b.is_surrounding_info=function(ab,ak)if ak=='input'then return b.is_composed_pattern(ab)or b.is_region_pair(ab)or b.is_region_pair_array(ab)elseif ak=='output'then return type(ab)=='table'and type(ab.left)=='string'and type(ab.right)=='string'end end;b.is_region=function(ab)if type(ab)~='table'then return false end;local as=type(ab.from)=='table'and type(ab.from.line)=='number'and type(ab.from.col)=='number'local at=true;if ab.to~=nil then at=type(ab.to)=='table'and type(ab.to.line)=='number'and type(ab.to.col)=='number'end;return as and at end;b.is_region_pair=function(ab)if type(ab)~='table'then return false end;return b.is_region(ab.left)and b.is_region(ab.right)end;b.is_region_pair_array=function(ab)if not b.islist(ab)then return false end;for aq,au in ipairs(ab)do if not b.is_region_pair(au)then return false end end;return true end;b.is_composed_pattern=function(ab)if not(b.islist(ab)and#ab>0)then return false end;for aq,av in ipairs(ab)do local aw=type(av)if not(aw=='table'or aw=='string'or vim.is_callable(av))then return false end end;return true end;b.find_surrounding=function(ax,B)if ax==nil then return end;if b.is_region_pair(ax)then return ax end;B=vim.tbl_deep_extend('force',b.get_default_opts(),B or{})b.validate_search_method(B.search_method,'search_method')local ay=b.find_surrounding_region_pair(ax,B)if ay==nil then local af=([[No surrounding '%s%s' found within %d line%s and `config.search_method = '%s'`.]]):format(B.n_times>1 and B.n_times or'',ax.id,B.n_lines,B.n_lines>1 and's'or'',B.search_method)b.message(af)end;return ay end;b.find_surrounding_region_pair=function(ax,B)local az,aA,v=B.reference_region,B.n_times,B.n_lines;if aA==0 then return end;local aB=b.get_neighborhood(az,0)local aC=aB.region_to_span(az)local aD=function(aE)local D=b.find_best_match(aB,ax,aE,B)if D.span==nil then if v==0 or aB.n_neighbors>0 then return{}end;local aF=aB.span_to_region(aE)aB=b.get_neighborhood(az,v)aC=aB.region_to_span(az)aE=aB.region_to_span(aF)D=b.find_best_match(aB,ax,aE,B)end;return D end;local aG={span=aC}for aq=1,aA do aG=aD(aG.span)if aG.span==nil then return end end;local aH=function(aI,aJ)if type(aJ)=='table'then return aJ end;local aK=aB['1d']:sub(aI.from,aI.to-1)local aL=b.extract_surr_spans(aK,aJ)local aM=aI.from-1;local V,W=aL.left,aL.right;return{left={from=V.from+aM,to=V.to+aM},right={from=W.from+aM,to=W.to+aM}}end;local aN=aH(aG.span,aG.extract_pattern)local aO={from=aN.left.from,to=aN.right.to}if b.is_span_covering(aC,aO)then aG=aD(aG.span)if aG.span==nil then return end;aN=aH(aG.span,aG.extract_pattern)aO={from=aN.left.from,to=aN.right.to}if b.is_span_covering(aC,aO)then return end end;return{left=aB.span_to_region(aN.left),right=aB.span_to_region(aN.right)}end;b.get_default_opts=function()local c=b.get_config()local aP=vim.api.nvim_win_get_cursor(0)return{n_lines=c.n_lines,n_times=b.cache.count or vim.v.count1,reference_region={from={line=aP[1],col=aP[2]+1}},search_method=b.cache.search_method or c.search_method}end;b.prepare_captures=function(E)local aQ=function(ab)return type(ab)=='string'and ab:sub(1,1)=='@'end;if not(type(E)=='table'and aQ(E.outer)and aQ(E.inner))then b.error('Wrong format for `captures`. See `MiniSurround.gen_spec.input.treesitter()` for details.')end;return{outer=E.outer,inner=E.inner}end;b.get_matched_node_pairs_plugin=function(E)local aR=require('nvim-treesitter.query')local aS=require('nvim-treesitter.parsers')local aT={}local aU=aS.get_parser(0)if aU then aU:for_each_tree(function(aV,aW)local aX=aW:lang()local aY=aR.get_capture_matches(0,E.outer,'textobjects',aV:root(),aX)for aq,a3 in pairs(aY)do a3.lang=aX end;vim.list_extend(aT,aY)end)end;return vim.tbl_map(function(aZ)local a_=aZ.node;local b0=aR.get_capture_matches(0,E.inner,'textobjects',a_,aZ.lang)local b1=vim.tbl_map(function(ab)return ab.node end,b0)return{outer=a_,inner=b.get_biggest_node(b1)}end,aT)end;b.get_matched_node_pairs_builtin=function(E)local aX=vim.bo.filetype;local C,aU=pcall(vim.treesitter.get_parser,0,aX)if not C then b.error_treesitter('parser',aX)end;local b2=vim.fn.has('nvim-0.9')==1 and vim.treesitter.query.get or vim.treesitter.get_query;local b3=b2(aX,'textobjects')if b3==nil then b.error_treesitter('query',aX)end;local b4,b5=E.outer:sub(2),E.inner:sub(2)local b6={}for aq,aV in ipairs(aU:trees())do vim.list_extend(b6,b.get_builtin_matched_nodes(b4,aV:root(),b3))end;return vim.tbl_map(function(a_)local b1=b.get_builtin_matched_nodes(b5,a_,b3)return{outer=a_,inner=b.get_biggest_node(b1)}end,b6)end;b.get_builtin_matched_nodes=function(b7,b8,b3)local D={}for b9,ba,aq in b3:iter_captures(b8,0)do if b3.captures[b9]==b7 then table.insert(D,ba)end end;return D end;b.get_biggest_node=function(bb)local bc,bd=nil,-math.huge;for aq,ba in ipairs(bb)do local aq,aq,be=ba:start()local aq,aq,bf=ba:end_()local bg=bf-be+1;if bd<bg then bc,bd=ba,bg end end;return bc end;b.error_treesitter=function(bh,aX)local bi=vim.api.nvim_get_current_buf()local af=string.format([[Can not get %s for buffer %d and language '%s'.]],bh,bi,aX)b.error(af)end;b.find_best_match=function(bj,ax,aC,B)local bk,bl,bm;local bn=function(aI)if b.is_better_span(aI,bk,aC,B)then bk=aI;bl=bm end end;if b.is_region_pair_array(ax)then for aq,ay in ipairs(ax)do local bo={from=ay.left.from,to=ay.right.to or ay.right.from}if bj.is_region_inside(bo)then bm={{left=bj.region_to_span(ay.left),right=bj.region_to_span(ay.right)}}bn(bj.region_to_span(bo))end end else for aq,bp in ipairs(b.cartesian_product(ax))do bm=bp;b.iterate_matched_spans(bj['1d'],bp,bn)end end;local aJ;if bl~=nil then aJ=bl[#bl]end;return{span=bk,extract_pattern=aJ}end;b.iterate_matched_spans=function(bq,bp,bn)local br=#bp;local bs={}local bt;bt=function(bu,bv,bw)local bx=bp[bu]local by=function(aK,bz)return b.string_find(aK,bx,bz)end;if vim.is_callable(bx)then by=bx end;local bA=type(bx)=='string'and bx:match('^%%b(.)%1$')~=nil;local bz=1;while bz<=bv:len()do local p,bB=by(bv,bz)if p==nil then break end;if bu==br then local bC=b.new_span(p+bw,bB+bw)local bD=string.format('%s_%s',bC.from,bC.to)if not bs[bD]then bn(bC)bs[bD]=true end else local bE=bv:sub(p,bB)local bF=bw+p-1;bt(bu+1,bE,bF)end;bz=(bA and bB or p)+1 end end;bt(1,bq,0)end;b.new_span=function(p,bB)return{from=p,to=bB==nil and p or bB+1}end;b.is_better_span=function(bG,bH,bI,B)if b.is_span_covering(bI,bG)or b.is_span_equal(bG,bI)then return false end;return b.span_compare_methods[B.search_method](bG,bH,bI)end;b.span_compare_methods={cover=function(bG,bH,bI)local D=b.is_better_covering_span(bG,bH,bI)if D~=nil then return D end;return false end,cover_or_next=function(bG,bH,bI)local D=b.is_better_covering_span(bG,bH,bI)if D~=nil then return D end;if not b.is_span_on_left(bI,bG)then return false end;if bH==nil then return true end;local bJ=b.span_distance.next;return bJ(bG,bI)<bJ(bH,bI)end,cover_or_prev=function(bG,bH,bI)local D=b.is_better_covering_span(bG,bH,bI)if D~=nil then return D end;if not b.is_span_on_left(bG,bI)then return false end;if bH==nil then return true end;local bJ=b.span_distance.prev;return bJ(bG,bI)<bJ(bH,bI)end,cover_or_nearest=function(bG,bH,bI)local D=b.is_better_covering_span(bG,bH,bI)if D~=nil then return D end;if bH==nil then return true end;local bJ=b.span_distance.near;return bJ(bG,bI)<bJ(bH,bI)end,next=function(bG,bH,bI)if b.is_span_covering(bG,bI)then return false end;if not b.is_span_on_left(bI,bG)then return false end;if bH==nil then return true end;local bJ=b.span_distance.next;return bJ(bG,bI)<bJ(bH,bI)end,prev=function(bG,bH,bI)if b.is_span_covering(bG,bI)then return false end;if not b.is_span_on_left(bG,bI)then return false end;if bH==nil then return true end;local bJ=b.span_distance.prev;return bJ(bG,bI)<bJ(bH,bI)end,nearest=function(bG,bH,bI)if b.is_span_covering(bG,bI)then return false end;if bH==nil then return true end;local bJ=b.span_distance.near;return bJ(bG,bI)<bJ(bH,bI)end}b.span_distance={next=function(bK,bL)return math.abs(bK.from-bL.from)end,prev=function(bK,bL)return math.abs(bK.to-bL.to)end,near=function(bK,bL)return math.min(math.abs(bK.from-bL.from),math.abs(bK.to-bL.to))end}b.is_better_covering_span=function(bG,bH,bI)local bM=b.is_span_covering(bG,bI)local bN=b.is_span_covering(bH,bI)if bM and bN then return bG.to-bG.from<bH.to-bH.from end;if bM and not bN then return true end;if not bM and bN then return false end;return nil end;b.is_span_covering=function(aI,bO)if aI==nil or bO==nil then return false end;if aI.from==aI.to then return aI.from==bO.from and bO.to==aI.to end;if bO.from==bO.to then return aI.from<=bO.from and bO.to<aI.to end;return aI.from<=bO.from and bO.to<=aI.to end;b.is_span_equal=function(bK,bL)if bK==nil or bL==nil then return false end;return bK.from==bL.from and bK.to==bL.to end;b.is_span_on_left=function(bK,bL)if bK==nil or bL==nil then return false end;return bK.from<=bL.from and bK.to<=bL.to end;b.is_point_inside_spans=function(bP,bQ)for aq,aI in ipairs(bQ)do if aI[1]<=bP and bP<=aI[2]then return true end end;return false end;b.get_marks_pos=function(d)local bR,bS;if d=='visual'then bR,bS='<','>'else bR,bS='[',']'end;local bT=vim.api.nvim_buf_get_mark(0,bR)local bU=vim.api.nvim_buf_get_mark(0,bS)local bV=b.get_selection_type(d)if bV=='linewise'then local aq,bW=vim.fn.getline(bT[1]):find('^%s*')bT[2]=bW;bU[2]=vim.fn.getline(bU[1]):find('%s*$')-2 end;bT[2],bU[2]=bT[2]+1,bU[2]+1;if d=='visual'and vim.o.selection=='exclusive'then bU[2]=bU[2]-1 else local bX=vim.fn.getline(bU[1])local bY=vim.str_utfindex(bX,math.min(#bX,bU[2]))bU[2]=vim.str_byteindex(bX,bY)end;return{first={line=bT[1],col=bT[2]},second={line=bU[1],col=bU[2]},selection_type=bV}end;b.get_selection_type=function(d)if d=='char'or d=='visual'and vim.fn.visualmode()=='v'then return'charwise'end;if d=='line'or d=='visual'and vim.fn.visualmode()=='V'then return'linewise'end;if d=='block'or d=='visual'and vim.fn.visualmode()=='\22'then return'blockwise'end end;b.set_cursor=function(bq,bZ)vim.api.nvim_win_set_cursor(0,{bq,bZ-1})end;b.set_cursor_nonblank=function(bq)b.set_cursor(bq,1)vim.cmd('normal! ^')end;b.compare_pos=function(bT,bU)if bT.line<bU.line then return'<'end;if bT.line>bU.line then return'>'end;if bT.col<bU.col then return'<'end;if bT.col>bU.col then return'>'end;return'='end;b.cursor_cycle=function(t,u)local aP=vim.api.nvim_win_get_cursor(0)aP={line=aP[1],col=aP[2]+1}local b_,c0,c1,c2;for aq,c3 in pairs(t)do b_=b.compare_pos(aP,c3)c0=b_=='>'and u=='left'c1=c2==nil and b_=='<'and u=='right'if c0 or c1 then c2=c3 end end;c2=c2 or(u=='right'and t[1]or t[#t])b.set_cursor(c2.line,c2.col)end;b.user_surround_id=function(ak)local c4=true;vim.defer_fn(function()if not c4 then return end;local af=string.format('Enter %s surrounding identifier (single character) ',ak)b.echo(af)b.cache.msg_shown=true end,1000)local C,am=pcall(vim.fn.getcharstr)c4=false;b.unecho()if not C or am=='\27'then return nil end;if am:find('^[%w%p%s]$')==nil then b.message('Input must be single character: alphanumeric, punctuation, or space.')return nil end;return am end;b.pos_to_left=function(c3)if c3.line==1 and c3.col==1 then return{line=c3.line,col=c3.col}end;if c3.col==1 then return{line=c3.line-1,col=b.get_line_cols(c3.line-1)}end;return{line=c3.line,col=c3.col-1}end;b.pos_to_right=function(c3)local c5=b.get_line_cols(c3.line)if c3.line==vim.api.nvim_buf_line_count(0)and c3.col>c5 then return{line=c3.line,col=c5}end;if c3.col>c5 then return{line=c3.line+1,col=1}end;return{line=c3.line,col=c3.col+1}end;b.region_replace=function(c6,x)local c7,c8=c6.from.line-1,c6.from.col-1;local c9,ca;if b.region_is_empty(c6)then c9,ca=c7,c8 else c9,ca=c6.to.line-1,c6.to.col;if c9<vim.api.nvim_buf_line_count(0)and b.get_line_cols(c9+1)<ca then c9,ca=c9+1,0 end end;if type(x)=='string'then x={x}end;if#x>0 then x=vim.split(table.concat(x,'\n'),'\n')end;pcall(vim.api.nvim_buf_set_text,0,c7,c8,c9,ca,x)end;b.surr_to_pos_array=function(o)local D={}local cb=function(c3,cc)if c3==nil then return end;if b.get_line_cols(c3.line)<c3.col and c3.col>1 then c3=cc=='left'and b.pos_to_left(c3)or b.pos_to_right(c3)end;local bq,bZ=c3.line,c3.col;local cd=D[#D]if not(cd~=nil and cd.line==bq and cd.col==bZ)then table.insert(D,{line=bq,col=bZ})end end;if not b.region_is_empty(o.left)then cb(o.left.from,'right')cb(o.left.to,'right')end;if not b.region_is_empty(o.right)then cb(o.right.from,'left')cb(o.right.to,'left')end;return D end;b.region_highlight=function(r,c6)if b.region_is_empty(c6)then return end;local ce=b.ns_id.highlight;local i,l,j,m=c6.from.line-1,c6.from.col-1,c6.to.line-1,c6.to.col;vim.highlight.range(r,ce,'MiniSurround',{i,l},{j,m})end;b.region_unhighlight=function(r,c6)local ce=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(r,ce,c6.from.line-1,(c6.to or c6.from).line)end;b.region_is_empty=function(c6)return c6.to==nil end;b.get_range_indent=function(i,j)local cf,cg=math.huge,nil;local ch=vim.api.nvim_buf_get_lines(0,i-1,j,true)local ci,cj;for aq,ck in ipairs(ch)do aq,ci,cj=ck:find('^(%s*)')if ci<cf and ci<ck:len()then cf,cg=ci,cj end end;return cg or''end;b.shift_indent=function(cl,i,j)if j<i then return end;vim.cmd('silent '..i..','..j..cl)end;b.is_line_blank=function(cm)return vim.fn.nextnonblank(cm)~=cm end;b.extract_surr_spans=function(aK,aJ)local cn={aK:match(aJ)}local co=true;for aq,c3 in ipairs(cn)do if type(c3)~='number'then co=false end end;local cp=co and(#cn==2 or#cn==4)if not cp then local af='Could not extract proper positions (two or four empty captures) from '..string.format([[string '%s' with extraction pattern '%s'.]],aK,aJ)b.error(af)end;if#cn==2 then return{left=b.new_span(1,cn[1]-1),right=b.new_span(cn[2],aK:len())}end;return{left=b.new_span(cn[1],cn[2]-1),right=b.new_span(cn[3],cn[4]-1)}end;b.get_neighborhood=function(az,cq)local i,j=az.from.line,(az.to or az.from).line;local cr=math.max(1,i-cq)local cs=math.min(vim.api.nvim_buf_line_count(0),j+cq)local ct=vim.api.nvim_buf_get_lines(0,cr-1,cs,false)for cu,au in pairs(ct)do ct[cu]=au..'\n'end;local cv=table.concat(ct,'')local cw=function(c3)if c3==nil then return nil end;local cm=cr;local cx=0;while cm<c3.line do cx=cx+ct[cm-cr+1]:len()cm=cm+1 end;return cx+c3.col end;local cy=function(cx)if cx==nil then return nil end;local cm=1;local cz=0;while cm<=#ct and cz+ct[cm]:len()<cx do cz=cz+ct[cm]:len()cm=cm+1 end;return{line=cr+cm-1,col=cx-cz}end;local cA=function(c6)if c6==nil then return nil end;local cB=c6.to==nil;local bB=c6.to or c6.from;return{from=cw(c6.from),to=cw(bB)+(cB and 0 or 1)}end;local cC=function(aI)if aI==nil then return nil end;local D={from=cy(aI.from)}if aI.from<aI.to then D.to=cy(aI.to-1)end;return D end;local cD=function(c6)local D=cr<=c6.from.line;if c6.to~=nil then D=D and c6.to.line<=cs end;return D end;return{n_neighbors=cq,region=az,['1d']=cv,['2d']=ct,pos_to_offset=cw,offset_to_pos=cy,region_to_span=cA,span_to_region=cC,is_region_inside=cD}end;b.echo=function(af,cE)if b.get_config().silent then return end;af=type(af)=='string'and{{af}}or af;table.insert(af,1,{'(mini.surround) ','WarningMsg'})local cF=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local cG,cH={},0;for aq,cI in ipairs(af)do local cJ={vim.fn.strcharpart(cI[1],0,cF-cH),cI[2]}table.insert(cG,cJ)cH=cH+vim.fn.strdisplaywidth(cJ[1])if cH>=cF then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(cG,cE,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(af)b.echo(af,true)end;b.error=function(af)error(string.format('(mini.surround) %s',af))end;b.map=function(d,a0,a1,B)if a0==''then return end;B=vim.tbl_deep_extend('force',{silent=true},B or{})vim.keymap.set(d,a0,a1,B)end;b.get_line_cols=function(cm)return vim.fn.getline(cm):len()end;b.string_find=function(aK,bx,bz)bz=bz or 1;if bx:sub(1,1)=='^'then if bz>1 then return nil end;return string.find(aK,bx)end;local cK,aq,cL=string.find(bx,'(.)%.%-')local cM=cK~=nil and cL~='%'if not cM then return string.find(aK,bx,bz)end;local p,bB=string.find(aK,bx,bz)if p==nil then return end;local cN,cO=p,bB;while cO==bB do p,bB=cN,cO;cN,cO=string.find(aK,bx,cN+1)end;return p,bB end;b.cartesian_product=function(cP)if not(type(cP)=='table'and#cP>0)then return{}end;cP=vim.tbl_map(function(ab)return b.islist(ab)and ab or{ab}end,cP)local D,cQ={},{}local bt;bt=function(bu)for n=1,#cP[bu]do table.insert(cQ,cP[bu][n])if bu==#cP then table.insert(D,b.tbl_flatten(cQ))else bt(bu+1)end;table.remove(cQ,#cQ)end end;bt(1)return D end;b.wrap_callable_table=function(ab)if vim.is_callable(ab)and type(ab)=='table'then return function(...)return ab(...)end end;return ab end;b.islist=vim.fn.has('nvim-0.10')==1 and vim.islist or vim.tbl_islist;b.tbl_flatten=vim.fn.has('nvim-0.10')==1 and function(ab)return vim.iter(ab):flatten(math.huge):totable()end or vim.tbl_flatten;return a
