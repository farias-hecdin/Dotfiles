local a={}local b={}local c=table.unpack or unpack;local unpack=function(d,e,f)return c(d,e or 1,f or d.n or#d)end;local g=function(...)return{n=select("#",...),...}end;a.pack=g;a.unpack=unpack;function a.deepcompare(h,i,j,k,l,m)local n=type(h)local o=type(i)if n~='table'or o~='table'then return h==i end;local p=debug.getmetatable(h)local q=debug.getmetatable(i)if p and p==q and p.__eq then if not j then return h==i end else if rawequal(h,i)then return true end end;k=k or{{},{}}l,m=l or 1,m or 1;k[1][h]=k[1][h]or 0;k[2][i]=k[2][i]or 0;if k[1][h]==1 or k[2][i]==1 then l=k[1][h]+1;m=k[2][i]+1 end;if k[1][h]>l and k[2][i]>m then return true end;k[1][h]=k[1][h]+1;k[2][i]=k[2][i]+1;for r,s in next,h do local t=i[r]if t==nil then return false,{r}end;local u,v=a.deepcompare(s,t,nil,k,l,m)if not u then v=v or{}table.insert(v,r)return false,v end end;for w,x in next,i do if h[w]==nil then return false,{w}end end;k[1][h]=k[1][h]-1;k[2][i]=k[2][i]-1;return true end;function a.shallowcopy(d)if type(d)~="table"then return d end;local y={}setmetatable(y,getmetatable(d))for z,A in next,d do y[z]=A end;return y end;function a.deepcopy(d,B,C)local D=require'luassert.spy'if type(d)~="table"then return d end;local y={}local C=C or{}if C[d]then return C[d]end;C[d]=y;for z,A in next,d do y[z]=D.is_spy(A)and A or a.deepcopy(A,B,C)end;if B then debug.setmetatable(y,a.deepcopy(debug.getmetatable(d),false,C))else debug.setmetatable(y,debug.getmetatable(d))end;return y end;function a.copyargs(E)local y={}setmetatable(y,getmetatable(E))local F=require'luassert.match'local D=require'luassert.spy'for z,A in pairs(E)do y[z]=(F.is_matcher(A)or D.is_spy(A))and A or a.deepcopy(A)end;return{vals=y,refs=a.shallowcopy(E)}end;function a.cleararglist(G)for H=G.n,1,-1 do a.tremove(G,H)end;G.n=nil end;local function I(E,J,K)local F=require'luassert.match'for H,L in pairs(E)do local M=K[H]if F.is_matcher(M)then if F.is_ref_matcher(M)then L=J[H]end;if not M(L)then return false end elseif M==nil or not a.deepcompare(L,M)then return false end end;for H,M in pairs(K)do local L=E[H]if L==nil then if F.is_matcher(M)then if not M(L)then return false end else return false end end end;return true end;function a.matchargs(N,K)assert(not a.is_arglist(N),"expected a list of arglist-object, got an arglist")for O=#N,1,-1 do local P=N[O]if I(P.vals,P.refs,K)then return P end end;return nil end;function a.matchoncalls(Q,E)for x,R in ipairs(Q)do if I(E,E,R.vals)then return R end end;return nil end;function a.tinsert(...)local E={...}local S=select('#',...)local d=E[1]local T=E[2]local P=E[3]if S<3 then P=T;T=nil end;d.n=(d.n or#d)+1;if not T then T=d.n elseif T>d.n then d[T]=P;d.n=T end;for e=d.n,T+1,-1 do d[e]=d[e-1]end;d[T]=P end;function a.tremove(d,T)d.n=d.n or#d;if not T then T=d.n elseif T>d.n then local U=d[T]d[T]=nil;return U end;local U=d[T]for e=T,d.n do d[e]=d[e+1]end;d[d.n]=nil;d.n=d.n-1;return U end;function a.callable(V)return type(V)=="function"or type((debug.getmetatable(V)or{}).__call)=="function"end;function a.hastostring(V)return type(V)=="string"or type((debug.getmetatable(V)or{}).__tostring)=="function"end;function a.errorlevel(W)local W=(W or 1)+1;local X=debug.getinfo(W)local Y=(X or{}).source;local Z=Y;while Z and(Z==Y or Y=="=(tail call)")do W=W+1;X=debug.getinfo(W)Y=(X or{}).source end;if W>1 then W=W-1 end;return W end;function a.extract_keys(_,a0)local a1=require'luassert.namespaces'local a2={}local a3=nil;local e=#a0;while e>0 do local a4=a0[e]a3=a3 and a4 ..'_'..a3 or a4;local a5=e>1 and a0[e-1]..'_'..a3 or nil;while e>1 and a5 and a1[_][a5]do a3=a5;e=e-1;a4=a0[e]a5=a4 ..'_'..a3 end;if a1.modifier[a3]or a1[_][a3]then table.insert(a2,1,a3)a3=nil end;e=e-1 end;if a3 then error("luassert: unknown modifier/".._..": '"..a3 .."'",a.errorlevel(2))end;return a2 end;function a.make_arglist(...)local G={...}G.n=select('#',...)return setmetatable(G,b)end;function a.is_arglist(V)return getmetatable(V)==b end;return a
