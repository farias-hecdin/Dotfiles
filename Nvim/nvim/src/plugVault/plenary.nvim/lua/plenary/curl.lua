local a,b={},{}local c=require"plenary.functional"local d=require"plenary.job"local e=require"plenary.path"local f=require"plenary.compat"a.url_encode=function(g)if type(g)~="number"then g=g:gsub("\r?\n","\r\n")g=g:gsub("([^%w%-%.%_%~ ])",function(h)return string.format("%%%02X",h:byte())end)g=g:gsub(" ","+")return g else return g end end;a.kv_to_list=function(i,j,k)return f.flatten(c.kv_map(function(l)return{j,l[1]..k..l[2]}end,i))end;a.kv_to_str=function(i,k,m)return c.join(c.kv_map(function(l)return l[1]..m..a.url_encode(l[2])end,i),k)end;a.gen_dump_path=function()local n;local o=string.gsub("xxxx4xxx","[xy]",function(p)local q=p=="x"and math.random(0,0xf)or math.random(0,0xb)return string.format("%x",q)end)if e.path.sep=="\\"then n=string.format("%s\\AppData\\Local\\Temp\\plenary_curl_%s.headers",os.getenv"USERPROFILE",o)else local r=os.getenv"XDG_RUNTIME_DIR"or"/tmp"n=r.."/plenary_curl_"..o..".headers"end;return{"-D",n}end;b.headers=function(s)if not s then return end;local t=function(g)return string.gsub(" "..g,"%W%l",string.upper):sub(2)end;return a.kv_to_list((function()local u={}for v,q in pairs(s)do u[t(v:gsub("_","%-"))]=q end;return u end)(),"-H",": ")end;b.data_body=function(s)if not s then return end;return a.kv_to_list(s,"-d","=")end;b.raw_body=function(w)if not w then return end;if type(w)=="table"then return b.data_body(w)else return{"--data-raw",w}end end;b.form=function(s)if not s then return end;return a.kv_to_list(s,"-F","=")end;b.curl_query=function(s)if not s then return end;return a.kv_to_str(s,"&","=")end;b.method=function(x)if not x then return end;if x~="head"then return{"-X",string.upper(x)}else return{"-I"}end end;b.file=function(y)if not y then return end;return{"-d","@"..e.expand(e.new(y))}end;b.auth=function(w)if not w then return end;return{"-u",type(w)=="table"and a.kv_to_str(w,nil,":")or w}end;b.url=function(w,z)if not w then return end;z=b.curl_query(z)if type(w)=="string"then return z and w.."?"..z or w elseif type(w)=="table"then error"Low level URL definition is not supported."end end;b.accept_header=function(x)if not x then return end;return{"-H","Accept: "..x}end;b.http_version=function(x)if not x then return end;if x=="HTTP/0.9"or x=="HTTP/1.0"or x=="HTTP/1.1"or x=="HTTP/2"or x=="HTTP/3"then x=x:lower()x=x:gsub("/","")return{"--"..x}else error"Unknown HTTP version."end end;b.request=function(A)if A.body then local B=A.body;local C=function()local D,E=pcall(e.is_file,e.new(B))return D and E end;A.body=nil;if type(B)=="table"then A.data=B elseif C()then A.in_file=B elseif type(B)=="string"then A.raw_body=B end end;local E={"-sSL",A.dump}local F=function(q)if q then table.insert(E,q)end end;if A.insecure then table.insert(E,"--insecure")end;if A.proxy then table.insert(E,{"--proxy",A.proxy})end;if A.compressed then table.insert(E,"--compressed")end;F(b.method(A.method))F(b.headers(A.headers))F(b.accept_header(A.accept))F(b.raw_body(A.raw_body))F(b.data_body(A.data))F(b.form(A.form))F(b.file(A.in_file))F(b.auth(A.auth))F(b.http_version(A.http_version))F(A.raw)if A.output then table.insert(E,{"-o",A.output})end;table.insert(E,b.url(A.url,A.query))return f.flatten(E),A end;b.response=function(G,H,I)local J=e.readlines(H)local D=tonumber(string.match(J[1],"([%w+]%d+)"))local K=c.join(G,"\n")vim.loop.fs_unlink(H)table.remove(J,1)return{status=D,headers=J,body=K,exit=I}end;local L=function(M)local N={}local O,A=b.request(vim.tbl_extend("force",{compressed=package.config:sub(1,1)~="\\",dry_run=false,dump=a.gen_dump_path()},M))if A.dry_run then return O end;local P={command=vim.g.plenary_curl_bin_path or"curl",args=O}if A.stream then P.on_stdout=A.stream end;P.on_exit=function(Q,I)if I~=0 then local R=vim.inspect(Q:stderr_result())local S=string.format("%s %s - curl error exit_code=%s stderr=%s",A.method,A.url,I,R)if A.on_error then return A.on_error{message=S,stderr=R,exit=I}else error(S)end end;local T=b.response(Q:result(),A.dump[2],I)if A.callback then return A.callback(T)else N=T end end;local U=d:new(P)if A.callback or A.stream then U:start()return U else local V=A.timeout or 10000;U:sync(V)return N end end;return(function()local W={}local X=function(Y)return function(Z,A)A=A or{}if type(Z)=="table"then A=Z;W.method=Y else W.url=Z;W.method=Y end;A=Y=="request"and A or vim.tbl_extend("keep",A,W)return L(A)end end;return{get=X"get",post=X"post",put=X"put",head=X"head",patch=X"patch",delete=X"delete",request=X"request"}end)()
