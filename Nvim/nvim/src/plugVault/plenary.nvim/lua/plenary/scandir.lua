local a=require"plenary.path"local b=a.path.sep;local c=require"plenary.functional"local d=require"plenary.compat"local e=vim.loop;local f={}local g=function(h)local i={}local j=false;for k,l in ipairs(h)do local m=a:new(l..b..".gitignore")if m:exists()then j=true;i[l]={ignored={},negated={}}for n in m:iter()do local o=n:sub(1,1)local p=o=="!"if p then n=n:sub(2)o=n:sub(1,1)end;if o=="/"then n=l..n end;if not(o==""or o=="#")then local q=vim.trim(n)q=q:gsub("%-","%%-")q=q:gsub("%.","%%.")q=q:gsub("/%*%*/","/%%w+/")q=q:gsub("%*%*","")q=q:gsub("%*","%%w+")q=q:gsub("%?","%%w")if q~=""then table.insert(p and i[l].negated or i[l].ignored,q)end end end end end;if not j then return nil end;return function(r,s)for k,l in ipairs(r)do if s:find(l,1,true)then local p=false;for k,t in ipairs(i[l].ignored)do if not p and s:match(t)then for k,u in ipairs(i[l].negated)do if not p and s:match(u)then p=true end end;if not p then return false end end end end end;return true end end;f.__make_gitignore=g;local v=function(w,s,x)for k,l in ipairs(w)do if s:find(l,1,true)then local y=s:sub(#l+1,-1)y=y:sub(1,1)==b and y:sub(2,-1)or y;local k,z=y:gsub(b,"")if x<=z+1 then return nil end end end;return s end;local A=function(B)if type(B)=="string"then return function(s)return s:match(B)end elseif type(B)=="table"then return function(s)for k,l in ipairs(B)do if s:match(l)then return true end end;return false end elseif type(B)=="function"then return B end end;local C=function(D,E,F,G,H,r,I,J,K)if D.hidden or E:sub(1,1)~="."then if F=="directory"then local s=G..b..E;if D.depth then table.insert(H,v(r,s,D.depth))else table.insert(H,s)end;if D.add_dirs or D.only_dirs then if not J or J(r,s.."/")then if not K or K(s)then table.insert(I,s)if D.on_insert then D.on_insert(s,F)end end end end elseif not D.only_dirs then local s=G..b..E;if not J or J(r,s)then if not K or K(s)then table.insert(I,s)if D.on_insert then D.on_insert(s,F)end end end end end end;f.scan_dir=function(L,D)D=D or{}local I={}local w=d.flatten{L}local H=d.flatten{L}local M=D.respect_gitignore and g(w)or nil;local N=D.search_pattern and A(D.search_pattern)or nil;for O=#w,1,-1 do if e.fs_access(w[O],"X")==false then if not c.if_nil(D.silent,false,D.silent)then print(string.format("%s is not accessible by the current user!",w[O]))end;table.remove(w,O)end end;if#w==0 then return{}end;repeat local G=table.remove(H,1)local P=e.fs_scandir(G)if P then while true do local E,F=e.fs_scandir_next(P)if E==nil then break end;C(D,E,F,G,H,w,I,M,N)end end until#H==0;return I end;f.scan_dir_async=function(L,D)D=D or{}local I={}local w=d.flatten{L}local H=d.flatten{L}local G=table.remove(H,1)local M=D.respect_gitignore and g(w)or nil;local N=D.search_pattern and A(D.search_pattern)or nil;for O=#w,1,-1 do if e.fs_access(w[O],"X")==false then if not c.if_nil(D.silent,false,D.silent)then print(string.format("%s is not accessible by the current user!",w[O]))end;table.remove(w,O)end end;if#w==0 then return{}end;local Q;Q=function(R,P)if not R then while true do local E,F=e.fs_scandir_next(P)if E==nil then break end;C(D,E,F,G,H,w,I,M,N)end;if#H==0 then if D.on_exit then D.on_exit(I)end else G=table.remove(H,1)e.fs_scandir(G,Q)end end end;e.fs_scandir(G,Q)end;local S=(function()local T=function(U)local V,O=0,1;while U~=0 do V=V+U%8*O;U=math.floor(U/8)O=O*10 end;return V end;local W={[1]="p",[2]="c",[4]="d",[6]="b",[10]=".",[12]="l",[14]="s"}local X={[0]="---","--x","-w-","-wx","r--","r-x","rw-","rwx"}local Y={4,2,1}return function(Z,_)if Z[_]then return Z[_]end;local V=string.format("%6d",T(_))local a0=V:sub(#V-3,-1)local a1=tonumber(a0:sub(1,1))local a2=W[tonumber(V:sub(1,2))]or"-"for O=2,#a0 do a2=a2 ..X[tonumber(a0:sub(O,O))]if a1-Y[O-1]>=0 then a2=a2:sub(1,-2)..(Y[O-1]==1 and"T"or"S")a1=a1-Y[O-1]end end;Z[_]=a2;return a2 end end)()local a3=(function()local a4={"","K","M","G","T","P","E","Z"}return function(a5)for k,l in ipairs(a4)do if math.abs(a5)<1024.0 then if math.abs(a5)>9 then return string.format("%3d%s",a5,l)else return string.format("%3.1f%s",a5,l)end end;a5=a5/1024.0 end;return string.format("%.1f%s",a5,"Y")end end)()local a6=(function()local a7=os.date"%Y"return function(a8)if a7~=os.date("%Y",a8)then return os.date("%b %d  %Y",a8)end;return os.date("%b %d %H:%M",a8)end end)()local a9=(function()local aa=function(ab,ac)if not ab then return ac end;if ab[ac]then return ab[ac]end;ab[ac]=tostring(ac)return ac end;if jit and b~="\\"then local ad=require"ffi"ad.cdef[[
      typedef unsigned int __uid_t;
      typedef __uid_t uid_t;
      typedef unsigned int __gid_t;
      typedef __gid_t gid_t;

      typedef struct {
        char *pw_name;
        char *pw_passwd;
        __uid_t pw_uid;
        __gid_t pw_gid;
        char *pw_gecos;
        char *pw_dir;
        char *pw_shell;
      } passwd;

      passwd *getpwuid(uid_t uid);
    ]]local ae=function(ab,ac)if ab[ac]then return ab[ac]end;local af=ad.C.getpwuid(ac)local E;if af==nil then E=tostring(ac)else E=ad.string(af.pw_name)end;ab[ac]=E;return E end;local ag=pcall(ae,{},1000)if ag then return ae else return aa end else return aa end end)()local ah=(function()local aa=function(ab,ac)if not ab then return ac end;if ab[ac]then return ab[ac]end;ab[ac]=tostring(ac)return ac end;if jit and b~="\\"then local ad=require"ffi"ad.cdef[[
      typedef unsigned int __gid_t;
      typedef __gid_t gid_t;

      typedef struct {
        char *gr_name;
        char *gr_passwd;
        __gid_t gr_gid;
        char **gr_mem;
      } group;
      group *getgrgid(gid_t gid);
    ]]local ae=function(ab,ac)if ab[ac]then return ab[ac]end;local af=ad.C.getgrgid(ac)local E;if af==nil then E=tostring(ac)else E=ad.string(af.gr_name)end;ab[ac]=E;return E end;local ag=pcall(ae,{},1000)if ag then return ae else return aa end else return aa end end)()local ai=function(ab)if not ab then return 0 end;local aj=0;for k,l in pairs(ab)do if#l>aj then aj=#l end end;return aj end;local ak=function(I,L,D)if not I or#I==0 then return{},{}end;local al=function(am,an)if am:sub(1,1)=="l"then local ao=e.fs_realpath(L..b..an)if not ao then return an end;if ao:sub(1,#L)==L then ao=ao:sub(#L+2,-1)end;return string.format("%s -> %s",an,ao)end;return an end;local ap,aq={},{}local ar=b~="\\"and{}or nil;local as=b~="\\"and{}or nil;local at,au={},{}for k,l in ipairs(I)do local av=e.fs_lstat(l)if av then at[l]=av;a9(ar,av.uid)ah(as,av.gid)end end;local aw=(function()if not ar and not as then local ax={[5]=2,[6]=0}return function(...)local ay={...}local az={{start_index=01,end_index=11},{start_index=12,end_index=17}}local aA=19;for aB=5,6 do local l=ax[aB]local aC=aA+#ay[aB]table.insert(az,{start_index=aA,end_index=aC})aA=aC+l end;table.insert(aq,az)table.insert(ap,string.format("%10s %5s  %s  %s",ay[1],ay[2],ay[5],al(ay[1],ay[6])))end else local aD=ai(ar)local aE=ai(as)local ax={[3]={max=aD,add=1},[4]={max=aE,add=2},[5]={add=2},[6]={add=0}}local aF="%10s %5s %-"..aD.."s %-"..aE.."s  %s  %s"return function(...)local ay={...}local az={{start_index=01,end_index=11},{start_index=12,end_index=17}}local aA=18;for aB=3,6 do local l=ax[aB]local aC=aA+#ay[aB]table.insert(az,{start_index=aA,end_index=aC})if l.max then aA=aA+l.max+l.add else aA=aC+l.add end end;table.insert(aq,az)table.insert(ap,string.format(aF,ay[1],ay[2],ay[3],ay[4],ay[5],al(ay[1],ay[6])))end end end)()for E,av in pairs(at)do aw(S(au,av.mode),a3(av.size),a9(ar,av.uid),ah(as,av.gid),a6(av.mtime.sec),E:sub(#L+2,-1))end;if D and D.group_directories_first then local aG={}local aH={}for aB,l in ipairs(ap)do if l:sub(1,1)=="d"then table.insert(aG,l)table.insert(aH,aq[aB])end end;for aB,l in ipairs(ap)do if l:sub(1,1)~="d"then table.insert(aG,l)table.insert(aH,aq[aB])end end;return aG,aH else return ap,aq end end;f.ls=function(L,D)D=D or{}D.depth=D.depth or 1;D.add_dirs=D.add_dirs or true;local I=f.scan_dir(L,D)return ak(I,L,D)end;f.ls_async=function(L,D)D=D or{}D.depth=D.depth or 1;D.add_dirs=D.add_dirs or true;local aI=vim.deepcopy(D)aI.on_exit=function(I)if D.on_exit then D.on_exit(ak(I,L,aI))end end;f.scan_dir_async(L,aI)end;return f
