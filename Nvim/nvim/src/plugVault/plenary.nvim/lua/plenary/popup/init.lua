local a=require"plenary.window.border"local b=require"plenary.window"local c=require"plenary.popup.utils"local d=vim.F.if_nil;local e={}e._pos_map={topleft="NW",topright="NE",botleft="SW",botright="SE"}e._hidden={}e._borders={}local function f(g,h,i)if g[h]==nil then return i[h]else return g[h]end end;e._callbacks={}local function j(k,l,m)m=m or{}local n=function(o,p)assert(string.find(o,"^cursor"),"Invalid value for "..p)k.relative="cursor"local q=0;if o:match"cursor%+(%d+)"then q=q+tonumber(o:match"cursor%+(%d+)")elseif o:match"cursor%-(%d+)"then q=q-tonumber(o:match"cursor%-(%d+)")end;return q end;local r=d(l.width,m.width)local s=d(l.height,m.height)k.width=c.bounded(r,l.minwidth,l.maxwidth)k.height=c.bounded(s,l.minheight,l.maxheight)if l.line and l.line~=0 then if type(l.line)=="string"then k.row=n(l.line,"row")else k.row=l.line-1 end else k.row=math.floor((vim.o.lines-k.height)/2)end;if l.col and l.col~=0 then if type(l.col)=="string"then k.col=n(l.col,"col")else k.col=l.col-1 end else k.col=math.floor((vim.o.columns-k.width)/2)end;if l.pos then if l.pos=="center"then l.line=0;l.col=0;k.anchor="NW"else k.anchor=e._pos_map[l.pos]end else k.anchor="NW"end end;function e.create(t,l)l=vim.deepcopy(l)local u;if type(t)=="number"then u=t else u=vim.api.nvim_create_buf(false,true)assert(u,"Failed to create buffer")vim.api.nvim_buf_set_option(u,"bufhidden","wipe")vim.api.nvim_buf_set_option(u,"modifiable",true)if type(t)=="string"then t={t}else assert(type(t)=="table",'"what" must be a table')end;if l.padding then local v,w,x,y;if vim.tbl_isempty(l.padding)then v=1;w=1;x=1;y=1 else local z=l.padding;v=z[1]or 0;w=z[2]or 0;x=z[3]or 0;y=z[4]or 0 end;local A=string.rep(" ",y)local B=string.rep(" ",w)for C=1,#t do t[C]=string.format("%s%s%s",A,t[C],B)end;for D=1,v do table.insert(t,1,"")end;for D=1,x do table.insert(t,"")end end;vim.api.nvim_buf_set_lines(u,0,-1,true,t)end;local E={posinvert=true,zindex=50}l.width=d(l.width,1)if type(t)=="number"then l.height=vim.api.nvim_buf_line_count(t)else for D,F in ipairs(t)do l.width=math.max(l.width,#F)end;l.height=#t end;local k={}k.relative="editor"k.style="minimal"j(k,l,{width=1,height=1})if f(l,"posinvert",E)then if k.anchor=="NW"or k.anchor=="NE"then if k.row+k.height>vim.o.lines and k.row*2>vim.o.lines then k.row=k.row-k.height-2 end elseif k.anchor=="SW"or k.anchor=="SE"then if k.row-k.height<0 and k.row*2<vim.o.lines then k.row=k.row+k.height+2 end end end;local G=f(l,"zindex",E)k.zindex=c.bounded(G,1,32000)k.noautocmd=d(l.noautocmd,true)k.focusable=d(l.focusable,false)local H;if l.hidden then assert(false,"I have not implemented this yet and don't know how")else H=vim.api.nvim_open_win(u,false,k)end;if l.moved then if l.moved=="any"then vim.lsp.util.close_preview_autocmd({"CursorMoved","CursorMovedI"},H)end else local I=false;vim.cmd(string.format("autocmd BufDelete %s <buffer=%s> ++once ++nested :lua require('plenary.window').try_close(%s, true)",I and"<silent>"or"",u,H))end;if l.time then local J=vim.loop.new_timer()J:start(l.time,0,vim.schedule_wrap(function()b.try_close(H,false)end))end;if l.cursorline then vim.api.nvim_win_set_option(H,"cursorline",true)end;if l.wrap~=nil then if l.noautocmd then vim.cmd(string.format("noautocmd lua vim.api.nvim_set_option(%s, wrap, %s)",H,l.wrap))else vim.api.nvim_win_set_option(H,"wrap",l.wrap)end end;local K=nil;local L={}if l.border then K=true;if type(l.border)=="boolean"or vim.tbl_isempty(l.border)then L.border_thickness=a._default_thickness elseif#l.border==4 then L.border_thickness={top=c.bounded(l.border[1],0,1),right=c.bounded(l.border[2],0,1),bot=c.bounded(l.border[3],0,1),left=c.bounded(l.border[4],0,1)}else error(string.format("Invalid configuration for border: %s",vim.inspect(l.border)))end elseif l.border==false then K=false end;if(K==nil or K)and l.borderchars then K=true;local M,N,O,P,Q,R,S,T;if l.borderchars==nil then M,N,O,P,Q,R,S,T="═","║","═","║","╔","╗","╝","╚"elseif#l.borderchars==1 then local U=l.borderchars[1]M,N,O,P,Q,R,S,T=U,U,U,U,U,U,U,U elseif#l.borderchars==2 then local U=l.borderchars[1]local V=l.borderchars[2]M,N,O,P,Q,R,S,T=U,U,U,U,V,V,V,V elseif#l.borderchars==8 then M,N,O,P,Q,R,S,T=unpack(l.borderchars)else error(string.format'Not enough arguments for "borderchars"')end;L.top=M;L.bot=O;L.right=N;L.left=P;L.topleft=Q;L.topright=R;L.botright=S;L.botleft=T end;if l.title then L.title=l.title end;local W=nil;if K then L.focusable=l.border_focusable;L.highlight=l.borderhighlight and string.format("Normal:%s",l.borderhighlight)L.titlehighlight=l.titlehighlight;W=a:new(u,H,k,L)e._borders[H]=W end;if l.highlight then vim.api.nvim_win_set_option(H,"winhl",string.format("Normal:%s,EndOfBuffer:%s",l.highlight,l.highlight))end;local X=l.enter;if X==nil then X=true end;if X then if l.noautocmd then vim.cmd("noautocmd lua vim.api.nvim_set_current_win("..H..")")else vim.api.nvim_set_current_win(H)end end;if l.callback then e._callbacks[u]=function()local Y,D=unpack(vim.api.nvim_win_get_cursor(H))l.callback(H,t[Y])vim.api.nvim_win_close(H,true)end;vim.api.nvim_buf_set_keymap(u,"n","<CR>",'<cmd>lua require"plenary.popup".execute_callback('..u..")<CR>",{noremap=true})end;if l.finalize_callback then l.finalize_callback(H,u)end;return H,{win_id=H,border=W}end;function e.move(H,l)local k={}k.relative="editor"local Z=vim.api.nvim_win_get_position(H)local m={width=vim.api.nvim_win_get_width(H),height=vim.api.nvim_win_get_height(H),row=Z[1],col=Z[2]}j(k,l,m)vim.api.nvim_win_set_config(H,k)local W=e._borders[H]if W~=nil then W:move(k,W._border_win_options)end end;function e.execute_callback(u)if e._callbacks[u]then local _=e._callbacks[u]_()e._callbacks[u]=nil end end;return e
