local a={}local b={}a.setup=function(c)_G.MiniHipatterns=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands()for d,e in ipairs(vim.api.nvim_list_wins())do b.auto_enable({buf=vim.api.nvim_win_get_buf(e)})end;b.create_default_hl()end;a.config={highlighters={},delay={text_change=200,scroll=50}}a.enable=function(f,c)f=b.validate_buf_id(f)c=b.validate_config_arg(c)if b.is_buf_enabled(f)then return end;b.update_cache(f,c)vim.api.nvim_buf_attach(f,false,{on_lines=function(d,d,d,g,d,h)local i=b.cache[f]if i==nil then return true end;b.process_lines(f,g+1,h,i.delay.text_change)end,on_reload=function()pcall(a.update,f)end,on_detach=function()a.disable(f)end})local j=vim.api.nvim_create_augroup('MiniHipatternsBuffer'..f,{clear=true})b.cache[f].augroup=j;local k=vim.schedule_wrap(function()if not b.is_buf_enabled(f)then return end;b.update_cache(f,c)local l=b.cache[f].delay.text_change;b.process_lines(f,1,vim.api.nvim_buf_line_count(f),l)end)vim.api.nvim_create_autocmd({'BufWinEnter','FileType'},{group=j,buffer=f,callback=k,desc='Update highlighting for whole buffer'})vim.api.nvim_create_autocmd('WinScrolled',{group=j,buffer=f,callback=b.update_view,desc='Update highlighting in view'})b.process_lines(f,1,vim.api.nvim_buf_line_count(f),0)end;a.disable=function(f)f=b.validate_buf_id(f)local i=b.cache[f]if i==nil then return end;b.cache[f]=nil;vim.api.nvim_del_augroup_by_id(i.augroup)for d,m in pairs(b.ns_id)do b.clear_namespace(f,m,0,-1)end end;a.toggle=function(f,c)f=b.validate_buf_id(f)c=b.validate_config_arg(c)if b.is_buf_enabled(f)then a.disable(f)else a.enable(f,c)end end;a.update=function(f,g,h)f=b.validate_buf_id(f)if not b.is_buf_enabled(f)then b.error(string.format('Buffer %d is not enabled.',f))end;g=g or 1;if type(g)~='number'then b.error('`from_line` should be a number.')end;h=h or vim.api.nvim_buf_line_count(f)if type(h)~='number'then b.error('`to_line` should be a number.')end;b.process_lines(f,g,h,0)end;a.get_enabled_buffers=function()local n={}for f,d in pairs(b.cache)do if vim.api.nvim_buf_is_valid(f)then table.insert(n,f)else b.cache[f]=nil end end;table.sort(n)return n end;a.get_matches=function(f,o)f=(f==nil or f==0)and vim.api.nvim_get_current_buf()or f;if not(type(f)=='number'and vim.api.nvim_buf_is_valid(f))then b.error('`buf_id` is not valid buffer identifier.')end;local p=b.get_all_highlighters()o=o or p;if not b.islist(o)then b.error('`highlighters` should be an array.')end;o=vim.tbl_filter(function(q)return vim.tbl_contains(p,q)end,o)local r=function(s,t)return s[2]<t[2]or s[2]==t[2]and s[3]<t[3]end;local n={}for d,u in ipairs(o)do local v=b.get_extmarks(f,b.ns_id[u],0,-1,{details=true})table.sort(v,r)for d,w in ipairs(v)do local x,y=w[4].end_row,w[4].end_col;x=type(x)=='number'and x+1 or x;y=type(y)=='number'and y+1 or y;local z={bufnr=f,highlighter=u,lnum=w[2]+1,col=w[3]+1,end_lnum=x,end_col=y,hl_group=w[4].hl_group}table.insert(n,z)end end;return n end;a.gen_highlighter={}a.gen_highlighter.hex_color=function(A)local B={style='full',priority=200,filter=b.always_true,inline_text='â–ˆ'}A=vim.tbl_deep_extend('force',B,A or{})local C=A.style;if C=='inline'and vim.fn.has('nvim-0.10')==0 then b.error('Style "inline" in `gen_highlighter.hex_color()` requires Neovim>=0.10.')end;local D=C=='#'and'()#()%x%x%x%x%x%x%f[%X]'or'#%x%x%x%x%x%x%f[%X]'local E=({full='bg',['#']='bg',line='line',inline='fg'})[C]or'bg'local F={priority=A.priority}if A.style=='inline'then local G,H=A.priority,A.inline_text;F=function(d,d,I)local J={{H,I.hl_group}}return{virt_text=J,virt_text_pos='inline',priority=G,right_gravity=false}end end;return{pattern=b.wrap_pattern_with_filter(D,A.filter),group=function(d,d,I)return a.compute_hex_color_group(I.full_match,E)end,extmark_opts=F}end;a.compute_hex_color_group=function(K,C)C=C or'bg'local L=K:lower():sub(2)local M=string.format('MiniHipatterns_%s_%s',L,C)if b.hex_color_groups[M]then return M end;if C=='bg'then local N=b.compute_opposite_color(L)vim.api.nvim_set_hl(0,M,{fg=N,bg=K})end;if C=='fg'then vim.api.nvim_set_hl(0,M,{fg=K})end;if C=='line'then vim.api.nvim_set_hl(0,M,{sp=K,underline=true})end;b.hex_color_groups[M]=true;return M end;b.default_config=vim.deepcopy(a.config)b.timer_debounce=vim.loop.new_timer()b.timer_view=vim.loop.new_timer()b.ns_id={}b.change_queue={}b.cache={}b.hex_color_groups={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({highlighters={c.highlighters,'table'},delay={c.delay,'table'}})vim.validate({['delay.text_change']={c.delay.text_change,'number'},['delay.scroll']={c.delay.scroll,'number'}})return c end;b.apply_config=function(c)a.config=c end;b.create_autocommands=function()local j=vim.api.nvim_create_augroup('MiniHipatterns',{})local O=function(P,D,Q,R)vim.api.nvim_create_autocmd(P,{group=j,pattern=D,callback=Q,desc=R})end;O('BufEnter','*',b.auto_enable,'Enable highlighting')O('ColorScheme','*',b.on_colorscheme,'Reload all enabled pattern highlighters')end;b.create_default_hl=function()vim.api.nvim_set_hl(0,'MiniHipatternsFixme',{default=true,link='DiagnosticError'})vim.api.nvim_set_hl(0,'MiniHipatternsHack',{default=true,link='DiagnosticWarn'})vim.api.nvim_set_hl(0,'MiniHipatternsTodo',{default=true,link='DiagnosticInfo'})vim.api.nvim_set_hl(0,'MiniHipatternsNote',{default=true,link='DiagnosticHint'})end;b.is_disabled=function(f)local S=b.get_buf_var(f,'minihipatterns_disable')return vim.g.minihipatterns_disable==true or S==true end;b.get_config=function(c,f)local T=b.get_buf_var(f,'minihipatterns_config')or{}return vim.tbl_deep_extend('force',a.config,T,c or{})end;b.get_buf_var=function(f,U)if not vim.api.nvim_buf_is_valid(f)then return nil end;return vim.b[f or 0][U]end;b.auto_enable=vim.schedule_wrap(function(I)if b.is_buf_enabled(I.buf)then return end;if vim.api.nvim_buf_is_valid(I.buf)and vim.bo[I.buf].buftype==''then a.enable(I.buf)end end)b.update_view=vim.schedule_wrap(function(I)local i=b.cache[I.buf]if i==nil then return end;b.timer_view:stop()b.timer_view:start(i.delay.scroll,0,b.process_view)end)b.on_colorscheme=function()b.hex_color_groups={}for f,d in pairs(b.cache)do a.disable(f)a.enable(f)end end;b.validate_buf_id=function(q)if q==nil or q==0 then return vim.api.nvim_get_current_buf()end;if not(type(q)=='number'and vim.api.nvim_buf_is_valid(q))then b.error('`buf_id` should be `nil` or valid buffer id.')end;return q end;b.validate_config_arg=function(q)if q==nil or type(q)=='table'then return q or{}end;b.error('`config` should be `nil` or table.')end;b.validate_string=function(q,U)if type(q)=='string'then return q end;b.error(string.format('`%s` should be string.'))end;b.is_buf_enabled=function(f)return b.cache[f]~=nil end;b.update_cache=function(f,c)local i=b.cache[f]or{}local T=b.get_config(c,f)i.highlighters=b.normalize_highlighters(T.highlighters)i.delay=T.delay;b.cache[f]=i end;b.normalize_highlighters=function(o)local n={}for V,W in pairs(o)do local D=type(W.pattern)=='string'and function()return W.pattern end or W.pattern;if vim.is_callable(D)then D={D}end;local X=b.islist(D)if X then for Y,Z in ipairs(D)do D[Y]=type(Z)=='string'and function()return Z end or Z;X=X and vim.is_callable(D[Y])end end;local _=type(W.group)=='string'and function()return W.group end or W.group;local a0=type(W.priority)=='number'if a0 then local a1='`priority` field of highlighter is soft deprecated.'..' Use `extmark_opts = { priority = <value> }`.'..' This works for now but will be removed after the next stable release.'vim.notify_once(a1,vim.log.levels.WARN)end;local F=W.extmark_opts or{priority=a0 and W.priority or 200}if type(F)=='table'then local a2=F;F=function(d,d,I)local A=vim.deepcopy(a2)A.hl_group=A.hl_group or I.hl_group;A.end_row=A.end_row or I.line-1;A.end_col=A.end_col or I.to_col;return A end end;if X and vim.is_callable(_)and vim.is_callable(F)then n[V]={pattern=D,group=_,extmark_opts=F}b.ns_id[V]=vim.api.nvim_create_namespace('MiniHipatterns-'..V)end end;return n end;b.get_all_highlighters=function()local a3=vim.tbl_map(function(q)return{q,tostring(q)}end,vim.tbl_keys(b.ns_id))table.sort(a3,function(s,t)return s[2]<t[2]end)return vim.tbl_map(function(q)return q[1]end,a3)end;b.process_lines=vim.schedule_wrap(function(f,g,h,l)table.insert(b.change_queue,{f,math.min(g,h),math.max(g,h)})b.timer_debounce:stop()b.timer_debounce:start(l,0,b.process_change_queue)end)b.process_view=vim.schedule_wrap(function()table.insert(b.change_queue,{vim.api.nvim_get_current_buf(),vim.fn.line('w0'),vim.fn.line('w$')})b.process_change_queue()end)b.process_change_queue=vim.schedule_wrap(function()local a4=b.normalize_change_queue()for f,a5 in pairs(a4)do b.process_buffer_changes(f,a5)end;b.change_queue={}end)b.normalize_change_queue=function()local n={}for d,a6 in ipairs(b.change_queue)do local f=a6[1]local a7=n[f]or{}for Y=a6[2],a6[3]do a7[Y]=true end;n[f]=a7 end;return n end;b.process_buffer_changes=vim.schedule_wrap(function(f,a5)local i=b.cache[f]if not vim.api.nvim_buf_is_valid(f)or b.is_disabled(f)or i==nil then return end;for V,W in pairs(i.highlighters)do local m=b.ns_id[V]for a8,d in pairs(a5)do b.clear_namespace(f,m,a8-1,a8)end;for d,D in ipairs(W.pattern)do b.apply_highlighter_pattern(D(f),W,f,m,a5)end end end)b.apply_highlighter_pattern=vim.schedule_wrap(function(D,W,f,m,a5)if type(D)~='string'then return end;local _,F=W.group,W.extmark_opts;local a9=D:sub(1,1)=='^'for a8,d in pairs(a5)do local aa=b.get_line(f,a8)local ab,ac,ad,ae=aa:find(D)while ab and ab<=ac do local af=aa:sub(ab,ac)ad,ae=ad or ab,ae or ac+1;ae=ae-1;local ag=aa:sub(ad,ae)local I={full_match=af,line=a8,from_col=ad,to_col=ae}local ah=_(f,ag,I)if ah~=nil then I.hl_group=ah;b.set_extmark(f,m,a8-1,ad-1,F(f,ag,I))end;if a9 then break end;ab,ac,ad,ae=aa:find(D,ac+1)end end end)b.wrap_pattern_with_filter=function(D,ai)return function(...)if not ai(...)then return nil end;return D end end;b.compute_opposite_color=function(L)local aj=tonumber(L,16)local t=b.correct_channel(math.fmod(aj,256)/255)local ak=b.correct_channel(math.fmod((aj-t)/256,256)/255)local al=b.correct_channel(math.floor(aj/65536)/255)local am=0.4122214708*al+0.5363325363*ak+0.0514459929*t;local an=0.2119034982*al+0.6806995451*ak+0.1073969566*t;local ao=0.0883024619*al+0.2817188376*ak+0.6299787005*t;local ap,aq,ar=b.cuberoot(am),b.cuberoot(an),b.cuberoot(ao)local as=b.correct_lightness(0.2104542553*ap+0.7936177850*aq-0.0040720468*ar)return as<0.5 and'#ffffff'or'#000000'end;b.correct_channel=function(q)return 0.04045<q and math.pow((q+0.055)/1.055,2.4)or q/12.92 end;b.correct_lightness=function(q)local at,au=0.206,0.03;local av=(1+at)/(1+au)return 0.5*(av*q-at+math.sqrt((av*q-at)^2+4*au*av*q))end;b.error=function(a1)error(string.format('(mini.hipatterns) %s',a1),0)end;b.get_line=function(f,aw)return vim.api.nvim_buf_get_lines(f,aw-1,aw,false)[1]or''end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.get_extmarks=function(...)local ax,n=pcall(vim.api.nvim_buf_get_extmarks,...)if not ax then return{}end;return n end;b.clear_namespace=function(...)pcall(vim.api.nvim_buf_clear_namespace,...)end;b.always_true=function()return true end;b.cuberoot=function(q)return math.pow(q,0.333333)end;b.islist=vim.fn.has('nvim-0.10')==1 and vim.islist or vim.tbl_islist;return a
