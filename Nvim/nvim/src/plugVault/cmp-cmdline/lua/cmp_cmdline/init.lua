local a=require('cmp')local function b(c,d)local e=[[\%(]]..table.concat(c,[[\|]])..[[\)]]if d then e='^'..e end;return vim.regex(e)end;local f={treat_trailing_slash=true,ignore_cmds={'Man','!'}}local g=b({[=[\s*abo\%[veleft]\s*]=],[=[\s*bel\%[owright]\s*]=],[=[\s*bo\%[tright]\s*]=],[=[\s*bro\%[wse]\s*]=],[=[\s*conf\%[irm]\s*]=],[=[\s*hid\%[e]\s*]=],[=[\s*keepal\s*t]=],[=[\s*keeppa\%[tterns]\s*]=],[=[\s*lefta\%[bove]\s*]=],[=[\s*loc\%[kmarks]\s*]=],[=[\s*nos\%[wapfile]\s*]=],[=[\s*rightb\%[elow]\s*]=],[=[\s*sil\%[ent]\s*]=],[=[\s*tab\s*]=],[=[\s*to\%[pleft]\s*]=],[=[\s*verb\%[ose]\s*]=],[=[\s*vert\%[ical]\s*]=]},true)local h=b({[=[\s*\%(\d\+\|\$\)\%[,\%(\d\+\|\$\)]\s*]=],[=[\s*'\%[<,'>]\s*]=],[=[\s*\%(\d\+\|\$\)\s*]=]},true)local i=b({[=[^\s*\%(\d\+\|\$\)\%[,\%(\d\+\|\$\)]\s*$]=],[=[^\s*'\%[<,'>]\s*$]=],[=[^\s*\%(\d\+\|\$\)\s*$]=]},true)local j=b({[=[se\%[tlocal][^=]*$]=]},true)local function k(l)local m,n=pcall(function()return vim.opt[l]:get()end)if m then return type(n)=='boolean'end end;local o={{ctype='cmdline',regex=[=[[^[:blank:]]*$]=],kind=a.lsp.CompletionItemKind.Variable,isIncomplete=true,exec=function(p,q,r,s)if not s and i:match_str(r)then return{}end;local t,u=pcall(function()local v=r;local w,x=h:match_str(v)if w and x then v=v:sub(x+1)end;return vim.api.nvim_parse_cmd(v,{})or{}end)u=u or{}if vim.tbl_contains(p.ignore_cmds,u.cmd)then return{}end;if q~=r then while true do local w,x=g:match_str(r)if w==nil then break end;r=string.sub(r,x+1)end end;local y;do local z=vim.regex([[\h\w*$]]):match_str(q)y=string.sub(q,1,z or#q)end;local A=j:match_str(r)~=nil;local B={}local C=r:gsub([[\\]],[[\\\\]])for t,D in ipairs(vim.fn.getcompletion(C,'cmdline'))do local l=type(D)=='string'and D or D.word;local E={label=l}table.insert(B,E)if A and k(l)then table.insert(B,vim.tbl_deep_extend('force',{},E,{label='no'..l,filterText=l}))end end;for t,E in ipairs(B)do if not string.find(E.label,y,1,true)then E.label=y..E.label end end;if p.treat_trailing_slash then for t,E in ipairs(B)do local F=string.match(E.label,[[/$]])F=F and not string.match(E.label,[[~/$]])F=F and not string.match(E.label,[[%./$]])F=F and not string.match(E.label,[[%.%./$]])if F then E.label=E.label:sub(1,-2)end end end;return B end}}local G={}G.new=function()return setmetatable({before_line='',offset=-1,ctype='',items={}},{__index=G})end;G.get_keyword_pattern=function()return[=[[^[:blank:]]*]=]end;G.get_trigger_characters=function()return{' ','.','#','-'}end;G.complete=function(self,H,I)local J=0;local K=''local B={}local L;local M=false;for t,N in ipairs(o)do local w,x=vim.regex(N.regex):match_str(H.context.cursor_before_line)if w and x then J=w;K=N.ctype;B=N.exec(vim.tbl_deep_extend('keep',H.option or{},f),string.sub(H.context.cursor_before_line,w+1),H.context.cursor_before_line,H.context:get_reason()==a.ContextReason.Manual)L=N.kind;M=N.isIncomplete;if not(#B==0 and N.fallback)then break end end end;local O={}for t,E in ipairs(B)do E.kind=L;O[E.label]=true end;local P=false;if#H.context.cursor_before_line>#self.before_line then P=string.find(H.context.cursor_before_line,self.before_line,1,true)==1 elseif#H.context.cursor_before_line<#self.before_line then P=string.find(self.before_line,H.context.cursor_before_line,1,true)==1 end;if P and self.offset==J and self.ctype==K then for t,E in ipairs(self.items)do if not O[E.label]then table.insert(B,E)end end end;self.before_line=H.context.cursor_before_line;self.offset=J;self.ctype=K;self.items=B;I({isIncomplete=M,items=B})end;return G
