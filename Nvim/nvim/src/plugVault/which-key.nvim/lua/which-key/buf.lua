local a=require("which-key.config")local b=require("which-key.tree")local c=require("which-key.triggers")local d=require("which-key.util")local e={}e.__index=e;local function f(g)if g and g.plugin then return false end;if g.keymap or not b.is_group(g)then return false end;if#g.path==1 then local h=g.path[1]if h:match("^[a-z]$")and not h:match("^[gz]$")then return false end end;return true end;function e:__tostring()return string.format("Mode(%s:%d)",self.mode,self.buf.buf)end;function e.new(i,j)local self=setmetatable({},e)self.buf=i;self.mode=j;self.tree=b.new()self.triggers={}self:update()return self end;function e:attach()local k={}self.tree:walk(function(g)if g.plugin then table.insert(k,g)return false end end)if a.triggers and not self:xo()then self.tree:walk(function(g)if f(g)then table.insert(k,g)return false end end)end;self.triggers={}for l,g in ipairs(k)do local m={mode=self.mode,keys=g.keys,plugin=g.plugin}if not a.disable.trigger(m)then table.insert(self.triggers,g)end end;c.schedule(self)end;function e:xo()return self.mode:find("[xo]")~=nil end;function e:clear()c.detach(self)self.tree:clear()end;function e:update()self.tree:clear()local n=vim.api.nvim_get_keymap(self.mode)vim.list_extend(n,vim.api.nvim_buf_get_keymap(self.buf.buf,self.mode))for l,o in ipairs(n)do if o.desc and o.desc:find("which-key-trigger",1,true)then elseif o.rhs==""or o.rhs=="<Nop>"then self.tree:add(o,true)elseif o.lhs:sub(1,6)~="<Plug>"and o.lhs:sub(1,5)~="<SNR>"then self.tree:add(o)end end;local p={[self.mode]=true}if self.mode=="s"then p.v=true elseif self.mode=="x"then p.v=true end;for l,q in ipairs(a.mappings)do if p[q.mode]and(not q.buffer or q.buffer==self.buf.buf)then self.tree:add(q,true)end end;self.tree:fix()self:attach()vim.schedule(function()require("which-key.state").update()end)end;local r={}r.__index=r;function r.new(i)local self=setmetatable({},r)i=i or 0;self.buf=i==0 and vim.api.nvim_get_current_buf()or i;self.modes={}return self end;function r:clear(s)s=s or{}assert(not s.buf or s.buf==self.buf,"buffer mismatch")local p=s.mode and{s.mode}or vim.tbl_keys(self.modes)for l,q in ipairs(p)do local j=self.modes[q]if j then j:clear()self.modes[q]=nil end end end;function r:valid()return vim.api.nvim_buf_is_valid(self.buf)end;function r:get(s)if not self:valid()then return end;s=s or{}local j=s.mode or d.mapmode()if not a.modes[j]then return end;local t=self.modes[j]if not t then self.modes[j]=e.new(self,j)d.debug("new "..tostring(self.modes[j]))return self.modes[j]elseif s.update then d.debug("update "..tostring(t))t:update()end;return t end;local u={}u.Buf=r;u.bufs={}function u.get(s)u.cleanup()s=s or{}local i=s.buf or vim.api.nvim_get_current_buf()if not vim.api.nvim_buf_is_valid(i)then return end;local v=vim.bo[i].filetype;local w=vim.bo[i].buftype;if vim.tbl_contains(a.disable.ft,v)then return end;if vim.tbl_contains(a.disable.bt,w)then return end;u.bufs[i]=u.bufs[i]or r.new(i)return u.bufs[i]:get(s)end;function u.cleanup()for i,l in pairs(u.bufs)do if not vim.api.nvim_buf_is_valid(i)then u.bufs[i]=nil end end end;function u.clear(s)u.cleanup()s=s or{}local x=s.buf and{s.buf}or vim.tbl_keys(u.bufs)for l,y in ipairs(x)do if u.bufs[y]then u.bufs[y]:clear(s)end end;if s.check~=false then u.check()end end;u.check=d.debounce(50,function()u.get()end)return u
