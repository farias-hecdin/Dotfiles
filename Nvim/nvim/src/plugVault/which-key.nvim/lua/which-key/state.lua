local a=require("which-key.buf")local b=require("which-key.config")local c=require("which-key.tree")local d=require("which-key.triggers")local e=require("which-key.util")local f=vim.uv or vim.loop;local g={}g.state=nil;function g.safe(h)local i,j=unpack(vim.split(h,":",{plain=true}))if i=="c"then return false,"command-mode"elseif vim.fn.reg_recording()~=""then return false,"recording"elseif vim.fn.reg_executing()~=""then return false,"executing"end;local k=vim.fn.getcharstr(1)if k~=""then return false,"pending "..("%q"):format(vim.fn.strtrans(k))end;return true end;function g.setup()local l=vim.api.nvim_create_augroup("wk",{clear=true})if b.debug then vim.on_key(function(m,n)if n and#n>0 then n=vim.fn.keytrans(n)if not n:find("ScrollWheel")and not n:find("Mouse")then e.debug("on_key",n)end end end)end;vim.api.nvim_create_autocmd({"RecordingEnter","RecordingLeave"},{group=l,callback=function(o)e.debug(o.event)if o.event=="RecordingEnter"then a.clear({buf=o.buf,check=false})g.stop()else a.check()end end})local p=f.new_timer()vim.api.nvim_create_autocmd({"FocusLost","FocusGained"},{group=l,callback=function(o)if o.event=="FocusGained"then p:stop()elseif g.state then p:start(5000,0,function()vim.api.nvim_input("<esc>")end)end end})local q={}for r,s in pairs(b.modes.defer)do if s then q[e.norm(r)]=true end end;local function t()local u=e.keys(vim.api.nvim_get_mode().mode)return u[1]and q[u[1]]end;local v=e.cooldown()vim.api.nvim_create_autocmd("ModeChanged",{group=l,callback=function(o)e.debug("ModeChanged("..o.match..")")if v()then return end;local w,x=g.safe(o.match)if not w and o.match:find("o")then return end;local y=a.get()e.debug(w and"Safe(true)"or"Safe(false):"..x)if not w then v(true)g.stop()elseif y and e.xo()then if not g.state then g.start({defer=t()})end elseif not o.match:find("c")then g.stop()end end})vim.api.nvim_create_autocmd({"LspAttach","LspDetach"},{group=l,callback=function(o)e.trace("Event("..o.event..")")a.clear({buf=o.buf})e.trace()end})vim.api.nvim_create_autocmd({"BufReadPost","BufNew"},{group=l,callback=function(o)e.trace("Event("..o.event..")")a.clear({buf=o.buf})e.trace()end})vim.api.nvim_create_autocmd({"BufEnter"},{group=l,callback=function(o)e.trace("Event("..o.event..")")a.get()e.trace()end})a.check()end;function g.stop()if g.state==nil then return end;e.debug("state:stop")g.state=nil;vim.schedule(function()if not g.state then require("which-key.view").hide()end end)end;function g.check(z,n)local A=require("which-key.view")local B=n==nil and z.node or(z.node.children or{})[n]local C=f.hrtime()/1e6-z.started;local D=vim.o.timeout and C>vim.o.timeoutlen;if B then local E=c.is_group(B)local F=B.keymap and(B.keymap.nowait==1 or not D)local G=B.action~=nil;if E and not F and not G then e.debug("continue",B.keys,tostring(z.mode),B.plugin)return B end elseif n=="<Esc>"then if z.mode:xo()then e.exit()end;return elseif n=="<BS>"then return z.node.parent or z.mode.tree.root elseif A.valid()and n and n:lower()==b.keys.scroll_down then A.scroll(false)return z.node elseif A.valid()and n and n:lower()==b.keys.scroll_up then A.scroll(true)return z.node end;g.execute(z,n,B)end;function g.execute(z,n,B)d.suspend(z.mode)if B and B.action then return B.action()end;local H=vim.deepcopy(z.node.path)H[#H+1]=n;local I=table.concat(H)if not z.mode:xo()then if vim.v.count>0 then I=vim.v.count..I end;if vim.v.register~=e.reg()and z.mode.mode~="i"and z.mode.mode~="c"then I='"'..vim.v.register..I end end;e.debug("feedkeys",tostring(z.mode),I)local J=vim.api.nvim_replace_termcodes(I,true,true,true)vim.api.nvim_feedkeys(J,"mit",false)end;function g.step(z)vim.cmd.redraw()e.debug("getchar")local K,L=pcall(vim.fn.getcharstr)if not K then e.debug("nok",L)return nil,true end;local n=vim.fn.keytrans(L)e.debug("got",n)local B=g.check(z,n)if B==z.node then return g.step(z)end;return B,n=="<Esc>"end;function g.start(M)M=M or{}M.update=true;local y=a.get(M)M.update=nil;if not y then return false end;local B=y.tree:find(M.keys or{})if not B then return false end;local N=y.mode;local A=require("which-key.view")g.state={mode=y,node=B,filter=M,started=f.hrtime()/1e6-(M.waited or 0)}e.trace("State(start)",tostring(y),"Node("..B.keys..")",M)if not g.check(g.state)then return true end;local O=false;local P=M.defer~=true;while g.state do y=a.get(M)if not y or y.mode~=N then break end;if P then A.update(M)end;P=true;local Q,R=g.step(g.state)if Q and g.state then g.state.node=Q else O=R or false;break end end;if M.loop and not O then vim.api.nvim_feedkeys("","x",false)vim.schedule(function()g.start(M)end)else g.state=nil;A.hide()end;e.trace()return true end;function g.update()if not g.state then return end;local y=a.get()if not y or y.mode~=g.state.mode.mode then return end;local B=y.tree:find(g.state.node.path)if not B then return end;g.state.node=B;require("which-key.view").update({schedule=false})end;function g.delay(M)local S=M.delay or type(b.delay)=="function"and b.delay(M)or b.delay;if M.waited then S=S-M.waited end;return math.max(0,S)end;return g
