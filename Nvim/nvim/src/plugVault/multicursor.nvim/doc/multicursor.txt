*multicursor.txt*                                             multicursor.nvim

Multiple cursors in Neovim.                                      *multicursor*
                                                            *multicursor.nvim*
                                                                          *mc*

==============================================================================
Table of Contents                              *multicursor-table-of-contents*

1. Features                                             |multicursor-features|
2. Example Configuration                   |multicursor-example-configuration|
 • Selecting Cursors                           |multicursor-selecting-cursors|
 • Changing Cursors                             |multicursor-changing-cursors|
 • Using Cursors                                   |multicursor-using-cursors|
3. Actions                                               |multicursor-actions|
4. API                                                       |multicursor-api|
 • Types                                               |multicursor-api-types|
 • Context Methods                                   |multicursor-api-Context|
 • Cursor Methods                                     |multicursor-api-Cursor|


==============================================================================
Features                                                *multicursor-features*

 • Visual and select modes with char/line/block selections
 • Normal, insert, replace modes
 • Undo/redo
 • Virtualedit
 • Autocompletion
 • Snippet expansion (use `vim.snippet.expand`)
 • Cursor specific registers for searching and yanking
 • Match & split cursor selections with regex
 • Transpose cursor selections
 • Align cursor columns
 • Easily extended with the Cursor API
 • Works with most plugins and remaps


==============================================================================
Example Configuration                      *multicursor-example-configuration*

Basic setup of multicursor.nvim with lazy.nvim, using the default config.
Continue reading for a guide of how to use the default config.

>lua
    {
        "jake-stewart/multicursor.nvim",
        branch = "1.0",
        config = function()
            local mc = require("multicursor-nvim")

            mc.setup()

            local set = vim.keymap.set

            -- Add or skip cursor above/below the main cursor.
            set({"n", "x"}, "<up>",
                function() mc.lineAddCursor(-1) end)
            set({"n", "x"}, "<down>",
                function() mc.lineAddCursor(1) end)
            set({"n", "x"}, "<leader><up>",
                function() mc.lineSkipCursor(-1) end)
            set({"n", "x"}, "<leader><down>",
                function() mc.lineSkipCursor(1) end)

            -- Add or skip adding a new cursor by matching word/selection
            set({"n", "x"}, "<leader>n",
                function() mc.matchAddCursor(1) end)
            set({"n", "x"}, "<leader>s",
                function() mc.matchSkipCursor(1) end)
            set({"n", "x"}, "<leader>N",
                function() mc.matchAddCursor(-1) end)
            set({"n", "x"}, "<leader>S",
                function() mc.matchSkipCursor(-1) end)

            -- In normal/visual mode, press `mwap` will create a cursor in every match of
            -- the word captured by `iw` (or visually selected range) inside the bigger
            -- range specified by `ap`. Useful to replace a word inside a function, e.g. mwif.
            set({"n", "x"}, "mw", function()
                mc.operator({ motion = "iw", visual = true })
                -- Or you can pass a pattern, press `mwi{` will select every \w,
                -- basically every char in a `{ a, b, c, d }`.
                -- mc.operator({ pattern = [[\<\w]] })
            end)

            -- Press `mWi"ap` will create a cursor in every match of string captured by `i"` inside range `ap`.
            set("n", "mW", mc.operator)

            -- Add all matches in the document
            set({"n", "x"}, "<leader>A", mc.matchAllAddCursors)

            -- You can also add cursors with any motion you prefer:
            -- set("n", "<right>", function()
            --     mc.addCursor("w")
            -- end)
            -- set("n", "<leader><right>", function()
            --     mc.skipCursor("w")
            -- end)

            -- Rotate the main cursor.
            set({"n", "x"}, "<left>", mc.nextCursor)
            set({"n", "x"}, "<right>", mc.prevCursor)

            -- Delete the main cursor.
            set({"n", "x"}, "<leader>x", mc.deleteCursor)

            -- Add and remove cursors with control + left click.
            set("n", "<c-leftmouse>", mc.handleMouse)
            set("n", "<c-leftdrag>", mc.handleMouseDrag)
            set("n", "<c-leftrelease>", mc.handleMouseRelease)

            -- Easy way to add and remove cursors using the main cursor.
            set({"n", "x"}, "<c-q>", mc.toggleCursor)

            -- Clone every cursor and disable the originals.
            set({"n", "x"}, "<leader><c-q>", mc.duplicateCursors)

            set("n", "<esc>", function()
                if not mc.cursorsEnabled() then
                    mc.enableCursors()
                elseif mc.hasCursors() then
                    mc.clearCursors()
                else
                    -- Default <esc> handler.
                end
            end)

            -- bring back cursors if you accidentally clear them
            set("n", "<leader>gv", mc.restoreCursors)

            -- Align cursor columns.
            set("n", "<leader>a", mc.alignCursors)

            -- Split visual selections by regex.
            set("x", "S", mc.splitCursors)

            -- Append/insert for each line of visual selections.
            set("x", "I", mc.insertVisual)
            set("x", "A", mc.appendVisual)

            -- match new cursors within visual selections by regex.
            set("x", "M", mc.matchCursors)

            -- Rotate visual selection contents.
            set("x", "<leader>t",
                function() mc.transposeCursors(1) end)
            set("x", "<leader>T",
                function() mc.transposeCursors(-1) end)

            -- Jumplist support
            set({"x", "n"}, "<c-i>", mc.jumpForward)
            set({"x", "n"}, "<c-o>", mc.jumpBackward)

            -- Customize how cursors look.
            local hl = vim.api.nvim_set_hl
            hl(0, "MultiCursorCursor", { link = "Cursor" })
            hl(0, "MultiCursorVisual", { link = "Visual" })
            hl(0, "MultiCursorSign", { link = "SignColumn"})
            hl(0, "MultiCursorMatchPreview", { link = "Search" })
            hl(0, "MultiCursorDisabledCursor", { link = "Visual" })
            hl(0, "MultiCursorDisabledVisual", { link = "Visual" })
            hl(0, "MultiCursorDisabledSign", { link = "SignColumn"})
        end
    }
<


------------------------------------------------------------------------------
Selecting Cursors                              *multicursor-selecting-cursors*

 • You can add cursors above/below the current cursor with `<up>` and
   `<down>`.
 • You can skip a line with `<leader><up>` or `<leader><down>`.
 • You can match the word/selection under the cursor forwards or backwards
   with
  `<leader>n` and `<leader>N`.
 • You can skip a match forwards or backwards using `<leader>s` and
   `<leader>S`.
 • You can add and remove cursors using the mouse with `<c-leftmouse>`.


------------------------------------------------------------------------------
Changing Cursors                                *multicursor-changing-cursors*

 • You can rotate through cursors with `<left>` and `<right>`.
 • You can delete the current cursor using `<leader>x`
 • You can disable cursors with `<c-q>`, which means only the main cursor
   moves.
 • You can also press `<leader><c-q>` to duplicate cursors, disabling the
   originals.
 • When cursors are disabled, you can press `<c-q>` to add a cursor under the
   main cursor.
 • You can press `<esc>` to enable cursors again.


------------------------------------------------------------------------------
Using Cursors                                      *multicursor-using-cursors*

 • Once you have your cursors, you use vim normally as you would with a single
   cursor.
 • You can press `<leader>a` to align cursor columns.
 • You can press `S` to split a visual selection by regex into multiple
   selections.
 • You can press `M` to run a regex within your visual selection, creating a
   new cursor for each match.
 • You can press `<leader>t` and `<leader>T` to transpose visual selections,
   which means the text within each visual selection will be rotated between
   cursors.
 • When you want to collapse your cursors back into one, press `<esc>`.


==============================================================================
Actions                                                  *multicursor-actions*

This is a reference to all the example actions created for you to use. If you
want to create your own complex action, see the |multicursor-api|.

 • mc.addCursor                                        |multicursor-addCursor|
 • mc.skipCursor                                      |multicursor-skipCursor|
 • mc.toggleCursor                                  |multicursor-toggleCursor|
 • mc.lineAddCursor                                |multicursor-lineAddCursor|
 • mc.lineSkipCursor                              |multicursor-lineSkipCursor|
 • mc.matchAddCursor                              |multicursor-matchAddCursor|
 • mc.matchSkipCursor                            |multicursor-matchSkipCursor|
 • mc.matchAllAddCursors                      |multicursor-matchAllAddCursors|
 • mc.nextCursor                                      |multicursor-nextCursor|
 • mc.prevCursor                                      |multicursor-prevCursor|
 • mc.firstCursor                                    |multicursor-firstCursor|
 • mc.lastCursor                                      |multicursor-lastCursor|
 • mc.hasCursors                                      |multicursor-hasCursors|
 • mc.deleteCursor                                  |multicursor-deleteCursor|
 • mc.clearCursors                                  |multicursor-clearCursors|
 • mc.handleMouse                                    |multicursor-handleMouse|
 • mc.handleMouseDrag                            |multicursor-handleMouseDrag|
 • mc.handleMouseRelease                      |multicursor-handleMouseRelease|
 • mc.alignCursors                                  |multicursor-alignCursors|
 • mc.splitCursors                                  |multicursor-splitCursors|
 • mc.matchCursors                                  |multicursor-matchCursors|
 • mc.transposeCursors                          |multicursor-transposeCursors|
 • mc.swapCursors                                    |multicursor-swapCursors|
 • mc.insertVisual                                  |multicursor-insertVisual|
 • mc.appendVisual                                  |multicursor-appendVisual|
 • mc.disableCursors                              |multicursor-disableCursors|
 • mc.enableCursors                                |multicursor-enableCursors|
 • mc.cursorsEnabled                              |multicursor-cursorsEnabled|
 • mc.feedkeys                                          |multicursor-feedkeys|
 • mc.action                                              |multicursor-action|


mc.addCursor({motion})                                 *multicursor-addCursor*
    Add a cursor and move only the main cursor using motion.

    Usage example: >lua
        vim.keymap.set("n", "<right>", function()
            mc.addCursor("w")
        end)
<
    Parameters: ~
      • {motion} (`string`) motion to execute on the main cursor leaving a new
        cursor behind


mc.skipCursor({motion})                               *multicursor-skipCursor*
    Move only the main cursor using motion.

    Usage example: >lua
        vim.keymap.set("n", "<leader><right>", function()
            mc.skipCursor("w")
        end)
<
    Parameters: ~
      • {motion} (`string`) motion to execute on the main cursor without
        adding a new cursor


mc.toggleCursor()                                   *multicursor-toggleCursor*
    Add or remove a cursor under the main cursor. This action disables all
    cursors. You can use `mc.enableCursors` to enable cursors again.

    Usage example: >lua
        vim.keymap.set("n", "<c-q>", mc.toggleCursor)

    See also: ~
      • |multicursor-enableCursors|


mc.lineAddCursor({direction})                      *multicursor-lineAddCursor*
    Add a cursor above or below the the main cursor, skipping empty lines.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<up>", function()
            mc.lineAddCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<down>", function()
            mc.lineAddCursor(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
	previous line, while `1` spawn in the next line


mc.lineSkipCursor({direction})                    *multicursor-lineSkipCursor*
    Move only the main cursor up or down a line, skipping empty lines.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader><up>", function()
            mc.lineSkipCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<leader><down>", function()
            mc.lineSkipCursor(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
	previous line, while `1` spawn in the next line


mc.matchAddCursor({direction})                    *multicursor-matchAddCursor*
    Add a new cursor by matching the current word/selection.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>n", function()
            mc.matchAddCursor(1)
        end)
        vim.keymap.set({"n", "v"}, "<leader>s", function()
            mc.matchSkipCursor(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
	previous line, while `1` spawn in the next line


mc.matchSkipCursor({direction})                  *multicursor-matchSkipCursor*
    Move only the main cursor by matching the current word/selection.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>N", function()
            mc.matchAddCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<leader>S", function()
            mc.matchSkipCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
	previous line, while `1` spawn in the next line


mc.matchAllAddCursors()                       *multicursor-matchAllAddCursors*
    Add a cursor for every match of the word/selection under the cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>A", mc.matchAllAddCursors)
<

mc.nextCursor({wrap?})                                *multicursor-nextCursor*
    Select the cursor after the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<left>", mc.nextCursor)
<
    Parameters: ~
      • {wrap?} (`boolean?`) wrap to the start of the file if no cursors are
	found after the main cursor. Defaults to `true`.
<

mc.prevCursor({wrap?})                                *multicursor-prevCursor*
    Select the cursor before the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<right>", mc.prevCursor)
<
    Parameters: ~
      • {wrap?} (`boolean?`) wrap to the end of the file if no cursors are
	found before the main cursor. Defaults to `true`.

mc.firstCursor()                                     *multicursor-firstCursor*
    Select the first cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "H", mc.firstCursor)
<

mc.lastCursor()                                       *multicursor-lastCursor*
    Select the last cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "L", mc.lastCursor)
<

mc.hasCursors()                                       *multicursor-hasCursors*
    Returns whether multiple cursors exist.

    Usage example: >lua
        vim.keymap.set({ "n", "v" }, "<esc>", function()
            if mc.hasCursors() then
                mc.clearCursors()
            end
        end)
<
    Return: ~
      • (`boolean`) true if there are more than 1 cursors.


mc.deleteCursor()                                   *multicursor-deleteCursor*
    Delete the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>x", mc.deleteCursor)
<

mc.clearCursors()                                   *multicursor-clearCursors*
    Clear all cursors except main cursor.

    Usage example: >lua
        vim.keymap.set({ "n", "v" }, "<esc>", function()
            if mc.hasCursors() then
                mc.clearCursors()
            end
        end)
<

mc.handleMouse()                                     *multicursor-handleMouse*
    Use in a mouse mapping to handle adding and removing cursors with mouse
    click.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftmouse>", mc.handleMouse)


mc.handleMouseDrag()                             *multicursor-handleMouseDrag*
    Use in a mouse mapping to handle adding and removing cursors with mouse
    drag.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftdrag>", mc.handleMouseDrag)
<

mc.handleMouseRelease()                       *multicursor-handleMouseRelease*
    Use in a mouse mapping to improve mouse support when dragging with a
    modifier after having already clicked without it.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftrelease>", mc.handleMouseRelease)
<

mc.alignCursors()                                   *multicursor-alignCursors*
    Align columns of cursors on multiple lines.

    Usage example: >lua
        vim.keymap.set("n", "<leader>a", mc.alignCursors)
<

mc.splitCursors()                                   *multicursor-splitCursors*
    Split visual selections with a regex separator. For example, visually
    selecting "a,b,c,d" and splitting with "," will create four cursors, one
    on each letter.

    Usage example: >lua
        vim.keymap.set("v", "S", mc.splitCursors)
<

mc.matchCursors()                                   *multicursor-matchCursors*
    Match a pattern over a visual selection, creating a new cursor for each
    match. For example, visually selecting "foo bar foo" and matching with
    "foo" will create two cursors, one on each "foo".

    Usage example: >lua
        vim.keymap.set("v", "M", mc.matchCursors)


mc.transposeCursors(direction)                  *multicursor-transposeCursors*
    Rotate the contents of each visual selection for each cursor.

    Usage example: >lua
        vim.keymap.set("v", "<leader>t", function()
            mc.transposeCursors(1)
        end)
        vim.keymap.set("v", "<leader>T", function()
            mc.transposeCursors(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.

    See also: ~
      • |multicursor-swapCursors|

mc.swapCursors(direction)                            *multicursor-swapCursors*
    Swaps the visual selection of the current cursor with that of the
    next/previous cursor, specified by direction.

    Usage example: >lua
        vim.keymap.set("v", "<leader>h", function()
            mc.swapCursors(-1)
        end)
        vim.keymap.set("v", "<leader>l", function()
            mc.swapCursors(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
	anti-clockwise.
      • {wrap?} (`boolean?`) Whether the search for the target cursor wrap
	if not found.

    See also: ~
      • |multicursor-transposeCursors|


mc.insertVisual()                                   *multicursor-insertVisual*
    Create a cursor for each line of the visual selection, and enter insert
    mode with `I`.

    Usage example: >lua
        vim.keymap.set("v", "I", mc.insertVisual)
<

mc.appendVisual()                                   *multicursor-appendVisual*
    Create a cursor for each line of the visual selection, and enter insert
    mode with `A`.

    Usage example: >lua
        vim.keymap.set("v", "A", mc.appendVisual)
<

mc.disableCursors()                               *multicursor-disableCursors*
    Locks the cursors from moving. This is useful for repositioning main
    cursor for adding more cursors.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<c-q>", mc.disableCursors)
<
    See also: ~
      • |multicursor-enableCursors|


mc.enableCursors()                                 *multicursor-enableCursors*
    Unlocks the cursors from moving.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<c-q>", mc.enableCursors)
<
    See also: ~
      • |multicursor-disableCursors|


mc.cursorsEnabled()                               *multicursor-cursorsEnabled*
    Returns whether the cursors are locked from moving.

    Usage example: >lua
        if not mc.cursorsEnabled() then
            mc.enableCursors()
        end
<
    Return: ~
      • (`boolean`) true if cursors are locked

    See also: ~
      • |multicursor-disableCursors|
      • |multicursor-enableCursors|


mc.feedkeys({keys}, {opts?})                            *multicursor-feedkeys*
    Use instead of `vim.fn.feedkeys()` or `vim.api.nvim_feedkeys()` in
    multicursor mappings to avoid bugs.

    Parameters: ~
      • {keys} (`string`) string representing a command
      • {opts?} (`table?`) options
        • {opts.remap?} (`boolean?`) if true use remapped keys
        • {opts.keycodes?} (`boolean?`) if true translate keycodes


mc.action(func)                                           *multicursor-action*
    Perform a complex action using the |multicursor-api|.

    Usage example: >lua
        mc.action(function(ctx)
            local cursors = ctx:getCursors()
        end)
<
    Parameters: ~
      • {func} (`function`) function to execute on cursors.
        • {ctx} (`CursorContext`) allows to query for cursors.

    See also: ~
      • |multicursor-api-Context|
      • |multicursor-api|


==============================================================================
API                                                          *multicursor-api*

All of the provided actions are implemented using the Cursor API, which is
accessible for writing your own complex multi-cursor logic.

You can use the Cursor API by calling |multicursor-action| with a callback,
like so:

>lua
    mc.action(function(ctx)
	local cursors = ctx:getCursors()
    end)
<

The `ctx` is a `CursorContext` which lets you query for cursors. In the
snippet, we simply called `getCursors()` to get a list of all our cursors.

In the next snippet, we will instead call `firstCursor()` to get only the
highest cursor in the document. Once we have our cursor, we can interact with
it.

>lua
    mc.action(function(ctx)
	local cursor = ctx:firstCursor()
	vim.print(cursor:getLine())
	cursor:feedkeys("ihello world")
    end)
>

And that's it. See the |multicursor-api-Context| and |multicursor-api-Cursor|
sections for an API overview. Also look at the `examples.lua` file in the
GitHub repo for example usage.

See also: ~
  • |multicursor-action|
  • |multicursor-api-Context|
  • |multicursor-api-Cursor|


------------------------------------------------------------------------------
Types                                                  *multicursor-api-types*

CursorQuery                                    *multicursor-types-CursorQuery*
>lua
    --- @alias CursorQuery {disableCursors?: boolean, enableCursors?: boolean}
<
    Fields: ~
      • disableCursors (`boolean?`) if true return disable cursors
      • enableCursors (`boolean?`) if true return enabled cursors


Pos                                                    *multicursor-types-Pos*
>lua
    --- @alias Pos [integer, integer, integer]
<
    Fields: ~
      • 1 (`integer`) 1-indexed line
      • 2 (`integer`) 1-indexed col
      • 3 (`integer`) offset


SimplePos                                        *multicursor-types-SimplePos*
>lua
    --- @alias SimplePos [integer, integer]
<
    Fields: ~
      • 1 (`integer`) 1-indexed line
      • 2 (`integer`) 1-indexed col


------------------------------------------------------------------------------
Context Methods                                      *multicursor-api-Context*

 • setCursorsEnabled                       |multicursor-ctx-setCursorsEnabled|
 • getCursors                                     |multicursor-ctx-getCursors|
 • addCursor                                       |multicursor-ctx-addCursor|
 • forEachCursor                               |multicursor-ctx-forEachCursor|
 • mapCursors                                     |multicursor-ctx-mapCursors|
 • findLastCursor                             |multicursor-ctx-findLastCursor|
 • findCursor                                     |multicursor-ctx-findCursor|
 • nextCursor                                     |multicursor-ctx-nextCursor|
 • prevCursor                                     |multicursor-ctx-prevCursor|
 • seekCursor                                     |multicursor-ctx-seekCursor|
 • seekBoundaryCursor                     |multicursor-ctx-seekBoundaryCursor|
 • nearestCursor                               |multicursor-ctx-nearestCursor|
 • getCursorAtPos                             |multicursor-ctx-getCursorAtPos|
 • overlappedCursor                         |multicursor-ctx-overlappedCursor|
 • mainCursor                                     |multicursor-ctx-mainCursor|
 • firstCursor                                   |multicursor-ctx-firstCursor|
 • lastCursor                                     |multicursor-ctx-lastCursor|
 • cursorsEnabled                             |multicursor-ctx-cursorsEnabled|
 • hasCursors                                     |multicursor-ctx-hasCursors|
 • numCursors                                     |multicursor-ctx-numCursors|
 • numEnabledCursors                       |multicursor-ctx-numEnabledCursors|
 • numDisabledCursors                     |multicursor-ctx-numDisabledCursors|
 • clear                                               |multicursor-ctx-clear|


ctx:setCursorsEnabled({value})             *multicursor-ctx-setCursorsEnabled*
    Enables or disables all cursors.

    Parameters: ~
      • {value} (`boolean`)


ctx:getCursors({opts?})                           *multicursor-ctx-getCursors*
    Returns a list of cursors, sorted by their position.

    Parameters: ~
      • {opts?} (`CursorQuery?`) type of cursors to get.

    Return: ~
      • (`Cursor[]`) table of `Cursor` objects.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:addCursor()                                    *multicursor-ctx-addCursor*
    Creates a new virtual cursor, returning it.

    Return: ~
      • (`Cursor`) the new cursor.

    See also: ~
      • |multicursor-api-Cursor|


ctx:forEachCursor({callback}, {opts?})         *multicursor-ctx-forEachCursor*
    Util which executes callback for each cursor, sorted by their position.

    Parameters: ~
      • {callback} (`function`) a function that will be executed on each
        cursor.
      • {opts?} (`CursorQuery?`) type of cursor iterate over.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:mapCursors({callback}, {opts?})               *multicursor-ctx-mapCursors*
    Util method which maps each cursor to a value.

    Parameters: ~
      • {callback} (`function`) a function that will be executed on each
        cursor.
      • {opts?} (`CursorQuery?`) type of cursor to map over.

    Return: ~
      • (`Cursor[]`) table with mapped results.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:findLastCursor({predicate}, {opts?})      *multicursor-ctx-findLastCursor*
    Util method which returns the last cursor matching the predicate.

    Parameters: ~
      • {predicate} (`function`)
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the last cursor matching predicate or nil if
        no cursors were found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:findCursor({predicate}, {opts?})              *multicursor-ctx-findCursor*
    Util method which returns the first cursor matching the predicate.

    Parameters: ~
      • {predicate} (`function`)
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the first cursor matching predicate or nil if
        no cursors were found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:nextCursor({pos}, {opts?})                    *multicursor-ctx-nextCursor*
    Returns the closest cursor which appears AFTER pos. A cursor exactly at
    pos will not be returned. It does not wrap, so if none are found, then nil
    is returned. If you wish to wrap, use:
    `ctx:nextCursor(...) or ctx:firstCursor(...)`

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the closest cursor after the pos or nil if
        none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:prevCursor({pos}, {opts?})                    *multicursor-ctx-prevCursor*
    Returns the closest cursor which appears BEFORE pos. A cursor exactly at
    pos will not be returned. It does not wrap, so if none are found, then nil
    is returned. If you wish to wrap, use:
    `ctx:prevCursor(...) or ctx:lastCursor(...)`

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the closest cursor before the pos or nil if
	none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

                                                  *multicursor-ctx-seekCursor*
ctx:seekCursor({pos}, {direction}, {wrap?}, {opts?})
    Returns the closest cursor in the specified direction, which can
    optionally wrap.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
	anti-clockwise.
      • {wrap?} (`boolean?`) Whether the seach should wrap around the
	document.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) the matched cursor or nil if none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

                                          *multicursor-ctx-seekBoundaryCursor*
ctx:seekBoundaryCursor({direction}, {opts?})
    Returns the first/last cursor, specified by direction.

    Parameters: ~
      • {direction} (`-1 | 1`) With `-1` for the first and `1` for the last
	cursor.
      • {wrap?} (`boolean?`) Whether the seach should wrap around the
	document.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) the matched cursor or nil if none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:nearestCursor({pos}, {opts?})              *multicursor-ctx-nearestCursor*
    Returns the nearest cursor to pos, and accepts a cursor exactly at pos.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns closest cursor or nil if none found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:getCursorAtPos({pos}, {opts?})            *multicursor-ctx-getCursorAtPos*
    Returns the exact cursor at pos.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search at.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the cursor or nil if there are no cursors at
	position.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:overlappedCursor()                      *multicursor-ctx-overlappedCursor*
    Returns the cursor under the main cursor.

    Return: ~
      • (`Cursor | nil`) returns cursor under the main cursor.

    See also: ~
      • |multicursor-api-Cursor|


ctx:mainCursor()                                  *multicursor-ctx-mainCursor*
    Returns the main cursor.

    Return: ~
      • (`Cursor`) return the main cursor.

    See also: ~
      • |multicursor-api-Cursor|


ctx:firstCursor({opts?})                         *multicursor-ctx-firstCursor*
    Returns the cursor closest to the start of the document.

    Parameters: ~
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the first cursor in the document or nil if
	there are none.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:lastCursor({opts?})                           *multicursor-ctx-lastCursor*
    Returns the cursor closest to the end of the document.

    Parameters: ~
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the last cursor in the document or nil if
	there are none.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:cursorsEnabled()                          *multicursor-ctx-cursorsEnabled*
    Returns whether all cursors are enabled.

    Return: ~
      • (`boolean`) true if ALL cursors are enabled.


ctx:hasCursors()                                  *multicursor-ctx-hasCursors*
    Returns whether there are virtual cursors.

    Return: ~
      • (`boolean`) true if there are any virtual cursors.


ctx:numCursors()                                  *multicursor-ctx-numCursors*
    Returns the total number of cursors.
    There is always at least one cursor (the main cursor).

    Return: ~
      • (`integer`) the number of cursors.


ctx:numEnabledCursors()                    *multicursor-ctx-numEnabledCursors*
    Returns number of enabled cursors.
    There is always at least one enabled cursor (the main cursor).

    Return: ~
      • (`integer`) the number of enabled cursors.


ctx:numDisabledCursors()                 *multicursor-ctx-numDisabledCursors*
    Returns the number of disabled cursors.

    Return: ~
      • (`integer`) the number of disabled cursors.


ctx:clear()                                            *multicursor-ctx-clear*
    Removes all cursors.


------------------------------------------------------------------------------
Cursor Methods                                        *multicursor-api-Cursor*

 • Cursor:line                                       |multicursor-cursor-line|
 • Cursor:col                                         |multicursor-cursor-col|
 • Cursor:getLine                                 |multicursor-cursor-getLine|
 • Cursor:delete                                   |multicursor-cursor-delete|
 • Cursor:overlappedCursor               |multicursor-cursor-overlappedCursor|
 • Cursor:select                                   |multicursor-cursor-select|
 • Cursor:isMainCursor                       |multicursor-cursor-isMainCursor|
 • Cursor:atVisualStart                     |multicursor-cursor-atVisualStart|
 • Cursor:splitVisualLines               |multicursor-cursor-splitVisualLines|
 • Cursor:getPos                                   |multicursor-Cursor-getPos|
 • Cursor:setPos                                   |multicursor-Cursor-setPos|
 • Cursor:setVisualAnchor                 |multicursor-Cursor-setVisualAnchor|
 • Cursor:getVisualAnchor                 |multicursor-Cursor-getVisualAnchor|
 • Cursor:setRedoChangePos               |multicursor-cursor-setRedoChangePos|
 • Cursor:registerUndo                       |multicursor-cursor-registerUndo|
 • Cursor:clone                                     |multicursor-cursor-clone|
 • Cursor:getVisualLines                   |multicursor-Cursor-getVisualLines|
 • Cursor:setVisualLines                   |multicursor-Cursor-setVisualLines|
 • Cursor:getFullVisualLines           |multicursor-Cursor-getFullVisualLines|
 • Cursor:getVisual                             |multicursor-cursor-getVisual|
 • Cursor:mode                                       |multicursor-cursor-mode|
 • Cursor:setMode                                 |multicursor-cursor-setMode|
 • Cursor:disable                                 |multicursor-cursor-disable|
 • Cursor:enable                                   |multicursor-cursor-enable|
 • Cursor:feedkeys                               |multicursor-cursor-feedkeys|
 • Cursor:perform                                 |multicursor-cursor-perform|
 • Cursor:getCursorWord                     |multicursor-cursor-getCursorWord|
 • Cursor:setSearch                             |multicursor-cursor-setSearch|
 • Cursor:setVisual                             |multicursor-cursor-setVisual|
 • Cursor:inVisualMode                       |multicursor-cursor-inVisualMode|
 • Cursor:inSelectMode                       |multicursor-cursor-inSelectMode|
 • Cursor:hasSelection                       |multicursor-cursor-hasSelection|


Cursor:line()                                        *multicursor-cursor-line*
    Returns this cursors current line number, 1 indexed.

    Return: ~
      • (`integer`) line number.


Cursor:col()                                          *multicursor-cursor-col*
    Returns this cursors current column number, 1 indexed.

    Return: ~
      • (`integer`) column number.


Cursor:getLine()                                  *multicursor-cursor-getLine*
    Returns the full line text of where this cursor is located.

    Return: ~
      • (`string`) line text.


Cursor:delete()                                    *multicursor-cursor-delete*
    Deletes this cursor. If this is the main cursor then the closest cursor to
    it is set as the new main cursor. If this is the last remaining cursor, a
    new cursor is created at its position.


Cursor:overlappedCursor()                *multicursor-cursor-overlappedCursor*
    Returns the disabled cursor underneath this one, if it exists.

    Return: ~
      • (`Cursor | nil`) disabled `Cursor` or nil if there isn't any.

    See also: ~
      • |multicursor-api-Cursor|


Cursor:select()                                    *multicursor-cursor-select*
    Sets this cursor as the main cursor.

    Return: ~
      • (`self`)


Cursor:isMainCursor()                        *multicursor-cursor-isMainCursor*
    Returns whether this cursor is the main cursor.

    Return: ~
      • (`boolean`) true if it is the main cursor.


Cursor:atVisualStart()                      *multicursor-cursor-atVisualStart*
    A cursor can either be at the start or end of a visual selection. For
    example, if you select lines 10-20, your cursor can either be on line 10
    (start) or 20 (end). this method returns true when at the start.

    Return: ~
      • (`boolean`) true if the cursor is at the beginning of its selection.


Cursor:splitVisualLines()                *multicursor-cursor-splitVisualLines*
    For each line of the cursor's visual selection, a new cursor is created,
    visually selecting only the single line. This method deletes the original
    cursor.

    Return: ~
      • (`Cursor[]`) table of Cursors


Cursor:getPos()                                    *multicursor-Cursor-getPos*
    Returns the position of a cursor.

    Return: ~
      • (`Pos`) position of the cursor.

    See also: ~
      • |multicursor-types-Pos|


Cursor:setPos({pos})                               *multicursor-Cursor-setPos*
    Sets the position of the cursor.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) new position of the cursor.

    Return: ~
      • (`self`)

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


Cursor:setVisualAnchor({pos})             *multicursor-Cursor-setVisualAnchor*
    Sets the position of the visual anchor equivalent of `setpos()` on `'v'`
    for a cursor.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) new position of the anchor.

    Return: ~
      • (`self`)

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|
      • |setpos()|


Cursor:getVisualAnchor()                  *multicursor-Cursor-getVisualAnchor*
    Returns the position of cursor's visual anchor same as `getpos('v')`.

    Return: ~
      • (`Pos`) position of the anchor.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|
      • |getpos()|


Cursor:setRedoChangePos({pos})           *multicursor-cursor-setRedoChangePos*
    Sets the position of the redo position marker.

    Parameters: ~
      • {pos} (`Pos`) new position cursor should have when redoing.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


Cursor:registerUndo()                        *multicursor-cursor-registerUndo*
    Registers this cursor so that its original position is restored upon undo.


Cursor:clone()                                      *multicursor-cursor-clone*
    Returns a new cursor with the same position, registers, visual selection,
    and mode as this cursor.

    Return: ~
      • (`Cursor`) the new cursor.

    See also: ~
      • |multicursor-api-Cursor|


Cursor:setVisualLines(lines)               *multicursor-Cursor-setVisualLines*
    Replace only the text contained in each line of the visual selection.
    If lines is longer than the visual selection, new lines are created.
    For visual block mode, the number of lines has to match the size of the
    visual selection.

    Parameters: ~
      • {lines} (`string[]`) lines to replace visual selection with

    Return: ~
      • (`self`)

    See also: ~
      • |multicursor-Cursor-getVisualLines|


Cursor:getVisualLines()                    *multicursor-Cursor-getVisualLines*
    Returns only the text contained in each line of the visual selection.

    Return: ~
      • (`string[]`) the lines.

    See also: ~
      • |multicursor-Cursor-setVisualLines|
      • |multicursor-Cursor-setFullVisualLines|


Cursor:getFullVisualLines()            *multicursor-Cursor-getFullVisualLines*
    Returns the full line for each line of the visual selection.

    Return: ~
      • (`string[]`) the lines.

    See also: ~
      • |multicursor-Cursor-getVisualLines|

Cursor:getVisual()                              *multicursor-cursor-getVisual*
    Returns start and end positions of visual selection start position is
    before or equal to end position.

    Return: ~
      • (`Pos`) starting position of the visual selection.
      • (`Pos`) ending position of the visual selection.

    See also: ~
      • |multicursor-types-Pos|


Cursor:mode()                                        *multicursor-cursor-mode*
    Returns this cursor's current mode. It should only ever be in normal,
    visual, or select modes.

    Return: ~
      • (`string`) mode of the cursor
	One of: "n" | "v" | "V" | <c-v> | "s" | "S" | <c-s>

    See also: ~
      • |mode()|


Cursor:setMode({mode})                            *multicursor-cursor-setMode*
    Sets this cursor's mode. It should only ever be in normal, visual, or
    select modes.

    Parameters: ~
      • {mode} (`string`) new mode of the cursor
        One of: "n" | "v" | "V" | <c-v> | "s" | "S" | <c-s>

    Return: ~
      • (`self`)

    See also: ~
      • |mode()|


Cursor:disable()                                  *multicursor-cursor-disable*
    Disable the cursor.


Cursor:enable()                                    *multicursor-cursor-enable*
    Enable the cursor.


Cursor:feedkeys({keys}, {opts?})                 *multicursor-cursor-feedkeys*
    Makes the cursor perform a command/commands. For example,
    `cursor:feedkeys('dw')` will delete a word. By default, keys are not
    remapped and keycodes are not parsed.

    Parameters: ~
      • {keys} (`string`) string representing a command
      • {opts?} (`table?`) options
        • {opts.remap?} (`boolean?`) if true use remapped keys
        • {opts.keycodes?} (`boolean?`) if true translate keycodes


Cursor:perform({callback})                        *multicursor-cursor-perform*
    Activates this cursor by setting its registers, visual selection, mode,
    position, etc. Then, it calls the provided callback where you can perform
    some lower level operations. Once the callback is finished, the new cursor
    state is read and the previously selected cursor is restored.

    Parameters: ~
      • {callback} (`function`) function to execute on a cursor
        • {cursor} (`Cursor`)

    See also: ~
      • |multicursor-api-cursor|


Cursor:getCursorWord()                      *multicursor-cursor-getCursorWord*
    Return the <cword> for this cursor.

    Return: ~
      • (`string`) current word under cursor.

    See also: ~
      • |<cword>|


Cursor:setSearch({search})                      *multicursor-cursor-setSearch*
    Set the search register of this cursor.

    Parameters: ~
      • (`string`) new content of the register.

    See also: ~
      • |"/|


Cursor:setVisual({visualStart}, {visualEnd})    *multicursor-cursor-setVisual*
    Sets the visual selection and sets the cursor position to `visualEnd`.

    Parameters: ~
      • {visualStart} (`SimplePos | Pos`) start position of the visual
        selection.
      • {visualEnd} (`SimplePos | Pos`) end position of the visual selection.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|


Cursor:inVisualMode()                        *multicursor-cursor-inVisualMode*
    Returns true if cursor is in visual mode.

    Return: ~
      • (`boolean`) true if cursor is in visual mode.

    See also: ~
      • |Visual|


Cursor:inSelectMode()                        *multicursor-cursor-inSelectMode*
    Returns true if cursor is in select mode.

    Return: ~
      • (`boolean`) true if cursor is in select mode.

    See also: ~
      • |Select|


Cursor:hasSelection()                        *multicursor-cursor-hasSelection*
    Returns true if cursor is in visual or select mode.

    Return: ~
      • (`boolean`) true if either in select or visual mode

    See also: ~
      • |Visual|
      • |Select|


Thanks to Cathyprime for writing these help pages.

vim:tw=78:ts=8:noet:ft=help:norl:
