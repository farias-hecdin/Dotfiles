local a=vim.api;local b={}function b.sanitize(c)local d,e=c:gsub("(%s-)\n(%s*)"," "):gsub("<!--(.-)-->",""):gsub("^%s*(.-)%s*$","%1")return d end;function b.slugify(c)return c:gsub("%s","-"):gsub("[^%w_-]",""):lower()end;function b.try_get_char_input()local f,g=pcall(vim.fn.getcharstr)if not f or g=="\27"then return false,nil end;return true,g end;function b.get_text(h,i,j)return a.nvim_buf_get_text(0,h,i,h,i+j,{})[1]end;function b.insert_text(h,i,k)a.nvim_buf_set_text(0,h,i,h,i,{k})end;function b.delete_text(h,i,j)a.nvim_buf_set_text(0,h,i,h,i+j,{""})end;function b.replace_text(h,i,j,k)a.nvim_buf_set_text(0,h,i,h,i+j,{k})end;function b.get_overlapping_range(l,m)local n,o,p,q;if l[1]<m[1]then n=m[1]o=m[2]elseif l[1]>m[1]then n=l[1]o=l[2]else n=l[1]o=math.max(l[2],m[2])end;if l[3]>m[3]then p=m[3]q=m[4]elseif l[3]<m[3]then p=l[3]q=l[4]else p=l[3]q=math.min(l[4],m[4])end;return{n,o,p,q}end;function b.range_contains_position(r,s)return(r[1]<s[1]or r[1]==s[1]and r[2]<=s[2])and(r[3]>s[1]or r[3]==s[1]and r[4]>=s[2])end;local function t(u,v,w,x)if u==w then if v>x then return 1 elseif v<x then return-1 else return 0 end elseif u>w then return 1 end;return-1 end;function b.ranges_overlap(n,o)if t(n[3],n[4],o[1],o[2])~=1 then return false end;if t(n[1],n[2],o[3],o[4])~=-1 then return false end;return true end;function b.get_cursor()local y=a.nvim_win_get_cursor(0)return y[1]-1,y[2]end;function b.get_user_command_range(z)if z.range==0 then local h=b.get_cursor()return h,h end;return z.line1-1,z.line2-1 end;function b.get_tab_str()if a.nvim_buf_get_option(0,"expandtab")then return string.rep(" ",a.nvim_buf_get_option(0,"tabstop"))end;return"\t"end;function b.get_visual_range()local c,A=a.nvim_buf_get_mark(0,"<"),a.nvim_buf_get_mark(0,">")local B=vim.fn.col({A[1],"$"})-1;if vim.o.selection=="exclusive"then A[2]=A[2]-1 end;c[1]=c[1]-1;A[1]=A[1]-1;local C=a.nvim_buf_get_lines(0,A[1],A[1]+1,false)[1]local D=string.byte(C,A[2]+1)if D~=nil then if D>=0xF0 then A[2]=A[2]+4 elseif D>=0xE0 then A[2]=A[2]+3 elseif D>=0xC0 then A[2]=A[2]+2 else A[2]=A[2]+1 end end;A[2]=math.min(A[2],B)return{c[1],c[2],A[1],A[2]}end;function b.get_motion_range(E)local c,A=a.nvim_buf_get_mark(0,"["),a.nvim_buf_get_mark(0,"]")if E=="line"then c[2]=0;A[2]=vim.fn.col({A[1],"$"})-1 else A[2]=A[2]+1 end;c[1]=c[1]-1;A[1]=A[1]-1;return{c[1],c[2],A[1],A[2]}end;return b
