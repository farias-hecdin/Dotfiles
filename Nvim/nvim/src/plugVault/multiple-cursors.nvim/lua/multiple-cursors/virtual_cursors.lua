local a={}local b=require("multiple-cursors.common")local c=require("multiple-cursors.extmarks")local d=require("multiple-cursors.virtual_cursor")local e={}local f=1;local g=false;local h=false;local function i()for j=#e,1,-1 do if e[j].delete then c.delete_virtual_cursor_extmarks(e[j])table.remove(e,j)end end end;local function k()if#e<2 then return end;for l=1,#e-1 do for m=l+1,#e do if e[l]==e[m]then e[m].delete=true end end end;i()end;local function n()a.sort()local o=vim.fn.getcurpos()local p=o[2]local q=o[3]for j,r in ipairs(e)do if r.lnum>p then return j elseif r.lnum==p and r.col>q then return j end end;return 0 end;function a.get_num_virtual_cursors()return#e end;function a.is_locked()return h end;function a.sort()table.sort(e)end;function a.add_with_visual_area(p,q,s,t,u,v)for w,r in ipairs(e)do if r.col==q and r.lnum==p then return end end;local x=set_first and#e==0;local y=0;if v then y=f;f=f+1 end;table.insert(e,d.new(p,q,s,t,u,y))c.update_virtual_cursor_extmarks(e[#e])end;function a.add(p,q,s,v)a.add_with_visual_area(p,q,s,0,0,v)end;function a.remove_by_lnum(p)local z=false;for w,r in ipairs(e)do if r.lnum==p then r.delete=true;z=true end end;if z then i()end end;function a.add_or_delete(p,q)local z=false;for w,r in ipairs(e)do if r.col==q and r.lnum==p then r.delete=true;z=true end end;if z then i()else a.add(p,q,q,false)end end;function a.get_exit_pos()local y=999999;local p=0;local q=0;local s=0;for w,r in ipairs(e)do if r.seq~=0 and r.seq<y then y=r.seq;p=r.lnum;q=r.col;s=r.curswant end end;if y~=999999 then return{p,q,s}else return nil end end;function a.clear()e={}f=1;h=false end;function a.update_extmarks()for w,r in ipairs(e)do c.update_virtual_cursor_extmarks(r)end end;function a.set_ignore_cursor_movement(A)g=A end;function a.cursor_moved()if g then return end;local B=vim.fn.getcurpos()for j=#e,1,-1 do local r=e[j]c.update_virtual_cursor_position(r)r.editable=not(r.lnum==B[2]and r.col==B[3])c.update_virtual_cursor_extmarks(r)end end;function a.toggle_lock()h=not h end;function a.visit_all(C)if h then return end;local D=vim.fn.getcurpos()local E=vim.wo.ve;if b.is_mode_insert_replace()then vim.wo.ve="onemore"end;for j,r in ipairs(e)do c.update_virtual_cursor_position(r)if not r.delete then C(r,j)c.update_virtual_cursor_extmarks(r)end end;if b.is_mode_insert_replace()then vim.wo.ve=E end;vim.fn.cursor({D[2],D[3],D[4],D[5]})i()k()end;function a.visit_with_cursor(C)g=true;a.visit_all(function(r,j)r:set_cursor_position()C(r,j)end)g=false end;function a.move_with_normal_command(F,G)a.visit_with_cursor(function(r)b.normal_bang(nil,F,G,nil)r:save_cursor_position()if b.is_mode_insert_replace()then if r.curswant==vim.v.maxcol then r.col=b.get_max_col(r.lnum)end end end)end;function a.edit(C)g=true;c.save_cursor()a.visit_all(function(r,j)if r.editable then C(r,j)end end)c.restore_cursor()g=false end;function a.edit_with_cursor_no_save(C)a.edit(function(r,j)r:set_cursor_position()C(r,j)end)end;function a.edit_with_cursor(C)a.edit_with_cursor_no_save(function(r,j)C(r,j)r:save_cursor_position()end)end;function a.edit_with_normal_command(F,G,H)a.edit_with_cursor(function(r)b.normal_bang(nil,F,G,H)end)end;function a.normal_mode_delete_yank(I,F,G,H)a.edit_with_cursor(function(r,j)b.normal_bang(I,F,G,H)r:save_register(I)end)end;function a.normal_mode_put(I,F,G)local J=true;for w,r in ipairs(e)do if r.editable and not r:has_register(I)then J=false;break end end;if not J then local K=vim.fn.getreginfo(I)if next(K)==nil then return end end;a.edit_with_cursor(function(r,j)local K=nil;if J then K=vim.fn.getreginfo(I)r:set_register(I)end;b.normal_bang(I,F,G,nil)if K then vim.fn.setreg(I,K)end end)end;function a.visual_mode(C)g=true;c.save_visual_area()a.visit_all(function(r,j)r:set_visual_area()C(r,j)if b.is_mode("v")then r:save_visual_area()else r:save_cursor_position()r.visual_start_lnum=0;r.visual_start_col=0 end end)c.restore_visual_area()g=false end;function a.visual_mode_delete_yank(I,G)a.visual_mode(function(r,j)b.normal_bang(I,0,G,nil)r:save_register(I)end)end;local function L(p)local B=vim.fn.getcurpos()B[2]=p;if not vim.o.startofline then B[3]=b.get_col(p,B[5])else B[3]=vim.fn.match(vim.fn.getline(p),"\\S")+1;B[5]=B[3]end;vim.fn.cursor({B[2],B[3],0,B[5]})end;function a.go_to(p)if h then return end;local M=vim.fn.line("$")local N=#e+1;if N>M then return end;if p+N-1>M then p=M-N+1 end;local O=n()g=true;for j,r in ipairs(e)do if O==j then L(p)p=p+1 end;c.update_virtual_cursor_position(r)r.lnum=p;if not vim.o.startofline then r.col=b.get_col(p,r.curswant)else r.col=vim.fn.match(vim.fn.getline(p),"\\S")+1;r.curswant=r.col end;c.update_virtual_cursor_extmarks(r)p=p+1 end;if O==0 then L(p)end;g=false end;function a.can_split_paste(M)local F=0;for w,r in ipairs(e)do if r.editable then F=F+1 end end;return F+1==M end;function a.reorder_lines_for_split_pasting(P)a.sort()local O=n()if O~=0 then local Q=table.remove(P,O)table.insert(P,Q)end end;local function R(S,T)for w,U in ipairs(S)do table.insert(T,U)end end;function a.get_registers()local V={}for w,r in ipairs(e)do for W,X in pairs(r.registers)do V[W]=true end end;local Y={}for W,w in pairs(V)do table.insert(Y,W)end;return Y end;function a.merge_register_info(I)local O=n()local K=vim.fn.getreginfo(I)local Z={}for j,r in ipairs(e)do if O==j then R(K.regcontents,Z)end;R(r.registers[I].regcontents,Z)end;if O==0 then R(K.regcontents,Z)end;K.regcontents=Z;vim.fn.setreg(I,K)end;return a
