local a=require('cmp_nvim_lsp.source')local b={}b.client_source_map={}b.setup=function()vim.api.nvim_create_autocmd('InsertEnter',{group=vim.api.nvim_create_augroup('cmp_nvim_lsp',{clear=true}),pattern='*',callback=b._on_insert_enter})end;local c=function(d,e)if d==nil then return e end;return d end;local function f(g,h,i,j,k)local l=g..' is deprecated'j=j or'Nvim'l=h and l..', use '..h..' instead.'or l;l=l..' See :h deprecated\nThis function will be removed in '..j..' version '..i;if vim.notify_once(l,vim.log.levels.WARN)and k~=false then vim.notify(debug.traceback('',2):sub(2),vim.log.levels.WARN)end end;b.default_capabilities=function(m)m=m or{}return{textDocument={completion={dynamicRegistration=c(m.dynamicRegistration,false),completionItem={snippetSupport=c(m.snippetSupport,true),commitCharactersSupport=c(m.commitCharactersSupport,true),deprecatedSupport=c(m.deprecatedSupport,true),preselectSupport=c(m.preselectSupport,true),tagSupport=c(m.tagSupport,{valueSet={1}}),insertReplaceSupport=c(m.insertReplaceSupport,true),resolveSupport=c(m.resolveSupport,{properties={"documentation","detail","additionalTextEdits","sortText","filterText","insertText","textEdit","insertTextFormat","insertTextMode"}}),insertTextModeSupport=c(m.insertTextModeSupport,{valueSet={1,2}}),labelDetailsSupport=c(m.labelDetailsSupport,true)},contextSupport=c(m.snippetSupport,true),insertTextMode=c(m.insertTextMode,1),completionList=c(m.completionList,{itemDefaults={'commitCharacters','editRange','insertTextFormat','insertTextMode','data'}})}}}end;b.update_capabilities=function(n,m)local o=vim.deprecate or f;o('cmp_nvim_lsp.update_capabilities','cmp_nvim_lsp.default_capabilities','1.0.0','cmp-nvim-lsp')return b.default_capabilities(m)end;b._on_insert_enter=function()local p=require('cmp')local q={}local r=vim.lsp.get_clients~=nil and vim.lsp.get_clients or vim.lsp.get_active_clients;for n,s in ipairs(r())do q[s.id]=s;if not b.client_source_map[s.id]then local t=a.new(s)if t:is_available()then b.client_source_map[s.id]=p.register_source('nvim_lsp',t)end end end;for n,s in ipairs(r({bufnr=0}))do q[s.id]=s;if not b.client_source_map[s.id]then local t=a.new(s)if t:is_available()then b.client_source_map[s.id]=p.register_source('nvim_lsp',t)end end end;for u,v in pairs(b.client_source_map)do if not q[u]or q[u]:is_stopped()then p.unregister_source(v)b.client_source_map[u]=nil end end end;return b
