local a={}local b={}a.setup=function(c)_G.MiniPick=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()b.create_user_commands()local d=vim.paste;vim.paste=function(...)if not a.is_picker_active()then return d(...)end;vim.notify('(mini.pick) Use `mappings.paste` (`<C-r>` by default) with "*" or "+" register.',vim.log.levels.HINT)end end;a.config={delay={async=10,busy=50},mappings={caret_left='<Left>',caret_right='<Right>',choose='<CR>',choose_in_split='<C-s>',choose_in_tabpage='<C-t>',choose_in_vsplit='<C-v>',choose_marked='<M-CR>',delete_char='<BS>',delete_char_right='<Del>',delete_left='<C-u>',delete_word='<C-w>',mark='<C-x>',mark_all='<C-a>',move_down='<C-n>',move_start='<C-g>',move_up='<C-p>',paste='<C-r>',refine='<C-Space>',refine_marked='<M-Space>',scroll_down='<C-f>',scroll_left='<C-h>',scroll_right='<C-l>',scroll_up='<C-b>',stop='<Esc>',toggle_info='<S-Tab>',toggle_preview='<Tab>'},options={content_from_bottom=false,use_cache=false},source={items=nil,name=nil,cwd=nil,match=nil,show=nil,preview=nil,choose=nil,choose_marked=nil},window={config=nil,prompt_cursor='▏',prompt_prefix='> '}}a.start=function(e)if a.is_picker_active()then a.stop()return vim.defer_fn(function()if a.is_picker_active()then b.picker_stop(b.pickers.active,true)end;a.start(e)end,0.5)end;b.cache={}e=b.validate_picker_opts(e)local f=b.picker_new(e)b.pickers.active=f;b.picker_set_busy(f,true)local g=b.expand_callable(e.source.items)if b.islist(g)then vim.schedule(function()a.set_picker_items(g)end)end;b.picker_track_lost_focus(f)return b.picker_advance(f)end;a.stop=function()if not a.is_picker_active()then return end;b.cache.is_force_stop_advance=true;if b.cache.is_in_getcharstr then vim.api.nvim_feedkeys('\3','t',true)end end;a.refresh=function()if not a.is_picker_active()then return end;b.picker_update(b.pickers.active,false,true)end;a.default_match=function(h,i,j,k)local l=k or not a.is_picker_active()local m=l and function(n)return n end or a.set_picker_match_inds;local o=function()if#j==0 then return m(b.seq_along(h))end;local p,q=b.match_filter(i,h,j)if p==nil then return end;if q=='nosort'then return m(b.seq_along(h))end;local r=b.match_sort(p)if r==nil then return end;return m(r)end;if l then return o()end;coroutine.resume(coroutine.create(o))end;a.default_show=function(s,g,j,e)local t={directory=' ',file=' ',none='  '}e=vim.tbl_deep_extend('force',{show_icons=false,icons=t},e or{})local u=e.show_icons and function(v)return b.get_icon(v,e.icons)end or function()return{text=''}end;local w=vim.tbl_map(u,g)local x=vim.tbl_map(b.item_to_string,g)local y=string.rep(' ',vim.o.tabstop)x=vim.tbl_map(function(z)return z:gsub('%z','│'):gsub('\n',' '):gsub('\t',y)end,x)local A={}for B,z in ipairs(x)do A[B]=w[B].text..z end;b.set_buflines(s,A)local C=b.ns_id.ranges;b.clear_namespace(s,C)if b.query_is_ignorecase(j)then x,j=vim.tbl_map(b.tolower,x),vim.tbl_map(b.tolower,j)end;local p,q,D=b.match_filter(b.seq_along(x),x,j)if p==nil then return end;local E=q=='fuzzy'and b.match_ranges_fuzzy or b.match_ranges_exact;local F=E(p,D,x)local G={hl_group='MiniPickMatchRanges',hl_mode='combine',priority=200}for B=1,#p do local H,I=p[B][3],F[B]local J=w[H].text:len()for K,L in ipairs(I)do G.end_row,G.end_col=H-1,J+L[2]b.set_extmark(s,C,H-1,J+L[1]-1,G)end end;if not e.show_icons then return end;local M={hl_mode='combine',priority=200}for B=1,#w do M.hl_group=w[B].hl;M.end_row,M.end_col=B-1,w[B].text:len()b.set_extmark(s,C,B-1,0,M)end end;a.default_preview=function(s,v,e)e=vim.tbl_deep_extend('force',{n_context_lines=2*vim.o.lines,line_position='top'},e or{})local N=b.parse_item(v)if N.type=='file'then return b.preview_file(s,N,e)end;if N.type=='directory'then return b.preview_directory(s,N)end;if N.type=='buffer'then return b.preview_buffer(s,N,e)end;if N.type=='uri'then return b.preview_uri(s,N,e)end;b.preview_inspect(s,v)end;a.default_choose=function(v)if v==nil then return end;local O=a.get_picker_state()local P=O~=nil and O.windows.target or vim.api.nvim_get_current_win()if not b.is_valid_win(P)then P=b.get_first_valid_normal_window()end;local N=b.parse_item(v)if N.type=='file'or N.type=='directory'or N.type=='uri'then return b.choose_path(P,N)end;if N.type=='buffer'then return b.choose_buffer(P,N)end;b.choose_print(v)end;a.default_choose_marked=function(g,e)if not b.islist(g)then b.error('`items` should be an array')end;if#g==0 then return end;e=vim.tbl_deep_extend('force',{list_type='quickfix'},e or{})local Q={}for K,v in ipairs(g)do local N=b.parse_item(v)if N.type=='file'or N.type=='buffer'or N.type=='uri'then local R,S=pcall(vim.uri_to_fname,N.path)local T={bufnr=N.buf_id,filename=R and S or N.path}T.lnum,T.col,T.text=N.lnum or 1,N.col or 1,N.text or''T.end_lnum,T.end_col=N.end_lnum,N.end_col;table.insert(Q,T)end end;local U=a.is_picker_active()if#Q==0 then if not U then return end;local V=a.get_picker_opts().source.choose;return V(g[1])end;local W='<No picker>'if U then local X,Y=a.get_picker_opts().source.name,table.concat(a.get_picker_query())W=X..(Y==''and''or' : '..Y)end;local Z={items=Q,title=W,nr='$'}if e.list_type=='location'then local P=a.get_picker_state().windows.target;if not b.is_valid_win(P)then P=b.get_first_valid_normal_window()end;vim.fn.setloclist(P,{},' ',Z)vim.schedule(function()vim.cmd('lopen')end)else vim.fn.setqflist({},' ',Z)vim.schedule(function()vim.cmd('copen')end)end end;a.ui_select=function(g,e,_)local a0=e.format_item or b.item_to_string;local a1={}for B=1,#g do table.insert(a1,{text=a0(g[B]),item=g[B],index=B})end;local a2=vim.is_callable(e.preview_item)and e.preview_item or function(n)return vim.split(vim.inspect(n),'\n')end;local a3=function(s,v)b.set_buflines(s,a2(v.item))end;local a4=true;local V=function(v)a4=false;if v==nil then return end;local P=a.get_picker_state().windows.target;if not b.is_valid_win(P)then P=b.get_first_valid_normal_window()end;vim.api.nvim_win_call(P,function()_(g[v.index],v.index)a.set_picker_target_window(vim.api.nvim_get_current_win())end)end;local a5={items=a1,name=e.prompt or e.kind,preview=a3,choose=V}local v=a.start({source=a5})if v==nil and a4 then _(nil)end end;a.builtin={}a.builtin.files=function(a6,e)a6=vim.tbl_deep_extend('force',{tool=nil},a6 or{})local a7=a6.tool or b.files_get_tool()local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Files (%s)',a7),show=a8}}e=vim.tbl_deep_extend('force',a9,e or{})if a7=='fallback'then e.source.items=function()b.files_fallback_items(e.source.cwd)end;return a.start(e)end;return a.builtin.cli({command=b.files_get_command(a7)},e)end;a.builtin.grep=function(a6,e)a6=vim.tbl_deep_extend('force',{tool=nil,pattern=nil},a6 or{})local a7=a6.tool or b.grep_get_tool()local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Grep (%s)',a7),show=a8}}e=vim.tbl_deep_extend('force',a9,e or{})local aa=type(a6.pattern)=='string'and a6.pattern or vim.fn.input('Grep pattern: ')if a7=='fallback'then e.source.items=function()b.grep_fallback_items(aa,e.source.cwd)end;return a.start(e)end;return a.builtin.cli({command=b.grep_get_command(a7,aa)},e)end;a.builtin.grep_live=function(a6,e)a6=vim.tbl_deep_extend('force',{tool=nil},a6 or{})local a7=a6.tool or b.grep_get_tool()if a7=='fallback'or not b.is_executable(a7)then b.error('`grep_live` needs non-fallback executable tool.')end;local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Grep live (%s)',a7),show=a8}}e=vim.tbl_deep_extend('force',a9,e or{})local ab,ac={do_match=false,querytick=b.querytick},{cwd=e.source.cwd}local ad;local ae=function(K,K,j)pcall(vim.loop.process_kill,ad)if b.querytick==ab.querytick then return end;if#j==0 then return a.set_picker_items({},ab)end;ab.querytick=b.querytick;local af=b.grep_get_command(a7,table.concat(j))ad=a.set_picker_items_from_cli(af,{set_items_opts=ab,spawn_opts=ac})end;e=vim.tbl_deep_extend('force',e or{},{source={items={},match=ae}})return a.start(e)end;a.builtin.help=function(a6,e)local ag=vim.api.nvim_create_buf(false,true)vim.bo[ag].buftype='help'local ah=vim.api.nvim_buf_call(ag,function()return vim.fn.taglist('.*')end)vim.api.nvim_buf_delete(ag,{force=true})vim.tbl_map(function(ai)ai.text=ai.name end,ah)local V=function(v,aj)if v==nil then return end;vim.schedule(function()vim.cmd((aj or'')..'help '..(v.name or''))end)end;local a3=function(s,v)vim.api.nvim_buf_call(s,function()vim.cmd('noautocmd edit '..vim.fn.fnameescape(v.filename))vim.bo.buftype,vim.bo.buflisted,vim.bo.bufhidden='nofile',false,'wipe'local ak=pcall(vim.treesitter.start,0)if not ak then vim.bo.syntax='help'end;local al=vim.v.hlsearch;local am=string.gsub(v.cmd,'^/','/\\V')vim.cmd('silent keeppatterns '..am)vim.cmd('let v:hlsearch='..al)vim.cmd('normal! zt')end)end;local an=function(ao,aj)local o=function()V(a.get_picker_matches().current,aj..' ')return true end;return{char=ao,func=o}end;local ap={choose_in_split='',show_help_in_split=an('<C-s>',''),choose_in_vsplit='',show_help_in_vsplit=an('<C-v>','vertical'),choose_in_tabpage='',show_help_in_tabpage=an('<C-t>','tab')}local a5={items=ah,name='Help',choose=V,preview=a3}e=vim.tbl_deep_extend('force',{source=a5,mappings=ap},e or{})return a.start(e)end;a.builtin.buffers=function(a6,e)a6=vim.tbl_deep_extend('force',{include_current=true,include_unlisted=false},a6 or{})local aq=vim.api.nvim_exec('buffers'..(a6.include_unlisted and'!'or''),true)local ar,as=vim.api.nvim_get_current_buf(),a6.include_current;local g={}for K,z in ipairs(vim.split(aq,'\n'))do local at,au=z:match('^%s*%d+'),z:match('"(.*)"')local s=tonumber(at)local v={text=au,bufnr=s}if s~=ar or as then table.insert(g,v)end end;local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name='Buffers',show=a8}}e=vim.tbl_deep_extend('force',a9,e or{},{source={items=g}})return a.start(e)end;a.builtin.cli=function(a6,e)a6=vim.tbl_deep_extend('force',{command={},postprocess=nil,spawn_opts={}},a6 or{})local au=string.format('CLI (%s)',tostring(a6.command[1]or''))e=vim.tbl_deep_extend('force',{source={name=au}},e or{})a6.spawn_opts.cwd=a6.spawn_opts.cwd or e.source.cwd;local af=a6.command;local av={postprocess=a6.postprocess,spawn_opts=a6.spawn_opts}e.source.items=vim.schedule_wrap(function()a.set_picker_items_from_cli(af,av)end)return a.start(e)end;a.builtin.resume=function()local f=b.pickers.latest;if f==nil then b.error('There is no picker to resume.')end;b.cache={}local s=b.picker_new_buf()local P=vim.api.nvim_get_current_win()local aw=b.picker_new_win(s,f.opts.window.config)f.buffers={main=s}f.windows={main=aw,target=P}f.view_state='main'b.pickers.active=f;return b.picker_advance(f)end;a.registry={}for au,o in pairs(a.builtin)do a.registry[au]=function(a6)return o(a6)end end;if type(MiniExtra)=='table'then for au,o in pairs(MiniExtra.pickers)do a.registry[au]=function(a6)return o(a6)end end end;a.get_picker_items=function()return vim.deepcopy((b.pickers.active or{}).items)end;a.get_picker_stritems=function()return vim.deepcopy((b.pickers.active or{}).stritems)end;a.get_picker_matches=function()if not a.is_picker_active()then return end;local f=b.pickers.active;local g=f.items;if g==nil or#g==0 then return{}end;local ax={all_inds=vim.deepcopy(f.match_inds),current_ind=f.match_inds[f.current_ind]}ax.all=vim.tbl_map(function(ay)return g[ay]end,f.match_inds)ax.current=f.items[ax.current_ind]local az=vim.tbl_keys(f.marked_inds_map)table.sort(az)ax.marked_inds,ax.marked=az,vim.tbl_map(function(ay)return g[ay]end,az)return ax end;a.get_picker_opts=function()return vim.deepcopy((b.pickers.active or{}).opts)end;a.get_picker_state=function()if not a.is_picker_active()then return end;local f=b.pickers.active;return vim.deepcopy({buffers=f.buffers,windows=f.windows,caret=f.caret,is_busy=f.is_busy})end;a.get_picker_query=function()return vim.deepcopy((b.pickers.active or{}).query)end;a.set_picker_items=function(g,e)if not b.islist(g)then b.error('`items` should be an array.')end;if not a.is_picker_active()then return end;e=vim.tbl_deep_extend('force',{do_match=true,querytick=nil},e or{})coroutine.wrap(b.picker_set_items)(b.pickers.active,g,e)end;a.set_picker_items_from_cli=function(af,e)if not a.is_picker_active()then return end;local aA=b.is_array_of(af,'string')and#af>=1;if not aA then b.error('`command` should be an array of strings.')end;local a9={postprocess=b.cli_postprocess,set_items_opts={},spawn_opts={}}e=vim.tbl_deep_extend('force',a9,e or{})local aB,aC=af[1],vim.list_slice(af,2,#af)local ad,aD,aE=nil,nil,vim.loop.new_pipe()local ac=vim.tbl_deep_extend('force',e.spawn_opts,{args=aC,stdio={nil,aE,nil}})if type(ac.cwd)=='string'then ac.cwd=b.full_path(ac.cwd)end;ad,aD=vim.loop.spawn(aB,ac,function()ad:close()end)local aF={}aE:read_start(function(aG,aH)assert(not aG,aG)if aH~=nil then return table.insert(aF,aH)end;local g=vim.split(table.concat(aF),'\n')aF=nil;aE:close()vim.schedule(function()a.set_picker_items(e.postprocess(g),e.set_items_opts)end)end)return ad,aD end;a.set_picker_match_inds=function(r)if not a.is_picker_active()then return end;if not b.is_array_of(r,'number')then b.error('`match_inds` should be an array of numbers.')end;b.picker_set_match_inds(b.pickers.active,r)b.picker_update(b.pickers.active,false)end;a.set_picker_opts=function(e)if not a.is_picker_active()then return end;b.pickers.active.opts=vim.tbl_deep_extend('force',b.pickers.active.opts,e or{})b.picker_update(b.pickers.active,true,true)end;a.set_picker_target_window=function(aw)if not a.is_picker_active()then return end;if not b.is_valid_win(aw)then b.error('`win_id` is not a valid window identifier.')end;b.pickers.active.windows.target=aw end;a.set_picker_query=function(j)if not a.is_picker_active()then return end;if not b.is_array_of(j,'string')then b.error('`query` should be an array of strings.')end;b.pickers.active.query,b.pickers.active.caret=j,#j+1;b.querytick=b.querytick+1;b.pickers.active.match_inds=b.seq_along(a.get_picker_items())b.picker_update(b.pickers.active,true)end;a.get_querytick=function()return b.querytick end;a.is_picker_active=function()return b.pickers.active~=nil end;a.poke_is_picker_active=function()local aI=coroutine.running()if aI==nil then return a.is_picker_active()end;b.schedule_resume_is_active(aI)return coroutine.yield()end;b.default_config=vim.deepcopy(a.config)b.ns_id={matches=vim.api.nvim_create_namespace('MiniPickMatches'),headers=vim.api.nvim_create_namespace('MiniPickHeaders'),preview=vim.api.nvim_create_namespace('MiniPickPreview'),ranges=vim.api.nvim_create_namespace('MiniPickRanges')}b.timers={busy=vim.loop.new_timer(),focus=vim.loop.new_timer(),getcharstr=vim.loop.new_timer()}b.pickers={active=nil,latest=nil}b.querytick=0;b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({delay={c.delay,'table'},mappings={c.mappings,'table'},options={c.options,'table'},source={c.source,'table'},window={c.window,'table'}})local aJ=function(n)return n==nil or type(n)=='table'or vim.is_callable(n)end;vim.validate({['delay.async']={c.delay.async,'number'},['delay.busy']={c.delay.busy,'number'},['mappings.caret_left']={c.mappings.caret_left,'string'},['mappings.caret_right']={c.mappings.caret_right,'string'},['mappings.choose']={c.mappings.choose,'string'},['mappings.choose_in_split']={c.mappings.choose_in_split,'string'},['mappings.choose_in_tabpage']={c.mappings.choose_in_tabpage,'string'},['mappings.choose_in_vsplit']={c.mappings.choose_in_vsplit,'string'},['mappings.choose_marked']={c.mappings.choose_marked,'string'},['mappings.delete_char']={c.mappings.delete_char,'string'},['mappings.delete_char_right']={c.mappings.delete_char_right,'string'},['mappings.delete_left']={c.mappings.delete_left,'string'},['mappings.delete_word']={c.mappings.delete_word,'string'},['mappings.mark']={c.mappings.mark,'string'},['mappings.mark_all']={c.mappings.mark_all,'string'},['mappings.move_down']={c.mappings.move_down,'string'},['mappings.move_start']={c.mappings.move_start,'string'},['mappings.move_up']={c.mappings.move_up,'string'},['mappings.paste']={c.mappings.paste,'string'},['mappings.refine']={c.mappings.refine,'string'},['mappings.refine_marked']={c.mappings.refine_marked,'string'},['mappings.scroll_down']={c.mappings.scroll_down,'string'},['mappings.scroll_up']={c.mappings.scroll_up,'string'},['mappings.scroll_left']={c.mappings.scroll_left,'string'},['mappings.scroll_right']={c.mappings.scroll_right,'string'},['mappings.stop']={c.mappings.stop,'string'},['mappings.toggle_info']={c.mappings.toggle_info,'string'},['mappings.toggle_preview']={c.mappings.toggle_preview,'string'},['options.content_from_bottom']={c.options.content_from_bottom,'boolean'},['options.use_cache']={c.options.use_cache,'boolean'},['source.items']={c.source.items,'table',true},['source.name']={c.source.name,'string',true},['source.cwd']={c.source.cwd,'string',true},['source.match']={c.source.match,'function',true},['source.show']={c.source.show,'function',true},['source.preview']={c.source.preview,'function',true},['source.choose']={c.source.choose,'function',true},['source.choose_marked']={c.source.choose_marked,'function',true},['window.config']={c.window.config,aJ,'table or callable'},['window.prompt_cursor']={c.window.prompt_cursor,'string'},['window.prompt_prefix']={c.window.prompt_prefix,'string'}})return c end;b.apply_config=function(c)a.config=c end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minipick_config or{},c or{})end;b.create_autocommands=function(c)local aK=vim.api.nvim_create_augroup('MiniPick',{})local aL=function(aM,aa,aN,aO)vim.api.nvim_create_autocmd(aM,{group=aK,pattern=aa,callback=aN,desc=aO})end;aL('VimResized','*',a.refresh,'Refresh on resize')end;b.create_default_hl=function()local aP=function(au,e)e.default=true;vim.api.nvim_set_hl(0,au,e)end;aP('MiniPickBorder',{link='FloatBorder'})aP('MiniPickBorderBusy',{link='DiagnosticFloatingWarn'})aP('MiniPickBorderText',{link='FloatTitle'})aP('MiniPickIconDirectory',{link='Directory'})aP('MiniPickIconFile',{link='MiniPickNormal'})aP('MiniPickHeader',{link='DiagnosticFloatingHint'})aP('MiniPickMatchCurrent',{link='CursorLine'})aP('MiniPickMatchMarked',{link='Visual'})aP('MiniPickMatchRanges',{link='DiagnosticFloatingHint'})aP('MiniPickNormal',{link='NormalFloat'})aP('MiniPickPreviewLine',{link='CursorLine'})aP('MiniPickPreviewRegion',{link='IncSearch'})aP('MiniPickPrompt',{link='DiagnosticFloatingInfo'})end;b.create_user_commands=function()local aN=function(aQ)local au,a6=b.command_parse_fargs(aQ.fargs)local o=a.registry[au]if o==nil then b.error(string.format('There is no picker named "%s" in registry.',au))end;o(a6)end;local e={nargs='+',complete=b.command_complete,desc="Pick from 'mini.pick' registry"}vim.api.nvim_create_user_command('Pick',aN,e)end;b.command_parse_fargs=function(aR)local au,aS=aR[1],vim.tbl_map(b.expandcmd,vim.list_slice(aR,2,#aR))local aT=string.format('{ %s }',table.concat(aS,', '))local aU=loadstring('return '..aT)if aU==nil then b.error('Could not convert extra command arguments to table: '..aT)end;return au,aU()end;b.command_complete=function(K,aV,aW)local aX,aY,aZ=string.find(aV,'^%S+%s+(%S*)')if aW<aX or aY<aW then return{}end;local a_=vim.tbl_filter(function(n)return tostring(n):find(aZ,1,true)~=nil end,vim.tbl_keys(a.registry))table.sort(a_)return a_ end;b.validate_picker_opts=function(e)e=e or{}if type(e)~='table'then b.error('Picker options should be table.')end;e=vim.deepcopy(b.get_config(e))local b0=function(n,b1)if not vim.is_callable(n)then b.error(string.format('`%s` should be callable.',b1))end end;local a5=e.source;local g=a5.items or{}local b2=b.islist(g)or vim.is_callable(g)if not b2 then b.error('`source.items` should be array or callable.')end;a5.name=tostring(a5.name or'<No name>')if type(a5.cwd)=='string'then a5.cwd=b.full_path(a5.cwd)end;if a5.cwd==nil then a5.cwd=vim.fn.getcwd()end;if vim.fn.isdirectory(a5.cwd)==0 then b.error('`source.cwd` should be a valid directory path.')end;a5.match=a5.match or a.default_match;b0(a5.match,'source.match')a5.show=a5.show or a.default_show;b0(a5.show,'source.show')a5.preview=a5.preview or a.default_preview;b0(a5.preview,'source.preview')a5.choose=a5.choose or a.default_choose;b0(a5.choose,'source.choose')a5.choose_marked=a5.choose_marked or a.default_choose_marked;b0(a5.choose_marked,'source.choose_marked')for b3,b4 in pairs(e.delay)do local b5=type(b4)=='number'and b4>0;if not b5 then b.error(string.format('`delay.%s` should be a positive number.',b3))end end;local b6=b.default_config.mappings;for b7,n in pairs(e.mappings)do if type(b7)~='string'then b.error('`mappings` should have only string fields.')end;local b8=b6[b7]~=nil;if b8 and type(n)~='string'then b.error(string.format('Mapping for built-in action "%s" should be string.',b7))end;if not b8 and not(type(n)=='table'and type(n.char)=='string'and vim.is_callable(n.func))then b.error(string.format('Mapping for custom action "%s" should be table with `char` and `func`.',b7))end end;local b9=e.options;if type(b9.content_from_bottom)~='boolean'then b.error('`options.content_from_bottom` should be boolean.')end;if type(b9.use_cache)~='boolean'then b.error('`options.use_cache` should be boolean.')end;local ba=e.window.config;local bb=ba==nil or type(ba)=='table'or vim.is_callable(ba)if not bb then b.error('`window.config` should be table or callable.')end;return e end;b.picker_new=function(e)local s=b.picker_new_buf()local P=vim.api.nvim_get_current_win()local aw=b.picker_new_win(s,e.window.config)local f={opts=e,items=nil,stritems=nil,stritems_ignorecase=nil,buffers={main=s,preview=nil,info=nil},windows={main=aw,target=P},query={},caret=1,match_inds=nil,marked_inds_map={},is_busy=false,cache={},view_state='main',visible_range={from=nil,to=nil},current_ind=nil}b.querytick=b.querytick+1;return f end;b.picker_advance=function(f)vim.schedule(function()vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStart'})end)local bc=b.picker_get_char_data(f)local bd,be=false,false;for K=1,1000000 do if b.cache.is_force_stop_advance then break end;b.picker_update(f,bd)local ao=b.getcharstr(f.opts.delay.async)if b.cache.is_force_stop_advance then break end;be=ao==nil;if be then break end;local bf=bc[ao]or{}bd=bf.name==nil or vim.startswith(bf.name,'delete')or bf.name=='paste'be=bf.name=='stop'local bg;if bf.is_custom then bg=bf.func()else bg=(bf.func or b.picker_query_add)(f,ao)end;if bg then break end end;local v;if not be then v=b.picker_get_current_item(f)end;b.cache.is_force_stop_advance=nil;b.picker_stop(f)return v end;b.picker_update=function(f,bd,bh)if bd then b.picker_match(f)end;if bh then local c=b.picker_compute_win_config(f.opts.window.config)vim.api.nvim_win_set_config(f.windows.main,c)b.picker_set_current_ind(f,f.current_ind,true)end;b.picker_set_bordertext(f)b.picker_set_lines(f)b.redraw()end;b.picker_new_buf=function()local s=b.create_scratch_buf()vim.bo[s].filetype='minipick'return s end;b.picker_new_win=function(s,ba)if vim.fn.mode()=='n'then b.cache.cmdheight=vim.o.cmdheight;vim.o.cmdheight=1;vim.cmd('noautocmd normal! :')end;local aw=vim.api.nvim_open_win(s,true,b.picker_compute_win_config(ba,true))vim.wo[aw].foldenable=false;vim.wo[aw].list=true;vim.wo[aw].listchars='extends:…'vim.wo[aw].scrolloff=0;vim.wo[aw].wrap=false;b.win_update_hl(aw,'NormalFloat','MiniPickNormal')b.win_update_hl(aw,'FloatBorder','MiniPickBorder')vim.fn.clearmatches(aw)return aw end;b.picker_compute_win_config=function(ba,bi)local bj=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bk=vim.o.laststatus>0;local bl=vim.o.lines-vim.o.cmdheight-(bj and 1 or 0)-(bk and 1 or 0)local bm=vim.o.columns;local bn={relative='editor',anchor='SW',width=math.floor(0.618*bm),height=math.floor(0.618*bl),col=0,row=bl+(bj and 1 or 0),border='single',style='minimal',noautocmd=bi}local c=vim.tbl_deep_extend('force',bn,b.expand_callable(ba)or{})if c.border=='none'then c.border={'',' ','','','',' ','',''}end;c.height=math.min(c.height,bl-2)c.width=math.min(c.width,bm-2)return c end;b.picker_track_lost_focus=function(f)local bo=vim.schedule_wrap(function()local bp=vim.api.nvim_get_current_win()==f.windows.main;local bq=bp and(b.cache.is_in_getcharstr or vim.fn.mode()~='n')if bq then return end;b.picker_stop(f,true)end)b.timers.focus:start(1000,1000,bo)end;b.picker_set_items=function(f,g,e)local h,br,bs={},{},b.tolower;local bt=b.poke_picker_throttle(e.querytick)for B,n in ipairs(g)do if not bt()then return end;local bu=b.item_to_string(n)table.insert(h,bu)table.insert(br,bs(bu))end;f.items,f.stritems,f.stritems_ignorecase=g,h,br;f.cache,f.marked_inds_map={},{}b.picker_set_busy(f,false)b.picker_set_match_inds(f,b.seq_along(g))b.picker_update(f,e.do_match)end;b.item_to_string=function(v)v=b.expand_callable(v)if type(v)=='string'then return v end;if type(v)=='table'and type(v.text)=='string'then return v.text end;return vim.inspect(v,{newline=' ',indent=''})end;b.picker_set_busy=function(f,b4)f.is_busy=b4;local bv=function()b.timers.busy:stop()b.win_update_hl(f.windows.main,'FloatBorder',f.is_busy and'MiniPickBorderBusy'or'MiniPickBorder')end;if b4 then return b.timers.busy:start(f.opts.delay.busy,0,vim.schedule_wrap(bv))end;bv()end;b.picker_set_match_inds=function(f,i)if i==nil then return end;b.picker_set_busy(f,false)f.match_inds=i;local bw=table.concat(f.query)if f.opts.options.use_cache then f.cache[bw]={inds=i}end;b.picker_show_main(f)b.picker_set_current_ind(f,1)end;b.picker_set_current_ind=function(f,ay,bx)if f.items==nil or#f.match_inds==0 then f.current_ind,f.visible_range=nil,{}return end;local by=#f.match_inds;ay=(ay-1)%by+1;local bz,bA,bB=f.visible_range.from,f.visible_range.to,f.visible_range.querytick;local bC=b.querytick~=bB or bz==nil or bA==nil or not(bz<=ay and ay<=bA)if(bx or bC)and b.is_valid_win(f.windows.main)then local bD=vim.api.nvim_win_get_height(f.windows.main)bA=math.min(by,math.floor(ay+0.5*bD))bz=math.max(1,bA-bD+1)bA=bz+math.min(bD,by)-1 end;f.current_ind=ay;f.visible_range={from=bz,to=bA,querytick=b.querytick}end;b.picker_set_lines=function(f)local s,aw=f.buffers.main,f.windows.main;if not(b.is_valid_buf(s)and b.is_valid_win(aw))then return end;if f.is_busy then return end;local bE,j=f.visible_range,f.query;if f.items==nil or bE.from==nil or bE.to==nil then f.opts.source.show(s,{},j)b.clear_namespace(s,b.ns_id.matches)return end;local bF,g,r={},f.items,f.match_inds;local bG,bH=f.current_ind,nil;local bI,bJ=f.marked_inds_map,{}local bK=f.opts.options.content_from_bottom;local bz=bK and bE.to or bE.from;local bA=bK and bE.from or bE.to;for B=bz,bA,bz<=bA and 1 or-1 do table.insert(bF,g[r[B]])if B==bG then bH=#bF end;if bI[r[B]]then table.insert(bJ,#bF)end end;local bL=bK and vim.api.nvim_win_get_height(aw)-#bF or 0;bH=bH+bL;bJ=vim.tbl_map(function(n)return n+bL end,bJ)f.opts.source.show(s,bF,j)if bL>0 then local bM=vim.fn['repeat']({''},bL)vim.api.nvim_buf_set_lines(s,0,0,true,bM)end;local C=b.ns_id.matches;b.clear_namespace(s,C)local bN={end_col=0,hl_group='MiniPickMatchMarked',priority=202}for K,bO in ipairs(bJ)do bN.end_row=bO;b.set_extmark(s,C,bO-1,0,bN)end;if bH>vim.api.nvim_buf_line_count(s)then return end;local bP={end_row=bH,end_col=0,hl_eol=true,hl_group='MiniPickMatchCurrent',priority=201}b.set_extmark(s,C,bH-1,0,bP)local bQ=vim.api.nvim_win_get_cursor(aw)if f.view_state=='main'and bQ[1]~=bH then b.set_cursor(aw,bH,bQ[2]+1)end end;b.picker_match=function(f)if f.items==nil then return end;local bR;if f.opts.options.use_cache then bR=f.cache[table.concat(f.query)]end;if bR~=nil then return b.picker_set_match_inds(f,bR.inds)end;local bS=b.query_is_ignorecase(f.query)local h=bS and f.stritems_ignorecase or f.stritems;local j=bS and vim.tbl_map(b.tolower,f.query)or f.query;b.picker_set_busy(f,true)local bT=f.opts.source.match(h,f.match_inds,j)b.picker_set_match_inds(f,bT)end;b.query_is_ignorecase=function(j)if not vim.o.ignorecase then return false end;if not vim.o.smartcase then return true end;local Y=table.concat(j)return Y==vim.fn.tolower(Y)end;b.picker_get_char_data=function(f,bU)local bV=b.replace_termcodes;local ax={}local bW={}if not bU then bW={move_down='<Down>',move_start='<Home>',move_up='<Up>'}end;for au,bX in pairs(f.opts.mappings)do local bY=type(bX)=='table'local ao=bY and bX.char or bX;local aH={char=ao,name=au,func=bY and bX.func or b.actions[au],is_custom=bY}ax[bV(ao)]=aH;local bZ=bW[au]if bZ~=nil then ax[bV(bZ)]=aH end end;return ax end;b.picker_set_bordertext=function(f)local e=f.opts;local aw=f.windows.main;if not b.is_valid_win(aw)then return end;local b_=f.view_state;local c;if b_=='main'then local j,c0=f.query,f.caret;local c1=table.concat(vim.list_slice(j,1,c0-1),'')local c2=table.concat(vim.list_slice(j,c0,#j),'')local c3=e.window.prompt_prefix..c1 ..e.window.prompt_cursor..c2;local Y={{b.win_trim_to_width(aw,c3),'MiniPickPrompt'}}c={title=Y}end;local c4=f.items~=nil;if b_=='preview'and c4 then local c5=f.stritems[f.match_inds[f.current_ind]]or''c5=c5:gsub('%z','│'):gsub('%s',' ')c={title={{b.win_trim_to_width(aw,c5),'MiniPickBorderText'}}}end;if b_=='info'then c={title={{b.win_trim_to_width(aw,'Info'),'MiniPickBorderText'}}}end;local c6=vim.fn.has('nvim-0.10')==1;if c6 and not f.is_busy then c.footer,c.footer_pos=b.picker_compute_footer(f,aw),'left'end;if c6 and e.options.content_from_bottom then c.title,c.footer=c.footer,c.title end;vim.api.nvim_win_set_config(aw,c)vim.wo[aw].list=true end;if vim.fn.has('nvim-0.9')==0 then b.picker_set_bordertext=function()end end;b.picker_compute_footer=function(f,aw)local c7=b.picker_get_general_info(f)local X=string.format(' %s ',c7.source_name)local c8=c7.n_marked==0 and''or c7.n_marked..'/'local i=string.format(' %s|%s|%s%s ',c7.relative_current_ind,c7.n_matched,c8,c7.n_total)local c9,ca,cb=vim.api.nvim_win_get_width(aw),vim.fn.strchars(X),vim.fn.strchars(i)local cc={{X,'MiniPickBorderText'}}local cd=c9-(ca+cb)if cd>0 then local ce=f.is_busy and'MiniPickBorderBusy'or'MiniPickBorder'cc[2]={b.win_get_bottom_border(aw):rep(cd),ce}cc[3]={i,'MiniPickBorderText'}end;return cc end;b.picker_stop=function(f,cf)vim.tbl_map(function(cg)pcall(vim.loop.timer_stop,cg)end,b.timers)pcall(function()vim.o.cmdheight=b.cache.cmdheight end)if f==nil then return end;vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStop'})if cf then b.pickers={}else local ch=vim.deepcopy(f)b.picker_free(b.pickers.latest)b.pickers={active=nil,latest=ch}end;b.set_curwin(f.windows.target)pcall(vim.api.nvim_win_close,f.windows.main,true)pcall(vim.api.nvim_buf_delete,f.buffers.main,{force=true})pcall(vim.api.nvim_buf_delete,f.buffers.info,{force=true})f.windows,f.buffers={},{}b.querytick=b.querytick+1 end;b.picker_free=function(f)if f==nil then return end;f.match_inds=nil;f.cache=nil;f.stritems,f.stritems_ignorecase,f.marked_inds_map=nil,nil,nil;f.items=nil;f=nil;vim.schedule(function()collectgarbage('collect')end)end;b.actions={caret_left=function(f,K)b.picker_move_caret(f,-1)end,caret_right=function(f,K)b.picker_move_caret(f,1)end,choose=function(f,K)return b.picker_choose(f,nil)end,choose_in_split=function(f,K)return b.picker_choose(f,'split')end,choose_in_tabpage=function(f,K)return b.picker_choose(f,'tabnew')end,choose_in_vsplit=function(f,K)return b.picker_choose(f,'vsplit')end,choose_marked=function(f,K)return not f.opts.source.choose_marked(a.get_picker_matches().marked)end,delete_char=function(f,K)b.picker_query_delete(f,1)end,delete_char_right=function(f,K)b.picker_query_delete(f,0)end,delete_left=function(f,K)b.picker_query_delete(f,f.caret-1)end,delete_word=function(f,K)local ci,cj=f.caret-1,0;if ci==0 then return end;local ck=vim.fn.match(f.query[ci],'[[:keyword:]]')>=0;for B=ci,1,-1 do local cl=vim.fn.match(f.query[B],'[[:keyword:]]')>=0;if ck and not cl or not ck and cl then break end;cj=cj+1 end;b.picker_query_delete(f,cj)end,mark=function(f,K)b.picker_mark_indexes(f,'current')end,mark_all=function(f,K)b.picker_mark_indexes(f,'all')end,move_down=function(f,K)b.picker_move_current(f,1)end,move_start=function(f,K)b.picker_move_current(f,nil,1)end,move_up=function(f,K)b.picker_move_current(f,-1)end,paste=function(f,K)local cm=b.getcharstr(f.opts.delay.async)local cn,co=pcall(vim.fn.getreg,cm)if not cn then return end;co=co:gsub('[\n\t]',' ')for B=1,vim.fn.strchars(co)do b.picker_query_add(f,vim.fn.strcharpart(co,B-1,1))end end,refine=function(f,K)b.picker_refine(f,'all')end,refine_marked=function(f,K)b.picker_refine(f,'marked')end,scroll_down=function(f,K)b.picker_scroll(f,'down')end,scroll_up=function(f,K)b.picker_scroll(f,'up')end,scroll_left=function(f,K)b.picker_scroll(f,'left')end,scroll_right=function(f,K)b.picker_scroll(f,'right')end,toggle_info=function(f,K)if f.view_state=='info'then return b.picker_show_main(f)end;b.picker_show_info(f)end,toggle_preview=function(f,K)if f.view_state=='preview'then return b.picker_show_main(f)end;b.picker_show_preview(f)end,stop=function(K,K)return true end}b.picker_query_add=function(f,ao)if vim.fn.strchars(ao)>1 or vim.fn.char2nr(ao)<=31 then return end;table.insert(f.query,f.caret,ao)f.caret=f.caret+1;b.querytick=b.querytick+1;local cp=f.items~=nil and f.caret<=#f.query;if cp then f.match_inds=b.seq_along(f.items)end end;b.picker_query_delete=function(f,cq)local cr=cq>0;local cs=cr and math.max(f.caret-cq,1)or f.caret;local ct=cr and f.caret-1 or math.min(f.caret+cq,#f.query)for B=ct,cs,-1 do table.remove(f.query,B)end;f.caret=cs;b.querytick=b.querytick+1;if f.items~=nil then f.match_inds=b.seq_along(f.items)end end;b.picker_choose=function(f,cu)local cv=b.picker_get_current_item(f)if cv==nil then return true end;local cw=f.windows.target;if cu~=nil and b.is_valid_win(cw)then vim.api.nvim_win_call(cw,function()vim.cmd(cu)f.windows.target=vim.api.nvim_get_current_win()end)end;return not f.opts.source.choose(cv)end;b.picker_mark_indexes=function(f,cx)if f.items==nil then return end;local cy=cx=='current'and{f.match_inds[f.current_ind]}or f.match_inds;local bI,cz=f.marked_inds_map,true;for K,ay in ipairs(cy)do cz=cz and bI[ay]end;local cA;if not cz then cA=true end;for K,ay in ipairs(cy)do bI[ay]=cA end;if f.view_state=='info'then b.picker_show_info(f)end end;b.picker_move_caret=function(f,cq)f.caret=math.min(math.max(f.caret+cq,1),#f.query+1)end;b.picker_move_current=function(f,cB,bA)if f.items==nil then return end;local by=#f.match_inds;if by==0 then return end;if bA==nil then cB=(f.opts.options.content_from_bottom and-1 or 1)*cB;bA=f.current_ind;if bA==1 and cB<0 then bA=by elseif bA==by and cB>0 then bA=1 else bA=bA+cB end;bA=math.min(math.max(bA,1),by)end;b.picker_set_current_ind(f,bA)if f.view_state=='info'then b.picker_show_info(f)end;if f.view_state=='preview'then b.picker_show_preview(f)end end;b.picker_refine=function(f,cC)if f.items==nil then return end;f.opts.source.match=b.get_config().source.match or a.default_match;f.query,f.caret={},1;a.set_picker_items(a.get_picker_matches()[cC]or{})f._refine=f._refine or{orig_name=f.opts.source.name,count=0}f._refine.count=f._refine.count+1;local cD=f._refine.count==1 and''or' '..f._refine.count;f.opts.source.name=string.format('%s (Refine%s)',f._refine.orig_name,cD)end;b.picker_scroll=function(f,cE)local aw=f.windows.main;if f.view_state=='main'and(cE=='down'or cE=='up')then local cq=(cE=='down'and 1 or-1)*vim.api.nvim_win_get_height(aw)b.picker_move_current(f,cq)else local cF=({down='<C-f>',up='<C-b>',left='zH',right='zL'})[cE]vim.api.nvim_win_call(aw,function()vim.cmd('normal! '..b.replace_termcodes(cF))end)end end;b.picker_get_current_item=function(f)if f.items==nil then return nil end;return f.items[f.match_inds[f.current_ind]]end;b.picker_show_main=function(f)b.set_winbuf(f.windows.main,f.buffers.main)f.view_state='main'end;b.picker_show_info=function(f)local c7=b.picker_get_general_info(f)local x={'General','Source name   │ '..c7.source_name,'Source cwd    │ '..c7.source_cwd,'Total items   │ '..c7.n_total,'Matched items │ '..c7.n_matched,'Marked items  │ '..c7.n_marked,'Current index │ '..c7.relative_current_ind}local cG={1}local cH=function(aH,cI)if#aH==0 then return end;table.insert(x,'')table.insert(x,cI)table.insert(cG,#x)local cJ=0;for K,ai in ipairs(aH)do local aO=ai.name:gsub('[%s%p]',' ')ai.desc=vim.fn.toupper(aO:sub(1,1))..aO:sub(2)ai.width=vim.fn.strchars(ai.desc)cJ=math.max(cJ,ai.width)end;table.sort(aH,function(cK,cL)return cK.desc<cL.desc end)for K,ai in ipairs(aH)do table.insert(x,string.format('%s%s │ %s',ai.desc,string.rep(' ',cJ-ai.width),ai.char))end end;local bc=b.picker_get_char_data(f,true)cH(vim.tbl_filter(function(n)return n.is_custom end,bc),'Mappings (custom)')cH(vim.tbl_filter(function(n)return not n.is_custom end,bc),'Mappings (built-in)')local cM=f.buffers.info;if not b.is_valid_buf(cM)then cM=b.create_scratch_buf()end;f.buffers.info=cM;b.set_buflines(cM,x)b.set_winbuf(f.windows.main,cM)f.view_state='info'local C=b.ns_id.headers;b.clear_namespace(cM,C)for K,bO in ipairs(cG)do b.set_extmark(cM,C,bO-1,0,{end_row=bO,end_col=0,hl_group='MiniPickHeader'})end end;b.picker_get_general_info=function(f)local c4=f.items~=nil;return{source_name=f.opts.source.name or'---',source_cwd=vim.fn.fnamemodify(f.opts.source.cwd,':~')or'---',n_total=c4 and#f.items or'-',n_matched=c4 and#f.match_inds or'-',n_marked=c4 and vim.tbl_count(f.marked_inds_map)or'-',relative_current_ind=c4 and f.current_ind or'-'}end;b.picker_show_preview=function(f)local a3=f.opts.source.preview;local v=b.picker_get_current_item(f)if v==nil then return end;local aw,s=f.windows.main,b.create_scratch_buf()vim.bo[s].bufhidden='wipe'b.set_winbuf(aw,s)a3(s,v)f.buffers.preview=s;f.view_state='preview'end;b.match_filter=function(i,h,j)local cN,cO,cP,cQ=j[1]=='*',j[1]=="'",j[1]=='^',j[#j]=='$'local cR,cS=b.match_query_group(j)if cN or cO or cP or cQ then local J=(cN or cO or cP)and 2 or 1;local cT=#j-(not cN and not cO and cQ and 1 or 0)j=vim.list_slice(j,J,cT)elseif cR then j=cS end;if#j==0 then return{},'nosort',j end;local cU=not(cO or cP or cQ)and#j>1;if cN or cU then return b.match_filter_fuzzy(i,h,j),'fuzzy',j end;local aZ=cP and'^'or''local cV=cQ and'$'or''local aa=aZ..vim.pesc(table.concat(j))..cV;return b.match_filter_exact(i,h,j,aa),'exact',j end;b.match_filter_exact=function(i,h,j,aa)local cW=b.match_filter_exact_single;local bt=b.poke_picker_throttle(b.querytick)local p={}for K,ay in ipairs(i)do if not bt()then return nil end;local aH=cW(h[ay],ay,aa)if aH~=nil then table.insert(p,aH)end end;return p end;b.match_filter_exact_single=function(cX,cY,aa)local cZ=string.find(cX,aa)if cZ==nil then return nil end;return{0,cZ,cY}end;b.match_ranges_exact=function(p,j)local c_,d0=0,{}for B=1,#j do d0[B]={c_,c_+j[B]:len()-1}c_=d0[B][2]+1 end;local ax={}for B=1,#p do local cZ=p[B][2]ax[B]=vim.tbl_map(function(n)return{cZ+n[1],cZ+n[2]}end,d0)end;return ax end;b.match_filter_fuzzy=function(i,h,j)local cW,d1=b.match_filter_fuzzy_single,b.match_find_query;local bt=b.poke_picker_throttle(b.querytick)local p={}for K,ay in ipairs(i)do if not bt()then return nil end;local aH=cW(h[ay],ay,j,d1)if aH~=nil then table.insert(p,aH)end end;return p end;b.match_filter_fuzzy_single=function(cX,cY,j,d1)local d2,d3=d1(cX,j,1)if d2==nil then return nil end;if d2==d3 then return{0,d2,cY,{d2}}end;local d4,d5,d6=d2,d3,d3-d2;while d3 do local d7=d3-d2;if d7<d6 then d4,d5,d6=d2,d3,d7 end;d2,d3=d1(cX,j,d2+1)end;return{d5-d4,d4,cY}end;b.match_ranges_fuzzy=function(p,j,h)local ax,d8,d9={},#j,vim.tbl_map(string.len,j)for da,aH in ipairs(p)do local db,bz,bA=h[aH[3]],aH[2],aH[2]+d9[1]-1;local I={{bz,bA}}for dc=2,d8 do bz,bA=string.find(db,j[dc],bA+1,true)I[dc]={bz,bA}end;ax[da]=I end;return ax end;b.match_find_query=function(db,j,ci)local d2,bA=string.find(db,j[1],ci,true)if d2==nil then return nil,nil end;local d3=d2;for B=2,#j do d3,bA=string.find(db,j[B],bA+1,true)if not d3 then return nil,nil end end;return d2,d3 end;b.match_query_group=function(j)local dd={{}}for K,n in ipairs(j)do local de=n:find('^%s+$')~=nil;if de then table.insert(dd,{})end;if not de then table.insert(dd[#dd],n)end end;return#dd>1,vim.tbl_map(table.concat,dd)end;b.match_sort=function(p)local df,bm,dg={},0,{}for B=1,#p do local aH,d7,cZ=p[B],p[B][1],p[B][2]local dh=df[d7]or{}local di=dh[cZ]or{}table.insert(di,aH[3])dh[cZ]=di;df[d7]=dh;bm=math.max(bm,d7)dg[d7]=math.max(dg[d7]or 0,cZ)end;local bt=b.poke_picker_throttle(b.querytick)for K,dh in pairs(df)do for K,di in pairs(dh)do if not bt()then return nil end;table.sort(di)end end;local ax={}for d7=0,bm do local dh=df[d7]for cZ=1,dg[d7]or 0 do local di=dh[cZ]or{}for B=1,#di do table.insert(ax,di[B])end end end;return ax end;b.get_icon=function(n,dj)local N=b.parse_item(n)local dk,dl=N.path,N.type;if dk==nil then dl,dk=b.parse_path(N.text)end;if dk==nil or dl==nil or dl=='none'then return{text=dj.none,hl='MiniPickNormal'}end;if _G.MiniIcons~=nil then local dm=dl=='directory'and'directory'or'file'local dn,dp=_G.MiniIcons.get(dm,dk)return{text=dn..' ',hl=dp}end;if dl=='directory'then return{text=dj.directory,hl='MiniPickIconDirectory'}end;local dq,dr=pcall(require,'nvim-web-devicons')if not dq then return{text=dj.file,hl='MiniPickIconFile'}end;local dn,dp=dr.get_icon(vim.fn.fnamemodify(dk,':t'),nil,{default=false})dn=type(dn)=='string'and dn..' 'or dj.file;return{text=dn,hl=dp or'MiniPickIconFile'}end;b.show_with_icons=function(s,g,j)a.default_show(s,g,j,{show_icons=true})end;b.parse_item=function(v)if type(v)=='table'then return b.parse_item_table(v)end;local ds=b.item_to_string(v)local dt,du=pcall(tonumber,ds)if dt and b.is_valid_buf(du)then return{type='buffer',buf_id=du}end;local dl,dk,bO,aW,dv=b.parse_path(ds)if dl~='none'then return{type=dl,path=dk,lnum=bO,col=aW,text=dv}end;return{}end;b.parse_item_table=function(v)local s=v.bufnr or v.buf_id or v.buf;if b.is_valid_buf(s)then return{type='buffer',buf_id=s,lnum=v.lnum,end_lnum=v.end_lnum,col=v.col,end_col=v.end_col,text=v.text}end;if type(v.path)=='string'then local dl=b.get_fs_type(v.path)if dl=='file'or dl=='uri'then return{type=dl,path=v.path,lnum=v.lnum,end_lnum=v.end_lnum,col=v.col,end_col=v.end_col,text=v.text}end;if dl=='directory'then return{type='directory',path=v.path}end end;return{}end;b.parse_path=function(n)if type(n)~='string'or n==''then return nil end;local dw='()%z(%d+)%z?(%d*)%z?(.*)$'local bz,bO,aW,dv=n:match(dw)local dk=n:sub(1,(bz or 0)-1)dk=dk:sub(1,1)=='~'and(vim.loop.os_homedir()or'~')..dk:sub(2)or dk;local dl=b.get_fs_type(dk)if dl=='none'and dk~=''then local dx=b.pickers.active==nil and vim.fn.getcwd()or b.pickers.active.opts.source.cwd;dk=string.format('%s/%s',dx,dk)dl=b.get_fs_type(dk)end;return dl,dk,tonumber(bO),tonumber(aW),dv or''end;b.get_fs_type=function(dk)if dk==''then return'none'end;if vim.fn.filereadable(dk)==1 then return'file'end;if vim.fn.isdirectory(dk)==1 then return'directory'end;if pcall(vim.uri_to_fname,dk)then return'uri'end;return'none'end;b.preview_file=function(s,N,e)if not b.is_file_text(N.path)then return b.set_buflines(s,{'-Non-text-file-'})end;local dy,x=pcall(vim.fn.readfile,N.path,'',(N.lnum or 1)+e.n_context_lines)if not dy then return end;N.line_position=e.line_position;b.preview_set_lines(s,x,N)end;b.preview_directory=function(s,N)local dk=N.path;local dz=function(n)return n..(vim.fn.isdirectory(dk..'/'..n)==1 and'/'or'')end;local x=vim.tbl_map(dz,vim.fn.readdir(dk))b.set_buflines(s,x)end;b.preview_buffer=function(s,N,e)local dA=N.buf_id;local dB=vim.o.eventignore;vim.o.eventignore='BufEnter'vim.fn.bufload(dA)vim.o.eventignore=dB;local x=vim.api.nvim_buf_get_lines(dA,0,(N.lnum or 1)+e.n_context_lines,false)N.filetype,N.line_position=vim.bo[dA].filetype,e.line_position;b.preview_set_lines(s,x,N)end;b.preview_uri=function(s,N,e)N.buf_id=vim.uri_to_bufnr(N.path)b.preview_buffer(s,N,e)end;b.preview_inspect=function(s,dC)b.set_buflines(s,vim.split(vim.inspect(dC),'\n'))end;b.preview_set_lines=function(s,x,dD)b.set_buflines(s,x)b.preview_highlight_region(s,dD.lnum,dD.col,dD.end_lnum,dD.end_col)if b.preview_should_highlight(s)then local dE=dD.filetype or vim.filetype.match({buf=s,filename=dD.path})local dF,dG=pcall(vim.treesitter.language.get_lang,dE)local ak,K=pcall(vim.treesitter.start,s,dF and dG or dE)if not ak then vim.bo[s].syntax=dE end end;local dH=a.get_picker_state()local aw=dH~=nil and dH.windows.main or vim.fn.bufwinid(s)b.set_cursor(aw,dD.lnum,dD.col)local dI=({top='zt',center='zz',bottom='zb'})[dD.line_position]or'zt'pcall(vim.api.nvim_win_call,aw,function()vim.cmd('normal! '..dI)end)end;b.preview_should_highlight=function(s)local dJ=vim.api.nvim_buf_call(s,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return dJ<=1000000 and dJ<=1000*vim.api.nvim_buf_line_count(s)end;b.preview_highlight_region=function(s,bO,aW,dK,dL)if bO==nil then return end;local dM={end_row=bO,end_col=0,hl_eol=true,hl_group='MiniPickPreviewLine',priority=201}b.set_extmark(s,b.ns_id.preview,bO-1,0,dM)if aW==nil then return end;local dN,dO=bO-1,aW;if dK~=nil and dL~=nil then dN,dO=dK-1,dL-1 end;dO=b.get_next_char_bytecol(vim.fn.getbufline(s,dN+1)[1],dO)local dP={end_row=dN,end_col=dO,priority=202}dP.hl_group='MiniPickPreviewRegion'b.set_extmark(s,b.ns_id.preview,bO-1,aW-1,dP)end;b.choose_path=function(P,N)local dk,dQ=N.path,nil;local R,S=pcall(vim.uri_to_fname,dk)dk=R and S or dk;for K,s in ipairs(vim.api.nvim_list_bufs())do local dR=b.is_valid_buf(s)and vim.bo[s].buflisted and vim.api.nvim_buf_get_name(s)==dk;if dR then dQ=s end end;if dQ~=nil then b.set_winbuf(P,dQ)else local dS=vim.fn.fnameescape(vim.fn.fnamemodify(dk,':.'))vim.api.nvim_win_call(P,function()pcall(vim.cmd,'edit '..dS)end)end;b.choose_set_cursor(P,N.lnum,N.col)end;b.choose_buffer=function(P,N)b.set_winbuf(P,N.buf_id)b.choose_set_cursor(P,N.lnum,N.col)end;b.choose_print=function(n)print(vim.inspect(n))end;b.choose_set_cursor=function(aw,bO,aW)if bO==nil then return end;b.set_cursor(aw,bO,aW)pcall(vim.api.nvim_win_call,aw,function()vim.cmd('normal! zvzz')end)end;b.cli_postprocess=function(g)while g[#g]==''do g[#g]=nil end;return g end;b.is_executable=function(a7)if a7=='fallback'then return true end;return vim.fn.executable(a7)==1 end;b.files_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('fd')then return'fd'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.files_get_command=function(a7)if a7=='rg'then return{'rg','--files','--no-follow','--color=never'}end;if a7=='fd'then return{'fd','--type=f','--no-follow','--color=never'}end;if a7=='git'then return{'git','ls-files','--cached','--others','--exclude-standard'}end;b.error([[Wrong 'tool' for `files` builtin.]])end;b.files_fallback_items=function(dx)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `files` builtin needs Neovim>=0.9.')end;dx=dx or'.'local bt=b.poke_picker_throttle()local o=function()local g={}for dk,dl in vim.fs.dir(dx,{depth=math.huge})do if not bt()then return end;if dl=='file'and b.is_file_text(string.format('%s/%s',dx,dk))then table.insert(g,dk)end end;a.set_picker_items(g)end;vim.schedule(coroutine.wrap(o))end;b.grep_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.grep_get_command=function(a7,aa)if a7=='rg'then return{'rg','--column','--line-number','--no-heading','--field-match-separator=\\0','--no-follow','--color=never','--',aa}end;if a7=='git'then local ax={'git','grep','--column','--line-number','--null','--color=never','--',aa}if vim.o.ignorecase then table.insert(ax,6,'--ignore-case')end;return ax end;b.error([[Wrong 'tool' for `grep` builtin.]])end;b.grep_fallback_items=function(aa,dx)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `grep` builtin needs Neovim>=0.9.')end;dx=dx or'.'local bt=b.poke_picker_throttle()local o=function()local dT,dU={},{}for dk,dl in vim.fs.dir(dx,{depth=math.huge})do if not bt()then return end;local dV=string.format('%s/%s',dx,dk)if dl=='file'and b.is_file_text(dV)then table.insert(dT,dk)table.insert(dU,dV)end end;local g={}for B,dk in ipairs(dU)do local dW=dT[B]if not bt()then return end;for bO,z in ipairs(vim.fn.readfile(dk))do local aW=string.find(z,aa)if aW~=nil then table.insert(g,string.format('%s\0%d\0%d\0%s',dW,bO,aW,z))end end end;a.set_picker_items(g)end;vim.schedule(coroutine.wrap(o))end;b.schedule_resume_is_active=vim.schedule_wrap(function(aI)coroutine.resume(aI,a.is_picker_active())end)b.poke_picker_throttle=function(dX)if not a.is_picker_active()then return function()return true end end;local dY,dZ=vim.loop.hrtime(),dX==nil;local d_=1000000*b.get_config().delay.async;local e0=vim.loop.hrtime;local e1=a.poke_is_picker_active;return function()local e2=e0()if e2-dY<d_ then return true end;dY=e2;return e1()and(dZ or dX==b.querytick)end end;b.error=function(e3)error(string.format('(mini.pick) %s',e3),0)end;b.is_valid_buf=function(s)return type(s)=='number'and vim.api.nvim_buf_is_valid(s)end;b.is_valid_win=function(aw)return type(aw)=='number'and vim.api.nvim_win_is_valid(aw)end;b.is_array_of=function(n,e4)if not b.islist(n)then return false end;for B=1,#n do if type(n[B])~=e4 then return false end end;return true end;b.create_scratch_buf=function()local s=vim.api.nvim_create_buf(false,true)vim.bo[s].matchpairs=''vim.b[s].minicursorword_disable=true;vim.b[s].miniindentscope_disable=true;return s end;b.get_first_valid_normal_window=function()for K,aw in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(aw).relative==''then return aw end end end;b.set_buflines=function(s,x)pcall(vim.api.nvim_buf_set_lines,s,0,-1,false,x)end;b.set_winbuf=function(aw,s)vim.api.nvim_win_set_buf(aw,s)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.set_cursor=function(aw,bO,aW)pcall(vim.api.nvim_win_set_cursor,aw,{bO or 1,(aW or 1)-1})end;b.set_curwin=function(aw)if not b.is_valid_win(aw)then return end;local bQ=vim.api.nvim_win_get_cursor(aw)vim.api.nvim_set_current_win(aw)b.set_cursor(aw,bQ[1],bQ[2]+1)end;b.clear_namespace=function(s,C)pcall(vim.api.nvim_buf_clear_namespace,s,C,0,-1)end;b.replace_termcodes=function(n)if n==nil then return nil end;return vim.api.nvim_replace_termcodes(n,true,true,true)end;b.expand_callable=function(n,...)if vim.is_callable(n)then return n(...)end;return n end;b.expandcmd=function(n)local dt,ax=pcall(vim.fn.expandcmd,n)return dt and ax or n end;b.redraw=function()vim.cmd('redraw')end;b.redraw_scheduled=vim.schedule_wrap(b.redraw)b.getcharstr=function(e5)b.timers.getcharstr:start(0,e5,b.redraw_scheduled)b.cache.is_in_getcharstr=true;local dt,ao=pcall(vim.fn.getcharstr)b.cache.is_in_getcharstr=nil;b.timers.getcharstr:stop()local e6;if b.pickers.active~=nil then e6=b.pickers.active.windows.main end;local e7=vim.v.mouse_winid~=0 and vim.v.mouse_winid~=e6;if not dt or ao==''or ao=='\3'or e7 then return end;return ao end;b.tolower=(function()local bs=vim.fn.tolower;return function(n)local dt,ax=pcall(bs,n)return dt and ax or string.lower(n)end end)()b.win_update_hl=function(aw,e8,e9)if not b.is_valid_win(aw)then return end;local ea=e8 ..':'..e9;local eb=string.format('(%s:[^,]*)',vim.pesc(e8))local ec,ed=vim.wo[aw].winhighlight:gsub(eb,ea)if ed==0 then ec=ec..','..ea end;vim.wo[aw].winhighlight=ec end;b.win_trim_to_width=function(aw,ee)local c9=vim.api.nvim_win_get_width(aw)return vim.fn.strcharpart(ee,vim.fn.strchars(ee)-c9,c9)end;b.win_get_bottom_border=function(aw)local ef=vim.api.nvim_win_get_config(aw).border or{}local ax=ef[6]if type(ax)=='table'then ax=ax[1]end;return ax or' 'end;b.seq_along=function(eg)if eg==nil then return nil end;local ax={}for B=1,#eg do table.insert(ax,B)end;return ax end;b.get_next_char_bytecol=function(eh,aW)if type(eh)~='string'then return aW end;local ei=vim.str_utfindex(eh,math.min(eh:len(),aW))return vim.str_byteindex(eh,ei)end;b.is_file_text=function(dk)local ej=vim.loop.fs_open(dk,'r',1)local ek=vim.loop.fs_read(ej,1024):find('\0')==nil;vim.loop.fs_close(ej)return ek end;b.full_path=function(dk)return vim.fn.fnamemodify(dk,':p'):gsub('(.)/$','%1')end;b.islist=vim.fn.has('nvim-0.10')==1 and vim.islist or vim.tbl_islist;return a
