local a={}function a.path_exists(b)return vim.loop.fs_stat(b)and true or false end;local c;if jit then c=jit.os:lower()end;local d=false;if c then d=c=='linux'or c=='osx'or c=='bsd'else local e=package.cpath:match('%p[\\|/]?%p(%a+)')d=e~='dll'end;function a.dirname(f)return f:match(string.format('^(.+)%s[^%s]+',a.path_sep,a.path_sep))end;function a.file_lines(b,g)g=g or{}local f=assert(io.open(b))local h=f:read('*a')local i=vim.split(h,'\n',{plain=true})if not g.raw then if i[#i]==''then i[#i]=nil end end;return i end;a.path_sep=package.config:sub(1,1)local function j(...)local k={}for l,m in ipairs({...})do k[l]=string.char(m)end;return table.concat(k)end;local n={['utf-8']=j(0xef,0xbb,0xbf),['utf-16le']=j(0xff,0xfe),['utf-16']=j(0xfe,0xff),['utf-16be']=j(0xfe,0xff),['utf-32le']=j(0xff,0xfe,0x00,0x00),['utf-32']=j(0xff,0xfe,0x00,0x00),['utf-32be']=j(0x00,0x00,0xfe,0xff),['utf-7']=j(0x2b,0x2f,0x76),['utf-1']=j(0xf7,0x54,0x4c)}local function o(p,q)local r=n[q]if r then return r..p end;return p end;function a.buf_lines(s)local t=vim.api.nvim_buf_get_lines(s,0,-1,false)local u=vim.bo[s].fileformat=='dos'if u then for l=1,#t-1 do t[l]=t[l]..'\r'end end;if vim.bo[s].endofline then if u then t[#t]=t[#t]..'\r'end;t[#t+1]=''end;if vim.bo[s].bomb then t[1]=o(t[1],vim.bo[s].fileencoding)end;return t end;local function v(w)local x=vim.api.nvim_buf_call(w,function()return vim.fn.bufnr('#')end)if x~=w and x~=-1 then pcall(vim.api.nvim_buf_delete,x,{force=true})end end;function a.buf_rename(s,y)vim.api.nvim_buf_set_name(s,y)v(s)end;function a.set_lines(s,z,A,i)if vim.bo[s].fileformat=='dos'then i=a.strip_cr(i)end;if z==0 and A==-1 and i[#i]==''then i=vim.deepcopy(i)i[#i]=nil end;vim.api.nvim_buf_set_lines(s,z,A,false,i)end;function a.tmpname()if d then return os.tmpname()end;return vim.fn.tempname()end;local function B(C,D,E)local F=math.floor(C/D)if F>1 then E=E..'s'end;return F..' '..E..' ago'end;function a.get_relative_time(G)local H=os.time()local I=H-G;if I==0 then return'a while ago'end;local J=60;local K=J*60;local L=K*24;local M=L*30;local N=M*12;if I<J then return B(I,1,'second')elseif I<K then return B(I,J,'minute')elseif I<L then return B(I,K,'hour')elseif I<M then return B(I,L,'day')elseif I<N then return B(I,M,'month')else return B(I,N,'year')end end;function a.strip_cr(O)for l=1,#O do if O[l]:sub(-1)~='\r'then return O end end;local P=vim.deepcopy(O)for l=1,#P do P[l]=P[l]:sub(1,-2)end;return P end;function a.calc_base(Q)if Q and Q:sub(1,1):match('[~\\^]')then Q='HEAD'..Q end;return Q end;function a.emptytable()return setmetatable({},{__index=function(R,S)R[S]={}return R[S]end})end;local function T(U,C)if U=='%R'then return a.get_relative_time(C)end;return os.date(U,C)end;function a.expand_format(U,V,W)local X={}for Y=1,20 do local Z,_,a0,a1,a2=U:find('(<([^:>]+):?([^>]*)>)')if not a0 then break end;X[#X+1],U=U:sub(1,Z-1),U:sub(_+1)local a3=V[a1]if a3 then if type(a3)=='table'then a3=table.concat(a3,'\n')end;if vim.endswith(a1,'_time')then if a2==''then a2=W and'%R'or'%Y-%m-%d'end;a3=T(a2,a3)end;a0=tostring(a3)end;X[#X+1]=a0 end;X[#X+1]=U;return table.concat(X,'')end;function a.bufexists(w)return vim.fn.bufexists(w)==1 end;function a.convert_blame_info(p)local X=vim.tbl_extend('error',p,p.commit)X.commit=nil;return X end;function a.list_remove(R,a4,a5)local a6=#R;for l=0,a6-a4 do R[a4+l]=R[a5+1+l]R[a5+1+l]=nil end end;function a.list_insert(R,a4,a5,a3)local a6=#R;for l=a6-a4,0,-1 do R[a5+1+l]=R[a4+l]end;for l=a4,a5 do R[l]=a3 end end;return a
