local a={}local b=vim.api;local function c(d,e)return b.nvim_buf_call(d,function()local f=0;for g,h in ipairs(e)do if vim.fn.type(h)==vim.v.t_string then local i=vim.fn.strdisplaywidth(h)if i>f then f=i end end end;return f+1 end)end;local function j(k,l,m)local n=0;local o=vim.o.lines-vim.o.cmdheight-(m~=''and 2 or 0)for g=0,50 do local p=b.nvim_win_get_height(k)if n>p then break end;local q=b.nvim_win_call(k,function()return vim.fn.line('w$')end)if q>=l then break end;n=p+l-q;if n>o then b.nvim_win_set_height(k,o)break end;b.nvim_win_set_height(k,n)end end;local function r(s,t)for g,u in ipairs(s)do u.start_row=(u.start_row or 0)+t;if u.end_row then u.end_row=u.end_row+t end end end;local function v(w)local e={}local x={}local y=0;for g,z in ipairs(w)do local A={}local B=0;for g,C in ipairs(z)do local D,E=C[1],C[2]A[#A+1]=D;local g,F=D:gsub('\n','')local G=y+F;local H=F>0 and 0 or B+#D;if type(E)=='string'then x[#x+1]={hl_group=E,start_row=y,end_row=G,start_col=B,end_col=H}else r(E,y)vim.list_extend(x,E)end;y=G;B=H end;local I=vim.split(table.concat(A),'\n',{plain=true})vim.list_extend(e,I)y=y+1 end;return e,x end;local function J(K)for g,k in ipairs(b.nvim_list_wins())do if vim.w[k].gitsigns_preview~=nil and vim.w[k].gitsigns_preview~=K then pcall(b.nvim_win_close,k,true)end end end;function a.close(K)for g,k in ipairs(b.nvim_list_wins())do if vim.w[k].gitsigns_preview==K then pcall(b.nvim_win_close,k,true)end end end;local L=b.nvim_create_namespace('gitsigns_popup')local function M(e,N)local O=vim.bo.tabstop;local d=b.nvim_create_buf(false,true)assert(d,'Failed to create buffer')vim.bo[d].modifiable=true;b.nvim_buf_set_lines(d,0,-1,true,e)vim.bo[d].modifiable=false;vim.bo[d].tabstop=O;for g,P in ipairs(N)do local Q,R=pcall(b.nvim_buf_set_extmark,d,L,P.start_row,P.start_col or 0,{hl_group=P.hl_group,end_row=P.end_row,end_col=P.end_col,hl_eol=true})if not Q then error(vim.inspect(P)..'\n'..R)end end;return d end;local function S(d,T,K)K=K or true;J(K)local e=b.nvim_buf_get_lines(d,0,-1,true)local U=vim.deepcopy(T or{})U.height=U.height or#e;U.width=U.width or c(d,e)local k=b.nvim_open_win(d,false,U)vim.w[k].gitsigns_preview=K;if not T.height then j(k,#e,T.border)end;if U.style=='minimal'then vim.wo[k].signcolumn='no'end;local V='gitsigns_popup'local W=b.nvim_create_augroup(V,{})local X=b.nvim_win_get_cursor(0)b.nvim_create_autocmd({'CursorMoved','CursorMovedI'},{group=W,callback=function()local Y=b.nvim_win_get_cursor(0)if(X[1]~=Y[1]or X[2]~=Y[2])and b.nvim_get_current_win()~=k then b.nvim_create_augroup(V,{})pcall(b.nvim_win_close,k,true)return end;X=Y end})b.nvim_create_autocmd('WinClosed',{pattern=tostring(k),group=W,callback=function()b.nvim_create_augroup(V,{})end})b.nvim_create_autocmd('WinScrolled',{buffer=b.nvim_get_current_buf(),group=W,callback=function()if b.nvim_win_is_valid(k)then b.nvim_win_set_config(k,U)end end})return k end;function a.create(Z,T,K)local e,N=v(Z)local d=M(e,N)local k=S(d,T,K)return k,d end;function a.is_open(K)for g,k in ipairs(b.nvim_list_wins())do if vim.w[k].gitsigns_preview==K then return k end end end;function a.focus_open(K)local k=a.is_open(K)if k then b.nvim_set_current_win(k)end;return k end;return a
