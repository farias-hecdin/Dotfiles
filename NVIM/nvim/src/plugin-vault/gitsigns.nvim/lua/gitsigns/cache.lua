local a=require('gitsigns.async')local b=require('gitsigns.config').config;local c=require('gitsigns.util')local d={CacheEntry={}}local e=d.CacheEntry;function e:get_compare_rev(f)f=f or self.base;if f then return f end;if self.commit then if b._signs_staged_enable then return self.commit else return string.format('%s^',self.commit)end end;local g=self.git_obj.has_conflicts and 1 or 0;return string.format(':%d',g)end;function e:get_rev_bufname(h)h=h or self:get_compare_rev()return string.format('gitsigns://%s/%s:%s',self.git_obj.repo.gitdir,h,self.git_obj.relpath)end;function e:invalidate(i)self.hunks=nil;self.hunks_staged=nil;self.blame=nil;if i then self.compare_text=nil;self.compare_text_head=nil end end;function d.new(j)j.staged_diffs=j.staged_diffs or{}return setmetatable(j,{__index=e})end;local k=a.wrap(function(l,m)vim.defer_fn(m,l)end,2)function e:wait_for_hunks()local n=0;while not self.hunks and n<10 do n=n+1;k(100)end end;local o=1000000;function e:run_blame(p,q)local r;repeat local s=c.buf_lines(self.bufnr)local t=vim.b[self.bufnr].changedtick;local u=#s>o and p or nil;r=self.git_obj:run_blame(s,u,q.ignore_whitespace)a.scheduler_if_buf_valid(self.bufnr)until vim.b[self.bufnr].changedtick==t;return r end;local function v(w,p)local x=require('gitsigns.git')return{orig_lnum=0,final_lnum=p,commit=x.not_commited(w),filename=w}end;function e:get_blame(p,q)local r=self.blame;if not r or not r[p]then self:wait_for_hunks()local y=require('gitsigns.hunks')if y.find_hunk(p,self.hunks)then r=r or{}r[p]=v(self.git_obj.relpath,p)else r=self:run_blame(p,q)end;self.blame=r end;if r then return r[p]end end;function e:destroy()local z=self.gitdir_watcher;if z and not z:is_closing()then z:close()end end;d.cache={}function d.destroy(A)d.cache[A]:destroy()d.cache[A]=nil end;return d
