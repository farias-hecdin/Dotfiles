local a=require('gitsigns.async')local b=require('gitsigns.git')local c=require('gitsigns.manager')local d=require('gitsigns.debug.log')local e=d.dprintf;local f=d.dprint;local g=require('gitsigns.cache')local h=g.cache;local i=require('gitsigns.status')local j=require('gitsigns.config').config;local k=require('gitsigns.util')local l=require('gitsigns.debounce').throttle_by_id;local m=vim.api;local n=vim.loop;local o={}local p=false;local function q(r)if vim.fn.exists('*FugitiveReal')==0 then f('Fugitive not installed')return end;local s=vim.fn.FugitiveReal(r)local t=vim.fn.FugitiveParse(r)[1]:match('([^:]+):.*')if t=='0'then t=nil end;return s,t end;local function u(r)local v,v,w,t,x=r:find([[^gitsigns://(.*)/%.git/(.*):(.*)]])if t==':0'then t=nil end;if w then r=w..'/'..x end;return r,t end;local function y(z)local A=n.fs_realpath(m.nvim_buf_get_name(z))or m.nvim_buf_call(z,function()return vim.fn.expand('%:p')end)if not vim.wo.diff then if vim.startswith(A,'fugitive://')then local s,t=q(A)e("Fugitive buffer for file '%s' from path '%s'",s,A)if s then local B=n.fs_realpath(s)if B then return B,t end end end;if vim.startswith(A,'gitsigns://')then local s,t=u(A)e("Gitsigns buffer for file '%s' from path '%s'",s,A)local B=n.fs_realpath(s)if B then return B,t end end end;return A end;local function C(v,z,v,D,E,F,G)if D==E and E==F and G==0 then return end;return c.on_lines(z,D,E,F)end;local function H(v,z)local I='on_reload'h[z]:invalidate()f('Reload')c.update_debounced(z)end;local function J(v,z)m.nvim_clear_autocmds({group='gitsigns',buffer=z})o.detach(z,true)end;local function K(z)local L,M;if j._on_attach_pre then local N=a.wrap(j._on_attach_pre,2)(z)e('ran on_attach_pre with result %s',vim.inspect(N))if type(N)=='table'then if type(N.gitdir)=='string'then L=N.gitdir end;if type(N.toplevel)=='string'then M=N.toplevel end end end;return L,M end;local function O(P,A,Q)if not j.worktrees then return end;for v,R in ipairs(j.worktrees)do local S=b.Obj.new(A,Q,R.gitdir,R.toplevel)if S and S.object_name then e('Using worktree %s',vim.inspect(R))return S end end end;local function T()m.nvim_create_autocmd('QuickFixCmdPre',{group='gitsigns',pattern='*vimgrep*',callback=function()p=true end})m.nvim_create_autocmd('QuickFixCmdPost',{group='gitsigns',pattern='*vimgrep*',callback=function()p=false end})end;local U=false;function o._setup()if U then return end;U=true;c.setup()require('gitsigns.highlight').setup()m.nvim_create_autocmd('OptionSet',{group='gitsigns',pattern={'fileformat','bomb','eol'},callback=function()require('gitsigns.actions').refresh()end})T()require('gitsigns.current_line_blame').setup()m.nvim_create_autocmd('VimLeavePre',{group='gitsigns',callback=o.detach_all})end;local V=l(function(W,X,Y)local I='attach'o._setup()if p then f('attaching is disabled')return end;if h[W]then f('Already attached')return end;if Y then e('Attaching (trigger=%s)',Y)else f('Attaching')end;if not m.nvim_buf_is_loaded(W)then f('Non-loaded buffer')return end;local Q=vim.bo[W].fileencoding;if Q==''then Q='utf-8'end;local A;local t;local Z;local _;if X then Z=X.gitdir;_=X.toplevel;A=X.toplevel..k.path_sep..X.file;t=X.commit else if m.nvim_buf_line_count(W)>j.max_file_length then f('Exceeds max_file_length')return end;if vim.bo[W].buftype~=''then f('Non-normal buffer')return end;A,t=y(W)local a0=k.dirname(A)if not a0 or not k.path_exists(a0)then f('Not a path')return end;Z,_=K(W)end;local S=b.Obj.new(A,Q,Z,_)if not S and not X then S=O(W,A,Q)a.scheduler_if_buf_valid(W)end;if not S then f('Empty git obj')return end;local a1=S.repo;a.scheduler_if_buf_valid(W)i:update(W,{head=a1.abbrev_head,root=a1.toplevel,gitdir=a1.gitdir})if vim.startswith(A,a1.gitdir..k.path_sep)then f('In non-standard git dir')return end;if not X and(not k.path_exists(A)or n.fs_stat(A).type=='directory')then f('Not a file')return end;if not S.relpath then f('Cannot resolve file in repo')return end;if not j.attach_to_untracked and S.object_name==nil then f('File is untracked')return end;a.scheduler_if_buf_valid(W)if j.on_attach and j.on_attach(W)==false then f('User on_attach() returned false')return end;h[W]=g.new({bufnr=W,base=X and X.base or j.base,file=A,commit=t,git_obj=S})if j.watch_gitdir.enable then local a2=require('gitsigns.watcher')h[W].gitdir_watcher=a2.watch_gitdir(W,a1.gitdir)end;if not m.nvim_buf_is_loaded(W)then f('Un-loaded buffer')return end;m.nvim_buf_attach(W,false,{on_lines=C,on_reload=H,on_detach=J})m.nvim_create_autocmd('BufWrite',{group='gitsigns',buffer=W,callback=function()c.update_debounced(W)end})c.update(W)end)function o.detach_all()for a3,v in pairs(h)do o.detach(a3)end end;function o.detach(z,a4)z=z or m.nvim_get_current_buf()f('Detached')local a5=h[z]if not a5 then f('Cache was nil')return end;c.detach(z,a4)i:clear(z)g.destroy(z)end;o.attach=a.void(function(z,X,a6)V(z or m.nvim_get_current_buf(),X,a6)end)return o
