local a=require('gitsigns.async')local b=require('gitsigns.git')local c=require('gitsigns.debug.log')local d=c.dprintf;local e=c.dprint;local f=require('gitsigns.manager')local g=require('gitsigns.highlight')local h=require('gitsigns.cache')local i=h.cache;local j=require('gitsigns.status')local k=require('gitsigns.config')local l=k.config;local m=require('gitsigns.async').void;local n=require('gitsigns.util')local o=require('gitsigns.debounce').throttle_by_id;local p=vim.api;local q=vim.loop;local r={}local s=false;local function t(u)if vim.fn.exists('*FugitiveReal')==0 then e('Fugitive not installed')return end;local v=vim.fn.FugitiveReal(u)local w=vim.fn.FugitiveParse(u)[1]:match('([^:]+):.*')if w=='0'then w=nil end;return v,w end;local function x(u)local y,y,z,w,A=u:find([[^gitsigns://(.*)/%.git/(.*):(.*)]])if w==':0'then w=nil end;if z then u=z..'/'..A end;return u,w end;local function B(C)local D=q.fs_realpath(p.nvim_buf_get_name(C))or p.nvim_buf_call(C,function()return vim.fn.expand('%:p')end)if not vim.wo.diff then if vim.startswith(D,'fugitive://')then local v,w=t(D)d("Fugitive buffer for file '%s' from path '%s'",v,D)if v then local E=q.fs_realpath(v)if E then return E,w end end end;if vim.startswith(D,'gitsigns://')then local v,w=x(D)d("Gitsigns buffer for file '%s' from path '%s'",v,D)local E=q.fs_realpath(v)if E then return E,w end end end;return D end;local function F(y,C,y,G,H,I,J)if G==H and H==I and J==0 then return end;return f.on_lines(C,G,H,I)end;local function K(y,C)local L='on_reload'i[C]:invalidate()e('Reload')f.update_debounced(C)end;local function M(y,C)p.nvim_clear_autocmds({group='gitsigns',buffer=C})r.detach(C,true)end;local function N(C)local O,P;if l._on_attach_pre then local Q=a.wrap(l._on_attach_pre,2)(C)d('ran on_attach_pre with result %s',vim.inspect(Q))if type(Q)=='table'then if type(Q.gitdir)=='string'then O=Q.gitdir end;if type(Q.toplevel)=='string'then P=Q.toplevel end end end;return O,P end;local function R(S,D,T)if not l.worktrees then return end;for y,U in ipairs(l.worktrees)do local V=b.Obj.new(D,T,U.gitdir,U.toplevel)if V and V.object_name then d('Using worktree %s',vim.inspect(U))return V end end end;local W=false;function r._setup()if W then return end;W=true;f.setup()g.setup_highlights()p.nvim_create_autocmd('ColorScheme',{group='gitsigns',callback=g.setup_highlights})p.nvim_create_autocmd('OptionSet',{group='gitsigns',pattern={'fileformat','bomb','eol'},callback=function()require('gitsigns.actions').refresh()end})p.nvim_create_autocmd('QuickFixCmdPre',{group='gitsigns',pattern='*vimgrep*',callback=function()s=true end})p.nvim_create_autocmd('QuickFixCmdPost',{group='gitsigns',pattern='*vimgrep*',callback=function()s=false end})require('gitsigns.current_line_blame').setup()p.nvim_create_autocmd('VimLeavePre',{group='gitsigns',callback=r.detach_all})end;local X=o(function(Y,Z,_)local L='attach'r._setup()if s then e('attaching is disabled')return end;if i[Y]then e('Already attached')return end;if _ then d('Attaching (trigger=%s)',_)else e('Attaching')end;if not p.nvim_buf_is_loaded(Y)then e('Non-loaded buffer')return end;local T=vim.bo[Y].fileencoding;if T==''then T='utf-8'end;local D;local w;local a0;local a1;if Z then a0=Z.gitdir;a1=Z.toplevel;D=Z.toplevel..n.path_sep..Z.file;w=Z.commit else if p.nvim_buf_line_count(Y)>l.max_file_length then e('Exceeds max_file_length')return end;if vim.bo[Y].buftype~=''then e('Non-normal buffer')return end;D,w=B(Y)local a2=n.dirname(D)if not a2 or not n.path_exists(a2)then e('Not a path')return end;a0,a1=N(Y)end;local V=b.Obj.new(D,T,a0,a1)if not V and not Z then V=R(Y,D,T)a.scheduler_if_buf_valid(Y)end;if not V then e('Empty git obj')return end;local a3=V.repo;a.scheduler_if_buf_valid(Y)j:update(Y,{head=a3.abbrev_head,root=a3.toplevel,gitdir=a3.gitdir})if vim.startswith(D,a3.gitdir..n.path_sep)then e('In non-standard git dir')return end;if not Z and(not n.path_exists(D)or q.fs_stat(D).type=='directory')then e('Not a file')return end;if not V.relpath then e('Cannot resolve file in repo')return end;if not l.attach_to_untracked and V.object_name==nil then e('File is untracked')return end;a.scheduler_if_buf_valid(Y)if l.on_attach and l.on_attach(Y)==false then e('User on_attach() returned false')return end;i[Y]=h.new({bufnr=Y,base=Z and Z.base or l.base,file=D,commit=w,git_obj=V})if l.watch_gitdir.enable then local a4=require('gitsigns.watcher')i[Y].gitdir_watcher=a4.watch_gitdir(Y,a3.gitdir)end;if not p.nvim_buf_is_loaded(Y)then e('Un-loaded buffer')return end;p.nvim_buf_attach(Y,false,{on_lines=F,on_reload=K,on_detach=M})p.nvim_create_autocmd('BufWrite',{group='gitsigns',buffer=Y,callback=function()f.update_debounced(Y)end})f.update(Y)end)function r.detach_all()for a5,y in pairs(i)do r.detach(a5)end end;function r.detach(C,a6)C=C or p.nvim_get_current_buf()e('Detached')local a7=i[C]if not a7 then e('Cache was nil')return end;f.detach(C,a6)j:clear(C)h.destroy(C)end;r.attach=m(function(C,Z,a8)X(C or p.nvim_get_current_buf(),Z,a8)end)return r
