local a=require('gitsigns.util')local b,c=math.min,math.max;local d={}function d.create_hunk(e,f,g,h)return{removed={start=e,count=f,lines={}},added={start=g,count=h,lines={}},head=('@@ -%d%s +%d%s @@'):format(e,f>0 and','..f or'',g,h>0 and','..h or''),vend=g+math.max(h-1,0),type=h==0 and'delete'or f==0 and'add'or'change'}end;function d.create_partial_hunk(i,j,k)local l,m=j,k-j+1;for n,o in ipairs(i)do local p=o.added.count-o.removed.count;local q=0;if o.added.start>=j and o.vend<=k then q=p else local r=c(0,k+1-(o.added.start+o.removed.count))local s=c(0,j-(o.added.start+o.removed.count))if o.added.start>=j and o.added.start<=k then q=r elseif o.vend>=j and o.vend<=k then q=p-s;l=l-s elseif o.added.start<=j and o.vend>=k then q=r-s;l=l-s end;if j>o.vend then l=l-p end end;m=m-q end;if m==0 then l=l-1 end;return d.create_hunk(l,m,j,k-j+1)end;function d.patch_lines(t,u)local v={}for n,w in ipairs(t.removed.lines)do v[#v+1]='-'..w end;for n,w in ipairs(t.added.lines)do v[#v+1]='+'..w end;if u=='dos'then v=a.strip_cr(v)end;return v end;local function x(y)return tonumber(y)end;function d.parse_diff_line(z)local A=vim.trim(vim.split(z,'@@',{plain=true})[2])local B,C=unpack(vim.tbl_map(function(D)return vim.split(string.sub(D,2),',')end,vim.split(A,' ')))local t=d.create_hunk(x(B[1]),x(B[2])or 1,x(C[1]),x(C[2])or 1)t.head=z;return t end;local function E(t)if t.added.count==0 then return t.added.start elseif t.removed.count==0 then return t.added.start+t.added.count-1 else return t.added.start+b(t.added.count,t.removed.count)-1 end end;function d.calc_signs(t,F,G,H)assert(not H or t.type=='add',string.format('Invalid hunk with untracked=%s hunk="%s"',H,t.head))F=F or 1;G=G or math.huge;local I,J,K=t.added.start,t.added.count,t.removed.count;if t.type=='delete'and I==0 then if F<=1 then return{{type='topdelete',count=K,lnum=1}}else return{}end end;local L={}local M=E(t)for N=c(I,F),b(M,G)do local O=t.type=='change'and K>J and N==M;L[#L+1]={type=O and'changedelete'or H and'untracked'or t.type,count=N==I and(t.type=='add'and J or K)or nil,lnum=N}end;if t.type=='change'and J>K and t.vend>=F and M<=G then for N=c(M,F),b(t.vend,G)do L[#L+1]={type='add',count=N==t.vend and J-K or nil,lnum=N}end end;return L end;function d.create_patch(P,i,Q,R)R=R or false;local S={string.format('diff --git a/%s b/%s',P,P),'index 000000..000000 '..Q,'--- a/'..P,'+++ b/'..P}local T=0;for n,U in ipairs(i)do local I,V,W=U.removed.start,U.removed.count,U.added.count;if U.type=='add'then I=I+1 end;local X=U.removed.lines;local Y=U.added.lines;if R then V,W=W,V;X,Y=Y,X end;table.insert(S,string.format('@@ -%s,%s +%s,%s @@',I,V,I+T,W))for n,w in ipairs(X)do S[#S+1]='-'..w end;for n,w in ipairs(Y)do S[#S+1]='+'..w end;U.removed.start=I+T;T=T+W-V end;return S end;function d.get_summary(i)local Z={added=0,changed=0,removed=0}for n,t in ipairs(i or{})do if t.type=='add'then Z.added=Z.added+t.added.count elseif t.type=='delete'then Z.removed=Z.removed+t.removed.count elseif t.type=='change'then local _,a0=t.added.count,t.removed.count;local a1=b(_,a0)Z.changed=Z.changed+a1;Z.added=Z.added+_-a1;Z.removed=Z.removed+a0-a1 end end;return Z end;function d.find_hunk(N,i)for a2,t in ipairs(i or{})do if N==1 and t.added.start==0 and t.vend==0 then return t,a2 end;if t.added.start<=N and t.vend>=N then return t,a2 end end end;function d.find_nearest_hunk(N,i,a3,a4)local a5;local a6;local a7=math.huge;if a3 then for a2=1,#i do local t=i[a2]local a8=t.added.start-N;if a8>0 and a8<a7 then a7=a8;a5=t;a6=a2 end end else for a2=#i,1,-1 do local t=i[a2]local a8=N-t.vend;if a8>0 and a8<a7 then a7=a8;a5=t;a6=a2 end end end;if not a5 and a4 then a6=a3 and 1 or#i;a5=i[a6]end;return a5,a6 end;function d.compare_heads(a9,aa)if a9==nil~=(aa==nil)then return true elseif a9 and#a9~=#aa then return true end;for a2,ab in ipairs(a9 or{})do if aa[a2].head~=ab.head then return true end end;return false end;local function ac(a9,aa)if a9.added.start~=aa.added.start then return false end;if a9.added.count~=aa.added.count then return false end;for a2=1,a9.added.count do if a9.added.lines[a2]~=aa.added.lines[a2]then return false end end;return true end;function d.filter_common(a9,aa)if not a9 and not aa then return end;a9,aa=a9 or{},aa or{}local ad=math.max(#a9,#aa)local ae=1;local af=1;local a5={}for n=1,ad do local ag,ah=a9[ae],aa[af]if not ag then break end;if not ah then for a2=ae,#a9 do a5[#a5+1]=a9[a2]end;break end;if ag.added.start>ah.added.start then af=af+1 elseif ag.added.start<ah.added.start then a5[#a5+1]=ag;ae=ae+1 else if not ac(ag,ah)then a5[#a5+1]=ag end;ae=ae+1;af=af+1 end end;return a5 end;return d
