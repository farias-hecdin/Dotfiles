local a=vim.api;local b=vim.loop;local c=require('gitsigns.status')local d=require('gitsigns.async')local e=require('gitsigns.debug.log')local f=require('gitsigns.util')local g=require('gitsigns.cache').cache;local h=require('gitsigns.config').config;local i=require('gitsigns.debounce').debounce_trailing;local j=require('gitsigns.manager')local k=j.buf_check;local l=e.dprint;local m=e.dprintf;local function n(o,p)local q=g[o]local r=q.git_obj;local s=r:has_moved()if s then m('File moved to %s',s)r.relpath=s;if not r.orig_relpath then r.orig_relpath=p end elseif r.orig_relpath then local t=r.repo.toplevel..f.path_sep..r.orig_relpath;if not r:file_info(t).relpath then return end;m('Moved file reset')r.relpath=r.orig_relpath;r.orig_relpath=nil else return end;r.file=r.repo.toplevel..f.path_sep..r.relpath;q.file=r.file;r:update_file_info()d.scheduler_if_buf_valid(o)local u=f.bufexists(q.file)local v=a.nvim_buf_get_name(o)if not u then f.buf_rename(o,q.file)end;local w=u and'Cannot rename'or'Renamed'm('%s buffer %d from %s to %s',w,o,v,q.file)end;local x=i(200,d.void(function(o)local y='watcher_handler'k(o)local r=g[o].git_obj;r.repo:update_abbrev_head()k(o)c:update(o,{head=r.repo.abbrev_head})local z=r.object_name~=nil;local p=r.relpath;r:update_file_info()k(o)if h.watch_gitdir.follow_files and z and not r.object_name then n(o,p)k(o)end;g[o]:invalidate(true)require('gitsigns.manager').update(o)end),1)local function A(B)return vim.inspect(B,{indent='',newline=' '})end;local C={}local D={ORIG_HEAD=true,FETCH_HEAD=true}function C.watch_gitdir(o,E)m('Watching git dir')local F=assert(b.new_fs_event())F:start(E,{},function(G,H,I)local y='watcher_cb'if G then m('Git dir update error: %s',G)return end;local J=string.format("Git dir update: '%s' %s",H,A(I))if H==nil or D[H]or vim.endswith(H,'.lock')then m('%s (ignoring)',J)return end;l(J)x(o)end)return F end;return C
