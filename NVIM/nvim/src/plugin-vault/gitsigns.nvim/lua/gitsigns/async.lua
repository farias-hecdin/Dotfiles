local a={}local b={}local c=setmetatable({},{__mode='k'})function a.running()local d=coroutine.running()if d and c[d]then return true end end;local function e(f)if f and type(f)=='table'and vim.is_callable(f.cancel)and vim.is_callable(f.is_cancelled)then return true end end;function b:cancel(g)if self._current and not self._current:is_cancelled()then self._current:cancel(g)end end;function b.new(h)local f=setmetatable({},{__index=b})c[h]=f;return f end;function b:is_cancelled()return self._current and self._current:is_cancelled()end;local function i(j,k,...)local h=coroutine.create(j)local f=b.new(h)local function l(...)local m={coroutine.resume(h,...)}local n=m[1]if not n then local o=m[2]error(string.format('The coroutine failed with this message: %s\n%s',o,debug.traceback(h)))end;if coroutine.status(h)=='dead'then if k then k(unpack(m,2,table.maxn(m)))end;return end;local p,q=m[2],m[3]assert(type(q)=='function','type error :: expected func')local r={select(4,unpack(m))}r[p]=l;local s=q(unpack(r,1,p))if e(s)then f._current=s end end;l(...)return f end;function a.wait(t,j,...)local function u(...)local r={...}local g=r[t]r[t]=function(...)g(true,...)end;xpcall(j,function(o)g(false,o,debug.traceback())end,unpack(r,1,t))end;local m={coroutine.yield(t,u,...)}local v=m[1]if not v then local w,o,x=unpack(m)error(string.format('Wrapped function failed: %s\n%s',o,x))end;return unpack(m,2,table.maxn(m))end;function a.wrap(j,t)assert(t)return function(...)if not a.running()then return j(...)end;return a.wait(t,j,...)end end;function a.create(j,t)t=t or 0;return function(...)if a.running()then return j(...)end;local k=select(t+1,...)return i(j,k,unpack({...},1,t))end end;function a.void(j)return function(...)if a.running()then return j(...)end;return i(j,nil,...)end end;a.scheduler=a.wrap(vim.schedule,1)a.scheduler_if_buf_valid=a.wrap(function(y,g)vim.schedule(function()if not y or vim.api.nvim_buf_is_valid(y)then g()end end)end,2)return a
