local a=vim.loop;local function b(c)if c and not c:is_closing()then c:close()end end;local d={HUP=1,INT=2,KILL=9,TERM=15}local function e(f)b(f.handle)b(f.stdin)b(f.stdout)b(f.stderr)b(f.timer)end;local g={}local function h(f)return setmetatable({pid=f.pid,_state=f},{__index=g})end;function g:kill(i)self._state.handle:kill(i)end;function g:_timeout(i)self._state.done='timeout'self:kill(i or d.TERM)end;local j=2^31;function g:wait(k)local f=self._state;local l=vim.wait(k or f.timeout or j,function()return f.result~=nil end)if not l then self:_timeout(d.KILL)vim.wait(k or f.timeout or j,function()return f.result~=nil end)end;return f.result end;function g:write(m)local n=self._state.stdin;if not n then error('stdin has not been opened on this object')end;if type(m)=='table'then for o,p in ipairs(m)do n:write(p)n:write('\n')end elseif type(m)=='string'then n:write(m)elseif m==nil then n:write('',function()n:shutdown(function()if n then n:close()end end)end)end end;function g:is_closing()local c=self._state.handle;return c==nil or c:is_closing()or false end;local function q(r)if r==nil then return assert(a.new_pipe(false)),nil end;if type(r)=='function'then return assert(a.new_pipe(false)),r end;assert(r==false)return nil,nil end;local function s(t)if not t then return end;local u;if type(t)=='string'or type(t)=='table'then u=t end;return assert(a.new_pipe(false)),u end;local v=vim.fn.environ()v['NVIM']=vim.v.servername;v['NVIM_LISTEN_ADDRESS']=nil;local function w(x,y)if y then return x end;x=vim.tbl_extend('force',v,x or{})local z={}for A,p in pairs(x)do z[#z+1]=string.format('%s=%s',A,tostring(p))end;return z end;local function B(C,D,E)return function(F,m)if F then error(F)end;if m~=nil then if D then E[#E+1]=m:gsub('\r\n','\n')else E[#E+1]=m end else C:read_stop()C:close()end end end;local function G(H,I,J,K)local c,L=a.spawn(H,I,J)if not c then K()error(L)end;return c,L end;local function M(k,N)local O=assert(a.new_timer())O:start(k,0,function()O:stop()O:close()N()end)return O end;local function P(f,Q,i,J)e(f)local R=assert(a.new_check())R:start(function()for o,S in pairs({f.stdin,f.stdout,f.stderr})do if not S:is_closing()then return end end;R:stop()R:close()if f.done==nil then f.done=true end;if(Q==0 or Q==1)and f.done=='timeout'then Q=124 end;local T=f.stdout_data;local U=f.stderr_data;f.result={code=Q,signal=i,stdout=T and table.concat(T)or nil,stderr=U and table.concat(U)or nil}if J then J(f.result)end end)end;local function V(H,I,J)local W='run_job'vim.validate({cmd={H,'table'},opts={I,'table',true},on_exit={J,'function',true}})I=I or{}local X,Y=q(I.stdout)local Z,_=q(I.stderr)local n,u=s(I.stdin)local f={done=false,cmd=H,timeout=I.timeout,stdin=n,stdout=X,stderr=Z}f.handle,f.pid=G(H[1],{args=vim.list_slice(H,2),stdio={n,X,Z},cwd=I.cwd,env=w(I.env,I.clear_env),detached=I.detach,hide=true},function(Q,i)P(f,Q,i,J)end,function()e(f)end)if X then f.stdout_data={}X:read_start(Y or B(X,I.text,f.stdout_data))end;if Z then f.stderr_data={}Z:read_start(_ or B(Z,I.text,f.stderr_data))end;local a0=h(f)if u then a0:write(u)a0:write(nil)end;if I.timeout then f.timer=M(I.timeout,function()if f.handle and f.handle:is_active()then a0:_timeout()end end)end;return a0 end;return V
