local a=require('gitsigns.async')local b=require('gitsigns.async').scheduler;local c=require('gitsigns.debug.log')local d=require('gitsigns.util')local e=require('gitsigns.system').system;local f=require('gitsigns.config')local g=f.config;local h=vim.loop;local i=vim.startswith;local j=require('gitsigns.debug.log').dprint;local k=require('gitsigns.debug.log').dprintf;local l=require('gitsigns.debug.log').eprint;local m=require('gitsigns.message').error;local n=require('gitsigns.message').error_once;local o={}local p=a.wrap(e,3)local function q(r)for s,t in ipairs(vim.split(r,d.path_sep))do if t=='.git'then return true end end;return false end;local u={}o.Obj=u;local v={}o.Repo=v;local function w(x)assert(x:match('%d+%.%d+%.%w+'),'Invalid git version: '..x)local y={}local z=vim.split(x,'%.')y.major=assert(tonumber(z[1]))y.minor=assert(tonumber(z[2]))if z[3]=='GIT'then y.patch=0 else local A=vim.split(z[3],'-')y.patch=assert(tonumber(A[1]))end;return y end;local function B(x)if not o.version then return false end;if o.version.major<x[1]then return false end;if x[2]and o.version.minor<x[2]then return false end;if x[3]and o.version.patch<x[3]then return false end;return true end;function o._set_version(x)if x~='auto'then o.version=w(x)return end;local C=p({'git','--version'})local D=vim.split(C.stdout or'','\n',{plain=true})[1]if not D then m("Unable to detect git version as 'git --version' failed to return anything")l(C.stderr)return end;assert(type(D)=='string','Unexpected output: '..D)assert(i(D,'git version'),'Unexpected output: '..D)local z=vim.split(D,'%s+')o.version=w(z[3])end;local E=a.create(function(F,G)if not o.version then o._set_version(g._git_version)end;G=G or{}local H={G.command or'git','--no-pager','--literal-pathspecs','-c','gc.auto=0',unpack(F)}if G.text==nil then G.text=true end;G.clear_env=true;local C=p(H,G)local I=C.stdout;local J=C.stderr;if not G.ignore_error and C.code>0 then local K=table.concat(H,' ')c.eprintf("Received exit code %d when running command\n'%s':\n%s",C.code,K,J)end;local L=vim.split(I or'','\n',{plain=true})if G.text then if L[#L]==''then L[#L]=nil end end;if c.verbose then c.vprintf('%d lines:',#L)for M=1,math.min(10,#L)do c.vprintf('\t%s',L[M])end end;if J==''then J=nil end;return L,J end,2)function o.diff(N,O,P,Q)return E({'-c','core.safecrlf=false','diff','--color=never','--'..(P and''or'no-')..'indent-heuristic','--diff-algorithm='..Q,'--patch-with-raw','--unified=0',N,O},{ignore_error=true})end;local function R(S,T,U,H)if not S then return T end;if T=='HEAD'then local V=E({'rev-parse','--short','HEAD'},{command=H,ignore_error=true,cwd=U})[1]or''if c.debug_mode and V~=''then V='HEAD'end;if d.path_exists(S..'/rebase-merge')or d.path_exists(S..'/rebase-apply')then return V..'(rebasing)'end;return V end;return T end;local W=jit and jit.os=='Windows'and vim.fn.executable('cygpath')==1;local X;if W then X=function(U)local C=p({'cygpath','-aw',U})return C.stdout end end;local function Y(U)if U and W and not h.fs_stat(U)then U=X(U)end;return U end;function o.get_repo_info(U,H,S,Z)local _=B({2,13})local a0=_ and'--absolute-git-dir'or'--git-dir'b()local F={}if S then vim.list_extend(F,{'--git-dir',S})end;if Z then vim.list_extend(F,{'--work-tree',Z})end;vim.list_extend(F,{'rev-parse','--show-toplevel',a0,'--abbrev-ref','HEAD'})local a1=E(F,{command=H,ignore_error=true,cwd=Z or U})local a2=Y(a1[1])local a3=Y(a1[2])if a3 and not _ then a3=assert(h.fs_realpath(a3))end;return{toplevel=a2,gitdir=a3,abbrev_head=R(a3,a1[3],U,H),detached=a2 and a3~=a2 ..'/.git'}end;function v:command(F,G)G=G or{}G.cwd=self.toplevel;local a4={'--git-dir',self.gitdir}if self.detached then vim.list_extend(a4,{'--work-tree',self.toplevel})end;vim.list_extend(a4,F)return E(a4,G)end;function v:files_changed()local a1=self:command({'status','--porcelain','--ignore-submodules'})local y={}for s,D in ipairs(a1)do if D:sub(1,2):match('^.M')then y[#y+1]=D:sub(4,-1)end end;return y end;local function a5(a6)if vim.startswith(a6,'utf-16')then return false elseif vim.startswith(a6,'utf-32')then return false end;return true end;function v:get_show_text(a7,a6)local I,J=self:command({'show',a7},{text=false,ignore_error=true})if a6 and a6~='utf-8'and a5(a6)then for M,a8 in ipairs(I)do I[M]=vim.iconv(a8,a6,'utf-8')end end;return I,J end;function v:update_abbrev_head()self.abbrev_head=o.get_repo_info(self.toplevel).abbrev_head end;function v.new(a9,S,Z)local self=setmetatable({},{__index=v})self.username=E({'config','user.name'},{ignore_error=true})[1]local aa=o.get_repo_info(a9,nil,S,Z)for ab,ac in pairs(aa)do self[ab]=ac end;if g.yadm.enable and not self.gitdir then if vim.startswith(a9,assert(os.getenv('HOME')))and#E({'ls-files',a9},{command='yadm'})~=0 then o.get_repo_info(a9,'yadm',S,Z)local ad=o.get_repo_info(a9,'yadm',S,Z)for ab,ac in pairs(ad)do self[ab]=ac end end end;return self end;function u:command(F,G)return self.repo:command(F,G)end;function u:update_file_info(ae,af)local ag=self.object_name;local ah=self:file_info(self.file,af)if ae then self.relpath=ah.relpath end;self.object_name=ah.object_name;self.mode_bits=ah.mode_bits;self.has_conflicts=ah.has_conflicts;self.i_crlf=ah.i_crlf;self.w_crlf=ah.w_crlf;return ag~=self.object_name end;function u:file_info(r,af)local a1,J=self:command({'-c','core.quotepath=off','ls-files','--stage','--others','--exclude-standard','--eol',r or self.file},{ignore_error=true})if J and not af then if not J:match('^warning: could not open directory .*: No such file or directory')then c.eprint(J)end end;local ai={}for s,D in ipairs(a1)do local z=vim.split(D,'\t')if#z>2 then local aj=vim.split(z[2],'%s+')ai.i_crlf=aj[1]=='i/crlf'ai.w_crlf=aj[2]=='w/crlf'ai.relpath=z[3]local ak=vim.split(z[1],'%s+')local al=tonumber(ak[3])if al<=1 then ai.mode_bits=ak[1]ai.object_name=ak[2]else ai.has_conflicts=true end else ai.relpath=z[2]end end;return ai end;function u:get_show_text(am)if am=='FILE'then return d.file_lines(self.file,{raw=true})end;if not self.relpath then return{}end;local I,J=self.repo:get_show_text(am..':'..self.relpath,self.encoding)if not self.i_crlf and self.w_crlf then for M=1,#I-1 do I[M]=I[M]..'\r'end end;return I,J end;function u:unstage_file()self:command({'reset',self.file})end;local an={author='Not Committed Yet',author_mail='<not.committed.yet>',committer='Not Committed Yet',committer_mail='<not.committed.yet>'}function o.not_commited(r)local ao=os.time()return{sha=string.rep('0',40),abbrev_sha=string.rep('0',8),author='Not Committed Yet',author_mail='<not.committed.yet>',author_tz='+0000',author_time=ao,committer='Not Committed Yet',committer_time=ao,committer_mail='<not.committed.yet>',committer_tz='+0000',summary='Version of '..r}end;local function ap(aq)return assert(tonumber(aq))end;function u:run_blame(ar,as,at)local y={}if not self.object_name or self.repo.abbrev_head==''then local au=o.not_commited(self.file)for M in ipairs(ar)do y[M]={orig_lnum=0,final_lnum=M,commit=au,filename=self.file}end;return y end;local F={'blame','--contents','-','--incremental'}if as then vim.list_extend(F,{'-L',as..',+1'})end;F[#F+1]=self.file;if at then F[#F+1]='-w'end;local av=self.repo.toplevel..'/.git-blame-ignore-revs'if h.fs_stat(av)then vim.list_extend(F,{'--ignore-revs-file',av})end;local a1,J=self:command(F,{stdin=ar,ignore_error=true})if J then n('Error running git-blame: '..J)return end;if#a1==0 then return end;local aw={}local M=1;while M<=#a1 do local function ax(ay)local a8=assert(a1[M])M=M+1;if ay then return a8:match(ay)end;return a8 end;local function az(ay)local a8=a1[M]if a8 and ay then return a8:match(ay)end;return a8 end;local aA,aB,aC,aD=ax('(%x+) (%d+) (%d+) (%d+)')local aE=ap(aB)local aF=ap(aC)local aG=ap(aD)if az():match('^author ')then local au={sha=aA,abbrev_sha=aA:sub(1,8)}while az()and not(az():match('^filename ')or az():match('^previous '))do local a8=ax()local aH,aI=a8:match('^([^%s]+) (.*)')if aH then if vim.endswith(aH,'_time')then aI=tonumber(aI)end;aH=aH:gsub('%-','_')au[aH]=aI else au[a8]=true;if a8~='boundary'then k("Unknown tag: '%s'",a8)end end end;if au.author_mail=='<external.file>'or au.author_mail=='External file (--contents)'then au=vim.tbl_extend('force',au,an)end;aw[aA]=au end;local aJ,aK=az():match('^previous (%x+) (.*)')if aJ then ax()end;local aL=assert(ax():match('^filename (.*)'))for aM=0,aG-1 do y[aF+aM]={final_lnum=aF+aM,orig_lnum=aE+aM,commit=aw[aA],filename=aL,previous_filename=aK,previous_sha=aJ}end end;return y end;local function aN(C)if C.object_name and not C.has_conflicts then return end;if not C.object_name then C:command({'add','--intent-to-add',C.file})else local aa=string.format('%s,%s,%s',C.mode_bits,C.object_name,C.relpath)C:command({'update-index','--add','--cacheinfo',aa})end;C:update_file_info()end;function u:stage_lines(ar)local I=self:command({'hash-object','-w','--path',self.relpath,'--stdin'},{stdin=ar})local aO=I[1]self:command({'update-index','--cacheinfo',string.format('%s,%s,%s',self.mode_bits,aO,self.relpath)})end;function u:stage_hunks(aP,aQ)aN(self)local aR=require('gitsigns.hunks')local aS=aR.create_patch(self.relpath,aP,self.mode_bits,aQ)if not self.i_crlf and self.w_crlf then for M=1,#aS do aS[M]=aS[M]:gsub('\r$','')end end;self:command({'apply','--whitespace=nowarn','--cached','--unidiff-zero','-'},{stdin=aS})end;function u:has_moved()local aT=self:command({'diff','--name-status','-C','--cached'})local aU=self.orig_relpath or self.relpath;for s,a8 in ipairs(aT)do local z=vim.split(a8,'%s+')if#z==3 then local aV,aW=z[2],z[3]if aU==aV then self.orig_relpath=aU;self.relpath=aW;self.file=self.repo.toplevel..'/'..aW;return aW end end end end;function u.new(r,a6,S,Z)if q(r)then j('In git dir')return nil end;local self=setmetatable({},{__index=u})self.file=r;self.encoding=a6;self.repo=v.new(d.dirname(r),S,Z)if not self.repo.gitdir then j('Not in git repo')return nil end;local af=S~=nil and Z~=nil;self:update_file_info(true,af)return self end;return o
