local function a(b,c,d,e)local f=vim.fn.mode()local g=f=='V'local h=f==''if b>e then b,c,d,e=d,e,b,c end;if h then for i=b,d do vim.api.nvim_buf_add_highlight(0,-1,'Visual',i-1,c,e)end else vim.api.nvim_buf_add_highlight(0,-1,'Visual',b,g and 0 or c,-1)for i=b+1,d-1 do vim.api.nvim_buf_add_highlight(0,-1,'Visual',i-1,0,-1)end;vim.api.nvim_buf_add_highlight(0,-1,'Visual',d-1,0,g and-1 or e)end end;local function j(k)local l=vim.api.nvim_get_current_buf()local m=vim.bo.filetype;local n=vim.api.nvim_buf_get_lines(l,0,-1,false)local o=vim.api.nvim_win_get_cursor(0)local f=vim.fn.mode()local p={['v']='normal! v',['V']='normal! V',['']='normal! '}local q=function()vim.cmd(p[f])end;local b,c,d,e;if k then b,c,d,e=k.sr,k.sc,k.er,k.ec else _,b,c,_=unpack(vim.fn.getpos('v')or{0,0,0,0})_,d,e,_=unpack(vim.fn.getcurpos())vim.fn.setpos(".",{l,b,c})q()vim.fn.setpos(".",{l,d,e})end;local r=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_lines(r,0,-1,false,n)vim.api.nvim_set_current_buf(r)vim.bo.filetype=m;if k then vim.api.nvim_buf_set_mark(r,'[',b,c,{})vim.api.nvim_buf_set_mark(r,']',d,e,{})else vim.api.nvim_buf_set_mark(r,'<',b,c,{})vim.api.nvim_buf_set_mark(r,'>',d,e,{})end;vim.fn.setpos(".",{r,b,c})q()vim.fn.setpos(".",{r,d,e})vim.api.nvim_win_set_cursor(0,o)vim.cmd('normal! zz')a(b,c,d,e)return function()vim.api.nvim_buf_delete(r,{force=true,unload=false})vim.api.nvim_set_current_buf(l)if k then vim.api.nvim_buf_set_mark(l,'[',b,c,{})vim.api.nvim_buf_set_mark(l,']',d,e,{})else vim.api.nvim_buf_set_mark(l,'<',b,c,{})vim.api.nvim_buf_set_mark(l,'>',d,e,{})vim.fn.setpos(".",{l,b,c})q()vim.fn.setpos(".",{l,d,e})end end end;local function s(t,u,v)return t:sub(1,u-1)..v..t:sub(u)end;local function w(x,y)y=y or{}local b,c,d,e;if y.marks then b,c,d,e=y.marks.sr,y.marks.sc,y.marks.er,y.marks.ec else _,b,c,_=unpack(vim.fn.getpos('v')or{0,0,0,0})_,d,e,_=unpack(vim.fn.getcurpos())if b>d or b==d and c>e then b,c,d,e=d,e,b,c end end;local f=vim.fn.mode()local z=f=='v'local h=f==''if y.preview and y.marks then a(b,c,d,e)end;if b==e then return end;if not x or x==''then return end;y.reverse=not not y.reverse;y.preview=not not y.preview;if d<b then d,b=b,d end;local A=0;local B={}local C=vim.api.nvim_buf_get_lines(0,b-1,d,true)if not C then return end;local D=math.min(c,e)local E=math.max(c,e)if y.regex then local F,G=pcall(vim.regex,x)if not F or G==nil then if not y.preview then error('Failed to compile "'..x..'" as a Vim regex.')end;return end;for i=b,d do local H=C[i-b+1]if not H then break end;local I,J;if h or i==b and z then local K=(h and D or c)-1;local L;F,L=pcall(function()return{G:match_line(0,i-1,K)}end)if not F then goto M end;I,J=unpack(L)if I~=nil and J~=nil then I=I+K;J=J+K end else I,J=G:match_str(H)end;if I==nil or J==nil then goto M end;I=I+1;if z and(i==d and e<J or i==b and c>I)then goto M end;if h and(E<J or D>I)then goto M end;local N=vim.fn.strdisplaywidth(H:sub(0,I))table.insert(B,{i,N})if y.reverse then for O=I-1,1,-1 do if H:sub(O,O)==" "then I=O;N=vim.fn.strdisplaywidth(H:sub(0,I))else break end end end;A=math.max(A,N)::M::end else for i=b,d do local H=C[i-b+1]if not H then break end;local P=(h or i==b and z)and H:find(x,h and D or c,true)or H:find(x,nil,true)local N=vim.fn.strdisplaywidth(H:sub(0,P))if P then if i==d and e<N+#x-1 and z then goto M end;if h and(E<N+#x-1 or D>N)then goto M end;table.insert(B,{i,N})if y.reverse then for O=P-1,1,-1 do if H:sub(O,O)==" "then P=O;N=vim.fn.strdisplaywidth(H:sub(0,P))else break end end end;A=math.max(A,N)end::M::end end;if not y.preview then vim.api.nvim_input('<Esc>')end;if A==0 or#B==0 then return end;for _,u in ipairs(B)do local Q,R=unpack(u)local S=C[Q-b+1]if R<=A then vim.api.nvim_buf_set_lines(0,Q-1,Q,true,{s(S,R,(' '):rep(A-R+(y.reverse and 1 or 0)))})else vim.api.nvim_buf_set_lines(0,Q-1,Q,true,{string.sub(S,1,A)..string.sub(S,R)})end end;if y.preview and y.marks then a(b,c,d,e)end;if not y.preview and y.callback then vim.schedule(y.callback)end;vim.print(' ')return 1 end;local function T(U)U=U or''local V=vim.fn.getcharstr()if V==vim.api.nvim_replace_termcodes('<Esc>',true,false,true)then vim.print(' ')return 0,nil end;if V==vim.api.nvim_replace_termcodes('<CR>',true,false,true)then return 1,nil end;if V==vim.api.nvim_replace_termcodes('<BS>',true,false,true)then return 2,U:sub(1,#U-1)else return nil,U..V end end;local function W(x,y)y=y or{}if y.marks and y.marks.sr then local b,c,d,e=y.marks.sr,y.marks.sc,y.marks.er,y.marks.ec;if b==d then return end;a(b,c,d,e)end;y.preview=false;w(x,y)end;local function X(y)y=y or{}if y.marks and y.marks.sr then local b,c,d,e=y.marks.sr,y.marks.sc,y.marks.er,y.marks.ec;if b==d then return end;a(b,c,d,e)end;y.length=math.max(y.length or 1,1)y.preview=not not y.preview and y.length>1;local Y='Enter '..(y.length>1 and y.length..' characters: 'or'a character: ')vim.print(Y)local x=''local Z=y.preview and j(y.marks)or nil;vim.cmd.redraw()while#x<y.length do vim.print(Y..x)local a0,a1=T(x)if a0==0 then if Z then Z()Z=function()end end;vim.api.nvim_input('<Esc>')return end;if a0==1 then break end;x=a1;if y.preview then if Z then Z()end;Z=j(y.marks)w(x,y)end;vim.cmd.redraw()end;if Z then Z()end;W(x,y)end;local function a2(y)y=y or{}if y.marks and y.marks.sr then local b,c,d,e=y.marks.sr,y.marks.sc,y.marks.er,y.marks.ec;if b==d then return end;a(b,c,d,e)end;y.preview=not not y.preview;y.regex=not not y.regex;local Y=y.regex and'Enter pattern: 'or'Enter string: 'vim.print(Y)local x=''local Z=y.preview and j(y.marks)or nil;vim.cmd.redraw()while true do vim.print(Y..x)local a0,a3=T(x)if a0==0 then if Z then Z()Z=function()end end;vim.api.nvim_input('<Esc>')vim.print(' ')return end;if a0==1 then break end;x=a3;if y.preview then if Z then Z()end;Z=j(y.marks)y.preview=true;w(x,y)end;vim.cmd.redraw()end;if Z then Z()end;W(x,y)end;local function a4(a5,y)y=y or{}local a6=vim.go.operatorfunc;_G.op_align=function()local b,c=unpack(vim.api.nvim_buf_get_mark(0,'['))local d,e=unpack(vim.api.nvim_buf_get_mark(0,']'))if not b or b==d then vim.go.operatorfunc=a6;_G.op_align=nil;return end;a(b,c,d,e)y.marks={sr=b,sc=c,er=d,ec=e}if a5==X then X(y)elseif a5==a2 then a2(y)elseif a5==W then W(y.pattern,y)else error('Unknown function: '..a5)end;vim.api.nvim_buf_clear_namespace(0,-1,0,-1)vim.go.operatorfunc=a6;_G.op_align=nil end;vim.go.operatorfunc='v:lua.op_align'vim.api.nvim_feedkeys('g@','n',false)end;return{align=W,align_to_char=X,align_to_string=a2,operator=a4}
