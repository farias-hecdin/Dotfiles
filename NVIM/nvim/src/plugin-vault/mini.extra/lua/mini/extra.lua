local a={}local b={}a.setup=function(c)_G.MiniExtra=a;c=b.setup_config(c)b.apply_config(c)end;a.config={}a.gen_ai_spec={}a.gen_ai_spec.buffer=function()return function(d)local e,f=1,vim.fn.line('$')if d=='i'then local g,h=vim.fn.nextnonblank(e),vim.fn.prevnonblank(f)if g==0 or h==0 then return{from={line=e,col=1}}end;e,f=g,h end;local i=math.max(vim.fn.getline(f):len(),1)return{from={line=e,col=1},to={line=f,col=i}}end end;a.gen_ai_spec.diagnostic=function(j)return function(d)local k=vim.diagnostic.get(0,{severity=j})local l={}for m,n in ipairs(k)do local o={line=n.lnum+1,col=n.col+1}local p={line=n.end_lnum+1,col=n.end_col}if p.line==nil or p.col==nil then p={line=n.lnum+1,col=n.col+1}end;table.insert(l,{from=o,to=p})end;return l end end;a.gen_ai_spec.indent=function()return b.ai_indent_spec end;a.gen_ai_spec.line=function()return function(d)local q=vim.fn.line('.')local r=vim.fn.getline(q)local s=d=='a'and 1 or r:match('^(%s*)'):len()+1;local i=r:len()return{from={line=q,col=s},to={line=q,col=i}}end end;a.gen_ai_spec.number=function()local t='%f[%d]%d+%f[%D]'local u=function(r,v)local o,p=r:find(t,v)if o==nil then return nil,nil end;if o==v and r:sub(o-1,o-1)=='-'then v=p+1;o,p=r:find(t,v)end;if o==nil then return nil,nil end;if r:sub(o-2):find('^%d%.')~=nil then v=p+1;o,p=r:find(t,v)end;if o==nil then return nil,nil end;if r:sub(o-1,o-1)=='-'then o=o-1 end;local w=r:sub(p+1):match('^%.%d+()')if w~=nil then p=p+w-1 end;return o,p end;return function(d)if d=='i'then return{t}end;return{u,{'^().*()$'}}end end;a.gen_highlighter={}a.gen_highlighter.words=function(x,y,z)if not vim.tbl_islist(x)then b.error('`words` should be an array.')end;if not(type(y)=='string'or vim.is_callable(y))then b.error('`group` should be string or callable.')end;local A=vim.tbl_map(function(B)if type(B)~='string'then b.error('All elements of `words` should be strings.')end;return'%f[%w]()'..vim.pesc(B)..'()%f[%W]'end,x)return{pattern=A,group=y,extmark_opts=z}end;a.pickers={}a.pickers.buf_lines=function(C,D)local E=b.validate_pick('buf_lines')C=vim.tbl_deep_extend('force',{scope='all'},C or{})local F=b.pick_validate_scope(C,{'all','current'},'buf_lines')local G=F=='all'local H={}if G then for m,I in ipairs(vim.api.nvim_list_bufs())do if vim.bo[I].buflisted and vim.bo[I].buftype==''then table.insert(H,I)end end else H={vim.api.nvim_get_current_buf()}end;local J=E.poke_is_picker_active;local K=function()local L={}for m,I in ipairs(H)do if not J()then return end;b.buf_ensure_loaded(I)local M=b.buf_get_name(I)or''for N,O in ipairs(vim.api.nvim_buf_get_lines(I,0,-1,false))do local P=G and string.format('%s:',M)or''table.insert(L,{text=string.format('%s%s:%s',P,N,O),bufnr=I,lnum=N})end end;E.set_picker_items(L)end;local L=vim.schedule_wrap(coroutine.wrap(K))local Q=b.pick_get_config().source.show;if G and Q==nil then Q=b.show_with_icons end;return b.pick_start(L,{source={name=string.format('Buffer lines (%s)',F),show=Q}},D)end;a.pickers.commands=function(C,D)local E=b.validate_pick('commands')local R=vim.tbl_deep_extend('force',vim.api.nvim_get_commands({}),vim.api.nvim_buf_get_commands(0,{}))local S=function(I,T)local U=R[T]local V=U==nil and{string.format('No command data for `%s` is yet available.',T)}or vim.split(vim.inspect(U),'\n')b.set_buflines(I,V)end;local W=function(T)local U=R[T]or{}local X=string.format(':%s%s',T,U.nargs=='0'and'\r'or' ')vim.schedule(function()vim.fn.feedkeys(X)end)end;local L=vim.fn.getcompletion('','command')local Y={source={name='Commands',preview=S,choose=W}}return b.pick_start(L,Y,D)end;a.pickers.diagnostic=function(C,D)local E=b.validate_pick('diagnostic')C=vim.tbl_deep_extend('force',{get_opts={},scope='all',sort_by='severity'},C or{})local F=b.pick_validate_scope(C,{'all','current'},'diagnostic')local Z=b.pick_validate_one_of('sort_by',C,{'severity','path','none'},'diagnostic')local _=function(B)if B==nil then return nil end;return B+1 end;local a0;if F=='current'then a0=vim.api.nvim_get_current_buf()end;local L=vim.deepcopy(vim.diagnostic.get(a0,C.get_opts))local a1=0;for m,T in ipairs(L)do T.path=b.buf_get_name(T.bufnr)or''T.severity=T.severity or 0;a1=math.max(a1,vim.fn.strchars(T.path))end;local a2=b.diagnostic_make_compare(Z)if vim.is_callable(a2)then table.sort(L,a2)end;for m,T in ipairs(L)do local j=vim.diagnostic.severity[T.severity]or' 'local a3=T.message:gsub('\n',' ')T.text=string.format('%s │ %s │ %s',j:sub(1,1),b.ensure_text_width(T.path,a1),a3)T.lnum,T.col,T.end_lnum,T.end_col=_(T.lnum),_(T.col),_(T.end_lnum),_(T.end_col)end;local a4={[vim.diagnostic.severity.ERROR]='DiagnosticFloatingError',[vim.diagnostic.severity.WARN]='DiagnosticFloatingWarn',[vim.diagnostic.severity.INFO]='DiagnosticFloatingInfo',[vim.diagnostic.severity.HINT]='DiagnosticFloatingHint'}local Q=function(I,a5,a6)E.default_show(I,a5,a6)b.pick_clear_namespace(I,b.ns_id.pickers)for a7,T in ipairs(a5)do b.pick_highlight_line(I,a7,a4[T.severity],199)end end;local a8=string.format('Diagnostic (%s)',F)return b.pick_start(L,{source={name=a8,choose=b.choose_with_buflisted,show=Q}},D)end;a.pickers.explorer=function(C,D)local E=b.validate_pick('explorer')C=vim.tbl_deep_extend('force',{cwd=nil,filter=nil,sort=nil},C or{})local a9=C.cwd or vim.fn.getcwd()if vim.fn.isdirectory(a9)==0 then b.error('`local_opts.cwd` should be valid directory path.')end;a9=b.full_path(vim.fn.fnamemodify(a9,':p'))local aa=C.filter or function()return true end;if not vim.is_callable(aa)then b.error('`local_opts.filter` should be callable.')end;local ab=C.sort or b.explorer_default_sort;if not vim.is_callable(ab)then b.error('`local_opts.sort` should be callable.')end;local W=function(T)local ac=T.path;if vim.fn.filereadable(ac)==1 then return E.default_choose(ac)end;if vim.fn.isdirectory(ac)==0 then return false end;E.set_picker_items(b.explorer_make_items(ac,aa,ab))E.set_picker_opts({source={cwd=ac}})E.set_picker_query({})return true end;local Q=b.pick_get_config().source.show or b.show_with_icons;local L=b.explorer_make_items(a9,aa,ab)local ad={items=L,name='File explorer',cwd=a9,show=Q,choose=W}D=vim.tbl_deep_extend('force',{source=ad},D or{})return E.start(D)end;a.pickers.git_branches=function(C,D)local E=b.validate_pick('git_branches')b.validate_git('git_branches')C=vim.tbl_deep_extend('force',{path=nil,scope='all'},C or{})local F=b.pick_validate_scope(C,{'all','local','remotes'},'git_branches')local ac,ae=b.git_normalize_path(C.path,'git_branches')local af=b.git_get_repo_dir(ac,ae,'git_branches')local ag=function(I,T)local ah=T:match('^%*?%s*(%S+)')local ai={'git','-C',af,'log',ah,'--format=format:%h %s'}b.cli_show_output(I,ai)end;local S=ag;local W=b.make_show_in_target_win('git_branches',ag)local aj={'git','branch','-v','--no-color','--list'}if F=='all'or F=='remotes'then table.insert(aj,3,'--'..F)end;local a8=string.format('Git branches (%s)',F)local ak={name=a8,cwd=af,preview=S,choose=W}D=vim.tbl_deep_extend('force',{source=ak},D or{})return E.builtin.cli({command=aj},D)end;a.pickers.git_commits=function(C,D)local E=b.validate_pick('git_commits')b.validate_git('git_commits')C=vim.tbl_deep_extend('force',{path=nil},C or{})local ac,ae=b.git_normalize_path(C.path,'git_commits')local af=b.git_get_repo_dir(ac,ae,'git_commits')if C.path==nil then ac=af end;local al=function(I,T)if type(T)~='string'then return end;vim.bo[I].syntax='git'b.cli_show_output(I,{'git','-C',af,'--no-pager','show',T:match('^(%S+)')})end;local S=al;local W=b.make_show_in_target_win('git_commits',al)local aj={'git','log',[[--format=format:%h %s]],'--',ac}local a8=string.format('Git commits (%s)',C.path==nil and'all'or'for path')local ak={name=a8,cwd=af,preview=S,choose=W}D=vim.tbl_deep_extend('force',{source=ak},D or{})return E.builtin.cli({command=aj},D)end;a.pickers.git_files=function(C,D)local E=b.validate_pick('git_files')b.validate_git('git_files')C=vim.tbl_deep_extend('force',{path=nil,scope='tracked'},C or{})local am={'tracked','modified','untracked','ignored','deleted'}local F=b.pick_validate_scope(C,am,'git_files')local ac,ae=b.git_normalize_path(C.path,'git_files')b.git_get_repo_dir(ac,ae,'git_files')local an=ae=='directory'and ac or vim.fn.fnamemodify(ac,':h')local Q=b.pick_get_config().source.show or b.show_with_icons;local aj=({tracked={'git','-C',an,'ls-files','--cached'},modified={'git','-C',an,'ls-files','--modified'},untracked={'git','-C',an,'ls-files','--others'},ignored={'git','-C',an,'ls-files','--others','--ignored','--exclude-standard'},deleted={'git','-C',an,'ls-files','--deleted'}})[C.scope]local a8=string.format('Git files (%s)',C.scope)local ak={name=a8,cwd=an,show=Q}D=vim.tbl_deep_extend('force',{source=ak},D or{})return E.builtin.cli({command=aj},D)end;a.pickers.git_hunks=function(C,D)local E=b.validate_pick('git_hunks')b.validate_git('git_hunks')local ao={n_context=3,path=nil,scope='unstaged'}C=vim.tbl_deep_extend('force',ao,C or{})if not(type(C.n_context)=='number'and C.n_context>=0)then b.error('`n_context` option in `pickers.git_hunks` picker should be non-negative number.')end;local ap=math.floor(C.n_context)local F=b.pick_validate_scope(C,{'unstaged','staged'},'git_hunks')local ac,ae=b.git_normalize_path(C.path,'git_hunks')local af=b.git_get_repo_dir(ac,ae,'git_hunks')if C.path==nil then ac=af end;local S=function(I,T)vim.bo[I].syntax='diff'local V=vim.deepcopy(T.header)vim.list_extend(V,T.hunk)b.set_buflines(I,V)end;local aj={'git','diff','--patch','--unified='..ap,'--color=never','--',ac}if F=='staged'then table.insert(aj,4,'--cached')end;local aq=function(V)return b.git_difflines_to_hunkitems(V,ap)end;local a8=string.format('Git hunks (%s %s)',F,C.path==nil and'all'or'for path')local ak={name=a8,cwd=af,preview=S}D=vim.tbl_deep_extend('force',{source=ak},D or{})return E.builtin.cli({command=aj,postprocess=aq},D)end;a.pickers.hipatterns=function(C,D)local E=b.validate_pick('hipatterns')local ar,as=pcall(require,'mini.hipatterns')if not ar then b.error([[`pickers.hipatterns` requires 'mini.hipatterns' which can not be found.]])end;C=vim.tbl_deep_extend('force',{highlighters=nil,scope='all'},C or{})if C.highlighters~=nil and not vim.tbl_islist(C.highlighters)then b.error('`local_opts.highlighters` should be an array of highlighter identifiers.')end;local at=C.highlighters;local F=b.pick_validate_scope(C,{'all','current'},'hipatterns')local H=F=='all'and as.get_enabled_buffers()or{vim.api.nvim_get_current_buf()}local L,au={},0;for m,I in ipairs(H)do local V=vim.api.nvim_buf_get_lines(I,0,-1,false)local M=b.buf_get_name(I)if M==''then M='Buffer_'..I end;for m,av in ipairs(as.get_matches(I,at))do av.highlighter=tostring(av.highlighter)av.buf_name,av.line=M,V[av.lnum]table.insert(L,av)au=math.max(au,vim.fn.strchars(av.highlighter))end end;for m,T in ipairs(L)do T.text=string.format('%s │ %s:%d:%d:%s',b.ensure_text_width(T.highlighter,au),T.buf_name,T.lnum,T.col,T.line)T.buf_name,T.line=nil,nil end;local Q=function(I,a5,a6)E.default_show(I,a5,a6)b.pick_clear_namespace(I,b.ns_id.pickers)for a7,T in ipairs(a5)do local aw=string.len(T.highlighter)local z={hl_group=T.hl_group,end_row=a7-1,end_col=aw,priority=1}vim.api.nvim_buf_set_extmark(I,b.ns_id.pickers,a7-1,0,z)end end;local a8=string.format('Mini.hipatterns matches (%s)',F)return b.pick_start(L,{source={name=a8,show=Q}},D)end;a.pickers.history=function(C,D)local E=b.validate_pick('history')C=vim.tbl_deep_extend('force',{scope='all'},C or{})local am={'all','cmd','search','expr','input','debug',':','/','?','=','@','>'}local F=b.pick_validate_scope(C,am,'history')local ax={cmd=':',search='/',expr='=',input='@',debug='>',[':']=':',['/']='/',['=']='=',['@']='@',['>']='>',['?']='?'}local L={}local ay=F=='all'and{'cmd','search','expr','input','debug'}or{F}for m,az in ipairs(ay)do local aA=vim.api.nvim_exec(':history '..az,true)local V=vim.split(aA,'\n')local aB=ax[az]for a7=#V,2,-1 do local aC=V[a7]:match('^.-%-?%d+%s+(.*)$')table.insert(L,string.format('%s %s',aB,aC))end end;local S=b.pick_make_no_preview('history')local W=function(T)if not(type(T)=='string'and vim.fn.mode()=='n')then return end;local aB,aD=T:match('^(.) (.*)$')if aB==':'or aB=='/'or aB=='?'then vim.schedule(function()vim.fn.feedkeys(aB..aD..'\r','nx')end)end end;local ak={name=string.format('History (%s)',F),preview=S,choose=W}return b.pick_start(L,{source=ak},D)end;a.pickers.hl_groups=function(C,D)local E=b.validate_pick('hl_groups')local aE=vim.split(vim.api.nvim_exec('highlight',true),'\n')local L={}for m,O in ipairs(aE)do local y=O:match('^(%S+)')if y~=nil then table.insert(L,y)end end;local Q=function(I,a5,a6)b.set_buflines(I,a5)b.pick_clear_namespace(I,b.ns_id.pickers)for a7=1,#a5 do b.pick_highlight_line(I,a7,a5[a7],300)end end;local S=function(I,T)local V=vim.split(vim.api.nvim_exec('hi '..T,true),'\n')b.set_buflines(I,V)end;local W=function(T)local aF=vim.split(vim.api.nvim_exec('hi '..T,true),'\n')[1]aF=aF:gsub('^(%S+)%s+xxx%s+','%1 ')vim.schedule(function()vim.fn.feedkeys(':hi '..aF,'n')end)end;local ak={name='Highlight groups',show=Q,preview=S,choose=W}return b.pick_start(L,{source=ak},D)end;a.pickers.keymaps=function(C,D)local E=b.validate_pick('keymaps')C=vim.tbl_deep_extend('force',{mode='all',scope='all'},C or{})local aG=b.pick_validate_one_of('mode',C,{'all','n','x','s','o','i','l','c','t'},'keymaps')local F=b.pick_validate_scope(C,{'all','global','buf'},'keymaps')local aH=vim.fn.has('nvim-0.8')==1 and vim.fn.keytrans or function(B)return B end;local L={}local aI=aG=='all'and{'n','x','s','o','i','l','c','t'}or{aG}local aJ=0;local aK=function(ad)for m,aL in ipairs(aI)do for m,aM in ipairs(ad(aL))do local aN=aM.desc~=nil and vim.inspect(aM.desc)or aM.rhs;local aO=aH(aM.lhsraw or aM.lhs)aJ=math.max(vim.fn.strchars(aO),aJ)table.insert(L,{lhs=aO,desc=aN,maparg=aM})end end end;if F=='all'or F=='buf'then aK(function(aL)return vim.api.nvim_buf_get_keymap(0,aL)end)end;if F=='all'or F=='global'then aK(vim.api.nvim_get_keymap)end;for m,T in ipairs(L)do local aP=T.maparg.buffer==0 and' 'or'@'local aQ=b.ensure_text_width(T.lhs,aJ)T.text=string.format('%s %s │ %s │ %s',T.maparg.mode,aP,aQ,T.desc or'')end;local aR=function(aM)if type(aM.callback)~='function'then return nil,nil end;local aS=debug.getinfo(aM.callback)local ac=aS.source:gsub('^@','')if vim.fn.filereadable(ac)==0 then return nil,nil end;return ac,aS.linedefined end;local S=function(I,T)local ac,N=aR(T.maparg)if ac~=nil then T.path,T.lnum=ac,N;return E.default_preview(I,T)end;local V=vim.split(vim.inspect(T.maparg),'\n')b.set_buflines(I,V)end;local W=function(T)local X=vim.api.nvim_replace_termcodes(T.maparg.lhs,true,true,true)if T.maparg.mode=='x'then X='gv'..X end;vim.schedule(function()vim.fn.feedkeys(X)end)end;local Y={source={name=string.format('Keymaps (%s)',F),preview=S,choose=W}}return b.pick_start(L,Y,D)end;a.pickers.list=function(C,D)local E=b.validate_pick('list')C=vim.tbl_deep_extend('force',{scope=nil},C or{})if C.scope==nil then b.error('`pickers.list` needs an explicit scope.')end;local aT={'quickfix','location','jump','change'}local F=b.pick_validate_scope(C,aT,'list')local aU,L=pcall(b.list_get[F])if not aU then L={}end;L=vim.tbl_filter(function(B)return b.is_valid_buf(B.bufnr)end,L)L=vim.tbl_map(b.list_enhance_item,L)local a8=string.format('List (%s)',F)return b.pick_start(L,{source={name=a8,choose=b.choose_with_buflisted}},D)end;a.pickers.lsp=function(C,D)if vim.fn.has('nvim-0.8')==0 then b.error('`pickers.lsp` requires Neovim>=0.8.')end;local E=b.validate_pick('lsp')C=vim.tbl_deep_extend('force',{scope=nil,symbol_query=''},C or{})if C.scope==nil then b.error('`pickers.lsp` needs an explicit scope.')end;local aT={'declaration','definition','document_symbol','implementation','references','type_definition','workspace_symbol'}local F=b.pick_validate_scope(C,aT,'lsp')if F=='references'then return vim.lsp.buf[F](nil,{on_list=b.lsp_make_on_list(F,D)})end;if F=='workspace_symbol'then local a6=tostring(C.symbol_query)return vim.lsp.buf[F](a6,{on_list=b.lsp_make_on_list(F,D)})end;vim.lsp.buf[F]({on_list=b.lsp_make_on_list(F,D)})end;a.pickers.marks=function(C,D)local E=b.validate_pick('marks')C=vim.tbl_deep_extend('force',{scope='all'},C or{})local F=b.pick_validate_scope(C,{'all','global','buf'},'marks')local L={}local aK=function(aV)for m,aS in ipairs(aV)do local ac;if type(aS.file)=='string'then ac=vim.fn.fnamemodify(aS.file,':.')end;local I;if ac==nil then I=aS.pos[1]end;local r,aW=aS.pos[2],math.abs(aS.pos[3])local a3=string.format('%s │ %s%s:%s',aS.mark:sub(2),ac==nil and''or ac..':',r,aW)table.insert(L,{text=a3,bufnr=I,path=ac,lnum=r,col=aW})end end;if F=='all'or F=='buf'then aK(vim.fn.getmarklist(vim.api.nvim_get_current_buf()))end;if F=='all'or F=='global'then aK(vim.fn.getmarklist())end;local Y={source={name=string.format('Marks (%s)',F)}}return b.pick_start(L,Y,D)end;a.pickers.oldfiles=function(C,D)local E=b.validate_pick('oldfiles')local aX=vim.v.oldfiles;if not vim.tbl_islist(aX)then b.error('`pickers.oldfiles` picker needs valid `v:oldfiles`.')end;local L=vim.schedule_wrap(function()local a9=E.get_picker_opts().source.cwd;local aY={}for m,ac in ipairs(aX)do if vim.fn.filereadable(ac)==1 then table.insert(aY,b.short_path(ac,a9))end end;E.set_picker_items(aY)end)local Q=b.pick_get_config().source.show or b.show_with_icons;return b.pick_start(L,{source={name='Old files',show=Q}},D)end;a.pickers.options=function(C,D)local E=b.validate_pick('options')C=vim.tbl_deep_extend('force',{scope='all'},C or{})local F=b.pick_validate_scope(C,{'all','global','win','buf'},'options')local L={}for a8,aS in pairs(vim.api.nvim_get_all_options_info())do if F=='all'or F==aS.scope then table.insert(L,{text=a8,info=aS})end end;table.sort(L,function(aZ,a_)return aZ.text<a_.text end)local Q=function(I,a5,a6)E.default_show(I,a5,a6)b.pick_clear_namespace(I,b.ns_id.pickers)for a7,T in ipairs(a5)do if not T.info.was_set then b.pick_highlight_line(I,a7,'Comment',199)end end end;local S=function(I,T)local b0=E.get_picker_state().windows;local b1=b0.target;if not b.is_valid_win(b1)then b1=b0.main end;local b2=({global='o',win='wo',buf='bo'})[T.info.scope]local b3,b4=pcall(function()return vim.api.nvim_win_call(b1,function()return vim[b2][T.info.name]end)end)if not b3 then b4='<Option is deprecated (will be removed in later Neovim versions)>'end;local V={'Value:',unpack(vim.split(vim.inspect(b4),'\n')),'','Info:'}local b5={1,#V}V=vim.list_extend(V,vim.split(vim.inspect(T.info),'\n'))b.set_buflines(I,V)b.pick_highlight_line(I,b5[1],'MiniPickHeader',200)b.pick_highlight_line(I,b5[2],'MiniPickHeader',200)end;local W=function(T)local X=string.format(':set %s%s',T.info.name,T.info.type=='boolean'and''or'=')vim.schedule(function()vim.fn.feedkeys(X)end)end;local a8=string.format('Options (%s)',F)local ak={name=a8,show=Q,preview=S,choose=W}return b.pick_start(L,{source=ak},D)end;a.pickers.registers=function(C,D)local E=b.validate_pick('registers')local b6=function(b7)local b8,b4=pcall(vim.fn.getreg,b7,1)if not b8 then return''end;return b4 end;local b9=vim.split('"*+:.%/#=-0123456789abcdefghijklmnopqrstuvwxyz','')local L={}for m,b7 in ipairs(b9)do local ba=b6(b7)local a3=string.format('%s │ %s',b7,ba)table.insert(L,{regname=b7,regcontents=ba,text=a3})end;local W=vim.schedule_wrap(function(T)local bb,ba,aG=T.regname,T.regcontents,vim.fn.mode()if bb=='='and ba~=''then bb=bb..T.regcontents..'\r'end;local X=string.format('"%s%s',bb,bb=='='and''or'P')if aG=='i'or aG=='c'then X='\18'..bb end;vim.fn.feedkeys(X)end)local S=function(I,T)b.set_buflines(I,vim.split(T.regcontents,'\n'))end;return b.pick_start(L,{source={name='Registers',preview=S,choose=W}},D)end;a.pickers.spellsuggest=function(C,D)local E=b.validate_pick('spellsuggest')C=vim.tbl_deep_extend('force',{n_suggestions=25},C or{})local bc=C.n_suggestions;if not(type(bc)=='number'and bc>0)then b.error('`local_opts.n_suggestions` should be a positive number.')end;local bd=vim.fn.expand('<cword>')local be=vim.fn.spellsuggest(bd,bc)local L={}for a7,bf in ipairs(be)do table.insert(L,{text=bf,index=a7})end;local S=b.pick_make_no_preview('spellsuggest')local W=vim.schedule_wrap(function(T)vim.cmd('normal! '..T.index..'z=')end)local a8='Spell suggestions for '..vim.inspect(bd)return b.pick_start(L,{source={name=a8,preview=S,choose=W}},D)end;a.pickers.treesitter=function(C,D)if vim.fn.has('nvim-0.8')==0 then b.error('`pickers.treesitter` requires Neovim>=0.8.')end;local E=b.validate_pick('treesitter')local I=vim.api.nvim_get_current_buf()local bg,bh=pcall(vim.treesitter.get_parser,I)if not bg or bh==nil then b.error('`pickers.treesitter` requires active tree-sitter parser.')end;local L,bi={},nil;bi=function(bj,bk)if bk>=1000 then return end;for bl in bj:iter_children()do if bl:named()then local N,aW,bm,aw=bl:range()N,aW,bm,aw=N+1,aW+1,bm+1,aw+1;local bn=string.rep(' ',bk)local a3=string.format('%s%s (%s:%s - %s:%s)',bn,bl:type()or'',N,aW,bm,aw)local T={text=a3,bufnr=I,lnum=N,col=aW,end_lnum=bm,end_col=aw}table.insert(L,T)bi(bl,bk+1)end end end;bh:for_each_tree(function(bo,m)bi(bo:root(),0)end)return b.pick_start(L,{source={name='Tree-sitter nodes'}},D)end;if type(_G.MiniPick)=='table'then for a8,K in pairs(a.pickers)do _G.MiniPick.registry[a8]=function(C)return K(C)end end end;b.default_config=a.config;b.ns_id={pickers=vim.api.nvim_create_namespace('MiniExtraPickers')}b.cache={}b.setup_config=function(c)end;b.apply_config=function(c)a.config=c end;b.ai_indent_spec=function(d)local V=vim.api.nvim_buf_get_lines(0,0,-1,false)local bp=string.rep(' ',vim.bo.tabstop)local bq,br,bs={},{},{}for a7,O in ipairs(V)do bq[a7]=O:match('^([ \t]*)')local bt=bq[a7]:len()~=O:len()if bt then b.ai_indent_update_rays(a7,bq[a7]:gsub('\t',bp):len(),br,bs)end end;table.sort(bs,function(aZ,a_)return aZ.from_line<a_.from_line end)local bu,bv,bw=0,0,1;if d=='i'then bu,bv,bw=1,-1,0 end;local aY={}for a7,bx in ipairs(bs)do local by,bz=bx.from_line+bu,bx.to_line+bv;local s=d=='a'and 1 or bq[by]:len()+1;local i=V[bz]:len()+bw;aY[a7]={from={line=by,col=s},to={line=bz,col=i}}end;return aY end;b.ai_indent_update_rays=function(q,bn,br,bs)for a7=#br,1,-1 do local bx=br[a7]if bx.indent<bn then bx.is_empty=false;break end;if not bx.is_empty then bx.to_line=q;table.insert(bs,bx)end;br[a7]=nil end;table.insert(br,{indent=bn,from_line=q,is_empty=true})end;b.validate_pick=function(bA)local bB,E=pcall(require,'mini.pick')if not bB then b.error(string.format([[`pickers.%s()` requires 'mini.pick' which can not be found.]],bA))end;return E end;b.pick_start=function(L,Y,D)local E=b.validate_pick()local bC={source={preview=E.default_preview,choose=E.default_choose,choose_marked=E.default_choose_marked}}local bD=vim.tbl_deep_extend('force',bC,Y,D or{},{source={items=L}})return E.start(bD)end;b.pick_highlight_line=function(I,r,bE,bF)local D={end_row=r,end_col=0,hl_mode='blend',hl_group=bE,priority=bF}vim.api.nvim_buf_set_extmark(I,b.ns_id.pickers,r-1,0,D)end;b.pick_prepend_position=function(T)local ac;if T.path~=nil then ac=T.path elseif b.is_valid_buf(T.bufnr)then local a8=vim.api.nvim_buf_get_name(T.bufnr)ac=a8==''and'Buffer_'..T.bufnr or a8 end;if ac==nil then return T end;ac=vim.fn.fnamemodify(ac,':p:.')local a3=T.text or''local bG=a3==''and''or': '..a3;T.text=string.format('%s:%s:%s%s',ac,T.lnum or 1,T.col or 1,bG)return T end;b.pick_clear_namespace=function(I,bH)pcall(vim.api.nvim_buf_clear_namespace,I,bH,0,-1)end;b.pick_make_no_preview=function(bI)local V={string.format('No preview available for `%s` picker',bI)}return function(I,m)b.set_buflines(I,V)end end;b.pick_validate_one_of=function(bJ,D,bK,bI)if vim.tbl_contains(bK,D[bJ])then return D[bJ]end;local bL=string.format('`pickers.%s` has wrong "%s" local option (%s). Should be one of %s.',bI,bJ,vim.inspect(D[bJ]),table.concat(vim.tbl_map(vim.inspect,bK),', '))b.error(bL)end;b.pick_validate_scope=function(...)return b.pick_validate_one_of('scope',...)end;b.pick_get_config=function()return vim.tbl_deep_extend('force',(require('mini.pick')or{}).config or{},vim.b.minipick_config or{})end;b.make_show_in_target_win=function(bA,bM)local E=b.validate_pick(bA)return function(T)local bN=(E.get_picker_state().windows or{}).target;if bN==nil or not b.is_valid_win(bN)then return end;local I=vim.api.nvim_create_buf(true,true)bM(I,T)vim.api.nvim_win_set_buf(bN,I)end end;b.show_with_icons=function(I,L,a6)require('mini.pick').default_show(I,L,a6,{show_icons=true})end;b.choose_with_buflisted=function(T)local E=require('mini.pick')E.default_choose(T)local bN=E.get_picker_state().windows.target;local I=vim.api.nvim_win_get_buf(bN)vim.bo[I].buflisted=true end;b.diagnostic_make_compare=function(Z)if Z=='severity'then return function(aZ,a_)if aZ.severity<a_.severity then return true end;if aZ.severity>a_.severity then return false end;if aZ.path<a_.path then return true end;if aZ.path>a_.path then return false end;if aZ.lnum<a_.lnum then return true end;if aZ.lnum>a_.lnum then return false end;return aZ.col<a_.col end end;if Z=='path'then return function(aZ,a_)if aZ.path<a_.path then return true end;if aZ.path>a_.path then return false end;if aZ.severity<a_.severity then return true end;if aZ.severity>a_.severity then return false end;if aZ.lnum<a_.lnum then return true end;if aZ.lnum>a_.lnum then return false end;return aZ.col<a_.col end end;return nil end;b.validate_git=function(bI)if vim.fn.executable('git')==1 then return true end;local bL=string.format('`pickers.%s` requires executable `git`.',bI)b.error(bL)end;b.git_normalize_path=function(ac,bI)ac=type(ac)=='string'and ac or vim.fn.getcwd()if ac==''then b.error(string.format('Path in `%s` is empty.',bI))end;ac=b.full_path(ac)local bO,bP=vim.fn.isdirectory(ac)==1,vim.fn.filereadable(ac)==1;if not(bO or bP)then b.error('Path '..ac..' is not a valid path.')end;return ac,bO and'directory'or'file'end;b.git_get_repo_dir=function(ac,ae,bI)local an=ae=='directory'and ac or vim.fn.fnamemodify(ac,':h')local af=vim.fn.systemlist({'git','-C',an,'rev-parse','--show-toplevel'})[1]if vim.v.shell_error~=0 then local bL=string.format('`pickers.%s` could not find Git repo for %s.',bI,ac)b.error(bL)end;return af end;b.git_difflines_to_hunkitems=function(V,ap)local bQ='^diff %-%-git'local bR='^@@ %-%d+,?%d* %+(%d+),?%d* @@'local bS='^%+%+%+ b/(.*)$'local bT,bU,bV={},nil,false;local L={}for m,O in ipairs(V)do if O:find(bQ)~=nil then bV=false;bT={}end;local bW=O:match(bS)if bW~=nil and not bV then bU=bW end;local bX=O:match(bR)if bX~=nil then bV=true;local T={path=bU,lnum=tonumber(bX),header=vim.deepcopy(bT),hunk={}}table.insert(L,T)end;if bV then table.insert(L[#L].hunk,O)else table.insert(bT,O)end end;local bY=function(T,a7)if T.hunk[a7]:find('^[+-]')==nil then return false end;T.lnum=T.lnum+a7-2;return true end;for m,T in ipairs(L)do for a7=2,#T.hunk do if bY(T,a7)then break end end end;local bZ,a1,b_={},0,0;for a7,T in ipairs(L)do local c0,c1=T.hunk[1]:match('@@ (.-) @@ ?(.*)$')c0,c1=c0 or'',c1 or''bZ[a7]={T.path,c0,c1}a1=math.max(a1,vim.fn.strchars(T.path))b_=math.max(b_,vim.fn.strchars(c0))end;for a7,T in ipairs(L)do local c2=bZ[a7]local ac,c0=b.ensure_text_width(c2[1],a1),b.ensure_text_width(c2[2],b_)T.text=string.format('%s │ %s │ %s',ac,c0,c2[3])end;return L end;b.lsp_make_on_list=function(ad,D)local c3=function(L)if ad~='document_symbol'then L=vim.tbl_map(b.pick_prepend_position,L)end;table.sort(L,b.lsp_items_compare)return L end;local Q;if ad=='document_symbol'or ad=='workspace_symbol'then local E=b.validate_pick()Q=function(I,a5,a6)E.default_show(I,a5,a6)b.pick_clear_namespace(I,b.ns_id.pickers)for a7,T in ipairs(a5)do local bE=string.format('@%s',string.lower(T.kind or'unknown'))b.pick_highlight_line(I,a7,bE,199)end end end;return function(U)local L=U.items;for m,T in ipairs(U.items)do T.text,T.path=T.text or'',T.filename or nil end;L=c3(L)return b.pick_start(L,{source={name=string.format('LSP (%s)',ad),show=Q}},D)end end;b.lsp_items_compare=function(aZ,a_)local c4,c5=aZ.path or'',a_.path or''if c4<c5 then return true end;if c4>c5 then return false end;local c6,c7=aZ.lnum or 1,a_.lnum or 1;if c6<c7 then return true end;if c6>c7 then return false end;local c8,c9=aZ.col or 1,a_.col or 1;if c8<c9 then return true end;if c8>c9 then return false end;return tostring(aZ)<tostring(a_)end;b.list_get={quickfix=function()return vim.tbl_map(b.list_enhance_qf_loc,vim.fn.getqflist())end,location=function()return vim.tbl_map(b.list_enhance_qf_loc,vim.fn.getloclist(0))end,jump=function()local ca=vim.fn.getjumplist()[1]local aY,cb={},#ca;for a7,B in ipairs(ca)do B.col=B.col+1;aY[cb-a7+1]=B end;return aY end,change=function()local cc=vim.api.nvim_get_current_buf()local aY=vim.fn.getchangelist(cc)[1]for m,B in ipairs(aY)do B.bufnr=cc end;return aY end}b.list_enhance_qf_loc=function(T)if T.end_lnum==0 then T.end_lnum=nil end;if T.end_col==0 then T.end_col=nil end;if b.is_valid_buf(T.bufnr)then local cd=vim.api.nvim_buf_get_name(T.bufnr)if cd~=''then T.filename=cd end end;return T end;b.list_enhance_item=function(T)if vim.fn.filereadable(T.filename)==1 then T.path=T.filename end;return b.pick_prepend_position(T)end;b.explorer_make_items=function(ac,aa,ab)if vim.fn.isdirectory(ac)==0 then return{}end;local aY={{fs_type='directory',path=vim.fn.fnamemodify(ac,':h'),text='..'}}for m,ce in ipairs(vim.fn.readdir(ac))do local cf=string.format('%s/%s',ac,ce)local cg=vim.fn.isdirectory(cf)==1 and'directory'or'file'table.insert(aY,{fs_type=cg,path=cf,text=ce..(cg=='directory'and'/'or'')})end;return ab(vim.tbl_filter(aa,aY))end;b.explorer_default_sort=function(L)local aY=vim.tbl_map(function(B)return{fs_type=B.fs_type,path=B.path,text=B.text,is_dir=B.fs_type=='directory',lower_name=B.text:lower()}end,L)local a2=function(aZ,a_)if aZ.is_dir and not a_.is_dir then return true end;if not aZ.is_dir and a_.is_dir then return false end;return aZ.lower_name<a_.lower_name end;table.sort(aY,a2)return vim.tbl_map(function(B)return{fs_type=B.fs_type,path=B.path,text=B.text}end,aY)end;b.cli_run=function(aj,ch)ch=ch or function()end;local ci,cj=aj[1],vim.list_slice(aj,2,#aj)local c3,ck,cl=nil,vim.loop.new_pipe(),vim.loop.new_pipe()local cm={args=cj,stdio={nil,ck,cl}}c3=vim.loop.spawn(ci,cm,function()c3:close()end)b.cli_read_stream(ck,ch)b.cli_read_stream(cl,function(V)local bL=table.concat(V,'\n')if bL==''then return end;b.error(bL)end)end;b.cli_show_output=function(I,aj)local ch=vim.schedule_wrap(function(V)if not b.is_valid_buf(I)then return end;b.set_buflines(I,V)end)b.cli_run(aj,ch)end;b.cli_read_stream=function(cn,co)local cp={}local cq=function(cr,U)assert(not cr,cr)if U~=nil then return table.insert(cp,U)end;local V=vim.split(table.concat(cp),'\n')cp=nil;cn:close()co(V)end;cn:read_start(cq)end;b.is_valid_buf=function(I)return type(I)=='number'and vim.api.nvim_buf_is_valid(I)end;b.buf_ensure_loaded=function(I)if type(I)~='number'or vim.api.nvim_buf_is_loaded(I)then return end;local cs=vim.o.eventignore;vim.o.eventignore='BufEnter'pcall(vim.fn.bufload,I)vim.o.eventignore=cs end;b.buf_get_name=function(I)if not b.is_valid_buf(I)then return nil end;local M=vim.api.nvim_buf_get_name(I)if M~=''then M=vim.fn.fnamemodify(M,':~:.')end;return M end;b.set_buflines=function(I,V)vim.api.nvim_buf_set_lines(I,0,-1,false,V)end;b.error=function(bL)error(string.format('(mini.extra) %s',bL),0)end;b.is_valid_win=function(ct)return type(ct)=='number'and vim.api.nvim_win_is_valid(ct)end;b.ensure_text_width=function(a3,cu)local cv=vim.fn.strchars(a3)if cv<=cu then return a3 ..string.rep(' ',cu-cv)end;return'…'..vim.fn.strcharpart(a3,cv-cu+1,cu-1)end;b.full_path=function(ac)return vim.fn.fnamemodify(ac,':p'):gsub('(.)/$','%1')end;b.short_path=function(ac,a9)a9=a9 or vim.fn.getcwd()if not vim.startswith(ac,a9)then return vim.fn.fnamemodify(ac,':~')end;local aY=ac:sub(a9:len()+1):gsub('^/+',''):gsub('/+$','')return aY end;return a
