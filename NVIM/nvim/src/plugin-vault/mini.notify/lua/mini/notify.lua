local a={}local b={}a.setup=function(c)_G.MiniNotify=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()end;a.config={content={format=nil,sort=nil},lsp_progress={enable=true,duration_last=1000},window={config={},winblend=25}}a.make_notify=function(d)local e={}for f,g in pairs(vim.log.levels)do e[g]=f end;local h={ERROR={duration=5000,hl_group='DiagnosticError'},WARN={duration=5000,hl_group='DiagnosticWarn'},INFO={duration=5000,hl_group='DiagnosticInfo'},DEBUG={duration=0,hl_group='DiagnosticHint'},TRACE={duration=0,hl_group='DiagnosticOk'},OFF={duration=0,hl_group='MiniNotifyNormal'}}d=vim.tbl_deep_extend('force',h,d or{})for i,j in pairs(d)do if h[i]==nil then b.error('Keys should be log level names.')end;if type(j)~='table'then b.error('Level data should be table.')end;if type(j.duration)~='number'then b.error('`duration` in level data should be number.')end;if type(j.hl_group)~='string'then b.error('`hl_group` in level data should be string.')end end;return function(k,l)l=l or vim.log.levels.INFO;local m=e[l]if m==nil then b.error('Only valid values of `vim.log.levels` are supported.')end;local n=d[m]if n.duration<=0 then return end;local o=a.add(k,m,n.hl_group)vim.defer_fn(function()a.remove(o)end,n.duration)end end;a.add=function(k,l,p)b.validate_msg(k)l=l or'INFO'b.validate_level(l)p=p or'MiniNotifyNormal'b.validate_hl_group(p)local q=b.get_timestamp()local r={msg=k,level=l,hl_group=p,ts_add=q,ts_update=q}local s=#b.history+1;b.history[s],b.active[s]=r,r;a.refresh()return s end;a.update=function(o,t)local u=b.active[o]if u==nil then b.error('`id` is not an identifier of active notification.')end;if type(t)~='table'then b.error('`new_data` should be table.')end;if t.msg~=nil then b.validate_msg(t.msg)end;if t.level~=nil then b.validate_level(t.level)end;if t.hl_group~=nil then b.validate_hl_group(t.hl_group)end;u.msg=t.msg or u.msg;u.level=t.level or u.level;u.hl_group=t.hl_group or u.hl_group;u.ts_update=b.get_timestamp()a.refresh()end;a.remove=function(o)local u=b.active[o]if u==nil then return end;u.ts_remove=b.get_timestamp()b.active[o]=nil;a.refresh()end;a.clear=function()local q=b.get_timestamp()for o,v in pairs(b.active)do b.active[o].ts_remove=q end;b.active={}a.refresh()end;a.refresh=function()if b.is_disabled()then return b.window_close()end;local w=vim.deepcopy(vim.tbl_values(b.active))local x=b.get_config().content;local y=vim.is_callable(x.sort)and x.sort or a.default_sort;w=y(w)if not b.is_notification_array(w)then b.error('Output of `content.sort` should be notification array.')end;if#w==0 then return b.window_close()end;local z=vim.is_callable(x.format)and x.format or a.default_format;w=b.notif_apply_format(w,z)local A=b.cache.buf_id;if not b.is_valid_buf(A)then A=b.buffer_create()end;b.buffer_refresh(A,w)local B=b.cache.win_id;if not(b.is_valid_win(B)and b.is_win_in_tabpage(B))then b.window_close()B=b.window_open(A)else local C=b.window_compute_config(A)vim.api.nvim_win_set_config(B,C)end;vim.cmd('redraw')b.cache.buf_id,b.cache.win_id=A,B end;a.get=function(o)return vim.deepcopy(b.history[o])end;a.get_all=function()return vim.deepcopy(b.history)end;a.show_history=function()local x=b.get_config().content;local w=a.get_all()table.sort(w,function(D,E)return D.ts_update<E.ts_update end)local z=vim.is_callable(x.format)and x.format or a.default_format;w=b.notif_apply_format(w,z)local A;for v,o in ipairs(vim.api.nvim_list_bufs())do if vim.bo[o].filetype=='mininotify-history'then A=o end end;if A==nil then A=vim.api.nvim_create_buf(true,true)vim.bo[A].filetype='mininotify-history'end;b.buffer_refresh(A,w)vim.api.nvim_win_set_buf(0,A)end;a.default_format=function(u)local F=vim.fn.strftime('%H:%M:%S',math.floor(u.ts_update))return string.format('%s â”‚ %s',F,u.msg)end;a.default_sort=function(w)local G=vim.deepcopy(w)table.sort(G,b.notif_compare)return G end;b.default_config=a.config;b.active={}b.history={}b.lsp_progress={}b.level_priority={ERROR=6,WARN=5,INFO=4,DEBUG=3,TRACE=2,OFF=1}b.ns_id={highlight=vim.api.nvim_create_namespace('MiniNotifyHighlight')}b.cache={buf_id=nil,win_id=nil}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({content={c.content,'table'},lsp_progress={c.lsp_progress,'table'},window={c.window,'table'}})local H=function(I)return type(I)=='table'or vim.is_callable(I)end;vim.validate({['content.format']={c.content.format,'function',true},['content.sort']={c.content.sort,'function',true},['lsp_progress.enable']={c.lsp_progress.enable,'boolean'},['lsp_progress.duration_last']={c.lsp_progress.duration_last,'number'},['window.config']={c.window.config,H,'table or callable'},['window.winblend']={c.window.winblend,'number'}})return c end;b.apply_config=function(c)a.config=c;if c.lsp_progress.enable then vim.schedule(function()if vim.lsp.handlers['$/progress before mini.notify']==nil then vim.lsp.handlers['$/progress before mini.notify']=vim.lsp.handlers['$/progress']end;vim.lsp.handlers['$/progress']=b.lsp_progress_handler end)end end;b.create_autocommands=function(c)local J=vim.api.nvim_create_augroup('MiniNotify',{})local K=function(L,M,N,O)vim.api.nvim_create_autocmd(L,{group=J,pattern=M,callback=N,desc=O})end;K('TabEnter','*',function()a.refresh()end,'Refresh in notifications in new tabpage')end;b.create_default_hl=function()local P=function(Q,d)d.default=true;vim.api.nvim_set_hl(0,Q,d)end;P('MiniNotifyBorder',{link='FloatBorder'})P('MiniNotifyNormal',{link='NormalFloat'})P('MiniNotifyTitle',{link='FloatTitle'})end;b.is_disabled=function()return vim.g.mininotify_disable==true or vim.b.mininotify_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.mininotify_config or{},c or{})end;b.lsp_progress_handler=function(R,S,T,c)if vim.is_callable(vim.lsp.handlers['$/progress before mini.notify'])then vim.lsp.handlers['$/progress before mini.notify'](R,S,T,c)end;local U=b.get_config().lsp_progress;if not U.enable then return end;if R~=nil then return vim.notify(vim.inspect(R),vim.log.levels.ERROR)end;if not(type(S)=='table'and type(S.value)=='table')then return end;local V=S.value;local W=vim.lsp.get_client_by_id(T.client_id).name;if type(W)~='string'then W=string.format('LSP[id=%s]',T.client_id)end;local A=T.bufnr or'nil'local X=A..W..(S.token or'')local Y=b.lsp_progress[X]or{}Y.percentage=V.percentage or Y.percentage or 0;if V.kind=='end'then b.lsp_progress[X]=nil;local Z=math.max(U.duration_last,0)vim.defer_fn(function()a.remove(Y.notif_id)end,Z)return end;if V.kind=='begin'then Y.title=V.title end;local k=string.format('%s: %s %s (%s%%)',W,Y.title or'',V.message or'',Y.percentage)if Y.notif_id==nil then Y.notif_id=a.add(k)else a.update(Y.notif_id,{msg=k})end;b.lsp_progress[X]=Y end;b.buffer_create=function()local A=vim.api.nvim_create_buf(false,true)vim.bo[A].filetype='mininotify'return A end;b.buffer_refresh=function(A,w)local _=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(A,_,0,-1)vim.api.nvim_buf_set_lines(A,0,-1,true,{})local a0,a1={},{}for v,u in ipairs(w)do local a2=vim.split(u.msg,'\n')for v,a3 in ipairs(a2)do table.insert(a0,a3)end;table.insert(a1,{group=u.hl_group,from_line=#a0-#a2+1,to_line=#a0})end;vim.api.nvim_buf_set_lines(A,0,-1,true,a0)local a4={end_col=0,hl_eol=true,hl_mode='combine'}for v,a5 in ipairs(a1)do a4.end_row,a4.hl_group=a5.to_line,a5.group;vim.api.nvim_buf_set_extmark(A,_,a5.from_line-1,0,a4)end end;b.buffer_default_dimensions=function(A)local a6=vim.tbl_map(vim.fn.strdisplaywidth,vim.api.nvim_buf_get_lines(A,0,-1,true))local a7=1;for v,a8 in ipairs(a6)do a7=math.max(a7,a8)end;a7=math.min(a7,math.floor(0.382*vim.o.columns))local a9=0;for v,a8 in ipairs(a6)do a9=a9+math.floor(math.max(a8-1,0)/a7)+1 end;return a7,a9 end;b.window_open=function(A)local c=b.window_compute_config(A,true)local B=vim.api.nvim_open_win(A,false,c)vim.wo[B].foldenable=false;vim.wo[B].wrap=true;vim.wo[B].winblend=b.get_config().window.winblend;vim.wo[B].winhighlight='NormalFloat:MiniNotifyNormal,FloatBorder:MiniNotifyBorder'..(vim.fn.has('nvim-0.8')==1 and',FloatTitle:MiniNotifyTitle'or'')return B end;b.window_compute_config=function(A,aa)local ab=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local ac=vim.o.laststatus>0;local ad=vim.o.lines-vim.o.cmdheight-(ab and 1 or 0)-(ac and 1 or 0)local ae=vim.o.columns;local af={relative='editor',style='minimal',noautocmd=aa,zindex=999}af.anchor,af.col,af.row='NE',vim.o.columns,ab and 1 or 0;af.width,af.height=b.buffer_default_dimensions(A)af.border='single'af.focusable=false;local ag=b.get_config().window.config;if vim.is_callable(ag)then ag=ag(A)end;local c=vim.tbl_deep_extend('force',af,ag or{})local ah=c.border=='none'and 0 or 2;c.height=math.min(c.height,ad-ah)c.width=math.min(c.width,ae-ah)return c end;b.window_close=function()if b.is_valid_win(b.cache.win_id)then vim.api.nvim_win_close(b.cache.win_id,true)end;b.cache.win_id=nil end;b.validate_msg=function(I)if type(I)~='string'then b.error('`msg` should be string.')end end;b.validate_level=function(I)if vim.log.levels[I]==nil then b.error('`level` should be key of `vim.log.levels`.')end end;b.validate_hl_group=function(I)if type(I)~='string'then b.error('`hl_group` should be string.')end end;b.is_notification=function(I)return type(I)=='table'and type(I.msg)=='string'and vim.log.levels[I.level]~=nil and type(I.hl_group)=='string'and type(I.ts_add)=='number'and type(I.ts_update)=='number'and(I.ts_remove==nil or type(I.ts_remove)=='number')end;b.is_notification_array=function(I)if not vim.tbl_islist(I)then return false end;for v,ai in ipairs(I)do if not b.is_notification(ai)then return false end end;return true end;b.notif_apply_format=function(w,z)for v,u in ipairs(w)do local G=z(u)if type(G)~='string'then b.error('Output of `content.format` should be string.')end;u.msg=G end;return w end;b.notif_compare=function(D,E)local aj,ak=b.level_priority[D.level],b.level_priority[E.level]return aj>ak or aj==ak and D.ts_update>E.ts_update end;b.error=function(k)error(string.format('(mini.notify) %s',k),0)end;b.is_valid_buf=function(A)return type(A)=='number'and vim.api.nvim_buf_is_valid(A)end;b.is_valid_win=function(B)return type(B)=='number'and vim.api.nvim_win_is_valid(B)end;b.is_win_in_tabpage=function(B)return vim.api.nvim_win_get_tabpage(B)==vim.api.nvim_get_current_tabpage()end;b.get_timestamp=function()local al,am=vim.loop.gettimeofday()return al+0.000001*am end;return a
