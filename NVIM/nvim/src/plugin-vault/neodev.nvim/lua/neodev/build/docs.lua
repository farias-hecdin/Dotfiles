local a=require("neodev.util")local b=require("neodev.build.annotations")local c={}c.function_pattern="^(%S-%([^(]-%))"c.function_signature_pattern="^(%S-)%(([^(]-)%)"c.vim_type_map={number="number",float="float",string="string",list="any[]",any="any",funcref="fun()",dict="table<string, any>",none="nil",set="boolean",boolean="boolean"}function c.read(d)local e=vim.fn.expand("$VIMRUNTIME/doc")local f=e.."/"..d..".txt"local g={}for h in io.lines(f)do table.insert(g,h)end;return g end;function c.strip_tags(i)local j={}return i:gsub("(%*%S-%*)",function(k)k=k:sub(2,-2)table.insert(j,k)return""end):gsub("%s*$",""),j end;function c.trim(l)return l:gsub("^%s*\n",""):gsub("\n+$","")end;function c.parse(d,m)m=m or{}m.continuation=m.continuation or"^[%s<>]"m.context=m.context or 1;local j={}local n={}local o={}local p={}local q={}local r={}local function s()if#q>0 then table.insert(r,{tags=vim.deepcopy(o),text=c.trim(table.concat(q,"\n")),match=vim.deepcopy(p)})end;q={}o={}end;local g=c.read(d)for t,h in ipairs(g)do h,n=c.strip_tags(h)if#n>0 then j=n end;local u=h;for v=1,m.context do if g[t+v]then u=u.."\n"..g[t+v]end end;local w={u:match(m.pattern)}if#w>0 then s()p=w;o=vim.deepcopy(j)table.insert(q,h)elseif#q>0 and(h:find(m.continuation)or h:find("^%s*$"))then table.insert(q,h)else s()end end;return r end;function c.parse_signature(h)local d,x,y=h:match(c.function_signature_pattern.."(.*)")if d then local z=x:find("%[")x=x:gsub("%[","")x=x:gsub("%]","")x=x:gsub("\n"," ")x=x:gsub("\t"," ")local A={}local B={}local C=0;local D=0;local E=""while C do C,D,E=x:find("{?([^ ,{}]+)}?",D+1)if C then local F=z and C>=z and true or nil;if E:sub(1,1)=="*"then F=true;E=E:sub(2)end;E=E:gsub("%-","_")if E:find("^%d+$")then E="p"..E end;local G=E;local v=1;while B[E]do E=G..v;v=v+1 end;B[E]=true;table.insert(A,{name=E,optional=F})end end;return{name=d,params=A,doc=c.trim(y)}end end;function c.options()local r={}local H="^'(%S-)'%s*"local I=c.parse("options",{pattern=H})for J,K in ipairs(I)do local d=K.match[1]local y=K.text:gsub("'(%S-)'","`'%1'` ")r[d]=y end;return r end;function c.parse_functions(y,m)m=m or{}local r={}local L=c.parse(y,{pattern=c.function_pattern,context=2})for J,M in ipairs(L)do local l=M.text;for J,k in ipairs(M.tags)do if k:find("vim.*%(%)$")then k=k:sub(1,-3)local d=l:match(c.function_signature_pattern)if k:sub(-#d)==d then l=l:gsub("^%S-%(",k.."(")end end end;local N=c.parse_signature(l)if N then local d=N.name;if m.name then d=m.name(d)end;if d and(m.filter==nil or m.filter(d))then r[d]={name=d,params=N.params,doc=N.doc,["return"]={}}end end end;return r end;function c.lua()return c.parse_functions("lua",{filter=function(d)return not b.is_lua(d)end})end;function c.luv()local r=c.parse_functions("luvref",{filter=function(d)return not b.is_lua(d)end,name=function(d)local r=d:gsub("^uv%.","vim.loop.")return r end})a.for_each(r,function(J,M)local O=M.doc:match("%s*Returns: (.*)\n")if not O then O=M.doc:match("%s*Returns %(sync version%): (.*)\n")end;local P={}if O then for Q in O:gmatch("`(.-)`")do if Q=="nil"or Q=="fail"then P.optional=true elseif not P.type then P.type=Q:find("userdata")and"userdata"or Q end end end;if not vim.tbl_isempty(P)then M["return"]={P}end end)return r end;function c.commands()local R="|:%S-|%s+:([a-z]%S-)%s+(.*)"local S=c.parse("index",{pattern=R,context=0,continuation="^%s+"})local r={}for J,T in ipairs(S)do if vim.tbl_contains(T.tags,"ex-cmd-index")then local U=T.match[1]local V=T.match[2]local W=U:find("%[")if W then r[U:sub(1,W-1)]=V;U=U:gsub("[%[%]]","")end;r[U]=V end end;return r end;function c.functions()local S=c.parse("builtin",{pattern=c.function_pattern,context=2})local X={}for J,T in ipairs(S)do if vim.tbl_contains(T.tags,"builtin-function-list")then local l=T.text;l=l:gsub(c.function_pattern.."%s+","%1\t")l=l:gsub("%s%s+","\t")local d,Y,P=l:match(c.function_signature_pattern.."\t(%w+)")if d then P=P:lower()if c.vim_type_map[P]then P=c.vim_type_map[P]if P~="nil"then X["vim.fn."..d]=P end else a.debug("Unknown retval: "..P)end else a.error("Couldnt parse builtin-function-list: "..vim.inspect(T))end end end;local r=c.parse_functions("builtin",{filter=function(d)d=d:match("vim%.fn%.(.*)")if d:find("%.")then return false end;return d and vim.fn.exists("*"..d)==1 end,name=function(d)return"vim.fn."..d end})for Z,M in pairs(r)do if X[Z]then M["return"]={{type=X[Z]:lower()}}end end;return r end;return c
