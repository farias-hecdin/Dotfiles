local a={}local b={}local c=vim.uv or vim.loop;local d='lsp_zero_format'local e=10000;function a.format_on_save(f)local g=vim.api.nvim_create_autocmd;local h=vim.api.nvim_create_augroup;local i=h(d,{clear=true})local j=h('lsp_zero_format_setup',{clear=true})f=f or{}local k=f.servers or{}local l=f.format_opts or{}if l.async then b.setup_async_format({servers=k,format_opts=l.formatting_options,setup_augroup=j,format_augroup=i,timeout_ms=l.timeout_ms or e})return end;local m=function(n)local o=vim.tbl_get(n,'data','client_id')if o==nil then return end;local p=vim.lsp.get_client_by_id(o)local q=k[p.name]or{}if type(q)=='string'then q={k[p.name]}end;if q==nil or vim.tbl_contains(q,vim.bo.filetype)==false then return end;vim.api.nvim_clear_autocmds({group=d,buffer=n.buf})local r={async=false,id=p.id,bufnr=n.buf,timeout_ms=l.timeout_ms or e,formatting_options=l.formatting_options}local s=function()local t=vim.b.lsp_zero_enable_autoformat;local u=t==nil or t==1 or t==true;if not u then return end;vim.lsp.buf.format(r)end;local v=string.format('Format buffer with %s',p.name)g('BufWritePre',{group=i,buffer=n.buf,desc=v,callback=s})end;g('LspAttach',{group=j,desc='Enable format on save',callback=m})end;function a.buffer_autoformat(p,w,f)local g=vim.api.nvim_create_autocmd;local h=vim.api.nvim_create_augroup;local i=h(d,{clear=false})f=f or{}p=p or{}w=w or vim.api.nvim_get_current_buf()vim.api.nvim_clear_autocmds({group=d,buffer=w})if vim.b.lsp_zero_enable_autoformat==nil then vim.b.lsp_zero_enable_autoformat=1 end;local r={async=false,id=p.id,name=p.name,bufnr=w,timeout_ms=f.timeout_ms or e,formatting_options=f.formatting_options}local s=function()local t=vim.b.lsp_zero_enable_autoformat;local u=t==1 or t==true;if not u then return end;vim.lsp.buf.format(r)end;local v='Format current buffer'if p.name then v=string.format('Format buffer with %s',p.name)end;g('BufWritePre',{group=i,buffer=w,desc=v,callback=s})end;function a.async_autoformat(p,w,f)if type(p)~='table'or p.id==nil then return end;if p.supports_method('textDocument/formatting')==false then return end;f=f or{}local g=vim.api.nvim_create_autocmd;local h=vim.api.nvim_create_augroup;if vim.b.lsp_zero_enable_autoformat==nil then vim.b.lsp_zero_enable_autoformat=1 end;local i=h(d,{clear=false})w=w or vim.api.nvim_get_current_buf()local x=f.formatting_options or{}local y=f.timeout_ms or e;vim.api.nvim_clear_autocmds({group=d,buffer=w})local v='Request format to %s'local z=p.name or string.format('Client %s',p.id)g('BufWritePost',{group=i,desc=v:format(z),buffer=w,callback=function(A)b.request_format(p.id,A.buf,x,y)end})end;function a.format_mapping(B,f)if f==nil or B==nil then return end;local g=vim.api.nvim_create_autocmd;local h=vim.api.nvim_create_augroup;local i=h('lsp_zero_format_mapping',{clear=true})local k=f.servers or{}local C=f.mode or{'n','x'}local l=f.format_opts or{}if vim.tbl_isempty(k)then return end;local m=function(n)local o=vim.tbl_get(n,'data','client_id')if o==nil then return end;local p=vim.lsp.get_client_by_id(o)local q=k[p.name]if type(q)=='string'then q={k[p.name]}end;if q==nil or vim.tbl_contains(q,vim.bo.filetype)==false then return end;local r={id=p.id,bufnr=n.buf,async=l.async==true or false,timeout_ms=l.timeout_ms or e,formatting_options=l.formatting_options}local D=function()vim.lsp.buf.format(r)end;local v=string.format('Format buffer with %s',p.name)vim.keymap.set(C,B,D,{buffer=n.buf,desc=v})end;local v=string.format('Format buffer with %s',B)g('LspAttach',{group=i,desc=v,callback=m})end;function a.check(E)local F=vim.api.nvim_get_current_buf()local p=vim.lsp.get_active_clients({bufnr=F,name=E})[1]if p==nil then local G='[lsp-zero] %s is not active'vim.notify(G:format(E),vim.log.levels.WARN)return end;if vim.lsp.buf_is_attached(F,p.id)==false then local G='[lsp-zero] %s is not active in the current buffer'vim.notify(G:format(E),vim.log.levels.WARN)return end;if p.supports_method('textDocument/formatting')==false then local G='[lsp-zero] %s does not support textDocument/formatting method'vim.notify(G:format(E),vim.log.levels.WARN)return end;local G='[lsp-zero] %s has formatting capabilities'vim.notify(G:format(E))end;function b.setup_async_format(f)local g=vim.api.nvim_create_autocmd;local m=function(n)local o=vim.tbl_get(n,'data','client_id')if o==nil then return end;local p=vim.lsp.get_client_by_id(o)local q=f.servers[p.name]or{}if type(q)=='string'then q={f.servers[p.name]}end;if q==nil or vim.tbl_contains(q,vim.bo.filetype)==false then return end;if p.supports_method('textDocument/formatting')==false then return end;vim.api.nvim_clear_autocmds({group=d,buffer=n.buf})if vim.b.lsp_zero_enable_autoformat==nil then vim.b.lsp_zero_enable_autoformat=1 end;g('BufWritePost',{group=f.format_augroup,desc=string.format('Request format to %s',p.name),buffer=n.buf,callback=function(A)b.request_format(o,A.buf,f.format_opts,f.timeout_ms)end})end;g('LspAttach',{group=f.setup_augroup,desc='Setup non-blocking format on save',callback=m})end;function b.request_format(o,F,l,y)if vim.b.lsp_zero_format_progress==1 then local G='[lsp-zero] A formatting request is already in progress.'vim.notify(G,vim.log.levels.WARN)return end;local t=vim.b.lsp_zero_enable_autoformat;local u=t==1 or t==true;if not u then return end;if vim.b.lsp_zero_changedtick==vim.b.changedtick then return end;if y<=0 then y=e end;vim.b.lsp_zero_changedtick=vim.b.changedtick;vim.b.lsp_zero_format_progress=1;local H=c.new_timer()local p=vim.lsp.get_client_by_id(o)local I=p.offset_encoding;local z=p.name or string.format('Client %s',p.id)local J=vim.schedule_wrap(function()H:stop()H:close()H=nil;b.format_cleanup(F,z)end)H:start(y,0,J)local K=function(L,M,N)if H==nil or H:get_due_in()==0 then return end;H:stop()H:close()H=nil;N.userdata={client_name=z,encoding=I}b.format_handler(L,M,N)end;local O=vim.lsp.util.make_formatting_params(l)p.request('textDocument/formatting',O,K,F)end;function b.format_handler(L,M,N)local P=vim.api.nvim_buf_get_var;local Q=vim.api.nvim_buf_set_var;local R='lsp_zero_format_progress'local S='lsp_zero_changedtick'local F=N.bufnr;if vim.fn.bufexists(F)==0 then return end;if L~=nil then vim.notify('[lsp-zero] Format request failed.',vim.log.levels.WARN)Q(F,R,0)return end;if M==nil then local G='[lsp-zero] %s could not format file.'vim.notify(G:format(N.userdata.client_name),vim.log.levels.WARN)Q(F,R,0)return end;local T=P(F,'changedtick')if not vim.api.nvim_buf_is_loaded(F)then vim.fn.bufload(F)Q(F,S,T)end;local U=P(F,S)if T~=U then local G='[lsp-zero] Format canceled. Buffer was modified after request.'vim.notify(G,vim.log.levels.WARN)Q(F,R,0)return end;vim.lsp.util.apply_text_edits(M,F,N.userdata.encoding)Q(F,R,0)if F==vim.api.nvim_get_current_buf()then pcall(vim.api.nvim_command,'noautocmd update')Q(F,S,vim.b.changedtick)end end;function b.format_cleanup(F,z)if vim.fn.bufexists(F)==0 then return end;local P=vim.api.nvim_buf_get_var;local Q=vim.api.nvim_buf_set_var;Q(F,'lsp_zero_format_progress',0)local G='[lsp-zero] Format request timeout. %s is taking too long to respond.'vim.notify(G:format(z),vim.log.levels.WARN)local V=P(F,'lsp_zero_changedtick')local T=P(F,'changedtick')if V==T then Q(F,'lsp_zero_changedtick',V-1)end end;return a
