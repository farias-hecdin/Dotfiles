local a={default_config=false,common_attach=nil,has_lspconfig=false,cmp_capabilities=false,setup_done=false}local b={}local c={exclude={},capabilities=nil,omit_keys={n={},i={},x={}}}function a.extend_lspconfig()if a.setup_done then return end;local d=require('lspconfig.util')d.default_config.capabilities=b.set_capabilities()d.on_setup=d.add_hook_after(d.on_setup,function(e,f)b.ensure_capabilities(e,f)if type(a.default_config)=='table'then b.apply_global_config(e,f,a.default_config)end end)a.has_lspconfig=true;a.setup_done=true end;function a.setup(g,h)if type(g)~='string'or c.exclude[g]then return false end;if type(h)~='table'then h={}end;a.skip_setup(g)local i=require('lspconfig')[g]if i.manager then return false end;local j=pcall(i.setup,h)if not j then local k='[lsp-zero] Failed to setup %s.\n'..'Configure this server using lspconfig to get the full error message.'vim.notify(k:format(g),vim.log.levels.WARN)return false end;return true end;function a.default_keymaps(h)local l=h.buffer or vim.api.nvim_get_current_buf()local m=true;local n={}if type(h.preserve_mappings)=='boolean'then m=h.preserve_mappings end;if type(h.exclude)=='table'then n=h.exclude end;local o=function(p,q,r)if vim.tbl_contains(n,q)then return end;if m and b.map_check(p,q)then return end;local s={buffer=l}vim.keymap.set(p,q,r,s)end;o('n','K','<cmd>lua vim.lsp.buf.hover()<cr>')o('n','gd','<cmd>lua vim.lsp.buf.definition()<cr>')o('n','gD','<cmd>lua vim.lsp.buf.declaration()<cr>')o('n','gi','<cmd>lua vim.lsp.buf.implementation()<cr>')o('n','go','<cmd>lua vim.lsp.buf.type_definition()<cr>')o('n','gr','<cmd>lua vim.lsp.buf.references()<cr>')o('n','gs','<cmd>lua vim.lsp.buf.signature_help()<cr>')o('n','<F2>','<cmd>lua vim.lsp.buf.rename()<cr>')o('n','<F3>','<cmd>lua vim.lsp.buf.format({async = true})<cr>')o('x','<F3>','<cmd>lua vim.lsp.buf.format({async = true})<cr>')o('n','<F4>','<cmd>lua vim.lsp.buf.code_action()<cr>')if vim.lsp.buf.range_code_action then o('x','<F4>','<cmd>lua vim.lsp.buf.range_code_action()<cr>')else o('x','<F4>','<cmd>lua vim.lsp.buf.code_action()<cr>')end;o('n','gl','<cmd>lua vim.diagnostic.open_float()<cr>')o('n','[d','<cmd>lua vim.diagnostic.goto_prev()<cr>')o('n',']d','<cmd>lua vim.diagnostic.goto_next()<cr>')end;function a.set_sign_icons(h)h=h or{}if vim.diagnostic.count then local t=vim.diagnostic.severity;local u={[t.ERROR]='error',[t.WARN]='warn',[t.INFO]='info',[t.HINT]='hint'}local v={}for w,x in pairs(u)do if type(h[x])=='string'then v[w]=h[x]end end;vim.diagnostic.config({signs={text=v}})return end;local y=function(z)if h[z.name]==nil then return end;vim.fn.sign_define(z.hl,{texthl=z.hl,text=h[z.name],numhl=''})end;y({name='error',hl='DiagnosticSignError'})y({name='warn',hl='DiagnosticSignWarn'})y({name='hint',hl='DiagnosticSignHint'})y({name='info',hl='DiagnosticSignInfo'})end;function a.nvim_workspace(h)local A=vim.split(package.path,';')table.insert(A,'lua/?.lua')table.insert(A,'lua/?/init.lua')local e={settings={Lua={telemetry={enable=false},runtime={version='LuaJIT',path=A},diagnostics={globals={'vim'}},workspace={checkThirdParty=false,library={vim.fn.expand('$VIMRUNTIME/lua'),vim.fn.stdpath('config')..'/lua'}}}}}return vim.tbl_deep_extend('force',e,h or{})end;function a.client_capabilities()if c.capabilities==nil then if a.has_lspconfig==false then local j=pcall(require,'lspconfig')a.has_lspconfig=j end;return b.set_capabilities()end;return c.capabilities end;function a.set_buf_commands(B)local C=vim.api.nvim_buf_create_user_command;local D=function(E)if#E.fargs>2 then vim.notify('Too many arguments for LspZeroFormat',vim.log.levels.ERROR)return end;local F=E.fargs[1]local G=E.fargs[2]if G and G:find('timeout=')then G=G:gsub('timeout=','')G=tonumber(G)end;if F and F:find('timeout=')then G=F:gsub('timeout=','')G=tonumber(G)F=E.fargs[2]end;vim.lsp.buf.format({async=E.bang,timeout_ms=G,name=F})end;C(B,'LspZeroFormat',D,{range=true,bang=true,nargs='*'})C(B,'LspZeroWorkspaceRemove','lua vim.lsp.buf.remove_workspace_folder()',{})end;function a.skip_setup(g)if type(g)=='string'then c.exclude[g]=true end end;function a.has_configs()local H=require('lspconfig.configs')for I,J in pairs(H)do if J.manager then return true end end;return false end;function a.highlight_symbol(K,B)if K==nil or K.supports_method('textDocument/documentHighlight')==false then return end;if B==nil or B==0 then B=vim.api.nvim_get_current_buf()end;local L=vim.api.nvim_create_autocmd;local M=vim.api.nvim_create_augroup('lsp_zero_highlight_symbol',{clear=false})vim.api.nvim_clear_autocmds({buffer=B,group=M})L({'CursorHold','CursorHoldI'},{group=M,buffer=B,callback=vim.lsp.buf.document_highlight})L({'CursorMoved','CursorMovedI'},{group=M,buffer=B,callback=vim.lsp.buf.clear_references})end;function b.set_capabilities(N)if c.capabilities==nil then local O={}local P={}if a.has_lspconfig then P=require('lspconfig.util').default_config.capabilities else P=vim.lsp.protocol.make_client_capabilities()end;local j,Q=pcall(require,'cmp_nvim_lsp')if j then a.cmp_capabilities=true;O=Q.default_capabilities()end;c.capabilities=vim.tbl_deep_extend('force',P,O,N or{})return c.capabilities end;if N==nil then return c.capabilities end;return vim.tbl_deep_extend('force',c.capabilities,N)end;function b.ensure_capabilities(R,f)local S=require('lspconfig.configs')[R.name]if type(S)~='table'then return end;local T=function(U)return vim.tbl_get(U,'capabilities','textDocument','completion')end;local V=vim.tbl_get(S,'document_config','default_config')local W=T(V or{})if V==nil or W==nil then return end;local X=T(f)or{}local Y=b.set_capabilities().textDocument.completion;local Z=vim.tbl_deep_extend('force',W,Y,X)R.capabilities.textDocument.completion=Z end;function b.map_check(_,q)local a0=c.omit_keys[_][q]if a0==nil then local a1=vim.fn.mapcheck(q,_)==''c.omit_keys[_][q]=not a1;return not a1 end;return a0 end;function b.apply_global_config(e,f,V)local a2=vim.deepcopy(V)b.tbl_merge(a2,f)for a3,U in pairs(a2)do if b.is_keyval(U)and b.is_keyval(e[a3])then b.tbl_merge(e[a3],U)elseif a3=='on_new_config'and e[a3]and e[a3]~=a2[a3]then local a4=e[a3]e[a3]=b.compose_fn(a4,a2[a3])else e[a3]=U end end end;function b.compose_fn(a5,a6)return function(...)a5(...)a6(...)end end;function b.is_keyval(a7)return type(a7)=='table'and not vim.tbl_islist(a7)end;function b.tbl_merge(a8,a9)for aa,a7 in pairs(a9)do if b.is_keyval(a8[aa])and b.is_keyval(a7)then b.tbl_merge(a8[aa],a7)else a8[aa]=a7 end end end;return a
