local a={}local b={}local c='lsp_zero_completion'local d='[[:keyword:]]'local e=vim.fn.match;local f=vim.fn.pumvisible;local g=vim.api.nvim_create_augroup;local h=vim.api.nvim_create_autocmd;local i=function(j)return vim.api.nvim_replace_termcodes(j,true,false,true)end;local k={omni='<C-x><C-o>',buffer='<C-x><C-n>',next_item='<Down>',prev_item='<Up>',confirm='<C-y>',abort='<C-e>',tab='<Tab>'}local l=i(k.omni)local m=i(k.buffer)function a.setup(n)if type(n)~='table'then n={}end;local o={tabcomplete=false,autocomplete=false,trigger=nil,use_fallback=false,verbose=false,preselect=true,keyword_pattern=nil,select_behavior='select',update_on_delete=false,mapping={confirm=nil,abort=nil,next_item=nil,prev_item=nil}}local p=vim.tbl_deep_extend('force',o,n)local q=g('lsp_zero_omnifunc',{clear=true})local r=p.mapping;if p.preselect==false then vim.opt.completeopt:append('noselect')end;if p.verbose==false then vim.opt.shortmess:append('c')end;if type(p.keyword_pattern)=='string'then d=p.keyword_pattern end;if p.select_behavior=='select'then vim.opt.completeopt:append('noinsert')elseif p.select_behavior=='insert'then vim.opt.completeopt:remove('noinsert')k.next_item='<C-n>'k.prev_item='<C-p>'end;vim.opt.completeopt:remove('preview')vim.opt.completeopt:append('menu')vim.opt.completeopt:append('menuone')b.keymap(r.next_item,k.next_item)b.keymap(r.prev_item,k.prev_item)b.keymap(r.abort,k.abort)if type(r.confirm)=='string'then local s=string.lower(r.confirm)if not vim.tbl_contains({'<enter>','<cr>'},s)then b.keymap(r.confirm,k.confirm)end end;local t=p.autocomplete;local u=p.tabcomplete;local v=p.trigger;local w=p.update_on_delete;if t then vim.opt.completeopt:append('noinsert')end;if p.use_fallback then if t then a.autocomplete_fallback()end;if u then a.tab_complete_fallback()end;if v then a.toggle_menu_fallback(v)end end;h('LspAttach',{group=q,desc='setup LSP omnifunc completion',callback=function(x)if t then a.autocomplete(x.buf)end;if u then a.tab_complete(x.buf)end;if v then a.toggle_menu(v,x.buf)end;if w then b.backspace(x.buf)end end})end;function a.autocomplete(y)pcall(vim.api.nvim_clear_autocmds,{group=c,buffer=y})g(c,{clear=false})h('InsertCharPre',{buffer=y,group=c,desc='Autocomplete using the LSP omnifunc',callback=b.try_complete})end;function a.autocomplete_fallback()g(c,{clear=false})h('InsertCharPre',{group=c,desc='Autocomplete using words in current file',callback=b.try_complete_fallback})end;function a.tab_complete(y)vim.keymap.set('i','<Tab>',b.tab_expr,{buffer=y,expr=true})vim.keymap.set('i','<S-Tab>',b.prev_item,{buffer=y,expr=true})end;function a.tab_complete_fallback()vim.keymap.set('i','<Tab>',b.complete_words,{expr=true})vim.keymap.set('i','<S-Tab>',b.prev_item,{expr=true})end;function a.toggle_menu(z,y)vim.keymap.set('i',z,b.toggle_expr,{buffer=y,expr=true})end;function a.toggle_menu_fallback(z)vim.keymap.set('i',z,b.toggle_fallback,{expr=true})end;function b.try_complete()if f()>0 or b.is_macro()then return end;if e(vim.v.char,d)>=0 then vim.api.nvim_feedkeys(l,'n',false)end end;function b.try_complete_fallback()if f()>0 or b.is_macro()or b.is_prompt()then return end;if e(vim.v.char,d)>=0 then vim.api.nvim_feedkeys(m,'n',false)end end;function b.backspace(y)local A=function()if f()==1 then return'<bs><c-x><c-o>'end;return'<bs>'end;vim.keymap.set('i','<bs>',A,{expr=true,buffer=y})end;function b.keymap(z,B)if z==nil or string.lower(z)==string.lower(B)then return end;local A=function()if f()==1 then return B end;return z end;vim.keymap.set('i',z,A,{expr=true})end;function b.has_words_before()local C=vim.api.nvim_win_get_cursor(0)local D=C[2]if D==0 then return false end;local E=C[1]local F=vim.api.nvim_buf_get_lines(0,E-1,E,true)[1]return F:sub(D,D):match('%s')==nil end;function b.is_macro()return vim.fn.reg_recording()~=''or vim.fn.reg_executing()~=''end;function b.is_prompt()return vim.api.nvim_buf_get_option(0,'buftype')=='prompt'end;function b.tab_expr()if f()==1 then return k.next_item end;if b.has_words_before()then return k.omni end;return k.tab end;function b.complete_words()if f()==1 then return k.next_item end;if b.has_words_before()then return k.buffer end;return k.tab end;function b.prev_item()if f()==1 then return k.prev_item end;return k.tab end;function b.toggle_expr()if f()==1 then return k.abort end;return k.omni end;function b.toggle_fallback()if f()==1 then return k.abort end;return k.buffer end;return a
