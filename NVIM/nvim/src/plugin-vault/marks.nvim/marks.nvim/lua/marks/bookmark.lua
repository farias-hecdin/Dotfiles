local a=require'marks.utils'local b=vim.api;local c={}local function d(e,f,g)f=f or b.nvim_get_current_buf()g=g or b.nvim_win_get_cursor(0)for h,i in pairs(e)do if i.marks[f]and i.marks[f][g[1]]then return h end end;return nil end;local function j(k)local l={}for m,n in pairs(k)do for m,o in pairs(n)do table.insert(l,o)end end;local function p(q,r)return q.buf==r.buf and q.line<r.line or q.buf<r.buf end;table.sort(l,p)return l end;function c:init(h)local s=b.nvim_create_namespace("Bookmarks"..h)local t=self.signs[h]local u=self.virt_text[h]self.groups[h]={ns=s,sign=t,virt_text=u,marks={}}end;function c:place_mark(h,f)f=f or b.nvim_get_current_buf()local i=self.groups[h]if not i then self:init(h)i=self.groups[h]end;local g=b.nvim_win_get_cursor(0)if i.marks[f]and i.marks[f][g[1]]then return end;local v={buf=f,line=g[1],col=g[2],sign_id=-1}local w=a.option_nil(self.opt.buf_signs[f],self.opt.signs)if w and i.sign then local x=i.sign:byte()*100+g[1]self:add_sign(f,i.sign,g[1],x)v.sign_id=x end;local y={}if i.virt_text then y.virt_text={{i.virt_text,"MarkVirtTextHL"}}y.virt_text_pos="eol"end;local z=b.nvim_buf_set_extmark(f,i.ns,g[1]-1,g[2],y)v.extmark_id=z;if not i.marks[f]then i.marks[f]={}end;i.marks[f][g[1]]=v;if self.prompt_annotate[h]then self:annotate(h)end end;function c:toggle_mark(h,f)f=f or b.nvim_get_current_buf()local i=self.groups[h]if not i then self:init(h)i=self.groups[h]end;local g=b.nvim_win_get_cursor(0)if i.marks[f]and i.marks[f][g[1]]then self:delete_mark(h)else self:place_mark(h)end end;function c:delete_mark(h,f,A)f=f or b.nvim_get_current_buf()A=A or b.nvim_win_get_cursor(0)[1]local i=self.groups[h]if not i then return end;local o=i.marks[f][A]if not o then return end;if o.sign_id then a.remove_sign(f,o.sign_id,"BookmarkSigns")end;b.nvim_buf_del_extmark(f,i.ns,o.extmark_id)i.marks[f][A]=nil end;function c:delete_mark_cursor()local f=b.nvim_get_current_buf()local g=b.nvim_win_get_cursor(0)local h=d(self.groups,f,g)if not h then return end;self:delete_mark(h,f,g[1])end;function c:delete_all(h)local i=self.groups[h]if not i then return end;for f,n in pairs(i.marks)do for m,o in pairs(n)do if o.sign_id then a.remove_sign(f,o.sign_id,"BookmarkSigns")end;b.nvim_buf_del_extmark(f,i.ns,o.extmark_id)end;i.marks[f]=nil end end;function c:next(h)local f=b.nvim_get_current_buf()local g=b.nvim_win_get_cursor(0)if not h then h=d(self.groups,f,g)end;local i=self.groups[h]if not i then return end;local k=j(i.marks)if vim.tbl_isempty(k)then return end;local function p(q,r,m)if q.line>r.line and q.buf==r.buf or q.buf>r.buf then return true end;return false end;local B=a.search(k,{buf=f,line=g[1]},{buf=math.huge,line=math.huge},p,false)if not B then B=k[1]end;if B.buf~=f then vim.cmd("silent b"..B.buf)end;b.nvim_win_set_cursor(0,{B.line,B.col})end;function c:prev(h)local f=b.nvim_get_current_buf()local g=b.nvim_win_get_cursor(0)if not h then h=d(self.groups,f,g)end;local i=self.groups[h]if not i then return end;local k=j(i.marks)if vim.tbl_isempty(k)then return end;local function p(q,r,m)if q.line<r.line and q.buf==r.buf or q.buf<r.buf then return true end;return false end;local C=a.search(k,{buf=f,line=g[1]},{buf=-1,line=-1},p,false)if not C then C=k[#k]end;if C.buf~=f then vim.cmd("silent b"..C.buf)end;b.nvim_win_set_cursor(0,{C.line,C.col})end;function c:annotate(h)if vim.fn.has("nvim-0.6")~=1 then error("virtual line annotations requires neovim 0.6 or higher")end;local f=b.nvim_get_current_buf()local g=b.nvim_win_get_cursor(0)h=h or d(self.groups,f,g)if not h then return end;local D=self.groups[h].marks[f][g[1]]if not D then return end;local E=vim.fn.input("annotation: ")if E~=""then b.nvim_buf_set_extmark(f,self.groups[h].ns,D.line-1,D.col,{id=D.extmark_id,virt_lines={{{E,"MarkVirtTextHL"}}},virt_lines_above=true})else b.nvim_buf_del_extmark(f,self.groups[h].ns,D.extmark_id)local y={}if self.groups[h].virt_text then y.virt_text={{self.groups[h].virt_text,"MarkVirtTextHL"}}y.virt_text_pos="eol"end;D.extmark_id=b.nvim_buf_set_extmark(f,self.groups[h].ns,D.line-1,D.col,y)end end;function c:refresh()local f=b.nvim_get_current_buf()local n;local w;a.remove_buf_signs(f,"BookmarkSigns")for m,i in pairs(self.groups)do n=i.marks[f]if n then for m,o in pairs(vim.tbl_values(n))do local A=b.nvim_buf_get_extmark_by_id(f,i.ns,o.extmark_id,{})[1]if A+1~=o.line then n[A+1]=o;n[o.line]=nil;n[A+1].line=A+1 end;w=a.option_nil(self.opt.buf_signs[f],self.opt.signs)if w and i.sign then self:add_sign(f,i.sign,A+1,o.sign_id)end end end end end;function c:to_list(F,h)if not h or not self.groups[h]then return end;F=F or"loclist"local G=a.choose_list(F)local H={}for f,I in pairs(self.groups[h].marks)do for A,o in pairs(I)do local E=b.nvim_buf_get_lines(f,A-1,A,true)[1]table.insert(H,{bufnr=f,lnum=A,col=o.col+1,text=E})end end;G(H,"r")end;function c:all_to_list(F)F=F or"loclist"local G=a.choose_list(F)local H={}for h,i in pairs(self.groups)do for f,I in pairs(i.marks)do for A,o in pairs(I)do local E=b.nvim_buf_get_lines(f,A-1,A,true)[1]table.insert(H,{bufnr=f,lnum=A,col=o.col+1,text="bookmark group "..h..": "..E})end end end;G(H,"r")end;function c:add_sign(f,E,A,x)a.add_sign(f,E,A,x,"BookmarkSigns",self.priority)end;function c.new()return setmetatable({signs={"!","@","#","$","%","^","&","*","(",[0]=")"},virt_text={},groups={},prompt_annotate={},opt={}},{__index=c})end;return c
