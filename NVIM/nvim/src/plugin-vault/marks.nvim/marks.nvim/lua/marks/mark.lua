local a=vim.api;local b=require'marks.utils'local c={}function c:register_mark(d,e,f,g)f=f or 1;g=g or a.nvim_get_current_buf()local h=self.buffers[g]if not h then return end;if h.placed_marks[d]then self:delete_mark(d,false)end;if h.marks_by_line[e]then table.insert(h.marks_by_line[e],d)else h.marks_by_line[e]={d}end;h.placed_marks[d]={line=e,col=f,id=-1}local i=b.option_nil(self.opt.buf_signs[g],self.opt.signs)if i then local j=d:byte()*100;h.placed_marks[d].id=j;self:add_sign(g,d,e,j)end;if not b.is_lower(d)or d:byte()>h.lowest_available_mark:byte()then return end;while self.buffers[g].placed_marks[d]do d=string.char(d:byte()+1)end;self.buffers[g].lowest_available_mark=d end;function c:place_mark_cursor(d)local g=a.nvim_get_current_buf()local k=a.nvim_win_get_cursor(0)self:register_mark(d,k[1],k[2],g)end;function c:place_next_mark(e,f)local g=a.nvim_get_current_buf()if not self.buffers[g]then self.buffers[g]={placed_marks={},marks_by_line={},lowest_available_mark="a"}end;local d=self.buffers[g].lowest_available_mark;self:register_mark(d,e,f,g)vim.cmd("normal! m"..d)end;function c:place_next_mark_cursor()local k=a.nvim_win_get_cursor(0)self:place_next_mark(k[1],k[2])end;function c:delete_mark(d,l)l=b.option_nil(l,true)local g=a.nvim_get_current_buf()local h=self.buffers[g]if not h or not h.placed_marks[d]then return end;if h.placed_marks[d].id~=-1 then b.remove_sign(g,h.placed_marks[d].id)end;local e=h.placed_marks[d].line;for m,n in pairs(h.marks_by_line[e])do if n==d then h.marks_by_line[e][m]=nil;break end end;if vim.tbl_isempty(h.marks_by_line[e])then h.marks_by_line[e]=nil end;h.placed_marks[d]=nil;if l then vim.cmd("delmark "..d)end;if self.opt.force_write_shada then vim.cmd("wshada!")end;if not b.is_lower(d)then return end;if d:byte()<h.lowest_available_mark:byte()then h.lowest_available_mark=d end end;function c:delete_line_marks()local g=a.nvim_get_current_buf()local k=a.nvim_win_get_cursor(0)if not self.buffers[g].marks_by_line[k[1]]then return end;local o=vim.tbl_values(self.buffers[g].marks_by_line[k[1]])for p,d in pairs(o)do self:delete_mark(d)end end;function c:toggle_mark_cursor()local g=a.nvim_get_current_buf()local k=a.nvim_win_get_cursor(0)if self.buffers[g].marks_by_line[k[1]]then self:delete_line_marks()else self:place_next_mark(k[1],k[2])end end;function c:delete_buf_marks(l)l=b.option_nil(l,true)local g=a.nvim_get_current_buf()self.buffers[g]={placed_marks={},marks_by_line={},lowest_available_mark="a"}b.remove_buf_signs(g)if l then vim.cmd("delmarks!")end end;function c:next_mark()local g=a.nvim_get_current_buf()if not self.buffers[g]then return end;local e=a.nvim_win_get_cursor(0)[1]local q={}for d,r in pairs(self.buffers[g].placed_marks)do if b.is_letter(d)then q[d]=r end end;if vim.tbl_isempty(q)then return end;local function s(t,u,p)return t.line>u.line end;local v=b.search(q,{line=e},{line=math.huge},s,self.opt.cyclic)if v then a.nvim_win_set_cursor(0,{v.line,v.col})end end;function c:prev_mark()local g=a.nvim_get_current_buf()if not self.buffers[g]then return end;local e=a.nvim_win_get_cursor(0)[1]local q={}for d,r in pairs(self.buffers[g].placed_marks)do if b.is_letter(d)then q[d]=r end end;if vim.tbl_isempty(q)then return end;local function s(t,u,p)return t.line<u.line end;local w=b.search(q,{line=e},{line=-1},s,self.opt.cyclic)if w then a.nvim_win_set_cursor(0,{w.line,w.col})end end;function c.preview_mark()a.nvim_echo({{"press letter mark to preview, or press <esc> to quit"}},true,{})local d=vim.fn.getchar()if d==27 then return else d=string.char(d)end;vim.defer_fn(function()a.nvim_echo({{""}},false,{})end,100)if not d then return end;local k=vim.fn.getpos("'"..d)if k[2]==0 then return end;local x=a.nvim_win_get_width(0)local y=a.nvim_win_get_height(0)a.nvim_open_win(k[1],true,{relative="win",win=0,width=math.floor(x/2),height=math.floor(y/2),col=math.floor(x/4),row=math.floor(y/8),border="single"})vim.cmd("normal! `"..d)vim.cmd("normal! zz")end;function c:buffer_to_list(z,g)z=z or"loclist"local A=b.choose_list(z)g=g or a.nvim_get_current_buf()if not self.buffers[g]then return end;local B={}for d,r in pairs(self.buffers[g].placed_marks)do local C=a.nvim_buf_get_lines(g,r.line-1,r.line,true)[1]table.insert(B,{bufnr=g,lnum=r.line,col=r.col+1,text="mark "..d..": "..C})end;A(B,"r")end;function c:all_to_list(z)z=z or"loclist"local A=b.choose_list(z)local B={}for g,D in pairs(self.buffers)do for d,r in pairs(D.placed_marks)do local C=a.nvim_buf_get_lines(g,r.line-1,r.line,true)[1]table.insert(B,{bufnr=g,lnum=r.line,col=r.col+1,text="mark "..d..": "..C})end end;A(B,"r")end;function c:global_to_list(z)z=z or"loclist"local A=b.choose_list(z)local B={}for g,D in pairs(self.buffers)do for d,r in pairs(D.placed_marks)do if b.is_upper(d)then local C=a.nvim_buf_get_lines(g,r.line-1,r.line,true)[1]table.insert(B,{bufnr=g,lnum=r.line,col=r.col+1,text="mark "..d..": "..C})end end end;A(B,"r")end;function c:refresh(g,E)E=E or false;g=g or a.nvim_get_current_buf()if not self.buffers[g]then self.buffers[g]={placed_marks={},marks_by_line={},lowest_available_mark="a"}end;for d,p in pairs(self.buffers[g].placed_marks)do if a.nvim_buf_get_mark(g,d)[1]==0 then self:delete_mark(d,false)end end;local d;local k;local F;for p,r in ipairs(vim.fn.getmarklist())do d=r.mark:sub(2,3)k=r.pos;F=self.buffers[g].placed_marks[d]if b.is_upper(d)and k[1]==g and(E or not F or k[2]~=F.line)then self:register_mark(d,k[2],k[3],g)end end;for p,r in ipairs(vim.fn.getmarklist("%"))do d=r.mark:sub(2,3)k=r.pos;F=self.buffers[g].placed_marks[d]if b.is_lower(d)and(E or not F or k[2]~=F.line)then self:register_mark(d,k[2],k[3],g)end end;for p,G in pairs(self.builtin_marks)do k=vim.fn.getpos("'"..G)F=self.buffers[g].placed_marks[G]if(k[1]==0 or k[1]==g)and k[2]~=0 and(E or not F or k[2]~=F.line)then self:register_mark(G,k[2],k[3],g)end end;return end;function c:add_sign(g,C,e,j)local H;if b.is_lower(C)then H=self.opt.priority[1]elseif b.is_upper(C)then H=self.opt.priority[2]else H=self.opt.priority[3]end;b.add_sign(g,C,e,j,"MarkSigns",H)end;function c.new()return setmetatable({buffers={},opt={}},{__index=c})end;return c
