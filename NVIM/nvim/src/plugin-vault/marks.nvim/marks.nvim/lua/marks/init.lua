local a=require'marks.mark'local b=require'marks.bookmark'local c=require'marks.utils'local d={}function d.set()local e,f=pcall(function()return string.char(vim.fn.getchar())end)if not e then return end;if c.is_valid_mark(f)then if not d.excluded_fts[vim.bo.ft]then d.mark_state:place_mark_cursor(f)end;vim.cmd("normal! m"..f)end end;function d.set_next()if not d.excluded_fts[vim.bo.ft]then d.mark_state:place_next_mark_cursor()end end;function d.toggle()if not d.excluded_fts[vim.bo.ft]then d.mark_state:toggle_mark_cursor()end end;function d.delete()local e,f=pcall(function()return string.char(vim.fn.getchar())end)if not e then return end;if c.is_valid_mark(f)then d.mark_state:delete_mark(f)return end end;function d.delete_line()d.mark_state:delete_line_marks()end;function d.delete_buf()d.mark_state:delete_buf_marks()end;function d.preview()d.mark_state:preview_mark()end;function d.next()d.mark_state:next_mark()end;function d.prev()d.mark_state:prev_mark()end;function d.annotate()d.bookmark_state:annotate()end;function d.refresh(g)if d.excluded_fts[vim.bo.ft]then return end;g=g or false;d.mark_state:refresh(nil,g)d.bookmark_state:refresh()end;function d._on_delete()local h=tonumber(vim.fn.expand("<abuf>"))if not h then return end;d.mark_state.buffers[h]=nil;for i,j in pairs(d.bookmark_state.groups)do j.marks[h]=nil end end;function d.toggle_signs(h)if not h then d.mark_state.opt.signs=not d.mark_state.opt.signs;d.bookmark_state.opt.signs=not d.bookmark_state.opt.signs;for k,i in pairs(d.mark_state.opt.buf_signs)do d.mark_state.opt.buf_signs[k]=d.mark_state.opt.signs end;for k,i in pairs(d.bookmark_state.opt.buf_signs)do d.bookmark_state.opt.buf_signs[k]=d.bookmark_state.opt.signs end else d.mark_state.opt.buf_signs[h]=not c.option_nil(d.mark_state.opt.buf_signs[h],d.mark_state.opt.signs)d.bookmark_state.opt.buf_signs[h]=not c.option_nil(d.bookmark_state.opt.buf_signs[h],d.bookmark_state.opt.signs)end;d.refresh(true)end;for l=0,9 do d["set_bookmark"..l]=function()d.bookmark_state:place_mark(l)end;d["toggle_bookmark"..l]=function()d.bookmark_state:toggle_mark(l)end;d["delete_bookmark"..l]=function()d.bookmark_state:delete_all(l)end;d["next_bookmark"..l]=function()d.bookmark_state:next(l)end;d["prev_bookmark"..l]=function()d.bookmark_state:prev(l)end end;function d.delete_bookmark()d.bookmark_state:delete_mark_cursor()end;function d.next_bookmark()d.bookmark_state:next()end;function d.prev_bookmark()d.bookmark_state:prev()end;d.mappings={set="m",set_next="m,",toggle="m;",next="m]",prev="m[",preview="m:",next_bookmark="m}",prev_bookmark="m{",delete="dm",delete_line="dm-",delete_bookmark="dm=",delete_buf="dm<space>"}for l=0,9 do d.mappings["set_bookmark"..l]="m"..tostring(l)d.mappings["delete_bookmark"..l]="dm"..tostring(l)end;local function m(n)for o,p in pairs(n.mappings)do if p~=false then d.mappings[o]=p else d.mappings[o]=nil end end end;local function q()for o,p in pairs(d.mappings)do vim.cmd("nnoremap <silent> "..p.." <cmd>lua require'marks'."..o.."()<cr>")end end;local function r(n)if not n.default_mappings then d.mappings={}end;if n.mappings then m(n)end;q()end;local function s()vim.cmd[[augroup Marks_autocmds
    autocmd!
    autocmd BufEnter * lua require'marks'.refresh(true)
    autocmd BufDelete * lua require'marks'._on_delete()
  augroup end]]end;function d.setup(n)n=n or{}d.mark_state=a.new()d.mark_state.builtin_marks=n.builtin_marks or{}d.bookmark_state=b.new()local t;for l=0,9 do t=n["bookmark_"..l]if t then if t.sign==false then d.bookmark_state.signs[l]=nil else d.bookmark_state.signs[l]=t.sign or d.bookmark_state.signs[l]end;d.bookmark_state.virt_text[l]=t.virt_text or d.bookmark_state.virt_text[l]d.bookmark_state.prompt_annotate[l]=t.annotate end end;local u={}for i,v in ipairs(n.excluded_filetypes or{})do u[v]=true end;d.excluded_fts=u;d.bookmark_state.opt.signs=true;d.bookmark_state.opt.buf_signs={}n.default_mappings=c.option_nil(n.default_mappings,true)r(n)s()d.mark_state.opt.signs=c.option_nil(n.signs,true)d.mark_state.opt.buf_signs={}d.mark_state.opt.force_write_shada=c.option_nil(n.force_write_shada,false)d.mark_state.opt.cyclic=c.option_nil(n.cyclic,true)d.mark_state.opt.priority={10,10,10}local w=d.mark_state.opt.priority;if type(n.sign_priority)=="table"then w[1]=n.sign_priority.lower or w[1]w[2]=n.sign_priority.upper or w[2]w[3]=n.sign_priority.builtin or w[3]d.bookmark_state.priority=n.sign_priority.bookmark or 10 elseif type(n.sign_priority)=="number"then w[1]=n.sign_priority;w[2]=n.sign_priority;w[3]=n.sign_priority;d.bookmark_state.priority=n.sign_priority end;local x=c.option_nil(n.refresh_interval,150)local y=vim.loop.new_timer()y:start(0,x,vim.schedule_wrap(d.refresh))end;return d
