local a={}local b={path_sep=package.config:sub(1,1)}a.setup=function(c)_G.MiniSessions=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)end;a.config={autoread=false,autowrite=true,directory=('%s%ssession'):format(vim.fn.stdpath('data'),b.path_sep),file='Session.vim',force={read=false,write=true,delete=false},hooks={pre={read=nil,write=nil,delete=nil},post={read=nil,write=nil,delete=nil}},verbose={read=false,write=true,delete=true}}a.detected={}a.read=function(d,e)if b.is_disabled()then return end;if vim.tbl_count(a.detected)==0 then b.error('There is no detected sessions. Change configuration and rerun `MiniSessions.setup()`.')end;b.detect_sessions()if d==nil then if a.detected[a.config.file]~=nil then d=a.config.file else d=a.get_latest()end end;e=vim.tbl_deep_extend('force',b.default_opts('read'),e or{})if not b.validate_detected(d)then return end;local f=a.detected[d]if not e.force then local g=b.get_unsaved_listed_buffers()if#g>0 then local h=table.concat(g,', ')b.error(('There are unsaved listed buffers: %s.'):format(h))end end;b.possibly_execute(e.hooks.pre,f)vim.cmd('%bwipeout!')local i=f.path;vim.cmd(('silent! source %s'):format(vim.fn.fnameescape(i)))vim.v.this_session=i;if e.verbose then b.message(('Read session %s'):format(i))end;b.possibly_execute(e.hooks.post,f)end;a.write=function(d,e)if b.is_disabled()then return end;e=vim.tbl_deep_extend('force',b.default_opts('write'),e or{})local i=b.name_to_path(d)if not e.force and b.is_readable_file(i)then b.error([[Can't write to existing session when `opts.force` is not `true`.]])end;local f=b.new_session(i)b.possibly_execute(e.hooks.pre,f)local j=('mksession%s'):format(e.force and'!'or'')vim.cmd(('%s %s'):format(j,vim.fn.fnameescape(i)))f.modify_time=vim.fn.getftime(i)a.detected[f.name]=f;if e.verbose then b.message(('Written session %s'):format(i))end;b.possibly_execute(e.hooks.post,f)end;a.delete=function(d,e)if b.is_disabled()then return end;if vim.tbl_count(a.detected)==0 then b.error('There is no detected sessions. Change configuration and rerun `MiniSessions.setup()`.')end;e=vim.tbl_deep_extend('force',b.default_opts('delete'),e or{})local i=b.name_to_path(d)b.detect_sessions()d=vim.fn.fnamemodify(i,':t')if not b.validate_detected(d)then return end;i=a.detected[d].path;local k=i==vim.v.this_session;if not e.force and k then b.error([[Can't delete current session when `opts.force` is not `true`.]])end;local f=a.detected[d]b.possibly_execute(e.hooks.pre,f)vim.fn.delete(i)a.detected[d]=nil;if k then vim.v.this_session=''end;if e.verbose then b.message(('Deleted session %s'):format(i))end;b.possibly_execute(e.hooks.post,f)end;a.select=function(l,e)if not(type(vim.ui)=='table'and type(vim.ui.select)=='function')then b.error('`MiniSessions.select()` requires `vim.ui.select()` function.')end;l=l or'read'if not vim.tbl_contains({'read','write','delete'},l)then b.error("`action` should be one of 'read', 'write', or 'delete'.")end;b.detect_sessions()local m={}for n,o in pairs(a.detected)do table.insert(m,o)end;local p=function(q,r)local s=q.type=='local'and''or q.name;local t=r.type=='local'and''or r.name;return s<t end;table.sort(m,p)local u=vim.tbl_map(function(v)return v.name end,m)vim.ui.select(u,{prompt='Select session to '..l,format_item=function(v)return('%s (%s)'):format(v,a.detected[v].type)end},function(w,x)if w==nil then return end;a[l](w,e)end)end;a.get_latest=function()if vim.tbl_count(a.detected)==0 then return end;local y,z=-1,nil;for A,f in pairs(a.detected)do if f.modify_time>y then y,z=f.modify_time,A end end;return z end;b.default_config=vim.deepcopy(a.config)b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({autoread={c.autoread,'boolean'},autowrite={c.autowrite,'boolean'},directory={c.directory,'string'},file={c.file,'string'},force={c.force,'table'},hooks={c.hooks,'table'},verbose={c.verbose,'table'}})vim.validate({['force.read']={c.force.read,'boolean'},['force.write']={c.force.write,'boolean'},['force.delete']={c.force.delete,'boolean'},['hooks.pre']={c.hooks.pre,'table'},['hooks.post']={c.hooks.post,'table'},['verbose.read']={c.verbose.read,'boolean'},['verbose.write']={c.verbose.write,'boolean'},['verbose.delete']={c.verbose.delete,'boolean'}})vim.validate({['hooks.pre.read']={c.hooks.pre.read,'function',true},['hooks.pre.write']={c.hooks.pre.write,'function',true},['hooks.pre.delete']={c.hooks.pre.delete,'function',true},['hooks.post.read']={c.hooks.post.read,'function',true},['hooks.post.write']={c.hooks.post.write,'function',true},['hooks.post.delete']={c.hooks.post.delete,'function',true}})return c end;b.apply_config=function(c)a.config=c;b.detect_sessions(c)end;b.create_autocommands=function(c)local B=vim.api.nvim_create_augroup('MiniSessions',{})if c.autoread then local C=function()if not b.is_something_shown()then a.read()end end;vim.api.nvim_create_autocmd('VimEnter',{group=B,nested=true,once=true,callback=C,desc='Autoread latest session'})end;if c.autowrite then local D=function()if vim.v.this_session~=''then a.write(nil,{force=true})end end;vim.api.nvim_create_autocmd('VimLeavePre',{group=B,callback=D,desc='Autowrite current session'})end end;b.is_disabled=function()return vim.g.minisessions_disable==true or vim.b.minisessions_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minisessions_config or{},c or{})end;b.detect_sessions=function(c)c=b.get_config(c)local E=c.directory==''and{}or b.detect_sessions_global(c.directory)local F=c.file==''and{}or b.detect_sessions_local(c.file)a.detected=vim.tbl_deep_extend('force',E,F)end;b.detect_sessions_global=function(G)G=b.full_path(G)if vim.fn.isdirectory(G)~=1 then local H,n=pcall(vim.fn.mkdir,G,'p')if not H then b.message(('%s is not a directory path.'):format(vim.inspect(G)))return{}end end;local I=vim.fn.globpath(G,'*')if#I==0 then return{}end;local J={}for n,K in pairs(vim.split(I,'\n'))do if b.is_readable_file(K)then local L=b.new_session(K,'global')J[L.name]=L end end;return J end;b.detect_sessions_local=function(M)local K=b.joinpath(vim.fn.getcwd(),M)if not b.is_readable_file(K)then return{}end;local J={}local L=b.new_session(K,'local')J[L.name]=L;return J end;b.new_session=function(i,N)return{modify_time=vim.fn.getftime(i),name=vim.fn.fnamemodify(i,':t'),path=b.full_path(i),type=N or b.get_session_type(i)}end;b.get_session_type=function(i)if a.config.directory==''then return'local'end;local O=b.full_path(i)local G=b.full_path(a.config.directory)return O==G and'global'or'local'end;b.validate_detected=function(d)local P=vim.tbl_contains(vim.tbl_keys(a.detected),d)if P then return true end;b.error(('%s is not a name for detected session.'):format(vim.inspect(d)))end;b.get_unsaved_listed_buffers=function()return vim.tbl_filter(function(Q)return vim.bo[Q].modified and vim.bo[Q].buflisted end,vim.api.nvim_list_bufs())end;b.get_current_session_name=function()return vim.fn.fnamemodify(vim.v.this_session,':t')end;b.name_to_path=function(d)if d==nil then if vim.v.this_session==''then b.error('There is no active session. Supply non-nil session name.')end;return vim.v.this_session end;d=tostring(d)if d==''then b.error('Supply non-empty session name.')end;local O=d==a.config.file and vim.fn.getcwd()or a.config.directory;local R=b.joinpath(O,d)return b.full_path(R)end;b.echo=function(S,T)S=type(S)=='string'and{{S}}or S;table.insert(S,1,{'(mini.sessions) ','WarningMsg'})local U=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local V,W={},0;for n,X in ipairs(S)do local Y={vim.fn.strcharpart(X[1],0,U-W),X[2]}table.insert(V,Y)W=W+vim.fn.strdisplaywidth(Y[1])if W>=U then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(V,T,{})end;b.message=function(S)b.echo(S,true)end;b.error=function(S)error(('(mini.sessions) %s'):format(S))end;b.default_opts=function(l)local c=a.config;return{force=c.force[l],verbose=c.verbose[l],hooks={pre=c.hooks.pre[l],post=c.hooks.post[l]}}end;b.is_readable_file=function(R)return vim.fn.isdirectory(R)~=1 and vim.fn.getfperm(R):sub(1,1)=='r'end;b.joinpath=function(Z,_)return('%s%s%s'):format(Z,b.path_sep,tostring(_))end;b.full_path=function(R)return vim.fn.resolve(vim.fn.fnamemodify(R,':p'))end;b.is_something_shown=function()local a0=vim.api.nvim_buf_get_lines(0,0,-1,true)if#a0>1 or#a0==1 and a0[1]:len()>0 then return true end;local a1=vim.tbl_filter(function(Q)return vim.fn.buflisted(Q)==1 end,vim.api.nvim_list_bufs())if#a1>1 then return true end;if vim.fn.argc()>0 then return true end;return false end;b.possibly_execute=function(K,...)if K==nil then return end;return K(...)end;return a
