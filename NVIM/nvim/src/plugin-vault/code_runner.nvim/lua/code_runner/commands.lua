local a=require("code_runner.options")local b="crunner_"local function c(d,e,f)if type(d)=="function"then local g=d(f)if type(g)=="string"then d=g else return end end;local h=d;d=d:gsub("$fileNameWithoutExt",vim.fn.fnamemodify(e,":t:r"))d=d:gsub("$fileName",vim.fn.fnamemodify(e,":t"))d=d:gsub("$file",e)d=d:gsub("$dir",vim.fn.fnamemodify(e,":p:h"))d=d:gsub("$end","")if d==h then d=d.." "..e end;return d end;local function i()local j=a.get().project;local e=vim.fn.expand("%:p")for k,l in pairs(j)do path_full=vim.fs.normalize(k)if string.find(e,path_full)==1 then current_proyect=j[k]current_proyect["path"]=k;return current_proyect end end end;local function m(n,e,f)local o=a.get()e=e or vim.fn.expand("%:p")local d=o.filetype[n]if d then local p=c(d,e,f)return p end end;local function q(r)local d=nil;if r.file_name then local s=r.path.."/"..r.file_name;if r.command then d=c(r.command,s)else local n=vim.filetype.match({filename=s})d=m(n,s)end else d="cd "..r.path.." &&"..r.command end;return d end;local function t(u)u=u or b..vim.fn.expand("%:t:r")local v=vim.fn.bufname("%")if string.find(v,b)then vim.cmd("bwipeout!")else local w=vim.fn.bufnr(u)if w~=-1 then vim.cmd("bwipeout!"..w)end end end;local function x(d,u,y)local o=a.get()y=y or o.prefix;local z="file "..u;local A=vim.api.nvim_get_current_win()t(u)vim.cmd(y)vim.fn.termopen(d)vim.cmd("norm G")vim.opt_local.relativenumber=false;vim.opt_local.number=false;vim.cmd(z)if y~="tabnew"then vim.bo.buflisted=false end;if o.focus then vim.cmd(o.insert_prefix)else vim.fn.win_gotoid(A)end end;btm_number=a.get().better_term.init;local function B(d)local o=a.get().better_term;local C,D=pcall(require,"betterTerm")if C then if o.number==nil then btm_number=btm_number+1 else btm_number=o.number end;D.send(d,btm_number,{clean=o.clean})end end;local E={}E.modes={term=function(d,u)x(d,u)end,tab=function(d,u)x(d,u,"tabnew")end,float=function(d,...)local F=require("code_runner.floats")F.floating(d)end,better_term=function(d,...)B(d)end,toggleterm=function(d,...)local G=string.format('TermExec cmd="%s"',d)vim.cmd(G)end}local function H(d,u,I)local o=a.get()I=I or o.mode;if I==""then I=o.mode end;u=b..u;local J=E.modes[I]if J==nil then vim.notify(":( mode not found, Select valid mode",vim.log.levels.INFO,{title="Project"})return end;J(d,u)end;E.run_mode=H;function E.get_filetype_command()local n=vim.bo.filetype;return m(n)or""end;function E.get_project_command()local K={}local o=a.get()local r=nil;if not vim.tbl_isempty(o.project)then r=i()end;if r then K.command=q(r)or""K.name=r.name;K.mode=r.mode;return K end end;function E.run_filetype(I)local d=E.get_filetype_command()if d~=""then a.get().before_run_filetype()H(d,vim.fn.expand("%:t:r"),I)else local L={lua="luafile %",vim="source %"}local g=L[vim.bo.filetype]or""vim.cmd(g)end end;function E.run_project(I,M)if M==nil then M=true end;local N=E.get_project_command()if N then if not I then I=N.mode end;H(N.command,N.name,I)return true end;if M then vim.notify(":( There is no project associated with this path",vim.log.levels.INFO,{title="Project"})end;return false end;function E.run_code(n,f)if n~=nil and n~=""then local O=m(n,nil,f)if O then a.get().before_run_filetype()H(O,vim.fn.expand("%:t:r"))return else return end end;local N=E.run_project(nil,false)if not N then E.run_filetype()end end;function E.run_close()local r=i()if r then t(b..r.name)else t()end end;return E
