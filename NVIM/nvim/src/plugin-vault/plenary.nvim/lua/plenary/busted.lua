local a=function(b)return vim.fn.fnamemodify(b,":h")end;local function c(d,e,f)local function g(h)local i=h.traceback:find"\n%s*%[C]"h.traceback=h.traceback:sub(1,i)return h end;e=e or 3;local j=a(debug.getinfo(1,"Sl").source,":h")local h=debug.getinfo(e,"Sl")while h.what=="C"or h.short_src:match"luassert[/\\].*%.lua$"or h.source:sub(1,1)=="@"and j==a(h.source)do e=e+1;h=debug.getinfo(e,"Sl")end;h.traceback=debug.traceback("",e)h.message=f;local k=false;return k and k.getTrace(k.name,h)or g(h)end;local l=require("plenary.nvim_meta").is_headless;print=function(...)for m,n in ipairs{...}do io.stdout:write(tostring(n))io.stdout:write"\t"end;io.stdout:write"\r\n"end;local o={}local p={}local q={}local r={}local s={}local t=function(u)table.insert(q,u)return vim.deepcopy(q)end;local v=function()q[#q]=nil end;local w=function()r[#q]={}s[#q]={}end;local x=function()r[#q]=nil;s[#q]=nil end;local y=function(u,z)local A=t(u)w()local B,f=xpcall(z,function(f)local C=c(nil,3,f)return C.message.."\n"..C.traceback end)x()v()return B,f,A end;local D={yellow=33,green=32,red=31}local E=function(F,G)if not l then return G end;return string.format("%s[%sm%s%s[%sm",string.char(27),D[F]or 0,G,string.char(27),0)end;local H=E("green","Success")local I=E("red","Fail")local J=E("yellow","Pending")local K=string.rep("=",40)o.format_results=function(L)print""print(E("green","Success: "),#L.pass)print(E("red","Failed : "),#L.fail)print(E("red","Errors : "),#L.errs)print(K)end;o.describe=function(u,z)p.pass=p.pass or{}p.fail=p.fail or{}p.errs=p.errs or{}describe=o.inner_describe;local B,f,A=y(u,z)describe=o.describe;if not B then table.insert(p.errs,{descriptions=A,msg=f})end end;o.inner_describe=function(u,z)local B,f,A=y(u,z)if not B then table.insert(p.errs,{descriptions=A,msg=f})end end;o.before_each=function(M)table.insert(r[#q],M)end;o.after_each=function(M)table.insert(s[#q],M)end;o.clear=function()vim.api.nvim_buf_set_lines(0,0,-1,false,{})end;local N=function(f,O)if O==nil then O=4 end;local P=string.rep(" ",O)return P..f:gsub("\n","\n"..P)end;local Q=function(R)for m,n in ipairs(R)do for m,S in ipairs(n)do if type(S)=="function"then S()end end end end;o.it=function(u,z)Q(r)local B,f,A=y(u,z)Q(s)local T={descriptions=A,msg=nil}local U;if not B then U=p.fail;T.msg=f;print(I,"||",table.concat(T.descriptions," "))print(N(f,12))else U=p.pass;print(H,"||",table.concat(T.descriptions," "))end;table.insert(U,T)end;o.pending=function(u,z)local V=vim.deepcopy(q)table.insert(V,u)print(J,"||",table.concat(V," "))end;_PlenaryBustedOldAssert=_PlenaryBustedOldAssert or assert;describe=o.describe;it=o.it;pending=o.pending;before_each=o.before_each;after_each=o.after_each;clear=o.clear;assert=require"luassert"o.run=function(k)k=k:gsub("\\","/")print("\n"..K)print("Testing: ",k)local W,f=loadfile(k)if not W then print(K)print"FAILED TO LOAD FILE"print(E("red",f))print(K)if l then return vim.cmd"2cq"else return end end;coroutine.wrap(function()W()if not p.pass then if l then return vim.cmd"0cq"else return end end;o.format_results(p)if#p.errs~=0 then print("We had an unexpected error: ",vim.inspect(p.errs),vim.inspect(p))if l then return vim.cmd"2cq"end elseif#p.fail>0 then print"Tests Failed. Exit: 1"if l then return vim.cmd"1cq"end else if l then return vim.cmd"0cq"end end end)()end;return o
