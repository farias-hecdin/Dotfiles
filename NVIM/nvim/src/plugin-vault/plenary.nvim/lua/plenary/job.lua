local vim=vim;local a=vim.loop;local b=require"plenary.functional"local c={}c.__index=c;local function d(e,f)local g=e[f]if not g then return end;if not g:is_closing()then g:close()end end;local h=function(i,j,k,l)a.check_start(i._shutdown_check,function()if not i:_pipes_are_closed(j)then return end;a.check_stop(i._shutdown_check)i._shutdown_check=nil;i:_shutdown(k,l)i=nil end)end;local m=function(i,j)return function(k,l)if a.is_closing(i._shutdown_check)then return i:shutdown(k,l)else h(i,j,k,l)end end end;local function n(o)if vim.in_fast_event()then return assert(a.fs_realpath(o),string.format("Path must be valid: %s",o))else return vim.fn.expand(vim.fn.escape(o,"[]$"),true)end end;function c:new(p)if not p then error(debug.traceback"Options are required for Job:new")end;local q=p.command;if not q then if p[1]then q=p[1]else error(debug.traceback"'command' is required for Job:new")end elseif p[1]then error(debug.traceback"Cannot pass both 'command' and array args")end;local r=p.args;if not r then if#p>1 then r={select(2,unpack(p))}end end;local s,t=pcall(vim.fn.executable,q)if not p.skip_validation and s and 1~=t then error(debug.traceback(q..": Executable not found"))end;local u={}u.command=q;u.args=r;u._raw_cwd=p.cwd;if p.env then if type(p.env)~="table"then error"[plenary.job] env has to be a table"end;local v={}for w,x in pairs(p.env)do if type(w)=="number"then table.insert(v,x)elseif type(w)=="string"then table.insert(v,w.."="..tostring(x))end end;u.env=v end;if p.interactive==nil then u.interactive=true else u.interactive=p.interactive end;if p.detached then u.detached=true end;u.enable_handlers=b.if_nil(p.enable_handlers,true,p.enable_handlers)u.enable_recording=b.if_nil(b.if_nil(p.enable_recording,p.enable_handlers,p.enable_recording),true,p.enable_recording)if not u.enable_handlers and u.enable_recording then error"[plenary.job] Cannot record items but disable handlers"end;u._user_on_start=p.on_start;u._user_on_stdout=p.on_stdout;u._user_on_stderr=p.on_stderr;u._user_on_exit=p.on_exit;u._additional_on_exit_callbacks={}u._maximum_results=p.maximum_results;u.user_data={}u.writer=p.writer;self._reset(u)return setmetatable(u,self)end;function c:_reset()self.is_shutdown=nil;if self._shutdown_check and a.is_active(self._shutdown_check)and not a.is_closing(self._shutdown_check)then vim.api.nvim_err_writeln(debug.traceback"We may be memory leaking here. Please report to TJ.")end;self._shutdown_check=a.new_check()self.stdin=nil;self.stdout=nil;self.stderr=nil;self._stdout_reader=nil;self._stderr_reader=nil;if self.enable_recording then self._stdout_results={}self._stderr_results={}else self._stdout_results=nil;self._stderr_results=nil end end;function c:_stop()d(self,"stdin")d(self,"stderr")d(self,"stdout")d(self,"handle")end;function c:_pipes_are_closed(j)for y,z in ipairs{j.stdin,j.stdout,j.stderr}do if z and not a.is_closing(z)then return false end end;return true end;function c:shutdown(k,l)if self._shutdown_check and a.is_active(self._shutdown_check)then return end;self:_shutdown(k,l)end;function c:_shutdown(k,l)if self.is_shutdown then return end;self.code=k;self.signal=l;if self._stdout_reader then pcall(self._stdout_reader,nil,nil,true)end;if self._stderr_reader then pcall(self._stderr_reader,nil,nil,true)end;if self._user_on_exit then self:_user_on_exit(k,l)end;for y,x in ipairs(self._additional_on_exit_callbacks)do x(self,k,l)end;if self.stdout then self.stdout:read_stop()end;if self.stderr then self.stderr:read_stop()end;self:_stop()self.is_shutdown=true;self._stdout_reader=nil;self._stderr_reader=nil end;function c:_create_uv_options()local j={}j.command=self.command;j.args=self.args;j.stdio={self.stdin,self.stdout,self.stderr}if self._raw_cwd then j.cwd=n(self._raw_cwd)end;if self.env then j.env=self.env end;if self.detached then j.detached=true end;return j end;local A=function(self,B,C)return coroutine.wrap(function(D,E,F)local G=1;local H,I,J,K;while true do if E then E=E:gsub("\r","")local L=1;local M=#E+1;repeat I=string.find(E,"\n",L,true)or M;H=string.sub(E,L,I-1)K=I~=M;if J then J=J..H elseif I~=L or K then J=H end;if K then if not J then return vim.api.nvim_err_writeln("Broken data thing due to: "..tostring(J).." "..tostring(E))end;if self.enable_recording then self[B][G]=J end;if C then C(D,J,self)end;if self._maximum_results and G>self._maximum_results then vim.schedule(function()self:shutdown()end)return end;G=G+1;J=nil end;L=I+1 until not K end;if self.enable_recording then self[B][G]=J end;if C and F and not K then C(D,J,self)end;if E==nil or F then return end;D,E,F=coroutine.yield()end end)end;function c:_prepare_pipes()self:_stop()if self.writer then if c.is_job(self.writer)then self.writer:_prepare_pipes()self.stdin=self.writer.stdout elseif self.writer.write then self.stdin=self.writer end end;if not self.stdin then self.stdin=self.interactive and a.new_pipe(false)or nil end;self.stdout=a.new_pipe(false)self.stderr=a.new_pipe(false)end;function c:_execute()local j=self:_create_uv_options()if self._user_on_start then self:_user_on_start()end;self.handle,self.pid=a.spawn(j.command,j,m(self,j))if not self.handle then error(debug.traceback("Failed to spawn process: "..vim.inspect(self)))end;if self.enable_handlers then self._stdout_reader=A(self,"_stdout_results",self._user_on_stdout)self.stdout:read_start(self._stdout_reader)self._stderr_reader=A(self,"_stderr_results",self._user_on_stderr)self.stderr:read_start(self._stderr_reader)end;if self.writer then if c.is_job(self.writer)then self.writer:_execute()elseif type(self.writer)=="table"and vim.tbl_islist(self.writer)then local N=#self.writer;for O,x in ipairs(self.writer)do self.stdin:write(x)if O~=N then self.stdin:write"\n"else self.stdin:write("\n",function()pcall(self.stdin.close,self.stdin)end)end end elseif type(self.writer)=="string"then self.stdin:write(self.writer,function()self.stdin:close()end)elseif self.writer.write then self.stdin=self.writer else error("Unknown self.writer: "..vim.inspect(self.writer))end end;return self end;function c:start()self:_reset()self:_prepare_pipes()self:_execute()end;function c:sync(P,Q)self:start()self:wait(P,Q)return self.enable_recording and self:result()or nil,self.code end;function c:result()assert(self.enable_recording,"'enabled_recording' is not enabled for this job.")return self._stdout_results end;function c:stderr_result()assert(self.enable_recording,"'enabled_recording' is not enabled for this job.")return self._stderr_results end;function c:pid()return self.pid end;function c:wait(P,Q,R)P=P or 5000;Q=Q or 10;if self.handle==nil then local S=vim.inspect(self)vim.schedule(function()vim.api.nvim_err_writeln(S)end)return end;local T=vim.wait(P,function()if R then vim.cmd[[redraw!]]end;if self.is_shutdown then assert(not self.handle or self.handle:is_closing(),"Job must be shutdown if it's closing")end;return self.is_shutdown end,Q,not R)if not T then error(string.format("'%s %s' was unable to complete in %s ms",self.command,table.concat(self.args or{}," "),P))end;return self end;function c:co_wait(U)U=U or 5;if self.handle==nil then vim.api.nvim_err_writeln(vim.inspect(self))return end;while not vim.wait(U,function()return self.is_shutdown end)do coroutine.yield()end;return self end;function c.join(...)local V={...}local W=table.getn(V)local P;if type(V[W])=="number"then P=table.remove(V,W)W=W-1 end;local X=0;return vim.wait(P or 10000,function()for Y,Z in pairs(V)do if Z.is_shutdown then V[Y]=nil;X=X+1 end end;return W==X end)end;local _=0;local a0={}function c:and_then(a1)self:add_on_exit_callback(function()a1:start()end)end;function c:and_then_wrap(a1)self:add_on_exit_callback(vim.schedule_wrap(function()a1:start()end))end;function c:after(a2)self:add_on_exit_callback(a2)return self end;function c:and_then_on_success(a1)self:add_on_exit_callback(function(y,k)if k==0 then a1:start()end end)end;function c:and_then_on_success_wrap(a1)self:add_on_exit_callback(vim.schedule_wrap(function(y,k)if k==0 then a1:start()end end))end;function c:after_success(a2)self:add_on_exit_callback(function(e,k,l)if k==0 then a2(e,k,l)end end)end;function c:and_then_on_failure(a1)self:add_on_exit_callback(function(y,k)if k~=0 then a1:start()end end)end;function c:and_then_on_failure_wrap(a1)self:add_on_exit_callback(vim.schedule_wrap(function(y,k)if k~=0 then a1:start()end end))end;function c:after_failure(a2)self:add_on_exit_callback(function(e,k,l)if k~=0 then a2(e,k,l)end end)end;function c.chain(...)_=_+1;a0[_]=false;local a3={...}for Y=2,#a3 do local a4=a3[Y-1]local a5=a3[Y]a4:add_on_exit_callback(vim.schedule_wrap(function()a5:start()end))end;local a6=a3[#a3]._user_on_exit;a3[#a3]._user_on_exit=function(self,D,E)if a6 then a6(self,D,E)end;a0[_]=true end;a3[1]:start()return _ end;function c.chain_status(a7)return a0[a7]end;function c.is_job(a8)if type(a8)~="table"then return false end;return getmetatable(a8)==c end;function c:add_on_exit_callback(C)table.insert(self._additional_on_exit_callbacks,C)end;function c:send(E)if not self.stdin then error"job has no 'stdin'. Have you run `job:start()` yet?"end;self.stdin:write(E)end;return c
