local a=coroutine;local b=require"plenary.functional"local c={}local d={}d.__index=d;function d:__call(e,f)return self.gen(e or self.param,f or self.state)end;function d:__tostring()return"<iterator>"end;local g=function(...)local h=select("#",...)if h>=3 then local i=select(h-2,...)if type(i)=="table"and getmetatable(i)==d and i.param==select(h-1,...)and i.state==select(h,...)then return h-2 end end;return h end;local j=function(k,...)if k==nil then return nil end;return...end;local l=function(m,k,...)if k==nil then return nil end;return k,m(...)end;local n=function(o,p)return nil end;local q=pairs{}local r=function(s,t)local u;t,u=q(s,t)return t,t,u end;local v=function(e,f)f=f+1;if f>#e then return nil end;local w=string.sub(e,f,f)return f,w end;local x=function(y,e,f)assert(y~=nil,"invalid iterator")if type(y)=="table"then local z=getmetatable(y)if z~=nil then if z==d then return y.gen,y.param,y.state end end;if vim.tbl_islist(y)then return ipairs(y)else return r,y,nil end elseif type(y)=="function"then return y,e,f elseif type(y)=="string"then if#y==0 then return n,nil,nil end;return v,y,0 end;error(string.format('object %s of type "%s" is not iterable',y,type(y)))end;local function A(B,e,f)return setmetatable({gen=B,param=e,state=f},d)end;local C=function(self)return self.gen,self.param,self.state end;local D=function(y,e,f)return A(x(y,e,f))end;c.iter=D;c.wrap=A;c.unwrap=C;function d:for_each(E)local e,f=self.param,self.state;repeat f=l(E,self.gen(e,f))until f==nil end;function d:stateful()return A(a.wrap(function()self:for_each(function(...)a.yield(b.first(...),...)end)while true do a.yield()end end),nil,nil)end;local F=function(e,f)local G,H=e[1],e[2]f=f+H;if f>G then return nil end;return f,f end;local I=function(e,f)local G,H=e[1],e[2]f=f+H;if f<G then return nil end;return f,f end;local J=function(K,G,H)if H==nil then if G==nil then if K==0 then return n,nil,nil end;G=K;K=G>0 and 1 or-1 end;H=K<=G and 1 or-1 end;assert(type(K)=="number","start must be a number")assert(type(G)=="number","stop must be a number")assert(type(H)=="number","step must be a number")assert(H~=0,"step must not be zero")if H>0 then return A(F,{G,H},K-H)elseif H<0 then return A(I,{G,H},K-H)end end;c.range=J;local L=function(M,k)return k+1,unpack(M)end;local N=function(M,k)return k+1,M(k)end;local O=function(M,k)return k+1,M end;local P=function(...)if select("#",...)<=1 then return A(O,select(1,...),0)else return A(L,{...},0)end end;c.duplicate=P;local Q=function(m)assert(type(m)=="function")return A(N,m,0)end;c.from_fun=Q;local R=function()return A(O,0,0)end;c.zeros=R;local S=function()return A(O,1,0)end;c.ones=S;local T=function(M,U)return 0,math.random(M[1],M[2])end;local V=function(W,U)return 0,math.random()end;local X=function(h,Y)if h==nil and Y==nil then return A(V,0,0)end;assert(type(h)=="number","invalid first arg to rands")if Y==nil then Y=h;h=0 else assert(type(Y)=="number","invalid second arg to rands")end;assert(h<Y,"empty interval")return A(T,{h,Y-1},0)end;c.rands=X;local Z=function(e,f)local _,a0=e[1],e[2]local a1=#_;if f>a1+1 then return end;local K,a2=string.find(_,a0,f,true)if not K then K=a1+1;a2=a1+1 end;local a3=_:sub(f,K-1)return a2+1,a3 end;local a4=function(_,a0)return A(Z,{_,a0},1)end;c.split=a4;local a5=function(_)return a4(_," ")end;c.words=a5;local a6=function(_)return a4(_,"\n")end;c.lines=a6;local a7=function(e,f)local a8,M,m=e[1],e[2],e[3]return l(m,a8(M,f))end;function d:map(m)return A(a7,{self.gen,self.param,m},self.state)end;local a9;do local i=function(aa,k,...)if k==nil then return nil end;return{aa.gen,aa.param,k},...end;a9=function(f,k,...)if k==nil then return nil end;local ab=b.first(...)if getmetatable(ab)==d then local aa=(ab..A(f[1],f[2],k)):flatten()return i(aa,aa.gen(aa.param,aa.state))end;return{f[1],f[2],k},...end end;local ac=function(ad,f)if f==nil then return end;local a8,M,k=f[1],f[2],f[3]return a9(f,a8(M,k))end;function d:flatten()return A(ac,false,{self.gen,self.param,self.state})end;local ae=function(m,a8,M,k,af)while true do if k==nil or m(af)then break end;k,af=a8(M,k)end;return k,af end;local ag;local ah=function(m,a8,M,k)return ag(m,a8,M,a8(M,k))end;ag=function(m,a8,M,k,...)if k==nil then return nil end;if m(...)then return k,...end;return ah(m,a8,M,k)end;local ai=function(m,a8,M,k,...)if select("#",...)<2 then return ae(m,a8,M,k,...)else return ag(m,a8,M,k,...)end end;local aj=function(e,k)local a8,M,m=e[1],e[2],e[3]return ai(m,a8,M,a8(M,k))end;function d:filter(m)return A(aj,{self.gen,self.param,m},self.state)end;function d:enumerate()local ak=0;return self:map(function(...)ak=ak+1;return ak,...end)end;function d:any(m)local w;local f,e,B=self.state,self.param,self.gen;repeat f,w=l(m,B(e,f))until f==nil or w;return w end;function d:all(m)local w;local f,e,B=self.state,self.param,self.gen;repeat f,w=l(m,B(e,f))until f==nil or not w;return f==nil end;function d:find(al)local B,e,f=self.gen,self.param,self.state;if type(al)=="function"then return j(ai(al,B,e,B(e,f)))else for ad,w in B,e,f do if w==al then return w end end;return nil end end;function d:fold(am,m)local an=am;local B,e,f=self.gen,self.param,self.state;for ad,w in B,e,f do an=m(an,w)end;return an end;function d:tolist()local ao={}self:for_each(function(af)table.insert(ao,af)end)return ao end;function d:tolistn()local ao={}self:for_each(function(...)table.insert(ao,{...})end)return ao end;function d:tomap()local s={}self:for_each(function(t,u)s[t]=u end)return s end;local ap;local aq=function(e,f,k,...)if k==nil then local ak=f[1]+1;if e[3*ak-1]==nil then return nil end;k=e[3*ak]return ap(e,{ak,k})end;return{f[1],k},...end;ap=function(e,f)local ak,k=f[1],f[2]local a8,M=e[3*ak-2],e[3*ak-1]return aq(e,f,a8(M,k))end;local ar=function(...)local h=g(...)if h==0 then return A(n,nil,nil)end;local e={[3*h]=0}local a8,M,k;for ak=1,h,1 do local as=select(ak,...)a8,M,k=C(as)e[3*ak-2]=a8;e[3*ak-1]=M;e[3*ak]=k end;return A(ap,e,{1,e[3]})end;d.chain=ar;d.__concat=ar;c.chain=ar;local function at(e,f,au,...)if#au==#e/2 then return au,...end;local ak=#au+1;local a8,M=e[2*ak-1],e[2*ak]local k,w=a8(M,f[ak])if k==nil then return nil end;table.insert(au,k)return at(e,f,au,w,...)end;local av=function(e,f)return at(e,f,{})end;local aw=function(...)local h=g(...)if h==0 then return A(n,nil,nil)end;local e={[2*h]=0}local f={[h]=0}local a8,M,k;for ak=1,h,1 do local i=select(h-ak+1,...)a8,M,k=x(i)e[2*ak-1]=a8;e[2*ak]=M;f[ak]=k end;return A(av,e,f)end;d.zip=aw;d.__div=aw;c.zip=aw;return c
