local a,b={},{}local c=require"plenary.functional"local d=require"plenary.job"local e=require"plenary.path"a.url_encode=function(f)if type(f)~="number"then f=f:gsub("\r?\n","\r\n")f=f:gsub("([^%w%-%.%_%~ ])",function(g)return string.format("%%%02X",g:byte())end)f=f:gsub(" ","+")return f else return f end end;a.kv_to_list=function(h,i,j)return vim.tbl_flatten(c.kv_map(function(k)return{i,k[1]..j..k[2]}end,h))end;a.kv_to_str=function(h,j,l)return c.join(c.kv_map(function(k)return k[1]..l..a.url_encode(k[2])end,h),j)end;a.gen_dump_path=function()local m;local n=string.gsub("xxxx4xxx","[xy]",function(o)local p=o=="x"and math.random(0,0xf)or math.random(0,0xb)return string.format("%x",p)end)if e.path.sep=="\\"then m=string.format("%s\\AppData\\Local\\Temp\\plenary_curl_%s.headers",os.getenv"USERPROFILE",n)else local q=os.getenv"XDG_RUNTIME_DIR"or"/tmp"m=q.."/plenary_curl_"..n..".headers"end;return{"-D",m}end;b.headers=function(r)if not r then return end;local s=function(f)return string.gsub(" "..f,"%W%l",string.upper):sub(2)end;return a.kv_to_list((function()local t={}for u,p in pairs(r)do t[s(u:gsub("_","%-"))]=p end;return t end)(),"-H",": ")end;b.data_body=function(r)if not r then return end;return a.kv_to_list(r,"-d","=")end;b.raw_body=function(v)if not v then return end;if type(v)=="table"then return b.data_body(v)else return{"--data-raw",v}end end;b.form=function(r)if not r then return end;return a.kv_to_list(r,"-F","=")end;b.curl_query=function(r)if not r then return end;return a.kv_to_str(r,"&","=")end;b.method=function(w)if not w then return end;if w~="head"then return{"-X",string.upper(w)}else return{"-I"}end end;b.file=function(x)if not x then return end;return{"-d","@"..e.expand(e.new(x))}end;b.auth=function(v)if not v then return end;return{"-u",type(v)=="table"and a.kv_to_str(v,nil,":")or v}end;b.url=function(v,y)if not v then return end;y=b.curl_query(y)if type(v)=="string"then return y and v.."?"..y or v elseif type(v)=="table"then error"Low level URL definition is not supported."end end;b.accept_header=function(w)if not w then return end;return{"-H","Accept: "..w}end;b.http_version=function(w)if not w then return end;if w=="HTTP/0.9"or w=="HTTP/1.0"or w=="HTTP/1.1"or w=="HTTP/2"or w=="HTTP/3"then w=w:lower()w=w:gsub("/","")return{"--"..w}else error"Unknown HTTP version."end end;b.request=function(z)if z.body then local A=z.body;local B=function()local C,D=pcall(e.is_file,e.new(A))return C and D end;z.body=nil;if type(A)=="table"then z.data=A elseif B()then z.in_file=A elseif type(A)=="string"then z.raw_body=A end end;local D={"-sSL",z.dump}local E=function(p)if p then table.insert(D,p)end end;if z.compressed then table.insert(D,"--compressed")end;E(b.method(z.method))E(b.headers(z.headers))E(b.accept_header(z.accept))E(b.raw_body(z.raw_body))E(b.data_body(z.data))E(b.form(z.form))E(b.file(z.in_file))E(b.auth(z.auth))E(b.http_version(z.http_version))E(z.raw)if z.output then table.insert(D,{"-o",z.output})end;table.insert(D,b.url(z.url,z.query))return vim.tbl_flatten(D),z end;b.response=function(F,G,H)local I=e.readlines(G)local C=tonumber(string.match(I[1],"([%w+]%d+)"))local J=c.join(F,"\n")vim.loop.fs_unlink(G)table.remove(I,1)return{status=C,headers=I,body=J,exit=H}end;local K=function(L)local M={}local N,z=b.request(vim.tbl_extend("force",{compressed=true,dry_run=false,dump=a.gen_dump_path()},L))if z.dry_run then return N end;local O={command="curl",args=N}if z.stream then O.on_stdout=z.stream else O.on_exit=function(P,H)if H~=0 then local Q=vim.inspect(P:stderr_result())local R=string.format("%s %s - curl error exit_code=%s stderr=%s",z.method,z.url,H,Q)if z.on_error then return z.on_error{message=R,stderr=Q,exit=H}else error(R)end end;local S=b.response(P:result(),z.dump[2],H)if z.callback then return z.callback(S)else M=S end end end;local T=d:new(O)if z.callback or z.stream then T:start()return T else local U=z.timeout or 10000;T:sync(U)return M end end;return(function()local V={}local W=function(X)return function(Y,z)z=z or{}if type(Y)=="table"then z=Y;V.method=X else V.url=Y;V.method=X end;z=X=="request"and z or vim.tbl_extend("keep",z,V)return K(z)end end;return{get=W"get",post=W"post",put=W"put",head=W"head",patch=W"patch",delete=W"delete",request=W"request"}end)()
