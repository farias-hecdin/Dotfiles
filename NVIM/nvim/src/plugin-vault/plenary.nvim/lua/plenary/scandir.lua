local a=require"plenary.path"local b=a.path.sep;local c=require"plenary.functional"local d=vim.loop;local e={}local f=function(g)local h={}local i=false;for j,k in ipairs(g)do local l=a:new(k..b..".gitignore")if l:exists()then i=true;h[k]={ignored={},negated={}}for m in l:iter()do local n=m:sub(1,1)local o=n=="!"if o then m=m:sub(2)n=m:sub(1,1)end;if n=="/"then m=k..m end;if not(n==""or n=="#")then local p=vim.trim(m)p=p:gsub("%-","%%-")p=p:gsub("%.","%%.")p=p:gsub("/%*%*/","/%%w+/")p=p:gsub("%*%*","")p=p:gsub("%*","%%w+")p=p:gsub("%?","%%w")if p~=""then table.insert(o and h[k].negated or h[k].ignored,p)end end end end end;if not i then return nil end;return function(q,r)for j,k in ipairs(q)do if r:find(k,1,true)then local o=false;for j,s in ipairs(h[k].ignored)do if not o and r:match(s)then for j,t in ipairs(h[k].negated)do if not o and r:match(t)then o=true end end;if not o then return false end end end end end;return true end end;e.__make_gitignore=f;local u=function(v,r,w)for j,k in ipairs(v)do if r:find(k,1,true)then local x=r:sub(#k+1,-1)x=x:sub(1,1)==b and x:sub(2,-1)or x;local j,y=x:gsub(b,"")if w<=y+1 then return nil end end end;return r end;local z=function(A)if type(A)=="string"then return function(r)return r:match(A)end elseif type(A)=="table"then return function(r)for j,k in ipairs(A)do if r:match(k)then return true end end;return false end elseif type(A)=="function"then return A end end;local B=function(C,D,E,F,G,q,H,I,J)if C.hidden or D:sub(1,1)~="."then if E=="directory"then local r=F..b..D;if C.depth then table.insert(G,u(q,r,C.depth))else table.insert(G,r)end;if C.add_dirs or C.only_dirs then if not I or I(q,r.."/")then if not J or J(r)then table.insert(H,r)if C.on_insert then C.on_insert(r,E)end end end end elseif not C.only_dirs then local r=F..b..D;if not I or I(q,r)then if not J or J(r)then table.insert(H,r)if C.on_insert then C.on_insert(r,E)end end end end end end;e.scan_dir=function(K,C)C=C or{}local H={}local v=vim.tbl_flatten{K}local G=vim.tbl_flatten{K}local L=C.respect_gitignore and f(v)or nil;local M=C.search_pattern and z(C.search_pattern)or nil;for N=#v,1,-1 do if d.fs_access(v[N],"X")==false then if not c.if_nil(C.silent,false,C.silent)then print(string.format("%s is not accessible by the current user!",v[N]))end;table.remove(v,N)end end;if#v==0 then return{}end;repeat local F=table.remove(G,1)local O=d.fs_scandir(F)if O then while true do local D,E=d.fs_scandir_next(O)if D==nil then break end;B(C,D,E,F,G,v,H,L,M)end end until#G==0;return H end;e.scan_dir_async=function(K,C)C=C or{}local H={}local v=vim.tbl_flatten{K}local G=vim.tbl_flatten{K}local F=table.remove(G,1)local L=C.respect_gitignore and f(v)or nil;local M=C.search_pattern and z(C.search_pattern)or nil;for N=#v,1,-1 do if d.fs_access(v[N],"X")==false then if not c.if_nil(C.silent,false,C.silent)then print(string.format("%s is not accessible by the current user!",v[N]))end;table.remove(v,N)end end;if#v==0 then return{}end;local P;P=function(Q,O)if not Q then while true do local D,E=d.fs_scandir_next(O)if D==nil then break end;B(C,D,E,F,G,v,H,L,M)end;if#G==0 then if C.on_exit then C.on_exit(H)end else F=table.remove(G,1)d.fs_scandir(F,P)end end end;d.fs_scandir(F,P)end;local R=(function()local S=function(T)local U,N=0,1;while T~=0 do U=U+T%8*N;T=math.floor(T/8)N=N*10 end;return U end;local V={[1]="p",[2]="c",[4]="d",[6]="b",[10]=".",[12]="l",[14]="s"}local W={[0]="---","--x","-w-","-wx","r--","r-x","rw-","rwx"}local X={4,2,1}return function(Y,Z)if Y[Z]then return Y[Z]end;local U=string.format("%6d",S(Z))local _=U:sub(#U-3,-1)local a0=tonumber(_:sub(1,1))local a1=V[tonumber(U:sub(1,2))]or"-"for N=2,#_ do a1=a1 ..W[tonumber(_:sub(N,N))]if a0-X[N-1]>=0 then a1=a1:sub(1,-2)..(X[N-1]==1 and"T"or"S")a0=a0-X[N-1]end end;Y[Z]=a1;return a1 end end)()local a2=(function()local a3={"","K","M","G","T","P","E","Z"}return function(a4)for j,k in ipairs(a3)do if math.abs(a4)<1024.0 then if math.abs(a4)>9 then return string.format("%3d%s",a4,k)else return string.format("%3.1f%s",a4,k)end end;a4=a4/1024.0 end;return string.format("%.1f%s",a4,"Y")end end)()local a5=(function()local a6=os.date"%Y"return function(a7)if a6~=os.date("%Y",a7)then return os.date("%b %d  %Y",a7)end;return os.date("%b %d %H:%M",a7)end end)()local a8=(function()local a9=function(aa,ab)if not aa then return ab end;if aa[ab]then return aa[ab]end;aa[ab]=tostring(ab)return ab end;if jit and b~="\\"then local ac=require"ffi"ac.cdef[[
      typedef unsigned int __uid_t;
      typedef __uid_t uid_t;
      typedef unsigned int __gid_t;
      typedef __gid_t gid_t;

      typedef struct {
        char *pw_name;
        char *pw_passwd;
        __uid_t pw_uid;
        __gid_t pw_gid;
        char *pw_gecos;
        char *pw_dir;
        char *pw_shell;
      } passwd;

      passwd *getpwuid(uid_t uid);
    ]]local ad=function(aa,ab)if aa[ab]then return aa[ab]end;local ae=ac.C.getpwuid(ab)local D;if ae==nil then D=tostring(ab)else D=ac.string(ae.pw_name)end;aa[ab]=D;return D end;local af=pcall(ad,{},1000)if af then return ad else return a9 end else return a9 end end)()local ag=(function()local a9=function(aa,ab)if not aa then return ab end;if aa[ab]then return aa[ab]end;aa[ab]=tostring(ab)return ab end;if jit and b~="\\"then local ac=require"ffi"ac.cdef[[
      typedef unsigned int __gid_t;
      typedef __gid_t gid_t;

      typedef struct {
        char *gr_name;
        char *gr_passwd;
        __gid_t gr_gid;
        char **gr_mem;
      } group;
      group *getgrgid(gid_t gid);
    ]]local ad=function(aa,ab)if aa[ab]then return aa[ab]end;local ae=ac.C.getgrgid(ab)local D;if ae==nil then D=tostring(ab)else D=ac.string(ae.gr_name)end;aa[ab]=D;return D end;local af=pcall(ad,{},1000)if af then return ad else return a9 end else return a9 end end)()local ah=function(aa)if not aa then return 0 end;local ai=0;for j,k in pairs(aa)do if#k>ai then ai=#k end end;return ai end;local aj=function(H,K,C)if not H or#H==0 then return{},{}end;local ak=function(al,am)if al:sub(1,1)=="l"then local an=d.fs_realpath(K..b..am)if not an then return am end;if an:sub(1,#K)==K then an=an:sub(#K+2,-1)end;return string.format("%s -> %s",am,an)end;return am end;local ao,ap={},{}local aq=b~="\\"and{}or nil;local ar=b~="\\"and{}or nil;local as,at={},{}for j,k in ipairs(H)do local au=d.fs_lstat(k)if au then as[k]=au;a8(aq,au.uid)ag(ar,au.gid)end end;local av=(function()if not aq and not ar then local aw={[5]=2,[6]=0}return function(...)local ax={...}local ay={{start_index=01,end_index=11},{start_index=12,end_index=17}}local az=19;for aA=5,6 do local k=aw[aA]local aB=az+#ax[aA]table.insert(ay,{start_index=az,end_index=aB})az=aB+k end;table.insert(ap,ay)table.insert(ao,string.format("%10s %5s  %s  %s",ax[1],ax[2],ax[5],ak(ax[1],ax[6])))end else local aC=ah(aq)local aD=ah(ar)local aw={[3]={max=aC,add=1},[4]={max=aD,add=2},[5]={add=2},[6]={add=0}}local aE="%10s %5s %-"..aC.."s %-"..aD.."s  %s  %s"return function(...)local ax={...}local ay={{start_index=01,end_index=11},{start_index=12,end_index=17}}local az=18;for aA=3,6 do local k=aw[aA]local aB=az+#ax[aA]table.insert(ay,{start_index=az,end_index=aB})if k.max then az=az+k.max+k.add else az=aB+k.add end end;table.insert(ap,ay)table.insert(ao,string.format(aE,ax[1],ax[2],ax[3],ax[4],ax[5],ak(ax[1],ax[6])))end end end)()for D,au in pairs(as)do av(R(at,au.mode),a2(au.size),a8(aq,au.uid),ag(ar,au.gid),a5(au.mtime.sec),D:sub(#K+2,-1))end;if C and C.group_directories_first then local aF={}local aG={}for aA,k in ipairs(ao)do if k:sub(1,1)=="d"then table.insert(aF,k)table.insert(aG,ap[aA])end end;for aA,k in ipairs(ao)do if k:sub(1,1)~="d"then table.insert(aF,k)table.insert(aG,ap[aA])end end;return aF,aG else return ao,ap end end;e.ls=function(K,C)C=C or{}C.depth=C.depth or 1;C.add_dirs=C.add_dirs or true;local H=e.scan_dir(K,C)return aj(H,K,C)end;e.ls_async=function(K,C)C=C or{}C.depth=C.depth or 1;C.add_dirs=C.add_dirs or true;local aH=vim.deepcopy(C)aH.on_exit=function(H)if C.on_exit then C.on_exit(aj(H,K,aH))end end;e.scan_dir_async(K,aH)end;return e
