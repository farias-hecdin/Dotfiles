local a=require"plenary.async.async"local b=require("plenary.async.structs").Deque;local c=require"plenary.tbl"local d={}local e={}e.__index=e;function e.new()return setmetatable({handles={}},e)end;e.wait=a.wrap(function(self,f)table.insert(self.handles,f)end,2)function e:notify_all()local g=#self.handles;for h,f in ipairs(self.handles)do if h>g then break end;f()end;for i=1,g do table.remove(self.handles)end end;function e:notify_one()if#self.handles==0 then return end;local j=math.random(#self.handles)self.handles[j]()table.remove(self.handles,j)end;d.Condvar=e;local k={}k.__index=k;function k.new(l)vim.validate{initial_permits={l,function(m)return m>0 end,"number greater than 0"}}return setmetatable({permits=l,handles={}},k)end;k.acquire=a.wrap(function(self,f)if self.permits>0 then self.permits=self.permits-1 else table.insert(self.handles,f)return end;local n={}n.forget=function(o)self.permits=self.permits+1;if self.permits>0 and#self.handles>0 then self.permits=self.permits-1;table.remove(self.handles)(o)end end;f(n)end,2)d.Semaphore=k;d.channel={}d.channel.oneshot=function()local p=nil;local q=nil;local r=false;local s=false;local t=false;local u=function(...)assert(not r,"Oneshot channel can only send once")r=true;if q~=nil then q(...)return end;local v=select("#",...)if v==1 or v==0 then p=...t=true else p=c.pack(...)end end;local w=a.wrap(function(f)assert(not s,"Oneshot channel can only receive one value!")if r then s=true;if t then return f(p)else return f(c.unpack(p))end else q=f end end,1)return u,w end;d.channel.counter=function()local x=0;local y=e.new()local z={}function z:send()x=x+1;y:notify_all()end;local A={}A.recv=function()if x==0 then y:wait()end;x=x-1 end;A.last=function()if x==0 then y:wait()end;x=0 end;return z,A end;d.channel.mpsc=function()local B=b.new()local y=e.new()local z={}function z.send(...)B:pushleft{...}y:notify_all()end;local A={}A.recv=function()if B:is_empty()then y:wait()end;return unpack(B:popright())end;A.last=function()if B:is_empty()then y:wait()end;local p=B:popleft()B:clear()return unpack(p or{})end;return z,A end;return d
