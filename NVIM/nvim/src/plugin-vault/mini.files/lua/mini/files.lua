local a={}local b={}a.setup=function(c)_G.MiniFiles=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()end;a.config={content={filter=nil,prefix=nil,sort=nil},mappings={close='q',go_in='l',go_in_plus='L',go_out='h',go_out_plus='H',reset='<BS>',reveal_cwd='@',show_help='g?',synchronize='=',trim_left='<',trim_right='>'},options={permanent_delete=true,use_as_default_explorer=true},windows={max_number=math.huge,preview=false,width_focus=50,width_nofocus=15,width_preview=25}}a.open=function(d,e,f)d=b.fs_full_path(d or vim.fn.getcwd())local g=b.fs_get_type(d)if g==nil then b.error('`path` is not a valid path ("'..d..'")')end;local h;if g=='file'then d,h=b.fs_get_parent(d),b.fs_get_basename(d)end;if e==nil then e=true end;local i=a.close()if i==false then return end;local j;if e then j=b.explorer_path_history[d]end;j=j or b.explorer_new(d)j.opts=b.normalize_opts(nil,f)j.target_window=vim.api.nvim_get_current_win()j=b.explorer_focus_on_entry(j,d,h)b.explorer_refresh(j)b.latest_paths[vim.api.nvim_get_current_tabpage()]=d;b.explorer_track_lost_focus()end;a.refresh=function(f)local j=b.explorer_get()if j==nil then return end;local k=(f or{}).content or{}local l=#vim.tbl_keys(k)>0;if l then l=b.explorer_confirm_modified(j,'buffer updates')end;j.opts=b.normalize_opts(j.opts,f)b.explorer_refresh(j,{force_update=l})end;a.synchronize=function()local j=b.explorer_get()if j==nil then return end;local m=b.explorer_compute_fs_actions(j)if m~=nil and b.fs_actions_confirm(m)then b.fs_actions_apply(m,j.opts)end;b.explorer_refresh(j,{force_update=true})end;a.reset=function()local j=b.explorer_get()if j==nil then return end;j.branch={j.anchor}j.depth_focus=1;for n,o in pairs(j.views)do o.cursor={1,0}end;b.explorer_refresh(j,{skip_update_cursor=true})end;a.close=function()local j=b.explorer_get()if j==nil then return nil end;pcall(vim.loop.timer_stop,b.timers.focus)if not b.explorer_confirm_modified(j,'close')then return false end;j=b.explorer_ensure_target_window(j)pcall(vim.api.nvim_set_current_win,j.target_window)j=b.explorer_update_cursors(j)for p,q in pairs(j.windows)do b.window_close(q)j.windows[p]=nil end;for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do local r=vim.api.nvim_win_get_buf(q)if vim.bo[r].filetype=='minifiles-help'then vim.api.nvim_win_close(q,true)end end;for d,o in pairs(j.views)do j.views[d]=b.view_invalidate_buffer(b.view_encode_cursor(o))end;local s,t=vim.api.nvim_get_current_tabpage(),j.anchor;b.explorer_path_history[t]=j;b.opened_explorers[s]=nil;return true end;a.go_in=function()local j=b.explorer_get()if j==nil then return end;local u=vim.fn.line('.')j=b.explorer_go_in_range(j,vim.api.nvim_get_current_buf(),u,u)b.explorer_refresh(j)end;a.go_out=function()local j=b.explorer_get()if j==nil then return end;if j.depth_focus==1 then j=b.explorer_open_root_parent(j)else j.depth_focus=j.depth_focus-1 end;b.explorer_refresh(j)end;a.trim_left=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_left(j)b.explorer_refresh(j)end;a.trim_right=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_right(j)b.explorer_refresh(j)end;a.reveal_cwd=function()local j=b.explorer_get()if j==nil then return end;local v=b.fs_full_path(vim.fn.getcwd())local w=string.format('^%s/.',vim.pesc(v))while j.branch[1]:find(w)~=nil do local x,y=b.fs_get_parent(j.branch[1]),b.fs_get_basename(j.branch[1])table.insert(j.branch,1,x)j.depth_focus=j.depth_focus+1;local z=j.views[x]or{}z.cursor=y;j.views[x]=z end;b.explorer_refresh(j)end;a.show_help=function()local j=b.explorer_get()if j==nil then return end;local r=vim.api.nvim_get_current_buf()if not b.is_opened_buffer(r)then return end;b.explorer_show_help(r,vim.api.nvim_get_current_win())end;a.get_fs_entry=function(r,A)r=b.validate_opened_buffer(r)A=b.validate_line(r,A)local B=b.match_line_path_id(b.get_bufline(r,A))if B==nil then return nil end;local d=b.path_index[B]return{fs_type=b.fs_get_type(d),name=b.fs_get_basename(d),path=d}end;a.get_target_window=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_ensure_target_window(j)return j.target_window end;a.set_target_window=function(q)if not b.is_valid_win(q)then b.error('`win_id` should be valid window identifier.')end;local j=b.explorer_get()if j==nil then return end;j.target_window=q end;a.get_latest_path=function()return b.latest_paths[vim.api.nvim_get_current_tabpage()]end;a.default_filter=function(C)return true end;a.default_prefix=function(C)if C.fs_type=='directory'then return' ','MiniFilesDirectory'end;local D,E=pcall(require,'nvim-web-devicons')if not D then return' ','MiniFilesFile'end;local F,G=E.get_icon(C.name,nil,{default=false})return(F or'')..' ',G or'MiniFilesFile'end;a.default_sort=function(H)local I=vim.tbl_map(function(J)return{fs_type=J.fs_type,name=J.name,path=J.path,lower_name=J.name:lower(),is_dir=J.fs_type=='directory'}end,H)table.sort(I,b.compare_fs_entries)return vim.tbl_map(function(J)return{name=J.name,fs_type=J.fs_type,path=J.path}end,I)end;b.default_config=vim.deepcopy(a.config)b.ns_id={highlight=vim.api.nvim_create_namespace('MiniFilesHighlight')}b.timers={focus=vim.loop.new_timer()}b.path_index={}b.explorer_path_history={}b.opened_explorers={}b.latest_paths={}b.opened_buffers={}b.is_windows=vim.loop.os_uname().sysname=='Windows_NT'b.block_event_trigger={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({content={c.content,'table'},mappings={c.mappings,'table'},options={c.options,'table'},windows={c.windows,'table'}})vim.validate({['content.filter']={c.content.filter,'function',true},['content.prefix']={c.content.prefix,'function',true},['content.sort']={c.content.sort,'function',true},['mappings.close']={c.mappings.close,'string'},['mappings.go_in']={c.mappings.go_in,'string'},['mappings.go_in_plus']={c.mappings.go_in_plus,'string'},['mappings.go_out']={c.mappings.go_out,'string'},['mappings.go_out_plus']={c.mappings.go_out_plus,'string'},['mappings.reset']={c.mappings.reset,'string'},['mappings.reveal_cwd']={c.mappings.reveal_cwd,'string'},['mappings.show_help']={c.mappings.show_help,'string'},['mappings.synchronize']={c.mappings.synchronize,'string'},['mappings.trim_left']={c.mappings.trim_left,'string'},['mappings.trim_right']={c.mappings.trim_right,'string'},['options.use_as_default_explorer']={c.options.use_as_default_explorer,'boolean'},['options.permanent_delete']={c.options.permanent_delete,'boolean'},['windows.max_number']={c.windows.max_number,'number'},['windows.preview']={c.windows.preview,'boolean'},['windows.width_focus']={c.windows.width_focus,'number'},['windows.width_nofocus']={c.windows.width_nofocus,'number'},['windows.width_preview']={c.windows.width_preview,'number'}})return c end;b.apply_config=function(c)a.config=c end;b.create_autocommands=function(c)local K=vim.api.nvim_create_augroup('MiniFiles',{})local L=function(M,N,O,P)vim.api.nvim_create_autocmd(M,{group=K,pattern=N,callback=O,desc=P})end;L('VimResized','*',a.refresh,'Refresh on resize')if c.options.use_as_default_explorer then vim.cmd('silent! autocmd! FileExplorer *')vim.cmd('autocmd VimEnter * ++once silent! autocmd! FileExplorer *')L('BufEnter','*',b.track_dir_edit,'Track directory edit')end end;b.create_default_hl=function()local Q=function(y,f)f.default=true;vim.api.nvim_set_hl(0,y,f)end;Q('MiniFilesBorder',{link='FloatBorder'})Q('MiniFilesBorderModified',{link='DiagnosticFloatingWarn'})Q('MiniFilesCursorLine',{link='CursorLine'})Q('MiniFilesDirectory',{link='Directory'})Q('MiniFilesFile',{})Q('MiniFilesNormal',{link='NormalFloat'})Q('MiniFilesTitle',{link='FloatTitle'})Q('MiniFilesTitleFocused',{link='FloatTitle'})end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minifiles_config or{},c or{})end;b.normalize_opts=function(R,f)f=vim.tbl_deep_extend('force',b.get_config(),R or{},f or{})f.content.filter=f.content.filter or a.default_filter;f.content.prefix=f.content.prefix or a.default_prefix;f.content.sort=f.content.sort or a.default_sort;return f end;b.track_dir_edit=function(S)if vim.api.nvim_get_current_buf()~=S.buf then return end;if vim.b.minifiles_processed_dir then return vim.api.nvim_buf_delete(0,{force=true})end;local d=vim.api.nvim_buf_get_name(0)if vim.fn.isdirectory(d)~=1 then return end;vim.bo.bufhidden='wipe'vim.b.minifiles_processed_dir=true;vim.schedule(function()a.open(d,false)end)end;b.explorer_new=function(d)return{branch={d},depth_focus=1,views={},windows={},anchor=d,target_window=vim.api.nvim_get_current_win(),opts={}}end;b.explorer_get=function(s)s=s or vim.api.nvim_get_current_tabpage()local I=b.opened_explorers[s]if b.explorer_is_visible(I)then return I end;b.opened_explorers[s]=nil;return nil end;b.explorer_is_visible=function(j)if j==nil then return nil end;for n,q in ipairs(j.windows)do if b.is_valid_win(q)then return true end end;return false end;b.explorer_refresh=function(j,f)j=b.explorer_normalize(j)if#j.branch==0 then return end;f=f or{}if not f.skip_update_cursor then j=b.explorer_update_cursors(j)end;if f.force_update then for d,o in pairs(j.views)do o=b.view_encode_cursor(o)o.children_path_ids=b.buffer_update(o.buf_id,d,j.opts)j.views[d]=o end end;for T=1,#j.branch do j=b.explorer_sync_cursor_and_branch(j,T)end;for n,q in ipairs(j.windows)do local r=vim.api.nvim_win_get_buf(q)b.opened_buffers[r].win_id=nil end;local U=b.compute_visible_depth_range(j,j.opts)local V,W=0,0;for T=U.from,U.to do W=W+1;local X=b.explorer_refresh_depth_window(j,T,W,V)V=V+X+2 end;for T=W+1,#j.windows do b.window_close(j.windows[T])j.windows[T]=nil end;local Y=j.depth_focus-U.from+1;local Z=j.windows[Y]b.window_focus(Z)local s=vim.api.nvim_win_get_tabpage(Z)b.opened_explorers[s]=j;return j end;b.explorer_track_lost_focus=function()local _=vim.schedule_wrap(function()local a0=vim.bo.filetype;if a0=='minifiles'or a0=='minifiles-help'then return end;local a1=vim.api.nvim_get_current_win()a.close()pcall(vim.api.nvim_set_current_win,a1)end)b.timers.focus:start(1000,1000,_)end;b.explorer_normalize=function(j)local a2={}for n,d in ipairs(j.branch)do if not b.fs_is_present_path(d)then break end;table.insert(a2,d)end;local a3=#a2;j.branch=a2;j.depth_focus=math.min(math.max(j.depth_focus,1),a3)for p=a3+1,#j.windows do b.window_close(j.windows[p])j.windows[p]=nil end;return j end;b.explorer_sync_cursor_and_branch=function(j,T)if#j.branch<T then return j end;local d,a4=j.branch[T],j.branch[T+1]local o=j.views[d]if o==nil then return j end;local r,a5=o.buf_id,o.cursor;if a5==nil then return j end;local a6;if type(a5)=='table'and b.is_valid_buf(r)then local a7=b.get_bufline(r,a5[1])a6=b.path_index[b.match_line_path_id(a7)]elseif type(a5)=='string'then a6=b.fs_child_path(d,a5)else return j end;if a6==a4 then return j end;for p=T+1,#j.branch do j.branch[p]=nil end;j.depth_focus=math.min(j.depth_focus,#j.branch)local a8=j.opts.windows.preview;local a9=type(a6)=='string'and b.fs_is_present_path(a6)local aa=r==vim.api.nvim_get_current_buf()if a8 and a9 and aa then table.insert(j.branch,a6)end;return j end;b.explorer_go_in_range=function(j,r,ab,ac)local ad,d,A={},nil,nil;for p=ab,ac do local C=a.get_fs_entry(r,p)or{}if C.fs_type=='file'then table.insert(ad,C.path)end;if C.fs_type=='directory'then d,A=C.path,p end end;for n,ae in ipairs(ad)do j=b.explorer_open_file(j,ae)end;if d~=nil then j=b.explorer_open_directory(j,d,j.depth_focus+1)local q=b.opened_buffers[r].win_id;if b.is_valid_win(q)then vim.api.nvim_win_set_cursor(q,{A,0})end end;return j end;b.explorer_focus_on_entry=function(j,d,h)if h==nil then return j end;j.depth_focus=b.explorer_get_path_depth(j,d)if j.depth_focus==nil then j.branch,j.depth_focus={d},1 end;local af=j.views[d]or{}af.cursor=h;j.views[d]=af;return j end;b.explorer_compute_fs_actions=function(j)local ag={}for n,o in pairs(j.views)do local ah=b.buffer_compute_fs_diff(o.buf_id,o.children_path_ids)if#ah>0 then vim.list_extend(ag,ah)end end;if#ag==0 then return nil end;local ai,aj,ak,al,am={},{},{},{},{}for n,an in ipairs(ag)do if an.from==nil then table.insert(ai,an.to)elseif an.to==nil then aj[an.from]=true else table.insert(am,an)end end;local ao={}for n,an in pairs(am)do if aj[an.from]then if b.fs_get_parent(an.from)==b.fs_get_parent(an.to)then table.insert(ak,an)else table.insert(al,an)end;aj[an.from]=nil else table.insert(ao,an)end end;return{create=ai,delete=vim.tbl_keys(aj),copy=ao,rename=ak,move=al}end;b.explorer_update_cursors=function(j)for n,q in ipairs(j.windows)do if b.is_valid_win(q)then local r=vim.api.nvim_win_get_buf(q)local d=b.opened_buffers[r].path;j.views[d].cursor=vim.api.nvim_win_get_cursor(q)end end;return j end;b.explorer_refresh_depth_window=function(j,T,ap,aq)local d=j.branch[T]local ar,as,f=j.views,j.windows,j.opts;local o=ar[d]or{}o=b.view_ensure_proper(o,d,f)ar[d]=o;local at=T==j.depth_focus;local au=f.windows.preview and T==j.depth_focus+1;local X=at and f.windows.width_focus or(au and f.windows.width_preview or f.windows.width_nofocus)local c={col=aq,height=vim.api.nvim_buf_line_count(o.buf_id),width=X,title=ap==1 and b.fs_shorten_path(b.fs_full_path(d))or b.fs_get_basename(d)}local q=as[ap]if not b.is_valid_win(q)then b.window_close(q)q=b.window_open(o.buf_id,c)as[ap]=q end;b.window_update(q,c)b.window_set_view(q,o)j.views=ar;j.windows=as;return X end;b.explorer_get_path_depth=function(j,d)for T,av in pairs(j.branch)do if d==av then return T end end end;b.explorer_confirm_modified=function(j,aw)local ax=false;for n,o in pairs(j.views)do if b.is_modified_buffer(o.buf_id)then ax=true end end;if not ax then return true end;local ay=string.format('There is at least one modified buffer\n\nConfirm %s without synchronization?',aw)local az=vim.fn.confirm(ay,'&Yes\n&No',1,'Question')return az==1 end;b.explorer_open_file=function(j,d)j=b.explorer_ensure_target_window(j)local aA;for n,r in ipairs(vim.api.nvim_list_bufs())do local aB=b.is_valid_buf(r)and vim.bo[r].buflisted and vim.api.nvim_buf_get_name(r)==d;if aB then aA=r end end;if aA~=nil then vim.api.nvim_win_set_buf(j.target_window,aA)else local aC=vim.fn.fnameescape(vim.fn.fnamemodify(d,':.'))pcall(vim.fn.win_execute,j.target_window,'edit '..aC)end;return j end;b.explorer_ensure_target_window=function(j)if not b.is_valid_win(j.target_window)then j.target_window=b.get_first_valid_normal_window()end;return j end;b.explorer_open_directory=function(j,d,aD)j.depth_focus=aD;local aE=d~=j.branch[aD]if aE then j.branch[aD]=d;j=b.explorer_trim_branch_right(j)end;return j end;b.explorer_open_root_parent=function(j)local aF=j.branch[1]local aG=b.fs_get_parent(aF)if aG==nil then return j end;table.insert(j.branch,1,aG)return b.explorer_focus_on_entry(j,aG,b.fs_get_basename(aF))end;b.explorer_trim_branch_right=function(j)for p=j.depth_focus+1,#j.branch do j.branch[p]=nil end;return j end;b.explorer_trim_branch_left=function(j)local aH={}for p=j.depth_focus,#j.branch do table.insert(aH,j.branch[p])end;j.branch=aH;j.depth_focus=1;return j end;b.explorer_show_help=function(aI,aJ)local aK=vim.api.nvim_buf_get_keymap(aI,'n')local aL,aM={},0;for n,S in ipairs(aK)do if S.desc~=nil then aL[S.desc]=S.lhs:lower()=='<lt>'and'<'or S.lhs;aM=math.max(aM,S.desc:len())end end;local aN=vim.tbl_keys(aL)table.sort(aN)local aO=string.format('%%-%ds │ %%s',aM)local aP={'Buffer mappings:',''}for n,P in ipairs(aN)do table.insert(aP,string.format(aO,P,aL[P]))end;table.insert(aP,'')table.insert(aP,'(Press `q` to close)')local r=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_lines(r,0,-1,false,aP)vim.keymap.set('n','q','<Cmd>close<CR>',{buffer=r,desc='Close this window'})vim.b[r].minicursorword_disable=true;vim.b[r].miniindentscope_disable=true;vim.bo[r].filetype='minifiles-help'local aQ=vim.tbl_map(vim.fn.strdisplaywidth,aP)local aR=math.max(unpack(aQ))local c=vim.api.nvim_win_get_config(aJ)c.relative='win'c.row=0;c.col=0;c.width=aR;c.height=#aP;c.title=vim.fn.has('nvim-0.9')==1 and[['mini.files' help]]or nil;c.zindex=c.zindex+1;c.style='minimal'local q=vim.api.nvim_open_win(r,false,c)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.window_update_highlight(q,'CursorLine','MiniFilesCursorLine')vim.wo[q].cursorline=true;vim.api.nvim_set_current_win(q)return q end;b.compute_visible_depth_range=function(j,f)local aS,aT=f.windows.width_focus+2,f.windows.width_nofocus+2;local aU=j.opts.windows.preview and j.depth_focus<#j.branch;local aV=aU and f.windows.width_preview+2 or aT;local aW=1;if aS+aV<=vim.o.columns then aW=aW+1 end;if aS+aV+aT<=vim.o.columns then aW=aW+math.floor((vim.o.columns-aS-aV)/aT)end;aW=math.min(math.max(aW,1),f.windows.max_number)local aX,aY=#j.branch,j.depth_focus;local aZ=math.min(aX,aW)local a_=math.min(aX,math.floor(aY+0.5*aZ))local b0=math.max(1,a_-aZ+1)a_=b0+math.min(aZ,aX)-1;return{from=b0,to=a_}end;b.view_ensure_proper=function(o,d,f)if not b.is_valid_buf(o.buf_id)then b.buffer_delete(o.buf_id)o.buf_id=b.buffer_create(d,f.mappings)o.children_path_ids=b.buffer_update(o.buf_id,d,f)end;o.cursor=o.cursor or{1,0}if type(o.cursor)=='string'then o=b.view_decode_cursor(o)end;return o end;b.view_encode_cursor=function(o)local r,a5=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a5)~='table'then return o end;local a7=b.get_bufline(r,a5[1])o.cursor=b.match_line_entry_name(a7)return o end;b.view_decode_cursor=function(o)local r,a5=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a5)~='string'then return o end;local aP=vim.api.nvim_buf_get_lines(r,0,-1,false)for p,a7 in ipairs(aP)do if a5==b.match_line_entry_name(a7)then o.cursor={p,0}end end;if type(o.cursor)~='table'then o.cursor={1,0}end;return o end;b.view_invalidate_buffer=function(o)b.buffer_delete(o.buf_id)o.buf_id=nil;o.children_path_ids=nil;return o end;b.view_track_cursor=vim.schedule_wrap(function(S)local r=S.buf;local b1=b.opened_buffers[r]if b1==nil then return end;local q=b1.win_id;if not b.is_valid_win(q)then return end;local b2=b.window_tweak_cursor(q,r)local s=vim.api.nvim_win_get_tabpage(q)local j=b.explorer_get(s)if j==nil then return end;local b3=b.explorer_get_path_depth(j,b1.path)if b3==nil then return end;local o=j.views[b1.path]if o~=nil then o.cursor=b2;j.views[b1.path]=o end;j=b.explorer_sync_cursor_and_branch(j,b3)b.block_event_trigger['MiniFilesWindowUpdate']=true;b.explorer_refresh(j)b.block_event_trigger['MiniFilesWindowUpdate']=false end)b.view_track_text_change=function(S)local r=S.buf;local b4=b.opened_buffers[r].n_modified+1;b.opened_buffers[r].n_modified=b4;local q=b.opened_buffers[r].win_id;if b4>0 and b.is_valid_win(q)then b.window_update_border_hl(q)end;if not b.is_valid_win(q)then return end;local b5=vim.api.nvim_buf_line_count(r)local b6=math.min(b5,b.window_get_max_height())vim.api.nvim_win_set_height(q,b6)local b7=vim.fn.line('w0',q)+b6-1;local b8=b7-b5;if b8>0 then vim.cmd('normal! '..b8 ..'\25')end end;b.buffer_create=function(d,b9)local r=vim.api.nvim_create_buf(false,true)b.opened_buffers[r]={path=d}b.buffer_make_mappings(r,b9)local K=vim.api.nvim_create_augroup('MiniFiles',{clear=false})local L=function(ba,P,O)vim.api.nvim_create_autocmd(ba,{group=K,buffer=r,desc=P,callback=O})end;L({'CursorMoved','CursorMovedI'},'Tweak cursor position',b.view_track_cursor)L({'TextChanged','TextChangedI','TextChangedP'},'Track buffer modification',b.view_track_text_change)vim.b[r].minicursorword_disable=true;vim.bo[r].filetype='minifiles'b.trigger_event('MiniFilesBufferCreate',{buf_id=r})return r end;b.buffer_make_mappings=function(r,b9)local bb=function()for n=1,vim.v.count1 do a.go_in()end end;local bc=function()for n=1,vim.v.count1-1 do a.go_in()end;local C=a.get_fs_entry()local bd=C~=nil and C.fs_type=='file'a.go_in()if bd then a.close()end end;local be=function()for n=1,vim.v.count1 do a.go_out()end end;local bf=function()be()a.trim_right()end;local bg=function()if vim.fn.mode()~='V'then return b9.go_in end;local bh,bi=vim.fn.line('v'),vim.fn.line('.')local ab,ac=math.min(bh,bi),math.max(bh,bi)vim.schedule(function()local j=b.explorer_get()j=b.explorer_go_in_range(j,r,ab,ac)b.explorer_refresh(j)end)return[[<C-\><C-n>]]end;local bj=function(bk,bl,bm,P)b.map(bk,bl,bm,{buffer=r,desc=P,nowait=true})end;bj('n',b9.close,a.close,'Close')bj('n',b9.go_in,bb,'Go in entry')bj('n',b9.go_in_plus,bc,'Go in entry plus')bj('n',b9.go_out,be,'Go out of directory')bj('n',b9.go_out_plus,bf,'Go out of directory plus')bj('n',b9.reset,a.reset,'Reset')bj('n',b9.reveal_cwd,a.reveal_cwd,'Reveal cwd')bj('n',b9.show_help,a.show_help,'Show Help')bj('n',b9.synchronize,a.synchronize,'Synchronize')bj('n',b9.trim_left,a.trim_left,'Trim branch left')bj('n',b9.trim_right,a.trim_right,'Trim branch right')b.map('x',b9.go_in,bg,{buffer=r,desc='Go in selected entries',expr=true})end;b.buffer_update=function(r,d,f)if not(b.is_valid_buf(r)and b.fs_is_present_path(d))then return end;local bn=b.fs_get_type(d)=='directory'and b.buffer_update_directory or b.buffer_update_file;local H=bn(r,d,f)b.trigger_event('MiniFilesBufferUpdate',{buf_id=r,win_id=b.opened_buffers[r].win_id})b.opened_buffers[r].n_modified=-1;return vim.tbl_map(function(J)return J.path_id end,H)end;b.buffer_update_directory=function(r,d,f)local aP,bo,bp={},{},{}local H=b.fs_read_dir(d,f.content)local bq=math.floor(math.log10(#b.path_index))+1;local br='/%0'..bq..'d/%s/%s'local bs=f.content.prefix;for n,bt in ipairs(H)do local bu,G=bs(bt)bu,G=bu or'',G or''table.insert(aP,string.format(br,b.path_index[bt.path],bu,bt.name))table.insert(bo,G)table.insert(bp,bt.fs_type=='directory'and'MiniFilesDirectory'or'MiniFilesFile')end;b.set_buflines(r,aP)local bv=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(r,bv,0,-1)local bw=function(A,bx,by)b.set_extmark(r,bv,A,bx,by)end;for p,a7 in ipairs(aP)do local bz,bA=a7:match('^/%d+/().-()/')local bB={hl_group=bo[p],end_col=bA-1,right_gravity=false}bw(p-1,bz-1,bB)local bC={hl_group=bp[p],end_row=p,end_col=0,right_gravity=false}bw(p-1,bA-1,bC)end;return H end;b.buffer_update_file=function(r,d,f)local bD=vim.loop.fs_open(d,'r',1)local bE=vim.loop.fs_read(bD,1024):find('\0')==nil;vim.loop.fs_close(bD)if not bE then b.set_buflines(r,{'-Non-text-file'..string.rep('-',f.windows.width_preview)})return{}end;local bF,bG=pcall(vim.fn.readfile,d,'',vim.o.lines)local aP=bF and vim.split(table.concat(bG,'\n'),'\n')or{}b.set_buflines(r,aP)if b.buffer_should_highlight(r)then local a0=vim.filetype.match({buf=r,filename=d})local bH,bI=pcall(vim.treesitter.language.get_lang,a0)local bJ,n=pcall(vim.treesitter.start,r,bH and bI or a0)if not bJ then vim.bo[r].syntax=a0 end end;return{}end;b.buffer_delete=function(r)if r==nil then return end;pcall(vim.api.nvim_buf_delete,r,{force=true})b.opened_buffers[r]=nil end;b.buffer_compute_fs_diff=function(r,bK)if not b.is_modified_buffer(r)then return{}end;local d=b.opened_buffers[r].path;local aP=vim.api.nvim_buf_get_lines(r,0,-1,false)local I,bL={},{}for n,a7 in ipairs(aP)do local B=b.match_line_path_id(a7)local bM=b.path_index[B]local bN=B~=nil and a7:sub(b.match_line_offset(a7))or a7;local bO=b.fs_child_path(d,bN)..(vim.endswith(bN,'/')and'/'or'')if a7:find('^%s*$')==nil and bM~=bO then table.insert(I,{from=bM,to=bO})elseif B~=nil then bL[B]=true end end;for n,bP in ipairs(bK)do if not bL[bP]then table.insert(I,{from=b.path_index[bP],to=nil})end end;return I end;b.buffer_should_highlight=function(r)if vim.fn.has('nvim-0.8')==0 then return false end;local bQ=vim.api.nvim_buf_call(r,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return bQ<=1000000 and bQ<=1000*vim.api.nvim_buf_line_count(r)end;b.is_opened_buffer=function(r)return b.opened_buffers[r]~=nil end;b.is_modified_buffer=function(r)local S=b.opened_buffers[r]return S~=nil and S.n_modified>0 end;b.match_line_entry_name=function(a7)if a7==nil then return nil end;local bR=b.match_line_offset(a7)local I=a7:sub(bR):gsub('/.*$','')return I end;b.match_line_offset=function(a7)if a7==nil then return nil end;return a7:match('^/.-/.-/()')or 1 end;b.match_line_path_id=function(a7)if a7==nil then return nil end;local bS=a7:match('^/(%d+)')local bT,I=pcall(tonumber,bS)if not bT then return nil end;return I end;b.window_open=function(r,c)c.anchor='NW'c.border='single'c.focusable=true;c.relative='editor'c.style='minimal'c.zindex=99;c.row=1;if vim.fn.has('nvim-0.9')==0 then c.title=nil end;local q=vim.api.nvim_open_win(r,false,c)vim.wo[q].concealcursor='nvic'vim.wo[q].foldenable=false;vim.wo[q].wrap=false;vim.api.nvim_win_call(q,function()vim.fn.matchadd('Conceal',[[^/\d\+/]])vim.fn.matchadd('Conceal',[[^/\d\+/[^/]*\zs/\ze]])end)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.window_update_highlight(q,'CursorLine','MiniFilesCursorLine')b.trigger_event('MiniFilesWindowOpen',{buf_id=r,win_id=q})return q end;b.window_update=function(q,c)local bU=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bV=b.window_get_max_height()c.row=bU and 1 or 0;c.height=c.height~=nil and math.min(c.height,bV)or nil;c.width=c.width~=nil and math.min(c.width,vim.o.columns)or nil;if vim.fn.has('nvim-0.9')==1 and c.title~=nil then local bW,bX=c.title,c.width;local bY=vim.fn.strcharlen(bW)if bX<bY then bW='…'..vim.fn.strcharpart(bW,bY-bX+1,bX-1)end;c.title=bW;c.border=vim.api.nvim_win_get_config(q).border else c.title=nil end;c.relative='editor'vim.api.nvim_win_set_config(q,c)b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')vim.wo[q].cursorline=true;vim.wo[q].conceallevel=3;b.trigger_event('MiniFilesWindowUpdate',{buf_id=vim.api.nvim_win_get_buf(q),win_id=q})end;b.window_update_highlight=function(q,bZ,b_)local c0=bZ..':'..b_;local c1=string.format('(%s:[^,]*)',vim.pesc(bZ))local c2,c3=vim.wo[q].winhighlight:gsub(c1,c0)if c3==0 then c2=c2 ..','..c0 end;pcall(function()vim.wo[q].winhighlight=c2 end)end;b.window_focus=function(q)vim.api.nvim_set_current_win(q)b.window_update_highlight(q,'FloatTitle','MiniFilesTitleFocused')end;b.window_close=function(q)if q==nil then return end;local c4,r=pcall(vim.api.nvim_win_get_buf,q)if c4 then b.opened_buffers[r].win_id=nil end;pcall(vim.api.nvim_win_close,q,true)end;b.window_set_view=function(q,o)local r=o.buf_id;vim.api.nvim_win_set_buf(q,r)b.opened_buffers[r].win_id=q;pcall(b.window_set_cursor,q,o.cursor)vim.wo[q].cursorline=true;b.window_update_border_hl(q)end;b.window_set_cursor=function(q,a5)if type(a5)~='table'then return end;vim.api.nvim_win_set_cursor(q,a5)b.window_tweak_cursor(q,vim.api.nvim_win_get_buf(q))end;b.window_tweak_cursor=function(q,r)local a5=vim.api.nvim_win_get_cursor(q)local a7=b.get_bufline(r,a5[1])local c5=b.match_line_offset(a7)if a5[2]<c5-1 then a5[2]=c5-1;vim.api.nvim_win_set_cursor(q,a5)vim.cmd('normal! 1000zh')end;return a5 end;b.window_update_border_hl=function(q)if not b.is_valid_win(q)then return end;local r=vim.api.nvim_win_get_buf(q)local c6=b.is_modified_buffer(r)and'MiniFilesBorderModified'or'MiniFilesBorder'b.window_update_highlight(q,'FloatBorder',c6)end;b.window_get_max_height=function()local bU=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local c7=vim.o.laststatus>0;return vim.o.lines-vim.o.cmdheight-(bU and 1 or 0)-(c7 and 1 or 0)-2 end;b.fs_read_dir=function(d,k)local c8=vim.loop.fs_scandir(d)local I={}if not c8 then return I end;local y,g=vim.loop.fs_scandir_next(c8)while y do if not(g=='file'or g=='directory')then g=b.fs_get_type(b.fs_child_path(d,y))end;table.insert(I,{fs_type=g,name=y,path=b.fs_child_path(d,y)})y,g=vim.loop.fs_scandir_next(c8)end;I=k.sort(vim.tbl_filter(k.filter,I))for n,bt in ipairs(I)do bt.path_id=b.add_path_to_index(bt.path)end;return I end;b.add_path_to_index=function(d)local c9=b.path_index[d]if c9~=nil then return c9 end;local ca=#b.path_index+1;b.path_index[ca]=d;b.path_index[d]=ca;return ca end;b.compare_fs_entries=function(cb,cc)if cb.is_dir and not cc.is_dir then return true end;if not cb.is_dir and cc.is_dir then return false end;return cb.lower_name<cc.lower_name end;b.fs_normalize_path=function(d)local I=d:gsub('\\','/'):gsub('/+','/'):gsub('(.)/$','%1')return I end;b.fs_is_present_path=function(d)return vim.loop.fs_stat(d)~=nil end;b.fs_child_path=function(cd,y)return b.fs_normalize_path(string.format('%s/%s',cd,y))end;b.fs_full_path=function(d)return b.fs_normalize_path(vim.fn.fnamemodify(d,':p'))end;b.fs_shorten_path=function(d)d=b.fs_normalize_path(d)local ce=b.fs_normalize_path(vim.loop.os_homedir()or'~')local I=d:gsub('^'..vim.pesc(ce),'~')return I end;b.fs_get_basename=function(d)return b.fs_normalize_path(d):match('[^/]+$')end;b.fs_get_parent=function(d)d=b.fs_full_path(d)local cf=b.fs_is_windows_top(d)or d=='/'if cf then return nil end;local I=b.fs_normalize_path(d:match('^.*/'))local cg=b.fs_is_windows_top(I)and'/'or''return I..cg end;b.fs_is_windows_top=function(d)return b.is_windows and d:find('^%w:[\\/]?$')~=nil end;b.fs_get_type=function(d)if not b.fs_is_present_path(d)then return nil end;return vim.fn.isdirectory(d)==1 and'directory'or'file'end;b.fs_actions_confirm=function(m)local ay=table.concat(b.fs_actions_to_lines(m),'\n')local az=vim.fn.confirm(ay,'&Yes\n&No',1,'Question')return az==1 end;b.fs_actions_to_lines=function(m)local ch={}local ci=function(d)local cj=b.fs_shorten_path(b.fs_get_parent(d))local ck=ch[cj]or{}ch[cj]=ck;return ck end;local cl=function(d)return string.format("'%s'",b.fs_get_basename(d))end;for n,an in ipairs(m.copy)do local ck=ci(an.from)local a7=string.format("    COPY: %s to '%s'",cl(an.from),b.fs_shorten_path(an.to))table.insert(ck,a7)end;for n,d in ipairs(m.create)do local ck=ci(d)local g=d:find('/$')==nil and'file'or'directory'local a7=string.format('  CREATE: %s (%s)',cl(d),g)table.insert(ck,a7)end;for n,d in ipairs(m.delete)do local ck=ci(d)local a7=string.format('  DELETE: %s',cl(d))table.insert(ck,a7)end;for n,an in ipairs(m.move)do local ck=ci(an.from)local a7=string.format("    MOVE: %s to '%s'",cl(an.from),b.fs_shorten_path(an.to))table.insert(ck,a7)end;for n,an in ipairs(m.rename)do local ck=ci(an.from)local a7=string.format('  RENAME: %s to %s',cl(an.from),cl(an.to))table.insert(ck,a7)end;local I={'CONFIRM FILE SYSTEM ACTIONS',''}for d,ck in pairs(ch)do table.insert(I,d..':')vim.list_extend(I,ck)table.insert(I,'')end;return I end;b.fs_actions_apply=function(m,f)for n,an in ipairs(m.copy)do local bT,cm=pcall(b.fs_copy,an.from,an.to)local S={action='copy',from=an.from,to=an.to}if bT and cm then b.trigger_event('MiniFilesActionCopy',S)end end;for n,d in ipairs(m.create)do local bT,cm=pcall(b.fs_create,d)local S={action='create',to=b.fs_normalize_path(d)}if bT and cm then b.trigger_event('MiniFilesActionCreate',S)end end;for n,an in ipairs(m.move)do local bT,cm=pcall(b.fs_move,an.from,an.to)local S={action='move',from=an.from,to=an.to}if bT and cm then b.trigger_event('MiniFilesActionMove',S)end end;for n,an in ipairs(m.rename)do local bT,cm=pcall(b.fs_rename,an.from,an.to)local S={action='rename',from=an.from,to=an.to}if bT and cm then b.trigger_event('MiniFilesActionRename',S)end end;for n,d in ipairs(m.delete)do local bT,cm=pcall(b.fs_delete,d,f.options.permanent_delete)local S={action='delete',from=d}if bT and cm then b.trigger_event('MiniFilesActionDelete',S)end end end;b.fs_create=function(d)if b.fs_is_present_path(d)then return false end;vim.fn.mkdir(b.fs_get_parent(d),'p')local g=d:find('/$')==nil and'file'or'directory'if g=='directory'then return vim.fn.mkdir(d)==1 else return vim.fn.writefile({},d)==0 end end;b.fs_copy=function(b0,a_)if b.fs_is_present_path(a_)then return false end;local cn=b.fs_get_type(b0)if cn==nil then return false end;vim.fn.mkdir(b.fs_get_parent(a_),'p')if cn=='file'then return vim.loop.fs_copyfile(b0,a_)end;local H=b.fs_read_dir(b0,{filter=function()return true end,sort=function(J)return J end})vim.fn.mkdir(a_)local cm=true;for n,bt in ipairs(H)do cm=cm and b.fs_copy(bt.path,b.fs_child_path(a_,bt.name))end;return cm end;b.fs_delete=function(d,co)if co then return vim.fn.delete(d,'rf')==0 end;local cp=b.fs_child_path(vim.fn.stdpath('data'),'mini.files/trash')vim.fn.mkdir(cp,'p')local cq=b.fs_child_path(cp,b.fs_get_basename(d))pcall(vim.fn.delete,cq,'rf')return vim.loop.fs_rename(d,cq)end;b.fs_move=function(b0,a_)if b.fs_is_present_path(a_)then return false end;vim.fn.mkdir(b.fs_get_parent(a_),'p')local cm=vim.loop.fs_rename(b0,a_)for n,r in ipairs(vim.api.nvim_list_bufs())do b.rename_loaded_buffer(r,b0,a_)end;return cm end;b.fs_rename=b.fs_move;b.rename_loaded_buffer=function(r,b0,a_)if not(vim.api.nvim_buf_is_loaded(r)and vim.bo[r].buftype=='')then return end;local cr=b.fs_normalize_path(vim.api.nvim_buf_get_name(r))local cs=cr:gsub('^'..vim.pesc(b0),a_)if cr==cs then return end;vim.api.nvim_buf_set_name(r,cs)vim.api.nvim_buf_call(r,function()vim.cmd('silent! write! | edit')end)end;b.validate_opened_buffer=function(J)if J==nil or J==0 then J=vim.api.nvim_get_current_buf()end;if not b.is_opened_buffer(J)then b.error('`buf_id` should be an identifier of an opened directory buffer.')end;return J end;b.validate_line=function(r,J)J=J or vim.fn.line('.')if not(type(J)=='number'and 1<=J and J<=vim.api.nvim_buf_line_count(r))then b.error('`line` should be a valid line number in buffer '..r..'.')end;return J end;b.error=function(ay)error(string.format('(mini.files) %s',ay),0)end;b.map=function(bk,bl,bm,f)if bl==''then return end;f=vim.tbl_deep_extend('force',{silent=true},f or{})vim.keymap.set(bk,bl,bm,f)end;b.trigger_event=function(ct,S)if b.block_event_trigger[ct]then return end;if vim.fn.has('nvim-0.8')==0 then S=nil end;vim.api.nvim_exec_autocmds('User',{pattern=ct,data=S})end;b.is_valid_buf=function(r)return type(r)=='number'and vim.api.nvim_buf_is_valid(r)end;b.is_valid_win=function(q)return type(q)=='number'and vim.api.nvim_win_is_valid(q)end;b.get_bufline=function(r,A)return vim.api.nvim_buf_get_lines(r,A-1,A,false)[1]end;b.set_buflines=function(r,aP)local cu=string.format('lockmarks lua vim.api.nvim_buf_set_lines(%d, 0, -1, false, %s)',r,vim.inspect(aP))vim.cmd(cu)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.get_first_valid_normal_window=function()for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(q).relative==''then return q end end end;return a
