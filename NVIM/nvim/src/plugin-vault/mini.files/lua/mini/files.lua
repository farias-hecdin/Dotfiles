local a={}local b={}a.setup=function(c)_G.MiniFiles=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()end;a.config={content={filter=nil,prefix=nil,sort=nil},mappings={close='q',go_in='l',go_in_plus='L',go_out='h',go_out_plus='H',reset='<BS>',reveal_cwd='@',show_help='g?',synchronize='=',trim_left='<',trim_right='>'},options={permanent_delete=true,use_as_default_explorer=true},windows={max_number=math.huge,preview=false,width_focus=50,width_nofocus=15,width_preview=25}}a.open=function(d,e,f)d=b.fs_full_path(d or vim.fn.getcwd())local g=b.fs_get_type(d)if g==nil then b.error('`path` is not a valid path ("'..d..'")')end;local h;if g=='file'then d,h=b.fs_get_parent(d),b.fs_get_basename(d)end;if e==nil then e=true end;local i=a.close()if i==false then return end;local j;if e then j=b.explorer_path_history[d]end;j=j or b.explorer_new(d)j.opts=b.normalize_opts(nil,f)j.target_window=vim.api.nvim_get_current_win()j=b.explorer_focus_on_entry(j,d,h)b.explorer_refresh(j)b.latest_paths[vim.api.nvim_get_current_tabpage()]=d;b.explorer_track_lost_focus()end;a.refresh=function(f)local j=b.explorer_get()if j==nil then return end;local k=(f or{}).content or{}local l=#vim.tbl_keys(k)>0;if l then l=b.explorer_confirm_modified(j,'buffer updates')end;j.opts=b.normalize_opts(j.opts,f)b.explorer_refresh(j,{force_update=l})end;a.synchronize=function()local j=b.explorer_get()if j==nil then return end;local m=b.explorer_compute_fs_actions(j)if m~=nil and b.fs_actions_confirm(m)then b.fs_actions_apply(m,j.opts)end;b.explorer_refresh(j,{force_update=true})end;a.reset=function()local j=b.explorer_get()if j==nil then return end;j.branch={j.anchor}j.depth_focus=1;for n,o in pairs(j.views)do o.cursor={1,0}end;b.explorer_refresh(j,{skip_update_cursor=true})end;a.close=function()local j=b.explorer_get()if j==nil then return nil end;pcall(vim.loop.timer_stop,b.timers.focus)if not b.explorer_confirm_modified(j,'close')then return false end;j=b.explorer_ensure_target_window(j)pcall(vim.api.nvim_set_current_win,j.target_window)j=b.explorer_update_cursors(j)for p,q in pairs(j.windows)do b.window_close(q)j.windows[p]=nil end;for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do local r=vim.api.nvim_win_get_buf(q)if vim.bo[r].filetype=='minifiles-help'then vim.api.nvim_win_close(q,true)end end;for d,o in pairs(j.views)do j.views[d]=b.view_invalidate_buffer(b.view_encode_cursor(o))end;local s,t=vim.api.nvim_get_current_tabpage(),j.anchor;b.explorer_path_history[t]=j;b.opened_explorers[s]=nil;return true end;a.go_in=function(f)local j=b.explorer_get()if j==nil then return end;f=vim.tbl_deep_extend('force',{close_on_file=false},f or{})local u=f.close_on_file;if u then local v=a.get_fs_entry()u=v~=nil and v.fs_type=='file'end;local w=vim.fn.line('.')j=b.explorer_go_in_range(j,vim.api.nvim_get_current_buf(),w,w)b.explorer_refresh(j)if u then a.close()end end;a.go_out=function()local j=b.explorer_get()if j==nil then return end;if j.depth_focus==1 then j=b.explorer_open_root_parent(j)else j.depth_focus=j.depth_focus-1 end;b.explorer_refresh(j)end;a.trim_left=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_left(j)b.explorer_refresh(j)end;a.trim_right=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_right(j)b.explorer_refresh(j)end;a.reveal_cwd=function()local j=b.explorer_get()if j==nil then return end;local x=b.fs_full_path(vim.fn.getcwd())local y=string.format('^%s/.',vim.pesc(x))while j.branch[1]:find(y)~=nil do local z,A=b.fs_get_parent(j.branch[1]),b.fs_get_basename(j.branch[1])table.insert(j.branch,1,z)j.depth_focus=j.depth_focus+1;local B=j.views[z]or{}B.cursor=A;j.views[z]=B end;b.explorer_refresh(j)end;a.show_help=function()local j=b.explorer_get()if j==nil then return end;local r=vim.api.nvim_get_current_buf()if not b.is_opened_buffer(r)then return end;b.explorer_show_help(r,vim.api.nvim_get_current_win())end;a.get_fs_entry=function(r,C)r=b.validate_opened_buffer(r)C=b.validate_line(r,C)local D=b.match_line_path_id(b.get_bufline(r,C))if D==nil then return nil end;local d=b.path_index[D]return{fs_type=b.fs_get_type(d),name=b.fs_get_basename(d),path=d}end;a.get_target_window=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_ensure_target_window(j)return j.target_window end;a.set_target_window=function(q)if not b.is_valid_win(q)then b.error('`win_id` should be valid window identifier.')end;local j=b.explorer_get()if j==nil then return end;j.target_window=q end;a.get_latest_path=function()return b.latest_paths[vim.api.nvim_get_current_tabpage()]end;a.default_filter=function(v)return true end;a.default_prefix=function(v)if v.fs_type=='directory'then return' ','MiniFilesDirectory'end;local E,F=pcall(require,'nvim-web-devicons')if not E then return' ','MiniFilesFile'end;local G,H=F.get_icon(v.name,nil,{default=false})return(G or'')..' ',H or'MiniFilesFile'end;a.default_sort=function(I)local J=vim.tbl_map(function(K)return{fs_type=K.fs_type,name=K.name,path=K.path,lower_name=K.name:lower(),is_dir=K.fs_type=='directory'}end,I)table.sort(J,b.compare_fs_entries)return vim.tbl_map(function(K)return{name=K.name,fs_type=K.fs_type,path=K.path}end,J)end;b.default_config=vim.deepcopy(a.config)b.ns_id={highlight=vim.api.nvim_create_namespace('MiniFilesHighlight')}b.timers={focus=vim.loop.new_timer()}b.path_index={}b.explorer_path_history={}b.opened_explorers={}b.latest_paths={}b.opened_buffers={}b.is_windows=vim.loop.os_uname().sysname=='Windows_NT'b.block_event_trigger={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({content={c.content,'table'},mappings={c.mappings,'table'},options={c.options,'table'},windows={c.windows,'table'}})vim.validate({['content.filter']={c.content.filter,'function',true},['content.prefix']={c.content.prefix,'function',true},['content.sort']={c.content.sort,'function',true},['mappings.close']={c.mappings.close,'string'},['mappings.go_in']={c.mappings.go_in,'string'},['mappings.go_in_plus']={c.mappings.go_in_plus,'string'},['mappings.go_out']={c.mappings.go_out,'string'},['mappings.go_out_plus']={c.mappings.go_out_plus,'string'},['mappings.reset']={c.mappings.reset,'string'},['mappings.reveal_cwd']={c.mappings.reveal_cwd,'string'},['mappings.show_help']={c.mappings.show_help,'string'},['mappings.synchronize']={c.mappings.synchronize,'string'},['mappings.trim_left']={c.mappings.trim_left,'string'},['mappings.trim_right']={c.mappings.trim_right,'string'},['options.use_as_default_explorer']={c.options.use_as_default_explorer,'boolean'},['options.permanent_delete']={c.options.permanent_delete,'boolean'},['windows.max_number']={c.windows.max_number,'number'},['windows.preview']={c.windows.preview,'boolean'},['windows.width_focus']={c.windows.width_focus,'number'},['windows.width_nofocus']={c.windows.width_nofocus,'number'},['windows.width_preview']={c.windows.width_preview,'number'}})return c end;b.apply_config=function(c)a.config=c end;b.create_autocommands=function(c)local L=vim.api.nvim_create_augroup('MiniFiles',{})local M=function(N,O,P,Q)vim.api.nvim_create_autocmd(N,{group=L,pattern=O,callback=P,desc=Q})end;M('VimResized','*',a.refresh,'Refresh on resize')if c.options.use_as_default_explorer then vim.cmd('silent! autocmd! FileExplorer *')vim.cmd('autocmd VimEnter * ++once silent! autocmd! FileExplorer *')M('BufEnter','*',b.track_dir_edit,'Track directory edit')end end;b.create_default_hl=function()local R=function(A,f)f.default=true;vim.api.nvim_set_hl(0,A,f)end;R('MiniFilesBorder',{link='FloatBorder'})R('MiniFilesBorderModified',{link='DiagnosticFloatingWarn'})R('MiniFilesCursorLine',{link='CursorLine'})R('MiniFilesDirectory',{link='Directory'})R('MiniFilesFile',{})R('MiniFilesNormal',{link='NormalFloat'})R('MiniFilesTitle',{link='FloatTitle'})R('MiniFilesTitleFocused',{link='FloatTitle'})end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minifiles_config or{},c or{})end;b.normalize_opts=function(S,f)f=vim.tbl_deep_extend('force',b.get_config(),S or{},f or{})f.content.filter=f.content.filter or a.default_filter;f.content.prefix=f.content.prefix or a.default_prefix;f.content.sort=f.content.sort or a.default_sort;return f end;b.track_dir_edit=function(T)if vim.api.nvim_get_current_buf()~=T.buf then return end;if vim.b.minifiles_processed_dir then return vim.api.nvim_buf_delete(0,{force=true})end;local d=vim.api.nvim_buf_get_name(0)if vim.fn.isdirectory(d)~=1 then return end;vim.bo.bufhidden='wipe'vim.b.minifiles_processed_dir=true;vim.schedule(function()a.open(d,false)end)end;b.explorer_new=function(d)return{branch={d},depth_focus=1,views={},windows={},anchor=d,target_window=vim.api.nvim_get_current_win(),opts={}}end;b.explorer_get=function(s)s=s or vim.api.nvim_get_current_tabpage()local J=b.opened_explorers[s]if b.explorer_is_visible(J)then return J end;b.opened_explorers[s]=nil;return nil end;b.explorer_is_visible=function(j)if j==nil then return nil end;for n,q in ipairs(j.windows)do if b.is_valid_win(q)then return true end end;return false end;b.explorer_refresh=function(j,f)j=b.explorer_normalize(j)if j.is_corrupted then j.is_corrupted=false;a.close()return end;if#j.branch==0 then return end;f=f or{}if not f.skip_update_cursor then j=b.explorer_update_cursors(j)end;if f.force_update then for d,o in pairs(j.views)do o=b.view_encode_cursor(o)o.children_path_ids=b.buffer_update(o.buf_id,d,j.opts)j.views[d]=o end end;for U=1,#j.branch do j=b.explorer_sync_cursor_and_branch(j,U)end;for n,q in ipairs(j.windows)do local r=vim.api.nvim_win_get_buf(q)b.opened_buffers[r].win_id=nil end;local V=b.compute_visible_depth_range(j,j.opts)local W,X=0,0;for U=V.from,V.to do X=X+1;local Y=b.explorer_refresh_depth_window(j,U,X,W)W=W+Y+2 end;for U=X+1,#j.windows do b.window_close(j.windows[U])j.windows[U]=nil end;local Z=j.depth_focus-V.from+1;local _=j.windows[Z]b.window_focus(_)local s=vim.api.nvim_win_get_tabpage(_)b.opened_explorers[s]=j;return j end;b.explorer_track_lost_focus=function()local a0=vim.schedule_wrap(function()local a1=vim.bo.filetype;if a1=='minifiles'or a1=='minifiles-help'then return end;local a2=vim.api.nvim_get_current_win()a.close()pcall(vim.api.nvim_set_current_win,a2)end)b.timers.focus:start(1000,1000,a0)end;b.explorer_normalize=function(j)local a3={}for n,d in ipairs(j.branch)do if not b.fs_is_present_path(d)then break end;table.insert(a3,d)end;local a4=#a3;j.branch=a3;j.depth_focus=math.min(math.max(j.depth_focus,1),a4)for p=a4+1,#j.windows do b.window_close(j.windows[p])j.windows[p]=nil end;for n,q in pairs(j.windows)do if not b.is_valid_win(q)then j.is_corrupted=true end end;return j end;b.explorer_sync_cursor_and_branch=function(j,U)if#j.branch<U then return j end;local d,a5=j.branch[U],j.branch[U+1]local o=j.views[d]if o==nil then return j end;local r,a6=o.buf_id,o.cursor;if a6==nil then return j end;local a7;if type(a6)=='table'and b.is_valid_buf(r)then local a8=b.get_bufline(r,a6[1])a7=b.path_index[b.match_line_path_id(a8)]elseif type(a6)=='string'then a7=b.fs_child_path(d,a6)else return j end;if a7==a5 then return j end;for p=U+1,#j.branch do j.branch[p]=nil end;j.depth_focus=math.min(j.depth_focus,#j.branch)local a9=j.opts.windows.preview;local aa=type(a7)=='string'and b.fs_is_present_path(a7)local ab=r==vim.api.nvim_get_current_buf()if a9 and aa and ab then table.insert(j.branch,a7)end;return j end;b.explorer_go_in_range=function(j,r,ac,ad)local ae,d,C={},nil,nil;for p=ac,ad do local v=a.get_fs_entry(r,p)or{}if v.fs_type=='file'then table.insert(ae,v.path)end;if v.fs_type=='directory'then d,C=v.path,p end end;for n,af in ipairs(ae)do j=b.explorer_open_file(j,af)end;if d~=nil then j=b.explorer_open_directory(j,d,j.depth_focus+1)local q=b.opened_buffers[r].win_id;if b.is_valid_win(q)then vim.api.nvim_win_set_cursor(q,{C,0})end end;return j end;b.explorer_focus_on_entry=function(j,d,h)if h==nil then return j end;j.depth_focus=b.explorer_get_path_depth(j,d)if j.depth_focus==nil then j.branch,j.depth_focus={d},1 end;local ag=j.views[d]or{}ag.cursor=h;j.views[d]=ag;return j end;b.explorer_compute_fs_actions=function(j)local ah={}for n,o in pairs(j.views)do local ai=b.buffer_compute_fs_diff(o.buf_id,o.children_path_ids)if#ai>0 then vim.list_extend(ah,ai)end end;if#ah==0 then return nil end;local aj,ak,al,am,an={},{},{},{},{}for n,ao in ipairs(ah)do if ao.from==nil then table.insert(aj,ao.to)elseif ao.to==nil then ak[ao.from]=true else table.insert(an,ao)end end;local ap={}for n,ao in pairs(an)do if ak[ao.from]then if b.fs_get_parent(ao.from)==b.fs_get_parent(ao.to)then table.insert(al,ao)else table.insert(am,ao)end;ak[ao.from]=nil else table.insert(ap,ao)end end;return{create=aj,delete=vim.tbl_keys(ak),copy=ap,rename=al,move=am}end;b.explorer_update_cursors=function(j)for n,q in ipairs(j.windows)do if b.is_valid_win(q)then local r=vim.api.nvim_win_get_buf(q)local d=b.opened_buffers[r].path;j.views[d].cursor=vim.api.nvim_win_get_cursor(q)end end;return j end;b.explorer_refresh_depth_window=function(j,U,aq,ar)local d=j.branch[U]local as,at,f=j.views,j.windows,j.opts;local o=as[d]or{}o=b.view_ensure_proper(o,d,f)as[d]=o;local au=U==j.depth_focus;local av=f.windows.preview and U==j.depth_focus+1;local Y=au and f.windows.width_focus or(av and f.windows.width_preview or f.windows.width_nofocus)local c={col=ar,height=vim.api.nvim_buf_line_count(o.buf_id),width=Y,title=aq==1 and b.fs_shorten_path(b.fs_full_path(d))or b.fs_get_basename(d)}local q=at[aq]if not b.is_valid_win(q)then b.window_close(q)q=b.window_open(o.buf_id,c)at[aq]=q end;b.window_update(q,c)b.window_set_view(q,o)j.views=as;j.windows=at;return Y end;b.explorer_get_path_depth=function(j,d)for U,aw in pairs(j.branch)do if d==aw then return U end end end;b.explorer_confirm_modified=function(j,ax)local ay=false;for n,o in pairs(j.views)do if b.is_modified_buffer(o.buf_id)then ay=true end end;if not ay then return true end;local az=string.format('There is at least one modified buffer\n\nConfirm %s without synchronization?',ax)local aA=vim.fn.confirm(az,'&Yes\n&No',1,'Question')return aA==1 end;b.explorer_open_file=function(j,d)j=b.explorer_ensure_target_window(j)local aB;for n,r in ipairs(vim.api.nvim_list_bufs())do local aC=b.is_valid_buf(r)and vim.bo[r].buflisted and vim.api.nvim_buf_get_name(r)==d;if aC then aB=r end end;if aB~=nil then vim.api.nvim_win_set_buf(j.target_window,aB)else local aD=vim.fn.fnameescape(vim.fn.fnamemodify(d,':.'))pcall(vim.fn.win_execute,j.target_window,'edit '..aD)end;return j end;b.explorer_ensure_target_window=function(j)if not b.is_valid_win(j.target_window)then j.target_window=b.get_first_valid_normal_window()end;return j end;b.explorer_open_directory=function(j,d,aE)j.depth_focus=aE;local aF=d~=j.branch[aE]if aF then j.branch[aE]=d;j=b.explorer_trim_branch_right(j)end;return j end;b.explorer_open_root_parent=function(j)local aG=j.branch[1]local aH=b.fs_get_parent(aG)if aH==nil then return j end;table.insert(j.branch,1,aH)return b.explorer_focus_on_entry(j,aH,b.fs_get_basename(aG))end;b.explorer_trim_branch_right=function(j)for p=j.depth_focus+1,#j.branch do j.branch[p]=nil end;return j end;b.explorer_trim_branch_left=function(j)local aI={}for p=j.depth_focus,#j.branch do table.insert(aI,j.branch[p])end;j.branch=aI;j.depth_focus=1;return j end;b.explorer_show_help=function(aJ,aK)local aL=vim.api.nvim_buf_get_keymap(aJ,'n')local aM,aN={},0;for n,T in ipairs(aL)do if T.desc~=nil then aM[T.desc]=T.lhs:lower()=='<lt>'and'<'or T.lhs;aN=math.max(aN,T.desc:len())end end;local aO=vim.tbl_keys(aM)table.sort(aO)local aP=string.format('%%-%ds │ %%s',aN)local aQ={'Buffer mappings:',''}for n,Q in ipairs(aO)do table.insert(aQ,string.format(aP,Q,aM[Q]))end;table.insert(aQ,'')table.insert(aQ,'(Press `q` to close)')local r=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_lines(r,0,-1,false,aQ)vim.keymap.set('n','q','<Cmd>close<CR>',{buffer=r,desc='Close this window'})vim.b[r].minicursorword_disable=true;vim.b[r].miniindentscope_disable=true;vim.bo[r].filetype='minifiles-help'local aR=vim.tbl_map(vim.fn.strdisplaywidth,aQ)local aS=math.max(unpack(aR))local c=vim.api.nvim_win_get_config(aK)c.relative='win'c.row=0;c.col=0;c.width=aS;c.height=#aQ;c.title=vim.fn.has('nvim-0.9')==1 and[['mini.files' help]]or nil;c.zindex=c.zindex+1;c.style='minimal'local q=vim.api.nvim_open_win(r,false,c)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.window_update_highlight(q,'CursorLine','MiniFilesCursorLine')vim.wo[q].cursorline=true;vim.api.nvim_set_current_win(q)return q end;b.compute_visible_depth_range=function(j,f)local aT,aU=f.windows.width_focus+2,f.windows.width_nofocus+2;local aV=j.opts.windows.preview and j.depth_focus<#j.branch;local aW=aV and f.windows.width_preview+2 or aU;local aX=1;if aT+aW<=vim.o.columns then aX=aX+1 end;if aT+aW+aU<=vim.o.columns then aX=aX+math.floor((vim.o.columns-aT-aW)/aU)end;aX=math.min(math.max(aX,1),f.windows.max_number)local aY,aZ=#j.branch,j.depth_focus;local a_=math.min(aY,aX)local b0=math.min(aY,math.floor(aZ+0.5*a_))local b1=math.max(1,b0-a_+1)b0=b1+math.min(a_,aY)-1;return{from=b1,to=b0}end;b.view_ensure_proper=function(o,d,f)if not b.is_valid_buf(o.buf_id)then b.buffer_delete(o.buf_id)o.buf_id=b.buffer_create(d,f.mappings)o.children_path_ids=b.buffer_update(o.buf_id,d,f)end;o.cursor=o.cursor or{1,0}if type(o.cursor)=='string'then o=b.view_decode_cursor(o)end;return o end;b.view_encode_cursor=function(o)local r,a6=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a6)~='table'then return o end;local a8=b.get_bufline(r,a6[1])o.cursor=b.match_line_entry_name(a8)return o end;b.view_decode_cursor=function(o)local r,a6=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a6)~='string'then return o end;local aQ=vim.api.nvim_buf_get_lines(r,0,-1,false)for p,a8 in ipairs(aQ)do if a6==b.match_line_entry_name(a8)then o.cursor={p,0}end end;if type(o.cursor)~='table'then o.cursor={1,0}end;return o end;b.view_invalidate_buffer=function(o)b.buffer_delete(o.buf_id)o.buf_id=nil;o.children_path_ids=nil;return o end;b.view_track_cursor=vim.schedule_wrap(function(T)local r=T.buf;local b2=b.opened_buffers[r]if b2==nil then return end;local q=b2.win_id;if not b.is_valid_win(q)then return end;local b3=b.window_tweak_cursor(q,r)local s=vim.api.nvim_win_get_tabpage(q)local j=b.explorer_get(s)if j==nil then return end;local b4=b.explorer_get_path_depth(j,b2.path)if b4==nil then return end;local o=j.views[b2.path]if o~=nil then o.cursor=b3;j.views[b2.path]=o end;j=b.explorer_sync_cursor_and_branch(j,b4)b.block_event_trigger['MiniFilesWindowUpdate']=true;b.explorer_refresh(j)b.block_event_trigger['MiniFilesWindowUpdate']=false end)b.view_track_text_change=function(T)local r=T.buf;local b5=b.opened_buffers[r].n_modified+1;b.opened_buffers[r].n_modified=b5;local q=b.opened_buffers[r].win_id;if b5>0 and b.is_valid_win(q)then b.window_update_border_hl(q)end;if not b.is_valid_win(q)then return end;local b6=vim.api.nvim_buf_line_count(r)local b7=math.min(b6,b.window_get_max_height())vim.api.nvim_win_set_height(q,b7)local b8=vim.fn.line('w0',q)+b7-1;local b9=b8-b6;if b9>0 then vim.cmd('normal! '..b9 ..'\25')end end;b.buffer_create=function(d,ba)local r=vim.api.nvim_create_buf(false,true)b.opened_buffers[r]={path=d}b.buffer_make_mappings(r,ba)local L=vim.api.nvim_create_augroup('MiniFiles',{clear=false})local M=function(bb,Q,P)vim.api.nvim_create_autocmd(bb,{group=L,buffer=r,desc=Q,callback=P})end;M({'CursorMoved','CursorMovedI'},'Tweak cursor position',b.view_track_cursor)M({'TextChanged','TextChangedI','TextChangedP'},'Track buffer modification',b.view_track_text_change)vim.b[r].minicursorword_disable=true;vim.bo[r].filetype='minifiles'b.trigger_event('MiniFilesBufferCreate',{buf_id=r})return r end;b.buffer_make_mappings=function(r,ba)local bc=function()for n=1,vim.v.count1 do a.go_in()end end;local bd=function()for n=1,vim.v.count1 do a.go_in({close_on_file=true})end end;local be=function()for n=1,vim.v.count1 do a.go_out()end end;local bf=function()be()a.trim_right()end;local bg=function()if vim.fn.mode()~='V'then return ba.go_in end;local bh,bi=vim.fn.line('v'),vim.fn.line('.')local ac,ad=math.min(bh,bi),math.max(bh,bi)vim.schedule(function()local j=b.explorer_get()j=b.explorer_go_in_range(j,r,ac,ad)b.explorer_refresh(j)end)return[[<C-\><C-n>]]end;local bj=function(bk,bl,bm,Q)b.map(bk,bl,bm,{buffer=r,desc=Q,nowait=true})end;bj('n',ba.close,a.close,'Close')bj('n',ba.go_in,bc,'Go in entry')bj('n',ba.go_in_plus,bd,'Go in entry plus')bj('n',ba.go_out,be,'Go out of directory')bj('n',ba.go_out_plus,bf,'Go out of directory plus')bj('n',ba.reset,a.reset,'Reset')bj('n',ba.reveal_cwd,a.reveal_cwd,'Reveal cwd')bj('n',ba.show_help,a.show_help,'Show Help')bj('n',ba.synchronize,a.synchronize,'Synchronize')bj('n',ba.trim_left,a.trim_left,'Trim branch left')bj('n',ba.trim_right,a.trim_right,'Trim branch right')b.map('x',ba.go_in,bg,{buffer=r,desc='Go in selected entries',expr=true})end;b.buffer_update=function(r,d,f)if not(b.is_valid_buf(r)and b.fs_is_present_path(d))then return end;local bn=b.fs_get_type(d)=='directory'and b.buffer_update_directory or b.buffer_update_file;local I=bn(r,d,f)b.trigger_event('MiniFilesBufferUpdate',{buf_id=r,win_id=b.opened_buffers[r].win_id})b.opened_buffers[r].n_modified=-1;return vim.tbl_map(function(K)return K.path_id end,I)end;b.buffer_update_directory=function(r,d,f)local aQ,bo,bp={},{},{}local I=b.fs_read_dir(d,f.content)local bq=math.floor(math.log10(#b.path_index))+1;local br='/%0'..bq..'d/%s/%s'local bs=f.content.prefix;for n,bt in ipairs(I)do local bu,H=bs(bt)bu,H=bu or'',H or''table.insert(aQ,string.format(br,b.path_index[bt.path],bu,bt.name))table.insert(bo,H)table.insert(bp,bt.fs_type=='directory'and'MiniFilesDirectory'or'MiniFilesFile')end;b.set_buflines(r,aQ)local bv=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(r,bv,0,-1)local bw=function(C,bx,by)b.set_extmark(r,bv,C,bx,by)end;for p,a8 in ipairs(aQ)do local bz,bA=a8:match('^/%d+/().-()/')local bB={hl_group=bo[p],end_col=bA-1,right_gravity=false}bw(p-1,bz-1,bB)local bC={hl_group=bp[p],end_row=p,end_col=0,right_gravity=false}bw(p-1,bA-1,bC)end;return I end;b.buffer_update_file=function(r,d,f)local bD=vim.loop.fs_open(d,'r',1)local bE=vim.loop.fs_read(bD,1024):find('\0')==nil;vim.loop.fs_close(bD)if not bE then b.set_buflines(r,{'-Non-text-file'..string.rep('-',f.windows.width_preview)})return{}end;local bF,bG=pcall(vim.fn.readfile,d,'',vim.o.lines)local aQ=bF and vim.split(table.concat(bG,'\n'),'\n')or{}b.set_buflines(r,aQ)if b.buffer_should_highlight(r)then local a1=vim.filetype.match({buf=r,filename=d})local bH,bI=pcall(vim.treesitter.language.get_lang,a1)local bJ,n=pcall(vim.treesitter.start,r,bH and bI or a1)if not bJ then vim.bo[r].syntax=a1 end end;return{}end;b.buffer_delete=function(r)if r==nil then return end;pcall(vim.api.nvim_buf_delete,r,{force=true})b.opened_buffers[r]=nil end;b.buffer_compute_fs_diff=function(r,bK)if not b.is_modified_buffer(r)then return{}end;local d=b.opened_buffers[r].path;local aQ=vim.api.nvim_buf_get_lines(r,0,-1,false)local J,bL={},{}for n,a8 in ipairs(aQ)do local D=b.match_line_path_id(a8)local bM=b.path_index[D]local bN=D~=nil and a8:sub(b.match_line_offset(a8))or a8;local bO=b.fs_child_path(d,bN)..(vim.endswith(bN,'/')and'/'or'')if a8:find('^%s*$')==nil and bM~=bO then table.insert(J,{from=bM,to=bO})elseif D~=nil then bL[D]=true end end;for n,bP in ipairs(bK)do if not bL[bP]then table.insert(J,{from=b.path_index[bP],to=nil})end end;return J end;b.buffer_should_highlight=function(r)if vim.fn.has('nvim-0.8')==0 then return false end;local bQ=vim.api.nvim_buf_call(r,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return bQ<=1000000 and bQ<=1000*vim.api.nvim_buf_line_count(r)end;b.is_opened_buffer=function(r)return b.opened_buffers[r]~=nil end;b.is_modified_buffer=function(r)local T=b.opened_buffers[r]return T~=nil and T.n_modified>0 end;b.match_line_entry_name=function(a8)if a8==nil then return nil end;local bR=b.match_line_offset(a8)local J=a8:sub(bR):gsub('/.*$','')return J end;b.match_line_offset=function(a8)if a8==nil then return nil end;return a8:match('^/.-/.-/()')or 1 end;b.match_line_path_id=function(a8)if a8==nil then return nil end;local bS=a8:match('^/(%d+)')local bT,J=pcall(tonumber,bS)if not bT then return nil end;return J end;b.window_open=function(r,c)c.anchor='NW'c.border='single'c.focusable=true;c.relative='editor'c.style='minimal'c.zindex=99;c.row=1;if vim.fn.has('nvim-0.9')==0 then c.title=nil end;local q=vim.api.nvim_open_win(r,false,c)vim.wo[q].concealcursor='nvic'vim.wo[q].foldenable=false;vim.wo[q].wrap=false;vim.api.nvim_win_call(q,function()vim.fn.matchadd('Conceal',[[^/\d\+/]])vim.fn.matchadd('Conceal',[[^/\d\+/[^/]*\zs/\ze]])end)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.window_update_highlight(q,'CursorLine','MiniFilesCursorLine')b.trigger_event('MiniFilesWindowOpen',{buf_id=r,win_id=q})return q end;b.window_update=function(q,c)local bU=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bV=b.window_get_max_height()c.row=bU and 1 or 0;c.height=c.height~=nil and math.min(c.height,bV)or nil;c.width=c.width~=nil and math.min(c.width,vim.o.columns)or nil;if vim.fn.has('nvim-0.9')==1 and c.title~=nil then local bW,bX=c.title,c.width;local bY=vim.fn.strcharlen(bW)if bX<bY then bW='…'..vim.fn.strcharpart(bW,bY-bX+1,bX-1)end;c.title=bW;c.border=vim.api.nvim_win_get_config(q).border else c.title=nil end;c.relative='editor'vim.api.nvim_win_set_config(q,c)b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')vim.wo[q].cursorline=true;vim.wo[q].conceallevel=3;b.trigger_event('MiniFilesWindowUpdate',{buf_id=vim.api.nvim_win_get_buf(q),win_id=q})end;b.window_update_highlight=function(q,bZ,b_)local c0=bZ..':'..b_;local c1=string.format('(%s:[^,]*)',vim.pesc(bZ))local c2,c3=vim.wo[q].winhighlight:gsub(c1,c0)if c3==0 then c2=c2 ..','..c0 end;pcall(function()vim.wo[q].winhighlight=c2 end)end;b.window_focus=function(q)vim.api.nvim_set_current_win(q)b.window_update_highlight(q,'FloatTitle','MiniFilesTitleFocused')end;b.window_close=function(q)if q==nil then return end;local c4,r=pcall(vim.api.nvim_win_get_buf,q)if c4 then b.opened_buffers[r].win_id=nil end;pcall(vim.api.nvim_win_close,q,true)end;b.window_set_view=function(q,o)local r=o.buf_id;vim.api.nvim_win_set_buf(q,r)b.opened_buffers[r].win_id=q;pcall(b.window_set_cursor,q,o.cursor)vim.wo[q].cursorline=true;b.window_update_border_hl(q)end;b.window_set_cursor=function(q,a6)if type(a6)~='table'then return end;vim.api.nvim_win_set_cursor(q,a6)b.window_tweak_cursor(q,vim.api.nvim_win_get_buf(q))end;b.window_tweak_cursor=function(q,r)local a6=vim.api.nvim_win_get_cursor(q)local a8=b.get_bufline(r,a6[1])local c5=b.match_line_offset(a8)if a6[2]<c5-1 then a6[2]=c5-1;vim.api.nvim_win_set_cursor(q,a6)vim.cmd('normal! 1000zh')end;return a6 end;b.window_update_border_hl=function(q)if not b.is_valid_win(q)then return end;local r=vim.api.nvim_win_get_buf(q)local c6=b.is_modified_buffer(r)and'MiniFilesBorderModified'or'MiniFilesBorder'b.window_update_highlight(q,'FloatBorder',c6)end;b.window_get_max_height=function()local bU=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local c7=vim.o.laststatus>0;return vim.o.lines-vim.o.cmdheight-(bU and 1 or 0)-(c7 and 1 or 0)-2 end;b.fs_read_dir=function(d,k)local c8=vim.loop.fs_scandir(d)local J={}if not c8 then return J end;local A,g=vim.loop.fs_scandir_next(c8)while A do if not(g=='file'or g=='directory')then g=b.fs_get_type(b.fs_child_path(d,A))end;table.insert(J,{fs_type=g,name=A,path=b.fs_child_path(d,A)})A,g=vim.loop.fs_scandir_next(c8)end;J=k.sort(vim.tbl_filter(k.filter,J))for n,bt in ipairs(J)do bt.path_id=b.add_path_to_index(bt.path)end;return J end;b.add_path_to_index=function(d)local c9=b.path_index[d]if c9~=nil then return c9 end;local ca=#b.path_index+1;b.path_index[ca]=d;b.path_index[d]=ca;return ca end;b.compare_fs_entries=function(cb,cc)if cb.is_dir and not cc.is_dir then return true end;if not cb.is_dir and cc.is_dir then return false end;return cb.lower_name<cc.lower_name end;b.fs_normalize_path=function(d)local J=d:gsub('\\','/'):gsub('/+','/'):gsub('(.)/$','%1')return J end;b.fs_is_present_path=function(d)return vim.loop.fs_stat(d)~=nil end;b.fs_child_path=function(cd,A)return b.fs_normalize_path(string.format('%s/%s',cd,A))end;b.fs_full_path=function(d)return b.fs_normalize_path(vim.fn.fnamemodify(d,':p'))end;b.fs_shorten_path=function(d)d=b.fs_normalize_path(d)local ce=b.fs_normalize_path(vim.loop.os_homedir()or'~')local J=d:gsub('^'..vim.pesc(ce),'~')return J end;b.fs_get_basename=function(d)return b.fs_normalize_path(d):match('[^/]+$')end;b.fs_get_parent=function(d)d=b.fs_full_path(d)local cf=b.fs_is_windows_top(d)or d=='/'if cf then return nil end;local J=b.fs_normalize_path(d:match('^.*/'))local cg=b.fs_is_windows_top(J)and'/'or''return J..cg end;b.fs_is_windows_top=function(d)return b.is_windows and d:find('^%w:[\\/]?$')~=nil end;b.fs_get_type=function(d)if not b.fs_is_present_path(d)then return nil end;return vim.fn.isdirectory(d)==1 and'directory'or'file'end;b.fs_actions_confirm=function(m)local az=table.concat(b.fs_actions_to_lines(m),'\n')local aA=vim.fn.confirm(az,'&Yes\n&No',1,'Question')return aA==1 end;b.fs_actions_to_lines=function(m)local ch={}local ci=function(d)local cj=b.fs_shorten_path(b.fs_get_parent(d))local ck=ch[cj]or{}ch[cj]=ck;return ck end;local cl=function(d)return string.format("'%s'",b.fs_get_basename(d))end;for n,ao in ipairs(m.copy)do local ck=ci(ao.from)local a8=string.format("    COPY: %s to '%s'",cl(ao.from),b.fs_shorten_path(ao.to))table.insert(ck,a8)end;for n,d in ipairs(m.create)do local ck=ci(d)local g=d:find('/$')==nil and'file'or'directory'local a8=string.format('  CREATE: %s (%s)',cl(d),g)table.insert(ck,a8)end;for n,d in ipairs(m.delete)do local ck=ci(d)local a8=string.format('  DELETE: %s',cl(d))table.insert(ck,a8)end;for n,ao in ipairs(m.move)do local ck=ci(ao.from)local a8=string.format("    MOVE: %s to '%s'",cl(ao.from),b.fs_shorten_path(ao.to))table.insert(ck,a8)end;for n,ao in ipairs(m.rename)do local ck=ci(ao.from)local a8=string.format('  RENAME: %s to %s',cl(ao.from),cl(ao.to))table.insert(ck,a8)end;local J={'CONFIRM FILE SYSTEM ACTIONS',''}for d,ck in pairs(ch)do table.insert(J,d..':')vim.list_extend(J,ck)table.insert(J,'')end;return J end;b.fs_actions_apply=function(m,f)for n,ao in ipairs(m.copy)do local bT,cm=pcall(b.fs_copy,ao.from,ao.to)local T={action='copy',from=ao.from,to=ao.to}if bT and cm then b.trigger_event('MiniFilesActionCopy',T)end end;for n,d in ipairs(m.create)do local bT,cm=pcall(b.fs_create,d)local T={action='create',to=b.fs_normalize_path(d)}if bT and cm then b.trigger_event('MiniFilesActionCreate',T)end end;for n,ao in ipairs(m.move)do local bT,cm=pcall(b.fs_move,ao.from,ao.to)local T={action='move',from=ao.from,to=ao.to}if bT and cm then b.trigger_event('MiniFilesActionMove',T)end end;for n,ao in ipairs(m.rename)do local bT,cm=pcall(b.fs_rename,ao.from,ao.to)local T={action='rename',from=ao.from,to=ao.to}if bT and cm then b.trigger_event('MiniFilesActionRename',T)end end;for n,d in ipairs(m.delete)do local bT,cm=pcall(b.fs_delete,d,f.options.permanent_delete)local T={action='delete',from=d}if bT and cm then b.trigger_event('MiniFilesActionDelete',T)end end end;b.fs_create=function(d)if b.fs_is_present_path(d)then return false end;vim.fn.mkdir(b.fs_get_parent(d),'p')local g=d:find('/$')==nil and'file'or'directory'if g=='directory'then return vim.fn.mkdir(d)==1 else return vim.fn.writefile({},d)==0 end end;b.fs_copy=function(b1,b0)if b.fs_is_present_path(b0)then return false end;local cn=b.fs_get_type(b1)if cn==nil then return false end;vim.fn.mkdir(b.fs_get_parent(b0),'p')if cn=='file'then return vim.loop.fs_copyfile(b1,b0)end;local I=b.fs_read_dir(b1,{filter=function()return true end,sort=function(K)return K end})vim.fn.mkdir(b0)local cm=true;for n,bt in ipairs(I)do cm=cm and b.fs_copy(bt.path,b.fs_child_path(b0,bt.name))end;return cm end;b.fs_delete=function(d,co)if co then return vim.fn.delete(d,'rf')==0 end;local cp=b.fs_child_path(vim.fn.stdpath('data'),'mini.files/trash')vim.fn.mkdir(cp,'p')local cq=b.fs_child_path(cp,b.fs_get_basename(d))pcall(vim.fn.delete,cq,'rf')return vim.loop.fs_rename(d,cq)end;b.fs_move=function(b1,b0)if b.fs_is_present_path(b0)then return false end;vim.fn.mkdir(b.fs_get_parent(b0),'p')local cm=vim.loop.fs_rename(b1,b0)for n,r in ipairs(vim.api.nvim_list_bufs())do b.rename_loaded_buffer(r,b1,b0)end;return cm end;b.fs_rename=b.fs_move;b.rename_loaded_buffer=function(r,b1,b0)if not(vim.api.nvim_buf_is_loaded(r)and vim.bo[r].buftype=='')then return end;local cr=b.fs_normalize_path(vim.api.nvim_buf_get_name(r))local cs=cr:gsub('^'..vim.pesc(b1),b0)if cr==cs then return end;vim.api.nvim_buf_set_name(r,cs)vim.api.nvim_buf_call(r,function()vim.cmd('silent! write! | edit')end)end;b.validate_opened_buffer=function(K)if K==nil or K==0 then K=vim.api.nvim_get_current_buf()end;if not b.is_opened_buffer(K)then b.error('`buf_id` should be an identifier of an opened directory buffer.')end;return K end;b.validate_line=function(r,K)K=K or vim.fn.line('.')if not(type(K)=='number'and 1<=K and K<=vim.api.nvim_buf_line_count(r))then b.error('`line` should be a valid line number in buffer '..r..'.')end;return K end;b.error=function(az)error(string.format('(mini.files) %s',az),0)end;b.map=function(bk,bl,bm,f)if bl==''then return end;f=vim.tbl_deep_extend('force',{silent=true},f or{})vim.keymap.set(bk,bl,bm,f)end;b.trigger_event=function(ct,T)if b.block_event_trigger[ct]then return end;if vim.fn.has('nvim-0.8')==0 then T=nil end;vim.api.nvim_exec_autocmds('User',{pattern=ct,data=T})end;b.is_valid_buf=function(r)return type(r)=='number'and vim.api.nvim_buf_is_valid(r)end;b.is_valid_win=function(q)return type(q)=='number'and vim.api.nvim_win_is_valid(q)end;b.get_bufline=function(r,C)return vim.api.nvim_buf_get_lines(r,C-1,C,false)[1]end;b.set_buflines=function(r,aQ)local cu=string.format('lockmarks lua vim.api.nvim_buf_set_lines(%d, 0, -1, false, %s)',r,vim.inspect(aQ))vim.cmd(cu)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.get_first_valid_normal_window=function()for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(q).relative==''then return q end end end;return a
