local a=require("which-key.tree")local b=require("which-key.util")local c=require("which-key.config")local d="Ãž"local e={}e.functions={}e.operators={}e.nowait={}e.blacklist={}function e.setup()local f=require("which-key.plugins.presets").operators;for g,h in pairs(f)do e.operators[g]=true end;local i={}for g,j in pairs(c.options.operators)do e.operators[g]=true;if f[g]then i[g]={name=j,i={name="inside"},a={name="around"}}end end;for h,k in pairs(c.options.triggers_nowait)do e.nowait[k]=true end;e.register(i,{mode="n",preset=true})e.register({i={name="inside"},a={name="around"}},{mode="v",preset=true})for l,m in pairs(c.options.triggers_blacklist)do for h,n in ipairs(m)do e.blacklist[l]=e.blacklist[l]or{}e.blacklist[l][n]=true end end end;function e.get_operator(o)for p,h in pairs(c.options.operators)do local q=b.t(p)if o:sub(1,#q)==q then return q,p end end end;function e.process_motions(r,l,o,s)local q,p="",""if l~="v"then q,p=e.get_operator(o)end;if(l=="n"or l=="v")and q then local t=o:sub(#q+1)local u=t:match("^(%d+)")if u=="0"then u=nil end;if c.options.motions.count==false then u=nil end;if u then t=t:sub(#u+1)end;local v=e.get_mappings("o",t,s)if not r.mapping and v.mapping then r.mapping=v.mapping;r.mapping.prefix=p..(u or"")..r.mapping.prefix;r.mapping.keys=b.parse_keys(r.mapping.prefix)end;for h,w in pairs(v.mappings)do w.prefix=p..(u or"")..w.prefix;w.keys=b.parse_keys(w.prefix)table.insert(r.mappings,w)end end end;function e.get_mappings(l,o,s)local r;r={mapping=nil,mappings={},mode=l,buf=s,prefix_i=o}local x=#b.parse_internal(o)local function y(z)if z then if z.mapping then r.mapping=vim.tbl_deep_extend("force",{},r.mapping or{},z.mapping)end;for A,B in pairs(z.children)do if B.mapping and B.mapping.label~="which_key_ignore"and B.mapping.desc~="which_key_ignore"and not(B.mapping.group and vim.tbl_isempty(B.children))then r.mappings[A]=vim.tbl_deep_extend("force",{},r.mappings[A]or{},B.mapping)end end end end;local C={buf=s,mode=l}y(e.get_tree(l).tree:get(o,nil,C))y(e.get_tree(l,s).tree:get(o,nil,C))e.process_motions(r,l,o,s)local D={}for h,E in pairs(r.mappings)do E.key=E.keys.notation[x+1]if c.options.key_labels[E.key]then E.key=c.options.key_labels[E.key]end;local F=not E.label and c.options.ignore_missing==true;if b.t(E.key)==b.t("<esc>")then F=true end;if not F then if E.group then E.label=E.label or"+prefix"E.label=E.label:gsub("^%+","")E.label=c.options.icons.group..E.label elseif not E.label then E.label=E.desc or E.cmd or""for h,G in ipairs(c.options.hidden)do E.label=E.label:gsub(G,"")end end;if E.value then E.value=vim.fn.strtrans(E.value)end;local H=false;for A,G in pairs(D)do if type(G)=="table"and G.key==E.key then D[A]=E;H=true;break end end;if not H then table.insert(D,E)end end end;table.sort(D,function(I,J)if I.order and J.order then return I.order<J.order end;if I.group==J.group then local K=(I.key or""):lower()local L=(J.key or""):lower()local M=K:match("[a-z]")and 1 or 0;local N=L:match("[a-z]")and 1 or 0;if M==N then return K<L end;return M<N else return(I.group and 1 or 0)<(J.group and 1 or 0)end end)r.mappings=D;return r end;e.mappings={}e.duplicates={}function e.map(l,n,O,s,P)local Q=vim.api.nvim_buf_call(s or 0,function()local r=vim.fn.maparg(n,l,false,true)return r and r.lhs and r.rhs and r.rhs~=O and r or nil end)if Q and Q.buffer==s then table.insert(e.duplicates,{mode=l,prefix=n,cmd=O,buf=s,other=Q})end;if s~=nil then pcall(vim.api.nvim_buf_set_keymap,s,l,n,O,P)else pcall(vim.api.nvim_set_keymap,l,n,O,P)end end;function e.register(i,P)P=P or{}i=require("which-key.mappings").parse(i,P)local R={}for h,w in pairs(i)do if not R[w.mode]then R[w.mode]=true;e.get_tree(w.mode)end;if w.cmd~=nil then e.map(w.mode,w.prefix,w.cmd,w.buf,w.opts)end;e.get_tree(w.mode,w.buf).tree:add(w)end end;e.hooked={}function e.hook_id(n,l,s)return l..(s or"")..b.t(n)end;function e.is_hooked(n,l,s)return e.hooked[e.hook_id(n,l,s)]end;function e.hook_del(n,l,s)local S=e.hook_id(n,l,s)e.hooked[S]=nil;if s then pcall(vim.api.nvim_buf_del_keymap,s,l,n)pcall(vim.api.nvim_buf_del_keymap,s,l,n..d)else pcall(vim.api.nvim_del_keymap,l,n)pcall(vim.api.nvim_del_keymap,l,n..d)end end;function e.hook_add(n,l,s,T)if e.blacklist[l]and e.blacklist[l][n]then return end;if tonumber(n)then return end;if l=="i"and(n=="j"or n=="k")then return end;if l=="n"and n=="q"then return end;if l=="s"then return end;if l=="o"then return end;if b.t(n)==b.t("<esc>")then return end;if(l=="v"or l=="x")and(n=="a"or n=="i"or e.operators[n])then return end;if type(c.options.triggers)=="string"and c.options.triggers~="auto"then if b.t(n)~=b.t(c.options.triggers)then return end end;if type(c.options.triggers)=="table"then local U=false;for h,V in pairs(c.options.triggers)do if b.t(V)==b.t(n)then U=true;break end end;if not U then return end end;local P={noremap=true,silent=true}local S=e.hook_id(n,l,s)local W=e.hook_id(n,l)if not e.hooked[S]and not e.hooked[W]then local O=[[<cmd>lua require("which-key").show(%q, {mode = %q, auto = true})<cr>]]O=string.format(O,b.t(n),l)local X=l=="v"and"x"or l;if T~=true then e.map(X,n,O,s,P)end;if not e.nowait[n]then e.map(X,n..d,"<nop>",s,P)end;e.hooked[S]=true end end;function e.update(s)for A,Y in pairs(e.mappings)do if Y.buf and not vim.api.nvim_buf_is_valid(Y.buf)then e.mappings[A]=nil elseif not s or not Y.buf or s==Y.buf then e.update_keymaps(Y.mode,Y.buf)e.add_hooks(Y.mode,Y.buf,Y.tree.root)end end end;function e.add_hooks(l,s,z,T)if not z.mapping then z.mapping={prefix=z.prefix_n,group=true,keys=b.parse_keys(z.prefix_n)}end;if z.prefix_n~=""and z.mapping.group==true and not(z.mapping.cmd or z.mapping.callback)then e.hook_add(z.prefix_n,l,s,T)T=true end;for h,B in pairs(z.children)do e.add_hooks(l,s,B,T)end end;function e.dump()local U={}local Z={}for h,Y in pairs(e.mappings)do e.update_keymaps(Y.mode,Y.buf)Y.tree:walk(function(z)if z.mapping then if z.mapping.label then U[z.mapping.prefix]=true;Z[z.mapping.prefix]=nil elseif not U[z.mapping.prefix]then Z[z.mapping.prefix]={z.mapping.cmd or""}end end end)end;return Z end;function e.get_tree(l,s)if l=="s"or l=="x"then l="v"end;b.check_mode(l,s)local _=l..(s or"")if not e.mappings[_]then e.mappings[_]={mode=l,buf=s,tree=a:new()}end;return e.mappings[_]end;function e.is_hook(a0,O)if a0:find(d,1,true)then return true end;return O and O:find("which-key",1,true)and O:find("auto",1,true)end;function e.update_keymaps(l,s)local a1=s and vim.api.nvim_buf_get_keymap(s,l)or vim.api.nvim_get_keymap(l)local Y=e.get_tree(l,s).tree;local function a2(a3)return not a3.callback and(a3.rhs==""or a3.rhs:lower()=="<nop>")end;for h,a3 in pairs(a1)do local F=e.is_hook(a3.lhs,a3.rhs)if a2(a3)then F=true end;if not F then local w={prefix=a3.lhs,cmd=a3.rhs,desc=a3.desc,callback=a3.callback,keys=b.parse_keys(a3.lhs)}if w.keys.notation[1]:lower()~="<plug>"then local z=Y:add(w)if z.mapping and z.mapping.preset and w.desc then z.mapping.label=w.desc end end end end end;return e
