local a={}local b={}a.setup=function(c)_G.MiniIndentscope=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands()b.create_default_hl()end;a.config={draw={delay=100,animation=function(d,e)return 20 end,priority=2},mappings={object_scope='ii',object_scope_with_border='ai',goto_top='[i',goto_bottom=']i'},options={border='both',indent_at_cursor=true,try_as_border=false},symbol='â•Ž'}a.get_scope=function(f,g,h)h=b.get_config({options=h}).options;if not(f and g)then local i=vim.fn.getcurpos()f=f or i[2]f=h.try_as_border and b.border_correctors[h.border](f,h)or f;g=g or(h.indent_at_cursor and i[5]or math.huge)end;local j=b.get_line_indent(f,h)local k=math.min(g,j)local l={indent=k}if k<=0 then l.top,l.bottom,l.indent=1,vim.fn.line('$'),j else local m,n;l.top,m=b.cast_ray(f,k,'up',h)l.bottom,n=b.cast_ray(f,k,'down',h)l.indent=math.min(j,m,n)end;return{body=l,border=b.border_from_body[h.border](l,h),buf_id=vim.api.nvim_get_current_buf(),reference={line=f,column=g,indent=k}}end;a.draw=function(o,h)o=o or a.get_scope()local c=b.get_config()local p=vim.tbl_deep_extend('force',{animation_fun=c.draw.animation,priority=c.draw.priority},h or{})b.undraw_scope()b.current.scope=o;b.draw_scope(o,p)end;a.undraw=function()b.undraw_scope()end;a.gen_animation={}a.gen_animation.none=function()return function()return 0 end end;a.gen_animation.linear=function(h)return b.animation_arithmetic_powers(0,b.normalize_animation_opts(h))end;a.gen_animation.quadratic=function(h)return b.animation_arithmetic_powers(1,b.normalize_animation_opts(h))end;a.gen_animation.cubic=function(h)return b.animation_arithmetic_powers(2,b.normalize_animation_opts(h))end;a.gen_animation.quartic=function(h)return b.animation_arithmetic_powers(3,b.normalize_animation_opts(h))end;a.gen_animation.exponential=function(h)return b.animation_geometrical_powers(b.normalize_animation_opts(h))end;a.move_cursor=function(q,r,o)o=o or a.get_scope()local s=r and o.border[q]or o.body[q]s=math.min(math.max(s,1),vim.fn.line('$'))vim.api.nvim_win_set_cursor(0,{s,0})vim.cmd('normal! ^')end;a.operator=function(q,t)local o=a.get_scope()if b.scope_get_draw_indent(o)<0 then return end;local u=vim.v.count1;if t then vim.cmd('normal! m`')end;for v=1,u do a.move_cursor(q,true,o)o=a.get_scope(nil,nil,{try_as_border=false})if b.scope_get_draw_indent(o)<0 then return end end end;a.textobject=function(r)local o=a.get_scope()if b.scope_get_draw_indent(o)<0 then return end;local u=r and vim.v.count1 or 1;for v=1,u do local w,x='top','bottom'if r and o.border.bottom==nil then w,x='bottom','top'end;b.exit_visual_mode()a.move_cursor(w,r,o)vim.cmd('normal! V')a.move_cursor(x,r,o)o=a.get_scope(nil,nil,{try_as_border=false})if b.scope_get_draw_indent(o)<0 then return end end end;b.default_config=vim.deepcopy(a.config)b.ns_id=vim.api.nvim_create_namespace('MiniIndentscope')b.timer=vim.loop.new_timer()b.current={event_id=0,scope={},draw_status='none'}b.indent_funs={['min']=function(y,z)return math.min(y,z)end,['max']=function(y,z)return math.max(y,z)end,['top']=function(y,z)return y end,['bottom']=function(y,z)return z end}b.blank_indent_funs={['none']=b.indent_funs.min,['top']=b.indent_funs.bottom,['bottom']=b.indent_funs.top,['both']=b.indent_funs.max}b.border_from_body={['none']=function(l,h)return{}end,['top']=function(l,h)return{top=l.top-1,indent=b.get_line_indent(l.top-1,h)}end,['bottom']=function(l,h)return{bottom=l.bottom+1,indent=b.get_line_indent(l.bottom+1,h)}end,['both']=function(l,h)return{top=l.top-1,bottom=l.bottom+1,indent=math.max(b.get_line_indent(l.top-1,h),b.get_line_indent(l.bottom+1,h))}end}b.border_correctors={['none']=function(f,h)return f end,['top']=function(f,h)local A,B=b.get_line_indent(f,h),b.get_line_indent(f+1,h)return A<B and f+1 or f end,['bottom']=function(f,h)local C,A=b.get_line_indent(f-1,h),b.get_line_indent(f,h)return A<C and f-1 or f end,['both']=function(f,h)local C,A,B=b.get_line_indent(f-1,h),b.get_line_indent(f,h),b.get_line_indent(f+1,h)if C<=A and B<=A then return f end;if C<=B then return f+1 end;return f-1 end}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({draw={c.draw,'table'},mappings={c.mappings,'table'},options={c.options,'table'},symbol={c.symbol,'string'}})vim.validate({['draw.delay']={c.draw.delay,'number'},['draw.animation']={c.draw.animation,'function'},['draw.priority']={c.draw.priority,'number'},['mappings.object_scope']={c.mappings.object_scope,'string'},['mappings.object_scope_with_border']={c.mappings.object_scope_with_border,'string'},['mappings.goto_top']={c.mappings.goto_top,'string'},['mappings.goto_bottom']={c.mappings.goto_bottom,'string'},['options.border']={c.options.border,'string'},['options.indent_at_cursor']={c.options.indent_at_cursor,'boolean'},['options.try_as_border']={c.options.try_as_border,'boolean'}})return c end;b.apply_config=function(c)a.config=c;local D=c.mappings;b.map('n',D.goto_top,[[<Cmd>lua MiniIndentscope.operator('top', true)<CR>]],{desc='Go to indent scope top'})b.map('n',D.goto_bottom,[[<Cmd>lua MiniIndentscope.operator('bottom', true)<CR>]],{desc='Go to indent scope bottom'})b.map('x',D.goto_top,[[<Cmd>lua MiniIndentscope.operator('top')<CR>]],{desc='Go to indent scope top'})b.map('x',D.goto_bottom,[[<Cmd>lua MiniIndentscope.operator('bottom')<CR>]],{desc='Go to indent scope bottom'})b.map('x',D.object_scope,'<Cmd>lua MiniIndentscope.textobject(false)<CR>',{desc='Object scope'})b.map('x',D.object_scope_with_border,'<Cmd>lua MiniIndentscope.textobject(true)<CR>',{desc='Object scope with border'})b.map('o',D.goto_top,[[<Cmd>lua MiniIndentscope.operator('top')<CR>]],{desc='Go to indent scope top'})b.map('o',D.goto_bottom,[[<Cmd>lua MiniIndentscope.operator('bottom')<CR>]],{desc='Go to indent scope bottom'})b.map('o',D.object_scope,'<Cmd>lua MiniIndentscope.textobject(false)<CR>',{desc='Object scope'})b.map('o',D.object_scope_with_border,'<Cmd>lua MiniIndentscope.textobject(true)<CR>',{desc='Object scope with border'})end;b.create_autocommands=function()local E=vim.api.nvim_create_augroup('MiniIndentscope',{})local F=function(G,H,I,J)vim.api.nvim_create_autocmd(G,{group=E,pattern=H,callback=I,desc=J})end;F({'CursorMoved','CursorMovedI','ModeChanged'},'*',function()b.auto_draw({lazy=true})end,'Auto draw indentscope lazily')F({'TextChanged','TextChangedI','TextChangedP','WinScrolled'},'*',function()b.auto_draw()end,'Auto draw indentscope')end;b.create_default_hl=function()vim.api.nvim_set_hl(0,'MiniIndentscopeSymbol',{default=true,link='Delimiter'})vim.api.nvim_set_hl(0,'MiniIndentscopeSymbolOff',{default=true,link='MiniIndentscopeSymbol'})end;b.is_disabled=function()return vim.g.miniindentscope_disable==true or vim.b.miniindentscope_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.miniindentscope_config or{},c or{})end;b.auto_draw=function(h)if b.is_disabled()then b.undraw_scope()return end;h=h or{}local o=a.get_scope()if h.lazy and b.current.draw_status~='none'and b.scope_is_equal(o,b.current.scope)then return end;local K=b.current.event_id+1;b.current.event_id=K;local p=b.make_autodraw_opts(o)if p.delay>0 then b.undraw_scope(p)end;vim.defer_fn(function()if b.current.event_id~=K then return end;b.undraw_scope(p)b.current.scope=o;b.draw_scope(o,p)end,p.delay)end;b.get_line_indent=function(f,h)local L=vim.fn.prevnonblank(f)local M=vim.fn.indent(L)if f~=L then local B=vim.fn.indent(vim.fn.nextnonblank(f))local N=b.blank_indent_funs[h.border]M=N(M,B)end;return M end;b.cast_ray=function(f,k,O,h)local P,Q=1,-1;if O=='down'then P,Q=vim.fn.line('$'),1 end;local R=math.huge;for S=f,P,Q do local T=b.get_line_indent(S+Q,h)if T<k then return S,R end;if T<R then R=T end end;return P,R end;b.scope_get_draw_indent=function(o)return o.border.indent or o.body.indent-1 end;b.scope_is_equal=function(U,V)if type(U)~='table'or type(V)~='table'then return false end;return U.buf_id==V.buf_id and b.scope_get_draw_indent(U)==b.scope_get_draw_indent(V)and U.body.top==V.body.top and U.body.bottom==V.body.bottom end;b.scope_has_intersect=function(U,V)if type(U)~='table'or type(V)~='table'then return false end;if U.buf_id~=V.buf_id or b.scope_get_draw_indent(U)~=b.scope_get_draw_indent(V)then return false end;local W,X=U.body,V.body;return X.top<=W.top and W.top<=X.bottom or W.top<=X.top and X.top<=W.bottom end;b.indicator_compute=function(o)o=o or b.current.scope;local k=b.scope_get_draw_indent(o)if k<0 then return{}end;local g=k-vim.fn.winsaveview().leftcol;if g<0 then return{}end;local Y=k%vim.fn.shiftwidth()==0 and'MiniIndentscopeSymbol'or'MiniIndentscopeSymbolOff'local Z={{b.get_config().symbol,Y}}return{buf_id=vim.api.nvim_get_current_buf(),virt_text=Z,virt_text_win_col=g,top=o.body.top,bottom=o.body.bottom}end;b.draw_scope=function(o,h)o=o or{}h=h or{}local _=b.indicator_compute(o)if _.virt_text==nil or#_.virt_text==0 then b.current.draw_status='finished'return end;local a0=b.make_draw_function(_,h)b.current.draw_status='drawing'b.draw_indicator_animation(_,a0,h.animation_fun)end;b.draw_indicator_animation=function(_,a0,a1)local a2,a3=_.top,_.bottom;local a4=math.min(math.max(vim.fn.line('.'),a2),a3)local a5=0;local a6=math.max(a4-a2,a3-a4)local a7=0;local a8;a8=vim.schedule_wrap(function()local a9=a0(a4-a5)if a5>0 then a9=a9 and a0(a4+a5)end;if not a9 or a5==a6 then b.current.draw_status=a5==a6 and'finished'or b.current.draw_status;b.timer:stop()return end;a5=a5+1;a7=a7+a1(a5,a6)if a7<1 then b.timer:set_repeat(0)return a8()else b.timer:set_repeat(a7)a7=a7-b.timer:get_repeat()b.timer:again()end end)b.timer:start(10000000,0,a8)a8()end;b.undraw_scope=function(h)h=h or{}if h.event_id and h.event_id~=b.current.event_id then return end;pcall(vim.api.nvim_buf_clear_namespace,b.current.scope.buf_id or 0,b.ns_id,0,-1)b.current.draw_status='none'b.current.scope={}end;b.make_autodraw_opts=function(o)local c=b.get_config()local M={event_id=b.current.event_id,type='animation',delay=c.draw.delay,animation_fun=c.draw.animation,priority=c.draw.priority}if b.current.draw_status=='none'then return M end;if b.scope_has_intersect(o,b.current.scope)then M.type='immediate'M.delay=0;M.animation_fun=a.gen_animation.none()return M end;return M end;b.make_draw_function=function(_,h)local aa={hl_mode='combine',priority=h.priority,right_gravity=false,virt_text=_.virt_text,virt_text_win_col=_.virt_text_win_col,virt_text_pos='overlay'}local ab=h.event_id;return function(S)if b.current.event_id~=ab and ab~=nil then return false end;if b.is_disabled()then return false end;if not(_.top<=S and S<=_.bottom)then return true end;return pcall(vim.api.nvim_buf_set_extmark,_.buf_id,b.ns_id,S-1,0,aa)end end;b.animation_arithmetic_powers=function(ac,h)local ad=({[0]=function(a6)return a6 end,[1]=function(a6)return a6*(a6+1)/2 end,[2]=function(a6)return a6*(a6+1)*(2*a6+1)/6 end,[3]=function(a6)return a6^2*(a6+1)^2/4 end})[ac]local ae,af=h.unit,h.duration;local ag=function(a6,ah)local ai=ae=='total'and af or af*a6;local aj;if ah then aj=2*ad(math.ceil(0.5*a6))-(a6%2==1 and 1 or 0)else aj=ad(a6)end;return ai/aj end;return({['in']=function(d,e)return ag(e)*(e-d+1)^ac end,['out']=function(d,e)return ag(e)*d^ac end,['in-out']=function(d,e)local ak=math.ceil(0.5*e)local al;if e%2==0 then al=d<=ak and ak-d+1 or d-ak else al=d<ak and ak-d+1 or d-ak+1 end;return ag(e,true)*al^ac end})[h.easing]end;b.animation_geometrical_powers=function(h)local ae,af=h.unit,h.duration;local ag=function(a6,ah)local ai=ae=='step'and af*a6 or af;if a6==1 then return ai+1 end;if ah then local ak=math.ceil(0.5*a6)if a6%2==1 then ai=ai+math.pow(0.5*ai+1,1/ak)-1 end;return math.pow(0.5*ai+1,1/ak)end;return math.pow(ai+1,1/a6)end;return({['in']=function(d,e)local am=ag(e)return(am-1)*am^(e-d)end,['out']=function(d,e)local am=ag(e)return(am-1)*am^(d-1)end,['in-out']=function(d,e)local ak,am=math.ceil(0.5*e),ag(e,true)local al;if e%2==0 then al=d<=ak and ak-d or d-ak-1 else al=d<ak and ak-d or d-ak end;return(am-1)*am^al end})[h.easing]end;b.normalize_animation_opts=function(an)an=vim.tbl_deep_extend('force',{easing='in-out',duration=20,unit='step'},an or{})if not vim.tbl_contains({'in','out','in-out'},an.easing)then b.error([[In `gen_animation` option `easing` should be one of 'in', 'out', or 'in-out'.]])end;if type(an.duration)~='number'or an.duration<0 then b.error([[In `gen_animation` option `duration` should be a positive number.]])end;if not vim.tbl_contains({'total','step'},an.unit)then b.error([[In `gen_animation` option `unit` should be one of 'step' or 'total'.]])end;return an end;b.error=function(ao)error(('(mini.indentscope) %s'):format(ao))end;b.map=function(ap,aq,ar,h)if aq==''then return end;h=vim.tbl_deep_extend('force',{silent=true},h or{})vim.keymap.set(ap,aq,ar,h)end;b.exit_visual_mode=function()local as=vim.api.nvim_replace_termcodes('<C-v>',true,true,true)local at=vim.fn.mode()if at=='v'or at=='V'or at==as then vim.cmd('normal! '..at)end end;return a
