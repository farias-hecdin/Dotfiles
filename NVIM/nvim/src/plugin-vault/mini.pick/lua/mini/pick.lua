local a={}local b={}a.setup=function(c)_G.MiniPick=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()vim.api.nvim_create_user_command('Pick',function(d)local e,f=b.command_parse_fargs(d.fargs)local g=a.registry[e]if g==nil then b.error(string.format('There is no picker named "%s" in registry.',e))end;g(f)end,{nargs='+',complete=b.command_complete,desc="Pick from 'mini.pick' registry"})end;a.config={delay={async=10,busy=50},mappings={caret_left='<Left>',caret_right='<Right>',choose='<CR>',choose_in_split='<C-s>',choose_in_tabpage='<C-t>',choose_in_vsplit='<C-v>',choose_marked='<M-CR>',delete_char='<BS>',delete_char_right='<Del>',delete_left='<C-u>',delete_word='<C-w>',mark='<C-x>',mark_all='<C-a>',move_down='<C-n>',move_start='<C-g>',move_up='<C-p>',paste='<C-r>',refine='<C-Space>',refine_marked='<M-Space>',scroll_down='<C-f>',scroll_left='<C-h>',scroll_right='<C-l>',scroll_up='<C-b>',stop='<Esc>',toggle_info='<S-Tab>',toggle_preview='<Tab>'},options={content_from_bottom=false,use_cache=false},source={items=nil,name=nil,cwd=nil,match=nil,show=nil,preview=nil,choose=nil,choose_marked=nil},window={config=nil}}a.start=function(h)if a.is_picker_active()then a.stop()return vim.defer_fn(function()if a.is_picker_active()then b.picker_stop(b.pickers.active,true)end;a.start(h)end,0.5)end;b.cache={}h=b.validate_picker_opts(h)local i=b.picker_new(h)b.pickers.active=i;b.picker_set_busy(i,true)local j=b.expand_callable(h.source.items)if vim.tbl_islist(j)then vim.schedule(function()a.set_picker_items(j)end)end;b.picker_track_lost_focus(i)return b.picker_advance(i)end;a.stop=function()if not a.is_picker_active()then return end;b.cache.is_force_stop_advance=true;if b.cache.is_in_getcharstr then vim.api.nvim_feedkeys('\3','t',true)end end;a.refresh=function()if not a.is_picker_active()then return end;b.picker_update(b.pickers.active,false,true)end;a.default_match=function(k,l,m,n)local o=n or not a.is_picker_active()local p=o and function(q)return q end or a.set_picker_match_inds;local g=function()if#m==0 then return p(b.seq_along(k))end;local r,s=b.match_filter(l,k,m)if r==nil then return end;if s=='nosort'then return p(b.seq_along(k))end;local t=b.match_sort(r)if t==nil then return end;return p(t)end;if o then return g()end;coroutine.resume(coroutine.create(g))end;a.default_show=function(u,j,m,h)local v={directory=' ',file=' ',none='  '}h=vim.tbl_deep_extend('force',{show_icons=false,icons=v},h or{})local w=vim.tbl_map(b.item_to_string,j)local x=string.rep(' ',vim.o.tabstop)w=vim.tbl_map(function(y)return y:gsub('\n',' '):gsub('\t',x)end,w)local z=h.show_icons and function(A)return b.get_icon(A,h.icons)end or function()return{text=''}end;local B=vim.tbl_map(z,w)local C={}for D,y in ipairs(w)do C[D]=B[D].text..y end;b.set_buflines(u,C)local E=b.ns_id.ranges;b.clear_namespace(u,E)if b.query_is_ignorecase(m)then w,m=vim.tbl_map(b.tolower,w),vim.tbl_map(b.tolower,m)end;local r,s,F=b.match_filter(b.seq_along(w),w,m)if r==nil then return end;local G=s=='fuzzy'and b.match_ranges_fuzzy or b.match_ranges_exact;local H=G(r,F,w)local I={hl_group='MiniPickMatchRanges',hl_mode='combine',priority=200}for D=1,#r do local J,K=r[D][3],H[D]local L=B[J].text:len()for M,N in ipairs(K)do I.end_row,I.end_col=J-1,L+N[2]b.set_extmark(u,E,J-1,L+N[1]-1,I)end end;if not h.show_icons then return end;local O={hl_mode='combine',priority=200}for D=1,#B do O.hl_group=B[D].hl;O.end_row,O.end_col=D-1,B[D].text:len()b.set_extmark(u,E,D-1,0,O)end end;a.default_preview=function(u,P,h)h=vim.tbl_deep_extend('force',{n_context_lines=2*vim.o.lines,line_position='top'},h or{})local Q=b.parse_item(P)if Q.type=='file'then return b.preview_file(u,Q,h)end;if Q.type=='directory'then return b.preview_directory(u,Q)end;if Q.type=='buffer'then return b.preview_buffer(u,Q,h)end;b.preview_inspect(u,P)end;a.default_choose=function(P)if P==nil then return end;local R=a.get_picker_state()local S=R~=nil and R.windows.target or vim.api.nvim_get_current_win()if not b.is_valid_win(S)then S=b.get_first_valid_normal_window()end;local Q=b.parse_item(P)if Q.type=='file'or Q.type=='directory'then return b.choose_path(S,Q)end;if Q.type=='buffer'then return b.choose_buffer(S,Q)end;b.choose_print(P)end;a.default_choose_marked=function(j,h)if not vim.tbl_islist(j)then b.error('`items` should be an array')end;if#j==0 then return end;h=vim.tbl_deep_extend('force',{list_type='quickfix'},h or{})local T={}for M,P in ipairs(j)do local Q=b.parse_item(P)if Q.type=='file'or Q.type=='buffer'then local U={bufnr=Q.buf_id,filename=Q.path}U.lnum,U.col,U.text=Q.lnum or 1,Q.col or 1,Q.text or''U.end_lnum,U.end_col=Q.end_lnum,Q.end_col;table.insert(T,U)end end;local V=a.is_picker_active()if#T==0 then if not V then return end;local W=a.get_picker_opts().source.choose;return W(j[1])end;local X='<No picker>'if V then local Y,Z=a.get_picker_opts().source.name,table.concat(a.get_picker_query())X=Y..(Z==''and''or' : '..Z)end;local _={items=T,title=X,nr='$'}if h.list_type=='location'then local S=a.get_picker_state().windows.target;if not b.is_valid_win(S)then S=b.get_first_valid_normal_window()end;vim.fn.setloclist(S,{},' ',_)vim.schedule(function()vim.cmd('lopen')end)else vim.fn.setqflist({},' ',_)vim.schedule(function()vim.cmd('copen')end)end end;a.ui_select=function(j,h,a0)local a1=h.format_item or b.item_to_string;local a2={}for D=1,#j do table.insert(a2,{text=a1(j[D]),item=j[D],index=D})end;local a3=vim.is_callable(h.preview_item)and h.preview_item or function(q)return vim.split(vim.inspect(q),'\n')end;local a4=function(u,P)b.set_buflines(u,a3(P.item))end;local a5=true;local W=function(P)a5=false;if P==nil then return end;local S=a.get_picker_state().windows.target;if not b.is_valid_win(S)then S=b.get_first_valid_normal_window()end;vim.api.nvim_win_call(S,function()a0(P.item,P.index)a.set_picker_target_window(vim.api.nvim_get_current_win())end)end;local a6={items=a2,name=h.kind or h.prompt,preview=a4,choose=W}local P=a.start({source=a6})if P==nil and a5 then a0(nil)end end;a.builtin={}a.builtin.files=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil},f or{})local a7=f.tool or b.files_get_tool()local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Files (%s)',a7),show=a8}}h=vim.tbl_deep_extend('force',a9,h or{})if a7=='fallback'then h.source.items=function()b.files_fallback_items(h.source.cwd)end;return a.start(h)end;return a.builtin.cli({command=b.files_get_command(a7)},h)end;a.builtin.grep=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil,pattern=nil},f or{})local a7=f.tool or b.grep_get_tool()local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Grep (%s)',a7),show=a8}}h=vim.tbl_deep_extend('force',a9,h or{})local aa=type(f.pattern)=='string'and f.pattern or vim.fn.input('Grep pattern: ')if a7=='fallback'then h.source.items=function()b.grep_fallback_items(aa,h.source.cwd)end;return a.start(h)end;return a.builtin.cli({command=b.grep_get_command(a7,aa)},h)end;a.builtin.grep_live=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil},f or{})local a7=f.tool or b.grep_get_tool()if a7=='fallback'or not b.is_executable(a7)then b.error('`grep_live` needs non-fallback executable tool.')end;local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Grep live (%s)',a7),show=a8}}h=vim.tbl_deep_extend('force',a9,h or{})local ab,ac={do_match=false,querytick=b.querytick},{cwd=h.source.cwd}local ad;local ae=function(M,M,m)pcall(vim.loop.process_kill,ad)if b.querytick==ab.querytick then return end;if#m==0 then return a.set_picker_items({},ab)end;ab.querytick=b.querytick;local af=b.grep_get_command(a7,table.concat(m))ad=a.set_picker_items_from_cli(af,{set_items_opts=ab,spawn_opts=ac})end;h=vim.tbl_deep_extend('force',h or{},{source={items={},match=ae}})return a.start(h)end;a.builtin.help=function(f,h)local ag=vim.api.nvim_create_buf(false,true)vim.bo[ag].buftype='help'local ah=vim.api.nvim_buf_call(ag,function()return vim.fn.taglist('.*')end)vim.api.nvim_buf_delete(ag,{force=true})vim.tbl_map(function(ai)ai.text=ai.name end,ah)local W=function(P,aj)if P==nil then return end;vim.schedule(function()vim.cmd((aj or'')..'help '..(P.name or''))end)end;local a4=function(u,P)vim.api.nvim_buf_call(u,function()vim.cmd('noautocmd edit '..vim.fn.fnameescape(P.filename))vim.bo.buftype,vim.bo.buflisted,vim.bo.bufhidden,vim.bo.syntax='nofile',false,'wipe','help'local ak=vim.v.hlsearch;local al=string.gsub(P.cmd,'^/','/\\V')vim.cmd('silent keeppatterns '..al)vim.cmd('let v:hlsearch='..ak)vim.cmd('normal! zt')end)end;local am=function(an,aj)local g=function()W(a.get_picker_matches().current,aj..' ')return true end;return{char=an,func=g}end;local ao={choose_in_split='',show_help_in_split=am('<C-s>',''),choose_in_vsplit='',show_help_in_vsplit=am('<C-v>','vertical'),choose_in_tabpage='',show_help_in_tabpage=am('<C-t>','tab')}local a6={items=ah,name='Help',choose=W,preview=a4}h=vim.tbl_deep_extend('force',{source=a6,mappings=ao},h or{})return a.start(h)end;a.builtin.buffers=function(f,h)f=vim.tbl_deep_extend('force',{include_current=true,include_unlisted=false},f or{})local ap=vim.api.nvim_exec('buffers'..(f.include_unlisted and'!'or''),true)local aq,ar=vim.api.nvim_get_current_buf(),f.include_current;local j={}for M,y in ipairs(vim.split(ap,'\n'))do local as,e=y:match('^%s*%d+'),y:match('"(.*)"')local u=tonumber(as)local P={text=e,bufnr=u}if u~=aq or ar then table.insert(j,P)end end;local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name='Buffers',show=a8}}h=vim.tbl_deep_extend('force',a9,h or{},{source={items=j}})return a.start(h)end;a.builtin.cli=function(f,h)f=vim.tbl_deep_extend('force',{command={},postprocess=nil,spawn_opts={}},f or{})local e=string.format('CLI (%s)',tostring(f.command[1]or''))h=vim.tbl_deep_extend('force',{source={name=e}},h or{})f.spawn_opts.cwd=f.spawn_opts.cwd or h.source.cwd;local af=f.command;local at={postprocess=f.postprocess,spawn_opts=f.spawn_opts}h.source.items=vim.schedule_wrap(function()a.set_picker_items_from_cli(af,at)end)return a.start(h)end;a.builtin.resume=function()local i=b.pickers.latest;if i==nil then b.error('There is no picker to resume.')end;local u=b.picker_new_buf()local S=vim.api.nvim_get_current_win()local au=b.picker_new_win(u,i.opts.window.config)i.buffers={main=u}i.windows={main=au,target=S}i.view_state='main'b.pickers.active,b.cache=i,{}return b.picker_advance(i)end;a.registry={}for e,g in pairs(a.builtin)do a.registry[e]=function(f)return g(f)end end;if type(MiniExtra)=='table'then for e,g in pairs(MiniExtra.pickers)do a.registry[e]=function(f)return g(f)end end end;a.get_picker_items=function()return vim.deepcopy((b.pickers.active or{}).items)end;a.get_picker_stritems=function()return vim.deepcopy((b.pickers.active or{}).stritems)end;a.get_picker_matches=function()if not a.is_picker_active()then return end;local i=b.pickers.active;local j=i.items;if j==nil or#j==0 then return{}end;local av={all_inds=vim.deepcopy(i.match_inds),current_ind=i.match_inds[i.current_ind]}av.all=vim.tbl_map(function(aw)return j[aw]end,i.match_inds)av.current=i.items[av.current_ind]local ax=vim.tbl_keys(i.marked_inds_map)table.sort(ax)av.marked_inds,av.marked=ax,vim.tbl_map(function(aw)return j[aw]end,ax)return av end;a.get_picker_opts=function()return vim.deepcopy((b.pickers.active or{}).opts)end;a.get_picker_state=function()if not a.is_picker_active()then return end;local i=b.pickers.active;return vim.deepcopy({buffers=i.buffers,windows=i.windows,caret=i.caret,is_busy=i.is_busy})end;a.get_picker_query=function()return vim.deepcopy((b.pickers.active or{}).query)end;a.set_picker_items=function(j,h)if not vim.tbl_islist(j)then b.error('`items` should be an array.')end;if not a.is_picker_active()then return end;h=vim.tbl_deep_extend('force',{do_match=true,querytick=nil},h or{})coroutine.wrap(b.picker_set_items)(b.pickers.active,j,h)end;a.set_picker_items_from_cli=function(af,h)if not a.is_picker_active()then return end;local ay=b.is_array_of(af,'string')and#af>=1;if not ay then b.error('`command` should be an array of strings.')end;local a9={postprocess=b.cli_postprocess,set_items_opts={},spawn_opts={}}h=vim.tbl_deep_extend('force',a9,h or{})local az,aA=af[1],vim.list_slice(af,2,#af)local ad,aB,aC=nil,nil,vim.loop.new_pipe()local ac=vim.tbl_deep_extend('force',h.spawn_opts,{args=aA,stdio={nil,aC,nil}})if type(ac.cwd)=='string'then ac.cwd=b.full_path(ac.cwd)end;ad,aB=vim.loop.spawn(az,ac,function()ad:close()end)local aD={}aC:read_start(function(aE,aF)assert(not aE,aE)if aF~=nil then return table.insert(aD,aF)end;local j=vim.split(table.concat(aD),'\n')aD=nil;aC:close()vim.schedule(function()a.set_picker_items(h.postprocess(j),h.set_items_opts)end)end)return ad,aB end;a.set_picker_match_inds=function(t)if not a.is_picker_active()then return end;if not b.is_array_of(t,'number')then b.error('`match_inds` should be an array of numbers.')end;b.picker_set_match_inds(b.pickers.active,t)b.picker_update(b.pickers.active,false)end;a.set_picker_opts=function(h)if not a.is_picker_active()then return end;b.pickers.active.opts=vim.tbl_deep_extend('force',b.pickers.active.opts,h or{})b.picker_update(b.pickers.active,true,true)end;a.set_picker_target_window=function(au)if not a.is_picker_active()then return end;if not b.is_valid_win(au)then b.error('`win_id` is not a valid window identifier.')end;b.pickers.active.windows.target=au end;a.set_picker_query=function(m)if not a.is_picker_active()then return end;if not b.is_array_of(m,'string')then b.error('`query` should be an array of strings.')end;b.pickers.active.query,b.pickers.active.caret=m,#m+1;b.querytick=b.querytick+1;b.pickers.active.match_inds=b.seq_along(a.get_picker_items())b.picker_update(b.pickers.active,true)end;a.get_querytick=function()return b.querytick end;a.is_picker_active=function()return b.pickers.active~=nil end;a.poke_is_picker_active=function()local aG=coroutine.running()if aG==nil then return a.is_picker_active()end;b.schedule_resume_is_active(aG)return coroutine.yield()end;b.default_config=vim.deepcopy(a.config)b.ns_id={matches=vim.api.nvim_create_namespace('MiniPickMatches'),headers=vim.api.nvim_create_namespace('MiniPickHeaders'),preview=vim.api.nvim_create_namespace('MiniPickPreview'),ranges=vim.api.nvim_create_namespace('MiniPickRanges')}b.timers={busy=vim.loop.new_timer(),focus=vim.loop.new_timer(),getcharstr=vim.loop.new_timer()}b.pickers={active=nil,latest=nil}b.querytick=0;b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({delay={c.delay,'table'},mappings={c.mappings,'table'},options={c.options,'table'},source={c.source,'table'},window={c.window,'table'}})vim.validate({['delay.async']={c.delay.async,'number'},['delay.busy']={c.delay.busy,'number'},['mappings.caret_left']={c.mappings.caret_left,'string'},['mappings.caret_right']={c.mappings.caret_right,'string'},['mappings.choose']={c.mappings.choose,'string'},['mappings.choose_in_split']={c.mappings.choose_in_split,'string'},['mappings.choose_in_tabpage']={c.mappings.choose_in_tabpage,'string'},['mappings.choose_in_vsplit']={c.mappings.choose_in_vsplit,'string'},['mappings.choose_marked']={c.mappings.choose_marked,'string'},['mappings.delete_char']={c.mappings.delete_char,'string'},['mappings.delete_char_right']={c.mappings.delete_char_right,'string'},['mappings.delete_left']={c.mappings.delete_left,'string'},['mappings.delete_word']={c.mappings.delete_word,'string'},['mappings.mark']={c.mappings.mark,'string'},['mappings.mark_all']={c.mappings.mark_all,'string'},['mappings.move_down']={c.mappings.move_down,'string'},['mappings.move_start']={c.mappings.move_start,'string'},['mappings.move_up']={c.mappings.move_up,'string'},['mappings.paste']={c.mappings.paste,'string'},['mappings.refine']={c.mappings.refine,'string'},['mappings.refine_marked']={c.mappings.refine_marked,'string'},['mappings.scroll_down']={c.mappings.scroll_down,'string'},['mappings.scroll_up']={c.mappings.scroll_up,'string'},['mappings.scroll_left']={c.mappings.scroll_left,'string'},['mappings.scroll_right']={c.mappings.scroll_right,'string'},['mappings.stop']={c.mappings.stop,'string'},['mappings.toggle_info']={c.mappings.toggle_info,'string'},['mappings.toggle_preview']={c.mappings.toggle_preview,'string'},['options.content_from_bottom']={c.options.content_from_bottom,'boolean'},['options.use_cache']={c.options.use_cache,'boolean'},['source.items']={c.source.items,'table',true},['source.name']={c.source.name,'string',true},['source.cwd']={c.source.cwd,'string',true},['source.match']={c.source.match,'function',true},['source.show']={c.source.show,'function',true},['source.preview']={c.source.preview,'function',true},['source.choose']={c.source.choose,'function',true},['source.choose_marked']={c.source.choose_marked,'function',true},['window.config']={c.window.config,function(q)return q==nil or type(q)=='table'or vim.is_callable(q)end,'table or callable'}})return c end;b.apply_config=function(c)a.config=c end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minipick_config or{},c or{})end;b.create_autocommands=function(c)local aH=vim.api.nvim_create_augroup('MiniPick',{})local aI=function(aJ,aa,aK,aL)vim.api.nvim_create_autocmd(aJ,{group=aH,pattern=aa,callback=aK,desc=aL})end;aI('VimResized','*',a.refresh,'Refresh on resize')end;b.create_default_hl=function()local aM=function(e,h)h.default=true;vim.api.nvim_set_hl(0,e,h)end;aM('MiniPickBorder',{link='FloatBorder'})aM('MiniPickBorderBusy',{link='DiagnosticFloatingWarn'})aM('MiniPickBorderText',{link='FloatTitle'})aM('MiniPickIconDirectory',{link='Directory'})aM('MiniPickIconFile',{link='MiniPickNormal'})aM('MiniPickHeader',{link='DiagnosticFloatingHint'})aM('MiniPickMatchCurrent',{link='CursorLine'})aM('MiniPickMatchMarked',{link='Visual'})aM('MiniPickMatchRanges',{link='DiagnosticFloatingHint'})aM('MiniPickNormal',{link='NormalFloat'})aM('MiniPickPreviewLine',{link='CursorLine'})aM('MiniPickPreviewRegion',{link='IncSearch'})aM('MiniPickPrompt',{link='DiagnosticFloatingInfo'})end;b.command_parse_fargs=function(aN)local e,aO=aN[1],vim.tbl_map(b.expandcmd,vim.list_slice(aN,2,#aN))local aP=string.format('{ %s }',table.concat(aO,', '))local aQ=loadstring('return '..aP)if aQ==nil then b.error('Could not convert extra command arguments to table: '..aP)end;return e,aQ()end;b.command_complete=function(M,A,aR)local aS,aT,aU=string.find(A,'^%S+%s+(%S*)')if aR<aS or aT<aR then return{}end;local aV=vim.tbl_filter(function(q)return tostring(q):find(aU,1,true)~=nil end,vim.tbl_keys(a.registry))table.sort(aV)return aV end;b.validate_picker_opts=function(h)h=h or{}if type(h)~='table'then b.error('Picker options should be table.')end;h=vim.deepcopy(b.get_config(h))local aW=function(q,aX)if not vim.is_callable(q)then b.error(string.format('`%s` should be callable.',aX))end end;local a6=h.source;local j=a6.items or{}local aY=vim.tbl_islist(j)or vim.is_callable(j)if not aY then b.error('`source.items` should be array or callable.')end;a6.name=tostring(a6.name or'<No name>')if type(a6.cwd)=='string'then a6.cwd=b.full_path(a6.cwd)end;if a6.cwd==nil then a6.cwd=vim.fn.getcwd()end;if vim.fn.isdirectory(a6.cwd)==0 then b.error('`source.cwd` should be a valid directory path.')end;a6.match=a6.match or a.default_match;aW(a6.match,'source.match')a6.show=a6.show or a.default_show;aW(a6.show,'source.show')a6.preview=a6.preview or a.default_preview;aW(a6.preview,'source.preview')a6.choose=a6.choose or a.default_choose;aW(a6.choose,'source.choose')a6.choose_marked=a6.choose_marked or a.default_choose_marked;aW(a6.choose_marked,'source.choose_marked')for aZ,a_ in pairs(h.delay)do local b0=type(a_)=='number'and a_>0;if not b0 then b.error(string.format('`delay.%s` should be a positive number.',aZ))end end;local b1=b.default_config.mappings;for b2,q in pairs(h.mappings)do if type(b2)~='string'then b.error('`mappings` should have only string fields.')end;local b3=b1[b2]~=nil;if b3 and type(q)~='string'then b.error(string.format('Mapping for built-in action "%s" should be string.',b2))end;if not b3 and not(type(q)=='table'and type(q.char)=='string'and vim.is_callable(q.func))then b.error(string.format('Mapping for custom action "%s" should be table with `char` and `func`.',b2))end end;local b4=h.options;if type(b4.content_from_bottom)~='boolean'then b.error('`options.content_from_bottom` should be boolean.')end;if type(b4.use_cache)~='boolean'then b.error('`options.use_cache` should be boolean.')end;local b5=h.window.config;local b6=b5==nil or type(b5)=='table'or vim.is_callable(b5)if not b6 then b.error('`window.config` should be table or callable.')end;return h end;b.picker_new=function(h)local u=b.picker_new_buf()local S=vim.api.nvim_get_current_win()local au=b.picker_new_win(u,h.window.config)local i={opts=h,items=nil,stritems=nil,stritems_ignorecase=nil,buffers={main=u,preview=nil,info=nil},windows={main=au,target=S},query={},caret=1,match_inds=nil,marked_inds_map={},is_busy=false,cache={},view_state='main',visible_range={from=nil,to=nil},current_ind=nil}b.querytick=b.querytick+1;return i end;b.picker_advance=function(i)vim.schedule(function()vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStart'})end)local b7=b.picker_get_char_data(i)local b8,b9=false,false;for M=1,1000000 do if b.cache.is_force_stop_advance then break end;b.picker_update(i,b8)local an=b.getcharstr(i.opts.delay.async)if b.cache.is_force_stop_advance then break end;b9=an==nil;if b9 then break end;local ba=b7[an]or{}b8=ba.name==nil or vim.startswith(ba.name,'delete')or ba.name=='paste'b9=ba.name=='stop'local bb;if ba.is_custom then bb=ba.func()else bb=(ba.func or b.picker_query_add)(i,an)end;if bb then break end end;local P;if not b9 then P=b.picker_get_current_item(i)end;b.cache.is_force_stop_advance=nil;b.picker_stop(i)return P end;b.picker_update=function(i,b8,bc)if b8 then b.picker_match(i)end;if bc then local c=b.picker_compute_win_config(i.opts.window.config)vim.api.nvim_win_set_config(i.windows.main,c)b.picker_set_current_ind(i,i.current_ind,true)end;b.picker_set_bordertext(i)b.picker_set_lines(i)b.redraw()end;b.picker_new_buf=function()local u=b.create_scratch_buf()vim.bo[u].filetype='minipick'return u end;b.picker_new_win=function(u,b5)if vim.fn.mode()=='n'then b.cache.cmdheight=vim.o.cmdheight;vim.o.cmdheight=1;vim.cmd('noautocmd normal! :')end;local au=vim.api.nvim_open_win(u,true,b.picker_compute_win_config(b5,true))vim.wo[au].foldenable=false;vim.wo[au].list=true;vim.wo[au].listchars='extends:…'vim.wo[au].scrolloff=0;vim.wo[au].wrap=false;b.win_update_hl(au,'NormalFloat','MiniPickNormal')b.win_update_hl(au,'FloatBorder','MiniPickBorder')return au end;b.picker_compute_win_config=function(b5,bd)local be=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bf=vim.o.laststatus>0;local bg=vim.o.lines-vim.o.cmdheight-(be and 1 or 0)-(bf and 1 or 0)local bh=vim.o.columns;local bi={relative='editor',anchor='SW',width=math.floor(0.618*bh),height=math.floor(0.618*bg),col=0,row=bg+(be and 1 or 0),border='single',style='minimal',noautocmd=bd}local c=vim.tbl_deep_extend('force',bi,b.expand_callable(b5)or{})if c.border=='none'then c.border={'',' ','','','',' ','',''}end;c.height=math.min(c.height,bg-2)c.width=math.min(c.width,bh-2)return c end;b.picker_track_lost_focus=function(i)local bj=vim.schedule_wrap(function()local bk=vim.api.nvim_get_current_win()==i.windows.main;local bl=bk and(b.cache.is_in_getcharstr or vim.fn.mode()~='n')if bl then return end;b.picker_stop(i,true)end)b.timers.focus:start(1000,1000,bj)end;b.picker_set_items=function(i,j,h)local k,bm,bn={},{},b.tolower;local bo=b.poke_picker_throttle(h.querytick)for D,q in ipairs(j)do if not bo()then return end;local bp=b.item_to_string(q)table.insert(k,bp)table.insert(bm,bn(bp))end;i.items,i.stritems,i.stritems_ignorecase=j,k,bm;i.cache,i.marked_inds_map={},{}b.picker_set_busy(i,false)b.picker_set_match_inds(i,b.seq_along(j))b.picker_update(i,h.do_match)end;b.item_to_string=function(P)P=b.expand_callable(P)if type(P)=='string'then return P end;if type(P)=='table'and type(P.text)=='string'then return P.text end;return vim.inspect(P,{newline=' ',indent=''})end;b.picker_set_busy=function(i,a_)i.is_busy=a_;local bq=function()b.timers.busy:stop()b.win_update_hl(i.windows.main,'FloatBorder',i.is_busy and'MiniPickBorderBusy'or'MiniPickBorder')end;if a_ then return b.timers.busy:start(i.opts.delay.busy,0,vim.schedule_wrap(bq))end;bq()end;b.picker_set_match_inds=function(i,l)if l==nil then return end;b.picker_set_busy(i,false)i.match_inds=l;local br=table.concat(i.query)if i.opts.options.use_cache then i.cache[br]={inds=l}end;b.picker_show_main(i)b.picker_set_current_ind(i,1)end;b.picker_set_current_ind=function(i,aw,bs)if i.items==nil or#i.match_inds==0 then i.current_ind,i.visible_range=nil,{}return end;local bt=#i.match_inds;aw=(aw-1)%bt+1;local bu,bv,bw=i.visible_range.from,i.visible_range.to,i.visible_range.querytick;local bx=b.querytick~=bw or bu==nil or bv==nil or not(bu<=aw and aw<=bv)if(bs or bx)and b.is_valid_win(i.windows.main)then local by=vim.api.nvim_win_get_height(i.windows.main)bv=math.min(bt,math.floor(aw+0.5*by))bu=math.max(1,bv-by+1)bv=bu+math.min(by,bt)-1 end;i.current_ind=aw;i.visible_range={from=bu,to=bv,querytick=b.querytick}end;b.picker_set_lines=function(i)local u,au=i.buffers.main,i.windows.main;if not(b.is_valid_buf(u)and b.is_valid_win(au))then return end;if i.is_busy then return end;local bz,m=i.visible_range,i.query;if i.items==nil or bz.from==nil or bz.to==nil then i.opts.source.show(u,{},m)b.clear_namespace(u,b.ns_id.matches)return end;local bA,j,t={},i.items,i.match_inds;local bB,bC=i.current_ind,nil;local bD,bE=i.marked_inds_map,{}local bF=i.opts.options.content_from_bottom;local bu=bF and bz.to or bz.from;local bv=bF and bz.from or bz.to;for D=bu,bv,bu<=bv and 1 or-1 do table.insert(bA,j[t[D]])if D==bB then bC=#bA end;if bD[t[D]]then table.insert(bE,#bA)end end;local bG=bF and vim.api.nvim_win_get_height(au)-#bA or 0;bC=bC+bG;bE=vim.tbl_map(function(q)return q+bG end,bE)i.opts.source.show(u,bA,m)if bG>0 then local bH=vim.fn['repeat']({''},bG)vim.api.nvim_buf_set_lines(u,0,0,true,bH)end;local E=b.ns_id.matches;b.clear_namespace(u,E)local bI={end_col=0,hl_group='MiniPickMatchMarked',priority=202}for M,bJ in ipairs(bE)do bI.end_row=bJ;b.set_extmark(u,E,bJ-1,0,bI)end;if bC>vim.api.nvim_buf_line_count(u)then return end;local bK={end_row=bC,end_col=0,hl_eol=true,hl_group='MiniPickMatchCurrent',priority=201}b.set_extmark(u,E,bC-1,0,bK)local bL=vim.api.nvim_win_get_cursor(au)if i.view_state=='main'and bL[1]~=bC then b.set_cursor(au,bC,bL[2]+1)end end;b.picker_match=function(i)if i.items==nil then return end;local bM;if i.opts.options.use_cache then bM=i.cache[table.concat(i.query)]end;if bM~=nil then return b.picker_set_match_inds(i,bM.inds)end;local bN=b.query_is_ignorecase(i.query)local k=bN and i.stritems_ignorecase or i.stritems;local m=bN and vim.tbl_map(b.tolower,i.query)or i.query;b.picker_set_busy(i,true)local bO=i.opts.source.match(k,i.match_inds,m)b.picker_set_match_inds(i,bO)end;b.query_is_ignorecase=function(m)if not vim.o.ignorecase then return false end;if not vim.o.smartcase then return true end;local Z=table.concat(m)return Z==vim.fn.tolower(Z)end;b.picker_get_char_data=function(i,bP)local bQ=b.replace_termcodes;local av={}local bR={}if not bP then bR={move_down='<Down>',move_start='<Home>',move_up='<Up>'}end;for e,bS in pairs(i.opts.mappings)do local bT=type(bS)=='table'local an=bT and bS.char or bS;local aF={char=an,name=e,func=bT and bS.func or b.actions[e],is_custom=bT}av[bQ(an)]=aF;local bU=bR[e]if bU~=nil then av[bQ(bU)]=aF end end;return av end;b.picker_set_bordertext=function(i)local au=i.windows.main;if not b.is_valid_win(au)then return end;local bV=i.view_state;local c;if bV=='main'then local m,bW=i.query,i.caret;local bX=table.concat(vim.list_slice(m,1,bW-1),'')local bY=table.concat(vim.list_slice(m,bW,#m),'')local bZ='> '..bX..'▏'..bY;local Z={{b.win_trim_to_width(au,bZ),'MiniPickPrompt'}}c={title=Z}end;local b_=i.items~=nil;if bV=='preview'and b_ then local c0=i.stritems[i.match_inds[i.current_ind]]or''c0=c0:gsub('[%s%z]',' ')c={title={{b.win_trim_to_width(au,c0),'MiniPickBorderText'}}}end;if bV=='info'then c={title={{b.win_trim_to_width(au,'Info'),'MiniPickBorderText'}}}end;local c1=vim.fn.has('nvim-0.10')==1;if c1 and not i.is_busy then c.footer,c.footer_pos=b.picker_compute_footer(i,au),'left'end;if c1 and i.opts.options.content_from_bottom then c.title,c.footer=c.footer,c.title end;vim.api.nvim_win_set_config(au,c)vim.wo[au].list=true end;if vim.fn.has('nvim-0.9')==0 then b.picker_set_bordertext=function()end end;b.picker_compute_footer=function(i,au)local c2=b.picker_get_general_info(i)local Y=string.format(' %s ',c2.source_name)local c3=c2.n_marked==0 and''or c2.n_marked..'/'local l=string.format(' %s|%s|%s%s ',c2.relative_current_ind,c2.n_matched,c3,c2.n_total)local c4,c5,c6=vim.api.nvim_win_get_width(au),vim.fn.strchars(Y),vim.fn.strchars(l)local c7={{Y,'MiniPickBorderText'}}local c8=c4-(c5+c6)if c8>0 then local c9=i.is_busy and'MiniPickBorderBusy'or'MiniPickBorder'c7[2]={b.win_get_bottom_border(au):rep(c8),c9}c7[3]={l,'MiniPickBorderText'}end;return c7 end;b.picker_stop=function(i,ca)vim.tbl_map(function(cb)pcall(vim.loop.timer_stop,cb)end,b.timers)pcall(function()vim.o.cmdheight=b.cache.cmdheight end)if i==nil then return end;vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStop'})if ca then b.pickers={}else local cc=vim.deepcopy(i)b.picker_free(b.pickers.latest)b.pickers={active=nil,latest=cc}end;b.set_curwin(i.windows.target)pcall(vim.api.nvim_win_close,i.windows.main,true)pcall(vim.api.nvim_buf_delete,i.buffers.main,{force=true})pcall(vim.api.nvim_buf_delete,i.buffers.info,{force=true})i.windows,i.buffers={},{}b.querytick=b.querytick+1 end;b.picker_free=function(i)if i==nil then return end;i.match_inds=nil;i.cache=nil;i.stritems,i.stritems_ignorecase,i.marked_inds_map=nil,nil,nil;i.items=nil;i=nil;vim.schedule(function()collectgarbage('collect')end)end;b.actions={caret_left=function(i,M)b.picker_move_caret(i,-1)end,caret_right=function(i,M)b.picker_move_caret(i,1)end,choose=function(i,M)return b.picker_choose(i,nil)end,choose_in_split=function(i,M)return b.picker_choose(i,'split')end,choose_in_tabpage=function(i,M)return b.picker_choose(i,'tabnew')end,choose_in_vsplit=function(i,M)return b.picker_choose(i,'vsplit')end,choose_marked=function(i,M)return not i.opts.source.choose_marked(a.get_picker_matches().marked)end,delete_char=function(i,M)b.picker_query_delete(i,1)end,delete_char_right=function(i,M)b.picker_query_delete(i,0)end,delete_left=function(i,M)b.picker_query_delete(i,i.caret-1)end,delete_word=function(i,M)local cd,ce=i.caret-1,0;if cd==0 then return end;local cf=vim.fn.match(i.query[cd],'[[:keyword:]]')>=0;for D=cd,1,-1 do local cg=vim.fn.match(i.query[D],'[[:keyword:]]')>=0;if cf and not cg or not cf and cg then break end;ce=ce+1 end;b.picker_query_delete(i,ce)end,mark=function(i,M)b.picker_mark_indexes(i,'current')end,mark_all=function(i,M)b.picker_mark_indexes(i,'all')end,move_down=function(i,M)b.picker_move_current(i,1)end,move_start=function(i,M)b.picker_move_current(i,nil,1)end,move_up=function(i,M)b.picker_move_current(i,-1)end,paste=function(i,M)local ch=b.getcharstr(i.opts.delay.async)local ci,cj=pcall(vim.fn.getreg,ch)if not ci then return end;cj=cj:gsub('[\n\t]',' ')for D=1,vim.fn.strchars(cj)do b.picker_query_add(i,vim.fn.strcharpart(cj,D-1,1))end end,refine=function(i,M)b.picker_refine(i,'all')end,refine_marked=function(i,M)b.picker_refine(i,'marked')end,scroll_down=function(i,M)b.picker_scroll(i,'down')end,scroll_up=function(i,M)b.picker_scroll(i,'up')end,scroll_left=function(i,M)b.picker_scroll(i,'left')end,scroll_right=function(i,M)b.picker_scroll(i,'right')end,toggle_info=function(i,M)if i.view_state=='info'then return b.picker_show_main(i)end;b.picker_show_info(i)end,toggle_preview=function(i,M)if i.view_state=='preview'then return b.picker_show_main(i)end;b.picker_show_preview(i)end,stop=function(M,M)return true end}b.picker_query_add=function(i,an)if vim.fn.strchars(an)>1 or vim.fn.char2nr(an)<=31 then return end;table.insert(i.query,i.caret,an)i.caret=i.caret+1;b.querytick=b.querytick+1;local ck=i.items~=nil and i.caret<=#i.query;if ck then i.match_inds=b.seq_along(i.items)end end;b.picker_query_delete=function(i,cl)local cm=cl>0;local cn=cm and math.max(i.caret-cl,1)or i.caret;local co=cm and i.caret-1 or math.min(i.caret+cl,#i.query)for D=co,cn,-1 do table.remove(i.query,D)end;i.caret=cn;b.querytick=b.querytick+1;if i.items~=nil then i.match_inds=b.seq_along(i.items)end end;b.picker_choose=function(i,cp)local cq=b.picker_get_current_item(i)if cq==nil then return true end;local cr=i.windows.target;if cp~=nil and b.is_valid_win(cr)then vim.api.nvim_win_call(cr,function()vim.cmd(cp)i.windows.target=vim.api.nvim_get_current_win()end)end;return not i.opts.source.choose(cq)end;b.picker_mark_indexes=function(i,cs)if i.items==nil then return end;local ct=cs=='current'and{i.match_inds[i.current_ind]}or i.match_inds;local bD,cu=i.marked_inds_map,true;for M,aw in ipairs(ct)do cu=cu and bD[aw]end;local cv;if not cu then cv=true end;for M,aw in ipairs(ct)do bD[aw]=cv end;if i.view_state=='info'then b.picker_show_info(i)end end;b.picker_move_caret=function(i,cl)i.caret=math.min(math.max(i.caret+cl,1),#i.query+1)end;b.picker_move_current=function(i,cw,bv)if i.items==nil then return end;local bt=#i.match_inds;if bt==0 then return end;if bv==nil then cw=(i.opts.options.content_from_bottom and-1 or 1)*cw;bv=i.current_ind;if bv==1 and cw<0 then bv=bt elseif bv==bt and cw>0 then bv=1 else bv=bv+cw end;bv=math.min(math.max(bv,1),bt)end;b.picker_set_current_ind(i,bv)if i.view_state=='info'then b.picker_show_info(i)end;if i.view_state=='preview'then b.picker_show_preview(i)end end;b.picker_refine=function(i,cx)if i.items==nil then return end;i.opts.source.match=b.get_config().source.match or a.default_match;i.query,i.caret={},1;a.set_picker_items(a.get_picker_matches()[cx]or{})i._refine=i._refine or{orig_name=i.opts.source.name,count=0}i._refine.count=i._refine.count+1;local cy=i._refine.count==1 and''or' '..i._refine.count;i.opts.source.name=string.format('%s (Refine%s)',i._refine.orig_name,cy)end;b.picker_scroll=function(i,cz)local au=i.windows.main;if i.view_state=='main'and(cz=='down'or cz=='up')then local cl=(cz=='down'and 1 or-1)*vim.api.nvim_win_get_height(au)b.picker_move_current(i,cl)else local cA=({down='<C-f>',up='<C-b>',left='zH',right='zL'})[cz]vim.api.nvim_win_call(au,function()vim.cmd('normal! '..b.replace_termcodes(cA))end)end end;b.picker_get_current_item=function(i)if i.items==nil then return nil end;return i.items[i.match_inds[i.current_ind]]end;b.picker_show_main=function(i)b.set_winbuf(i.windows.main,i.buffers.main)i.view_state='main'end;b.picker_show_info=function(i)local c2=b.picker_get_general_info(i)local w={'General','Source name   │ '..c2.source_name,'Source cwd    │ '..c2.source_cwd,'Total items   │ '..c2.n_total,'Matched items │ '..c2.n_matched,'Marked items  │ '..c2.n_marked,'Current index │ '..c2.relative_current_ind}local cB={1}local cC=function(aF,cD)if#aF==0 then return end;table.insert(w,'')table.insert(w,cD)table.insert(cB,#w)local cE=0;for M,ai in ipairs(aF)do local aL=ai.name:gsub('[%s%p]',' ')ai.desc=vim.fn.toupper(aL:sub(1,1))..aL:sub(2)ai.width=vim.fn.strchars(ai.desc)cE=math.max(cE,ai.width)end;table.sort(aF,function(cF,cG)return cF.desc<cG.desc end)for M,ai in ipairs(aF)do table.insert(w,string.format('%s%s │ %s',ai.desc,string.rep(' ',cE-ai.width),ai.char))end end;local b7=b.picker_get_char_data(i,true)cC(vim.tbl_filter(function(q)return q.is_custom end,b7),'Mappings (custom)')cC(vim.tbl_filter(function(q)return not q.is_custom end,b7),'Mappings (built-in)')local cH=i.buffers.info;if not b.is_valid_buf(cH)then cH=b.create_scratch_buf()end;i.buffers.info=cH;b.set_buflines(cH,w)b.set_winbuf(i.windows.main,cH)i.view_state='info'local E=b.ns_id.headers;b.clear_namespace(cH,E)for M,bJ in ipairs(cB)do b.set_extmark(cH,E,bJ-1,0,{end_row=bJ,end_col=0,hl_group='MiniPickHeader'})end end;b.picker_get_general_info=function(i)local b_=i.items~=nil;return{source_name=i.opts.source.name or'---',source_cwd=vim.fn.fnamemodify(i.opts.source.cwd,':~')or'---',n_total=b_ and#i.items or'-',n_matched=b_ and#i.match_inds or'-',n_marked=b_ and vim.tbl_count(i.marked_inds_map)or'-',relative_current_ind=b_ and i.current_ind or'-'}end;b.picker_show_preview=function(i)local a4=i.opts.source.preview;local P=b.picker_get_current_item(i)if P==nil then return end;local au,u=i.windows.main,b.create_scratch_buf()vim.bo[u].bufhidden='wipe'b.set_winbuf(au,u)a4(u,P)i.buffers.preview=u;i.view_state='preview'end;b.match_filter=function(l,k,m)local cI,cJ,cK,cL=m[1]=='*',m[1]=="'",m[1]=='^',m[#m]=='$'local cM,cN=b.match_query_group(m)if cI or cJ or cK or cL then local L=(cI or cJ or cK)and 2 or 1;local cO=#m-(not cI and not cJ and cL and 1 or 0)m=vim.list_slice(m,L,cO)elseif cM then m=cN end;if#m==0 then return{},'nosort',m end;local cP=not(cJ or cK or cL)and#m>1;if cI or cP then return b.match_filter_fuzzy(l,k,m),'fuzzy',m end;local aU=cK and'^'or''local cQ=cL and'$'or''local aa=aU..vim.pesc(table.concat(m))..cQ;return b.match_filter_exact(l,k,m,aa),'exact',m end;b.match_filter_exact=function(l,k,m,aa)local cR=b.match_filter_exact_single;local bo=b.poke_picker_throttle(b.querytick)local r={}for M,aw in ipairs(l)do if not bo()then return nil end;local aF=cR(k[aw],aw,aa)if aF~=nil then table.insert(r,aF)end end;return r end;b.match_filter_exact_single=function(cS,cT,aa)local cU=string.find(cS,aa)if cU==nil then return nil end;return{0,cU,cT}end;b.match_ranges_exact=function(r,m)local cV,cW=0,{}for D=1,#m do cW[D]={cV,cV+m[D]:len()-1}cV=cW[D][2]+1 end;local av={}for D=1,#r do local cU=r[D][2]av[D]=vim.tbl_map(function(q)return{cU+q[1],cU+q[2]}end,cW)end;return av end;b.match_filter_fuzzy=function(l,k,m)local cR,cX=b.match_filter_fuzzy_single,b.match_find_query;local bo=b.poke_picker_throttle(b.querytick)local r={}for M,aw in ipairs(l)do if not bo()then return nil end;local aF=cR(k[aw],aw,m,cX)if aF~=nil then table.insert(r,aF)end end;return r end;b.match_filter_fuzzy_single=function(cS,cT,m,cX)local cY,cZ=cX(cS,m,1)if cY==nil then return nil end;if cY==cZ then return{0,cY,cT,{cY}}end;local c_,d0,d1=cY,cZ,cZ-cY;while cZ do local d2=cZ-cY;if d2<d1 then c_,d0,d1=cY,cZ,d2 end;cY,cZ=cX(cS,m,cY+1)end;return{d0-c_,c_,cT}end;b.match_ranges_fuzzy=function(r,m,k)local av,d3,d4={},#m,vim.tbl_map(string.len,m)for d5,aF in ipairs(r)do local d6,bu,bv=k[aF[3]],aF[2],aF[2]+d4[1]-1;local K={{bu,bv}}for d7=2,d3 do bu,bv=string.find(d6,m[d7],bv+1,true)K[d7]={bu,bv}end;av[d5]=K end;return av end;b.match_find_query=function(d6,m,cd)local cY,bv=string.find(d6,m[1],cd,true)if cY==nil then return nil,nil end;local cZ=cY;for D=2,#m do cZ,bv=string.find(d6,m[D],bv+1,true)if not cZ then return nil,nil end end;return cY,cZ end;b.match_query_group=function(m)local d8={{}}for M,q in ipairs(m)do local d9=q:find('^%s+$')~=nil;if d9 then table.insert(d8,{})end;if not d9 then table.insert(d8[#d8],q)end end;return#d8>1,vim.tbl_map(table.concat,d8)end;b.match_sort=function(r)local da,bh,db={},0,{}for D=1,#r do local aF,d2,cU=r[D],r[D][1],r[D][2]local dc=da[d2]or{}local dd=dc[cU]or{}table.insert(dd,aF[3])dc[cU]=dd;da[d2]=dc;bh=math.max(bh,d2)db[d2]=math.max(db[d2]or 0,cU)end;local bo=b.poke_picker_throttle(b.querytick)for M,dc in pairs(da)do for M,dd in pairs(dc)do if not bo()then return nil end;table.sort(dd)end end;local av={}for d2=0,bh do local dc=da[d2]for cU=1,db[d2]or 0 do local dd=dc[cU]or{}for D=1,#dd do table.insert(av,dd[D])end end end;return av end;b.get_icon=function(q,de)local df,dg=b.parse_path(q)if df==nil then return{text=''}end;if df=='directory'then return{text=de.directory,hl='MiniPickIconDirectory'}end;if df=='none'then return{text=de.none,hl='MiniPickNormal'}end;local dh,di=pcall(require,'nvim-web-devicons')if not dh then return{text=de.file,hl='MiniPickIconFile'}end;local dj,dk=di.get_icon(vim.fn.fnamemodify(dg,':t'),nil,{default=false})dj=type(dj)=='string'and dj..' 'or de.file;return{text=dj,hl=dk or'MiniPickIconFile'}end;b.show_with_icons=function(u,j,m)a.default_show(u,j,m,{show_icons=true})end;b.parse_item=function(P)if type(P)=='table'then return b.parse_item_table(P)end;local dl=b.item_to_string(P)local dm,dn=pcall(tonumber,dl)if dm and b.is_valid_buf(dn)then return{type='buffer',buf_id=dn}end;local df,dg,bJ,aR,dp=b.parse_path(dl)if df~='none'then return{type=df,path=dg,lnum=bJ,col=aR,text=dp}end;return{}end;b.parse_item_table=function(P)local u=P.bufnr or P.buf_id or P.buf;if b.is_valid_buf(u)then return{type='buffer',buf_id=u,lnum=P.lnum,end_lnum=P.end_lnum,col=P.col,end_col=P.end_col,text=P.text}end;if type(P.path)=='string'then local df,dg,bJ,aR,dp=b.parse_path(P.path)if df=='file'then return{type='file',path=dg,lnum=bJ or P.lnum,end_lnum=P.end_lnum,col=aR or P.col,end_col=P.end_col,text=dp~=''and dp or P.text}end;if df=='directory'then return{type='directory',path=P.path}end end;return{}end;b.parse_path=function(q)if type(q)~='string'or q==''then return nil end;local dq=':(%d+):?(%d*):?(.*)$'local bJ,aR,dp=q:match(dq)local dg=q:gsub(dq,'',1)dg=dg:sub(1,1)=='~'and(vim.loop.os_homedir()or'~')..dg:sub(2)or dg;local df=b.get_fs_type(dg)if df=='none'and dg~=''then local dr=b.pickers.active==nil and vim.fn.getcwd()or b.pickers.active.opts.source.cwd;dg=string.format('%s/%s',dr,dg)df=b.get_fs_type(dg)end;return df,dg,tonumber(bJ),tonumber(aR),dp or''end;b.get_fs_type=function(dg)if dg==''then return'none'end;if vim.fn.filereadable(dg)==1 then return'file'end;if vim.fn.isdirectory(dg)==1 then return'directory'end;return'none'end;b.preview_file=function(u,Q,h)if not b.is_file_text(Q.path)then return b.set_buflines(u,{'-Non-text-file-'})end;local ds,w=pcall(vim.fn.readfile,Q.path,'',(Q.lnum or 1)+h.n_context_lines)if not ds then return end;Q.line_position=h.line_position;b.preview_set_lines(u,w,Q)end;b.preview_directory=function(u,Q)local dg=Q.path;local dt=function(q)return q..(vim.fn.isdirectory(dg..'/'..q)==1 and'/'or'')end;local w=vim.tbl_map(dt,vim.fn.readdir(dg))b.set_buflines(u,w)end;b.preview_buffer=function(u,Q,h)local du=Q.buf_id;local dv=vim.o.eventignore;vim.o.eventignore='BufEnter'vim.fn.bufload(du)vim.o.eventignore=dv;local w=vim.api.nvim_buf_get_lines(du,0,(Q.lnum or 1)+h.n_context_lines,false)Q.filetype,Q.line_position=vim.bo[du].filetype,h.line_position;b.preview_set_lines(u,w,Q)end;b.preview_inspect=function(u,dw)b.set_buflines(u,vim.split(vim.inspect(dw),'\n'))end;b.preview_set_lines=function(u,w,dx)b.set_buflines(u,w)b.preview_highlight_region(u,dx.lnum,dx.col,dx.end_lnum,dx.end_col)if b.preview_should_highlight(u)then local dy=dx.filetype or vim.filetype.match({buf=u,filename=dx.path})local dz,dA=pcall(vim.treesitter.language.get_lang,dy)local dB,M=pcall(vim.treesitter.start,u,dz and dA or dy)if not dB then vim.bo[u].syntax=dy end end;local dC=a.get_picker_state()local au=dC~=nil and dC.windows.main or vim.fn.bufwinid(u)b.set_cursor(au,dx.lnum,dx.col)local dD=({top='zt',center='zz',bottom='zb'})[dx.line_position]or'zt'pcall(vim.api.nvim_win_call,au,function()vim.cmd('normal! '..dD)end)end;b.preview_should_highlight=function(u)if vim.fn.has('nvim-0.8')==0 then return false end;local dE=vim.api.nvim_buf_call(u,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return dE<=1000000 and dE<=1000*vim.api.nvim_buf_line_count(u)end;b.preview_highlight_region=function(u,bJ,aR,dF,dG)if bJ==nil then return end;local dH={end_row=bJ,end_col=0,hl_eol=true,hl_group='MiniPickPreviewLine',priority=201}b.set_extmark(u,b.ns_id.preview,bJ-1,0,dH)if aR==nil then return end;local dI,dJ=bJ-1,aR;if dF~=nil and dG~=nil then dI,dJ=dF-1,dG-1 end;dJ=b.get_next_char_bytecol(vim.fn.getbufline(u,dI+1)[1],dJ)local dK={end_row=dI,end_col=dJ,priority=202}dK.hl_group='MiniPickPreviewRegion'b.set_extmark(u,b.ns_id.preview,bJ-1,aR-1,dK)end;b.choose_path=function(S,Q)local dg,dL=Q.path,nil;for M,u in ipairs(vim.api.nvim_list_bufs())do local dM=b.is_valid_buf(u)and vim.bo[u].buflisted and vim.api.nvim_buf_get_name(u)==dg;if dM then dL=u end end;if dL~=nil then b.set_winbuf(S,dL)else local dN=vim.fn.fnameescape(vim.fn.fnamemodify(dg,':.'))vim.api.nvim_win_call(S,function()pcall(vim.cmd,'edit '..dN)end)end;b.choose_set_cursor(S,Q.lnum,Q.col)end;b.choose_buffer=function(S,Q)b.set_winbuf(S,Q.buf_id)b.choose_set_cursor(S,Q.lnum,Q.col)end;b.choose_print=function(q)print(vim.inspect(q))end;b.choose_set_cursor=function(au,bJ,aR)if bJ==nil then return end;b.set_cursor(au,bJ,aR)pcall(vim.api.nvim_win_call,au,function()vim.cmd('normal! zvzz')end)end;b.cli_postprocess=function(j)while j[#j]==''do j[#j]=nil end;return j end;b.is_executable=function(a7)if a7=='fallback'then return true end;return vim.fn.executable(a7)==1 end;b.files_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('fd')then return'fd'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.files_get_command=function(a7)if a7=='rg'then return{'rg','--files','--no-follow','--color=never'}end;if a7=='fd'then return{'fd','--type=f','--no-follow','--color=never'}end;if a7=='git'then return{'git','ls-files','--cached','--others','--exclude-standard'}end;b.error([[Wrong 'tool' for `files` builtin.]])end;b.files_fallback_items=function(dr)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `files` builtin needs Neovim>=0.9.')end;dr=dr or'.'local bo=b.poke_picker_throttle()local g=function()local j={}for dg,df in vim.fs.dir(dr,{depth=math.huge})do if not bo()then return end;if df=='file'and b.is_file_text(string.format('%s/%s',dr,dg))then table.insert(j,dg)end end;a.set_picker_items(j)end;vim.schedule(coroutine.wrap(g))end;b.grep_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.grep_get_command=function(a7,aa)if a7=='rg'then return{'rg','--column','--line-number','--no-heading','--no-follow','--color=never','--',aa}end;if a7=='git'then local av={'git','grep','--column','--line-number','--color=never','--',aa}if vim.o.ignorecase then table.insert(av,6,'--ignore-case')end;return av end;b.error([[Wrong 'tool' for `grep` builtin.]])end;b.grep_fallback_items=function(aa,dr)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `grep` builtin needs Neovim>=0.9.')end;dr=dr or'.'local bo=b.poke_picker_throttle()local g=function()local dO,dP={},{}for dg,df in vim.fs.dir(dr,{depth=math.huge})do if not bo()then return end;local dQ=string.format('%s/%s',dr,dg)if df=='file'and b.is_file_text(dQ)then table.insert(dO,dg)table.insert(dP,dQ)end end;local j={}for D,dg in ipairs(dP)do local dR=dO[D]if not bo()then return end;for bJ,y in ipairs(vim.fn.readfile(dg))do local aR=string.find(y,aa)if aR~=nil then table.insert(j,string.format('%s:%d:%d:%s',dR,bJ,aR,y))end end end;a.set_picker_items(j)end;vim.schedule(coroutine.wrap(g))end;b.schedule_resume_is_active=vim.schedule_wrap(function(aG)coroutine.resume(aG,a.is_picker_active())end)b.poke_picker_throttle=function(dS)if not a.is_picker_active()then return function()return true end end;local dT,dU=vim.loop.hrtime(),dS==nil;local dV=1000000*b.get_config().delay.async;local dW=vim.loop.hrtime;local dX=a.poke_is_picker_active;return function()local dY=dW()if dY-dT<dV then return true end;dT=dY;return dX()and(dU or dS==b.querytick)end end;b.error=function(dZ)error(string.format('(mini.pick) %s',dZ),0)end;b.is_valid_buf=function(u)return type(u)=='number'and vim.api.nvim_buf_is_valid(u)end;b.is_valid_win=function(au)return type(au)=='number'and vim.api.nvim_win_is_valid(au)end;b.is_array_of=function(q,d_)if not vim.tbl_islist(q)then return false end;for D=1,#q do if type(q[D])~=d_ then return false end end;return true end;b.create_scratch_buf=function()local u=vim.api.nvim_create_buf(false,true)vim.bo[u].matchpairs=''vim.b[u].minicursorword_disable=true;vim.b[u].miniindentscope_disable=true;return u end;b.get_first_valid_normal_window=function()for M,au in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(au).relative==''then return au end end end;b.set_buflines=function(u,w)pcall(vim.api.nvim_buf_set_lines,u,0,-1,false,w)end;b.set_winbuf=function(au,u)vim.api.nvim_win_set_buf(au,u)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.set_cursor=function(au,bJ,aR)pcall(vim.api.nvim_win_set_cursor,au,{bJ or 1,(aR or 1)-1})end;b.set_curwin=function(au)if not b.is_valid_win(au)then return end;local bL=vim.api.nvim_win_get_cursor(au)vim.api.nvim_set_current_win(au)b.set_cursor(au,bL[1],bL[2]+1)end;b.clear_namespace=function(u,E)pcall(vim.api.nvim_buf_clear_namespace,u,E,0,-1)end;b.replace_termcodes=function(q)if q==nil then return nil end;return vim.api.nvim_replace_termcodes(q,true,true,true)end;b.expand_callable=function(q,...)if vim.is_callable(q)then return q(...)end;return q end;b.expandcmd=function(q)local dm,av=pcall(vim.fn.expandcmd,q)return dm and av or q end;b.redraw=function()vim.cmd('redraw')end;b.redraw_scheduled=vim.schedule_wrap(b.redraw)b.getcharstr=function(e0)b.timers.getcharstr:start(0,e0,b.redraw_scheduled)b.cache.is_in_getcharstr=true;local dm,an=pcall(vim.fn.getcharstr)b.cache.is_in_getcharstr=nil;b.timers.getcharstr:stop()local e1;if b.pickers.active~=nil then e1=b.pickers.active.windows.main end;local e2=vim.v.mouse_winid~=0 and vim.v.mouse_winid~=e1;if not dm or an==''or an=='\3'or e2 then return end;return an end;b.tolower=(function()local bn=vim.fn.tolower;return function(q)local dm,av=pcall(bn,q)return dm and av or string.lower(q)end end)()b.win_update_hl=function(au,e3,e4)if not b.is_valid_win(au)then return end;local e5=e3 ..':'..e4;local e6=string.format('(%s:[^,]*)',vim.pesc(e3))local e7,e8=vim.wo[au].winhighlight:gsub(e6,e5)if e8==0 then e7=e7 ..','..e5 end;pcall(function()vim.wo[au].winhighlight=e7 end)end;b.win_trim_to_width=function(au,e9)local c4=vim.api.nvim_win_get_width(au)return vim.fn.strcharpart(e9,vim.fn.strchars(e9)-c4,c4)end;b.win_get_bottom_border=function(au)local ea=vim.api.nvim_win_get_config(au).border or{}return ea[6]or' 'end;b.seq_along=function(eb)if eb==nil then return nil end;local av={}for D=1,#eb do table.insert(av,D)end;return av end;b.get_next_char_bytecol=function(ec,aR)if type(ec)~='string'then return aR end;local ed=vim.str_utfindex(ec,math.min(ec:len(),aR))return vim.str_byteindex(ec,ed)end;b.is_file_text=function(dg)local ee=vim.loop.fs_open(dg,'r',1)local ef=vim.loop.fs_read(ee,1024):find('\0')==nil;vim.loop.fs_close(ee)return ef end;b.full_path=function(dg)return vim.fn.fnamemodify(dg,':p'):gsub('(.)/$','%1')end;return a
