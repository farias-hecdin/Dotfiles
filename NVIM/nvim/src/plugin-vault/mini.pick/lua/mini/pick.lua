local a={}local b={}a.setup=function(c)_G.MiniPick=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()vim.api.nvim_create_user_command('Pick',function(d)local e,f=b.command_parse_fargs(d.fargs)local g=a.registry[e]if g==nil then b.error(string.format('There is no picker named "%s" in registry.',e))end;g(f)end,{nargs='+',complete=b.command_complete,desc="Pick from 'mini.pick' registry"})end;a.config={delay={async=10,busy=50},mappings={caret_left='<Left>',caret_right='<Right>',choose='<CR>',choose_in_split='<C-s>',choose_in_tabpage='<C-t>',choose_in_vsplit='<C-v>',choose_marked='<M-CR>',delete_char='<BS>',delete_char_right='<Del>',delete_left='<C-u>',delete_word='<C-w>',mark='<C-x>',mark_all='<C-a>',move_down='<C-n>',move_start='<C-g>',move_up='<C-p>',paste='<C-r>',refine='<C-Space>',refine_marked='<M-Space>',scroll_down='<C-f>',scroll_left='<C-h>',scroll_right='<C-l>',scroll_up='<C-b>',stop='<Esc>',toggle_info='<S-Tab>',toggle_preview='<Tab>'},options={content_from_bottom=false,use_cache=false},source={items=nil,name=nil,cwd=nil,match=nil,show=nil,preview=nil,choose=nil,choose_marked=nil},window={config=nil,prompt_cursor='▏',prompt_prefix='> '}}a.start=function(h)if a.is_picker_active()then a.stop()return vim.defer_fn(function()if a.is_picker_active()then b.picker_stop(b.pickers.active,true)end;a.start(h)end,0.5)end;b.cache={}h=b.validate_picker_opts(h)local i=b.picker_new(h)b.pickers.active=i;b.picker_set_busy(i,true)local j=b.expand_callable(h.source.items)if vim.tbl_islist(j)then vim.schedule(function()a.set_picker_items(j)end)end;b.picker_track_lost_focus(i)return b.picker_advance(i)end;a.stop=function()if not a.is_picker_active()then return end;b.cache.is_force_stop_advance=true;if b.cache.is_in_getcharstr then vim.api.nvim_feedkeys('\3','t',true)end end;a.refresh=function()if not a.is_picker_active()then return end;b.picker_update(b.pickers.active,false,true)end;a.default_match=function(k,l,m,n)local o=n or not a.is_picker_active()local p=o and function(q)return q end or a.set_picker_match_inds;local g=function()if#m==0 then return p(b.seq_along(k))end;local r,s=b.match_filter(l,k,m)if r==nil then return end;if s=='nosort'then return p(b.seq_along(k))end;local t=b.match_sort(r)if t==nil then return end;return p(t)end;if o then return g()end;coroutine.resume(coroutine.create(g))end;a.default_show=function(u,j,m,h)local v={directory=' ',file=' ',none='  '}h=vim.tbl_deep_extend('force',{show_icons=false,icons=v},h or{})local w=vim.tbl_map(b.item_to_string,j)local x=string.rep(' ',vim.o.tabstop)w=vim.tbl_map(function(y)return y:gsub('\n',' '):gsub('\t',x)end,w)local z=h.show_icons and function(A)return b.get_icon(A,h.icons)end or function()return{text=''}end;local B=vim.tbl_map(z,w)local C={}for D,y in ipairs(w)do C[D]=B[D].text..y end;b.set_buflines(u,C)local E=b.ns_id.ranges;b.clear_namespace(u,E)if b.query_is_ignorecase(m)then w,m=vim.tbl_map(b.tolower,w),vim.tbl_map(b.tolower,m)end;local r,s,F=b.match_filter(b.seq_along(w),w,m)if r==nil then return end;local G=s=='fuzzy'and b.match_ranges_fuzzy or b.match_ranges_exact;local H=G(r,F,w)local I={hl_group='MiniPickMatchRanges',hl_mode='combine',priority=200}for D=1,#r do local J,K=r[D][3],H[D]local L=B[J].text:len()for M,N in ipairs(K)do I.end_row,I.end_col=J-1,L+N[2]b.set_extmark(u,E,J-1,L+N[1]-1,I)end end;if not h.show_icons then return end;local O={hl_mode='combine',priority=200}for D=1,#B do O.hl_group=B[D].hl;O.end_row,O.end_col=D-1,B[D].text:len()b.set_extmark(u,E,D-1,0,O)end end;a.default_preview=function(u,P,h)h=vim.tbl_deep_extend('force',{n_context_lines=2*vim.o.lines,line_position='top'},h or{})local Q=b.parse_item(P)if Q.type=='file'then return b.preview_file(u,Q,h)end;if Q.type=='directory'then return b.preview_directory(u,Q)end;if Q.type=='buffer'then return b.preview_buffer(u,Q,h)end;b.preview_inspect(u,P)end;a.default_choose=function(P)if P==nil then return end;local R=a.get_picker_state()local S=R~=nil and R.windows.target or vim.api.nvim_get_current_win()if not b.is_valid_win(S)then S=b.get_first_valid_normal_window()end;local Q=b.parse_item(P)if Q.type=='file'or Q.type=='directory'then return b.choose_path(S,Q)end;if Q.type=='buffer'then return b.choose_buffer(S,Q)end;b.choose_print(P)end;a.default_choose_marked=function(j,h)if not vim.tbl_islist(j)then b.error('`items` should be an array')end;if#j==0 then return end;h=vim.tbl_deep_extend('force',{list_type='quickfix'},h or{})local T={}for M,P in ipairs(j)do local Q=b.parse_item(P)if Q.type=='file'or Q.type=='buffer'then local U={bufnr=Q.buf_id,filename=Q.path}U.lnum,U.col,U.text=Q.lnum or 1,Q.col or 1,Q.text or''U.end_lnum,U.end_col=Q.end_lnum,Q.end_col;table.insert(T,U)end end;local V=a.is_picker_active()if#T==0 then if not V then return end;local W=a.get_picker_opts().source.choose;return W(j[1])end;local X='<No picker>'if V then local Y,Z=a.get_picker_opts().source.name,table.concat(a.get_picker_query())X=Y..(Z==''and''or' : '..Z)end;local _={items=T,title=X,nr='$'}if h.list_type=='location'then local S=a.get_picker_state().windows.target;if not b.is_valid_win(S)then S=b.get_first_valid_normal_window()end;vim.fn.setloclist(S,{},' ',_)vim.schedule(function()vim.cmd('lopen')end)else vim.fn.setqflist({},' ',_)vim.schedule(function()vim.cmd('copen')end)end end;a.ui_select=function(j,h,a0)local a1=h.format_item or b.item_to_string;local a2={}for D=1,#j do table.insert(a2,{text=a1(j[D]),item=j[D],index=D})end;local a3=vim.is_callable(h.preview_item)and h.preview_item or function(q)return vim.split(vim.inspect(q),'\n')end;local a4=function(u,P)b.set_buflines(u,a3(P.item))end;local a5=true;local W=function(P)a5=false;if P==nil then return end;local S=a.get_picker_state().windows.target;if not b.is_valid_win(S)then S=b.get_first_valid_normal_window()end;vim.api.nvim_win_call(S,function()a0(P.item,P.index)a.set_picker_target_window(vim.api.nvim_get_current_win())end)end;local a6={items=a2,name=h.kind or h.prompt,preview=a4,choose=W}local P=a.start({source=a6})if P==nil and a5 then a0(nil)end end;a.builtin={}a.builtin.files=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil},f or{})local a7=f.tool or b.files_get_tool()local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Files (%s)',a7),show=a8}}h=vim.tbl_deep_extend('force',a9,h or{})if a7=='fallback'then h.source.items=function()b.files_fallback_items(h.source.cwd)end;return a.start(h)end;return a.builtin.cli({command=b.files_get_command(a7)},h)end;a.builtin.grep=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil,pattern=nil},f or{})local a7=f.tool or b.grep_get_tool()local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Grep (%s)',a7),show=a8}}h=vim.tbl_deep_extend('force',a9,h or{})local aa=type(f.pattern)=='string'and f.pattern or vim.fn.input('Grep pattern: ')if a7=='fallback'then h.source.items=function()b.grep_fallback_items(aa,h.source.cwd)end;return a.start(h)end;return a.builtin.cli({command=b.grep_get_command(a7,aa)},h)end;a.builtin.grep_live=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil},f or{})local a7=f.tool or b.grep_get_tool()if a7=='fallback'or not b.is_executable(a7)then b.error('`grep_live` needs non-fallback executable tool.')end;local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name=string.format('Grep live (%s)',a7),show=a8}}h=vim.tbl_deep_extend('force',a9,h or{})local ab,ac={do_match=false,querytick=b.querytick},{cwd=h.source.cwd}local ad;local ae=function(M,M,m)pcall(vim.loop.process_kill,ad)if b.querytick==ab.querytick then return end;if#m==0 then return a.set_picker_items({},ab)end;ab.querytick=b.querytick;local af=b.grep_get_command(a7,table.concat(m))ad=a.set_picker_items_from_cli(af,{set_items_opts=ab,spawn_opts=ac})end;h=vim.tbl_deep_extend('force',h or{},{source={items={},match=ae}})return a.start(h)end;a.builtin.help=function(f,h)local ag=vim.api.nvim_create_buf(false,true)vim.bo[ag].buftype='help'local ah=vim.api.nvim_buf_call(ag,function()return vim.fn.taglist('.*')end)vim.api.nvim_buf_delete(ag,{force=true})vim.tbl_map(function(ai)ai.text=ai.name end,ah)local W=function(P,aj)if P==nil then return end;vim.schedule(function()vim.cmd((aj or'')..'help '..(P.name or''))end)end;local a4=function(u,P)vim.api.nvim_buf_call(u,function()vim.cmd('noautocmd edit '..vim.fn.fnameescape(P.filename))vim.bo.buftype,vim.bo.buflisted,vim.bo.bufhidden='nofile',false,'wipe'local ak=pcall(vim.treesitter.start,0)if not ak then vim.bo.syntax='help'end;local al=vim.v.hlsearch;local am=string.gsub(P.cmd,'^/','/\\V')vim.cmd('silent keeppatterns '..am)vim.cmd('let v:hlsearch='..al)vim.cmd('normal! zt')end)end;local an=function(ao,aj)local g=function()W(a.get_picker_matches().current,aj..' ')return true end;return{char=ao,func=g}end;local ap={choose_in_split='',show_help_in_split=an('<C-s>',''),choose_in_vsplit='',show_help_in_vsplit=an('<C-v>','vertical'),choose_in_tabpage='',show_help_in_tabpage=an('<C-t>','tab')}local a6={items=ah,name='Help',choose=W,preview=a4}h=vim.tbl_deep_extend('force',{source=a6,mappings=ap},h or{})return a.start(h)end;a.builtin.buffers=function(f,h)f=vim.tbl_deep_extend('force',{include_current=true,include_unlisted=false},f or{})local aq=vim.api.nvim_exec('buffers'..(f.include_unlisted and'!'or''),true)local ar,as=vim.api.nvim_get_current_buf(),f.include_current;local j={}for M,y in ipairs(vim.split(aq,'\n'))do local at,e=y:match('^%s*%d+'),y:match('"(.*)"')local u=tonumber(at)local P={text=e,bufnr=u}if u~=ar or as then table.insert(j,P)end end;local a8=b.get_config().source.show or b.show_with_icons;local a9={source={name='Buffers',show=a8}}h=vim.tbl_deep_extend('force',a9,h or{},{source={items=j}})return a.start(h)end;a.builtin.cli=function(f,h)f=vim.tbl_deep_extend('force',{command={},postprocess=nil,spawn_opts={}},f or{})local e=string.format('CLI (%s)',tostring(f.command[1]or''))h=vim.tbl_deep_extend('force',{source={name=e}},h or{})f.spawn_opts.cwd=f.spawn_opts.cwd or h.source.cwd;local af=f.command;local au={postprocess=f.postprocess,spawn_opts=f.spawn_opts}h.source.items=vim.schedule_wrap(function()a.set_picker_items_from_cli(af,au)end)return a.start(h)end;a.builtin.resume=function()local i=b.pickers.latest;if i==nil then b.error('There is no picker to resume.')end;local u=b.picker_new_buf()local S=vim.api.nvim_get_current_win()local av=b.picker_new_win(u,i.opts.window.config)i.buffers={main=u}i.windows={main=av,target=S}i.view_state='main'b.pickers.active,b.cache=i,{}return b.picker_advance(i)end;a.registry={}for e,g in pairs(a.builtin)do a.registry[e]=function(f)return g(f)end end;if type(MiniExtra)=='table'then for e,g in pairs(MiniExtra.pickers)do a.registry[e]=function(f)return g(f)end end end;a.get_picker_items=function()return vim.deepcopy((b.pickers.active or{}).items)end;a.get_picker_stritems=function()return vim.deepcopy((b.pickers.active or{}).stritems)end;a.get_picker_matches=function()if not a.is_picker_active()then return end;local i=b.pickers.active;local j=i.items;if j==nil or#j==0 then return{}end;local aw={all_inds=vim.deepcopy(i.match_inds),current_ind=i.match_inds[i.current_ind]}aw.all=vim.tbl_map(function(ax)return j[ax]end,i.match_inds)aw.current=i.items[aw.current_ind]local ay=vim.tbl_keys(i.marked_inds_map)table.sort(ay)aw.marked_inds,aw.marked=ay,vim.tbl_map(function(ax)return j[ax]end,ay)return aw end;a.get_picker_opts=function()return vim.deepcopy((b.pickers.active or{}).opts)end;a.get_picker_state=function()if not a.is_picker_active()then return end;local i=b.pickers.active;return vim.deepcopy({buffers=i.buffers,windows=i.windows,caret=i.caret,is_busy=i.is_busy})end;a.get_picker_query=function()return vim.deepcopy((b.pickers.active or{}).query)end;a.set_picker_items=function(j,h)if not vim.tbl_islist(j)then b.error('`items` should be an array.')end;if not a.is_picker_active()then return end;h=vim.tbl_deep_extend('force',{do_match=true,querytick=nil},h or{})coroutine.wrap(b.picker_set_items)(b.pickers.active,j,h)end;a.set_picker_items_from_cli=function(af,h)if not a.is_picker_active()then return end;local az=b.is_array_of(af,'string')and#af>=1;if not az then b.error('`command` should be an array of strings.')end;local a9={postprocess=b.cli_postprocess,set_items_opts={},spawn_opts={}}h=vim.tbl_deep_extend('force',a9,h or{})local aA,aB=af[1],vim.list_slice(af,2,#af)local ad,aC,aD=nil,nil,vim.loop.new_pipe()local ac=vim.tbl_deep_extend('force',h.spawn_opts,{args=aB,stdio={nil,aD,nil}})if type(ac.cwd)=='string'then ac.cwd=b.full_path(ac.cwd)end;ad,aC=vim.loop.spawn(aA,ac,function()ad:close()end)local aE={}aD:read_start(function(aF,aG)assert(not aF,aF)if aG~=nil then return table.insert(aE,aG)end;local j=vim.split(table.concat(aE),'\n')aE=nil;aD:close()vim.schedule(function()a.set_picker_items(h.postprocess(j),h.set_items_opts)end)end)return ad,aC end;a.set_picker_match_inds=function(t)if not a.is_picker_active()then return end;if not b.is_array_of(t,'number')then b.error('`match_inds` should be an array of numbers.')end;b.picker_set_match_inds(b.pickers.active,t)b.picker_update(b.pickers.active,false)end;a.set_picker_opts=function(h)if not a.is_picker_active()then return end;b.pickers.active.opts=vim.tbl_deep_extend('force',b.pickers.active.opts,h or{})b.picker_update(b.pickers.active,true,true)end;a.set_picker_target_window=function(av)if not a.is_picker_active()then return end;if not b.is_valid_win(av)then b.error('`win_id` is not a valid window identifier.')end;b.pickers.active.windows.target=av end;a.set_picker_query=function(m)if not a.is_picker_active()then return end;if not b.is_array_of(m,'string')then b.error('`query` should be an array of strings.')end;b.pickers.active.query,b.pickers.active.caret=m,#m+1;b.querytick=b.querytick+1;b.pickers.active.match_inds=b.seq_along(a.get_picker_items())b.picker_update(b.pickers.active,true)end;a.get_querytick=function()return b.querytick end;a.is_picker_active=function()return b.pickers.active~=nil end;a.poke_is_picker_active=function()local aH=coroutine.running()if aH==nil then return a.is_picker_active()end;b.schedule_resume_is_active(aH)return coroutine.yield()end;b.default_config=vim.deepcopy(a.config)b.ns_id={matches=vim.api.nvim_create_namespace('MiniPickMatches'),headers=vim.api.nvim_create_namespace('MiniPickHeaders'),preview=vim.api.nvim_create_namespace('MiniPickPreview'),ranges=vim.api.nvim_create_namespace('MiniPickRanges')}b.timers={busy=vim.loop.new_timer(),focus=vim.loop.new_timer(),getcharstr=vim.loop.new_timer()}b.pickers={active=nil,latest=nil}b.querytick=0;b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({delay={c.delay,'table'},mappings={c.mappings,'table'},options={c.options,'table'},source={c.source,'table'},window={c.window,'table'}})local aI=function(q)return q==nil or type(q)=='table'or vim.is_callable(q)end;vim.validate({['delay.async']={c.delay.async,'number'},['delay.busy']={c.delay.busy,'number'},['mappings.caret_left']={c.mappings.caret_left,'string'},['mappings.caret_right']={c.mappings.caret_right,'string'},['mappings.choose']={c.mappings.choose,'string'},['mappings.choose_in_split']={c.mappings.choose_in_split,'string'},['mappings.choose_in_tabpage']={c.mappings.choose_in_tabpage,'string'},['mappings.choose_in_vsplit']={c.mappings.choose_in_vsplit,'string'},['mappings.choose_marked']={c.mappings.choose_marked,'string'},['mappings.delete_char']={c.mappings.delete_char,'string'},['mappings.delete_char_right']={c.mappings.delete_char_right,'string'},['mappings.delete_left']={c.mappings.delete_left,'string'},['mappings.delete_word']={c.mappings.delete_word,'string'},['mappings.mark']={c.mappings.mark,'string'},['mappings.mark_all']={c.mappings.mark_all,'string'},['mappings.move_down']={c.mappings.move_down,'string'},['mappings.move_start']={c.mappings.move_start,'string'},['mappings.move_up']={c.mappings.move_up,'string'},['mappings.paste']={c.mappings.paste,'string'},['mappings.refine']={c.mappings.refine,'string'},['mappings.refine_marked']={c.mappings.refine_marked,'string'},['mappings.scroll_down']={c.mappings.scroll_down,'string'},['mappings.scroll_up']={c.mappings.scroll_up,'string'},['mappings.scroll_left']={c.mappings.scroll_left,'string'},['mappings.scroll_right']={c.mappings.scroll_right,'string'},['mappings.stop']={c.mappings.stop,'string'},['mappings.toggle_info']={c.mappings.toggle_info,'string'},['mappings.toggle_preview']={c.mappings.toggle_preview,'string'},['options.content_from_bottom']={c.options.content_from_bottom,'boolean'},['options.use_cache']={c.options.use_cache,'boolean'},['source.items']={c.source.items,'table',true},['source.name']={c.source.name,'string',true},['source.cwd']={c.source.cwd,'string',true},['source.match']={c.source.match,'function',true},['source.show']={c.source.show,'function',true},['source.preview']={c.source.preview,'function',true},['source.choose']={c.source.choose,'function',true},['source.choose_marked']={c.source.choose_marked,'function',true},['window.config']={c.window.config,aI,'table or callable'},['window.prompt_cursor']={c.window.prompt_cursor,'string'},['window.prompt_prefix']={c.window.prompt_prefix,'string'}})return c end;b.apply_config=function(c)a.config=c end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minipick_config or{},c or{})end;b.create_autocommands=function(c)local aJ=vim.api.nvim_create_augroup('MiniPick',{})local aK=function(aL,aa,aM,aN)vim.api.nvim_create_autocmd(aL,{group=aJ,pattern=aa,callback=aM,desc=aN})end;aK('VimResized','*',a.refresh,'Refresh on resize')end;b.create_default_hl=function()local aO=function(e,h)h.default=true;vim.api.nvim_set_hl(0,e,h)end;aO('MiniPickBorder',{link='FloatBorder'})aO('MiniPickBorderBusy',{link='DiagnosticFloatingWarn'})aO('MiniPickBorderText',{link='FloatTitle'})aO('MiniPickIconDirectory',{link='Directory'})aO('MiniPickIconFile',{link='MiniPickNormal'})aO('MiniPickHeader',{link='DiagnosticFloatingHint'})aO('MiniPickMatchCurrent',{link='CursorLine'})aO('MiniPickMatchMarked',{link='Visual'})aO('MiniPickMatchRanges',{link='DiagnosticFloatingHint'})aO('MiniPickNormal',{link='NormalFloat'})aO('MiniPickPreviewLine',{link='CursorLine'})aO('MiniPickPreviewRegion',{link='IncSearch'})aO('MiniPickPrompt',{link='DiagnosticFloatingInfo'})end;b.command_parse_fargs=function(aP)local e,aQ=aP[1],vim.tbl_map(b.expandcmd,vim.list_slice(aP,2,#aP))local aR=string.format('{ %s }',table.concat(aQ,', '))local aS=loadstring('return '..aR)if aS==nil then b.error('Could not convert extra command arguments to table: '..aR)end;return e,aS()end;b.command_complete=function(M,A,aT)local aU,aV,aW=string.find(A,'^%S+%s+(%S*)')if aT<aU or aV<aT then return{}end;local aX=vim.tbl_filter(function(q)return tostring(q):find(aW,1,true)~=nil end,vim.tbl_keys(a.registry))table.sort(aX)return aX end;b.validate_picker_opts=function(h)h=h or{}if type(h)~='table'then b.error('Picker options should be table.')end;h=vim.deepcopy(b.get_config(h))local aY=function(q,aZ)if not vim.is_callable(q)then b.error(string.format('`%s` should be callable.',aZ))end end;local a6=h.source;local j=a6.items or{}local a_=vim.tbl_islist(j)or vim.is_callable(j)if not a_ then b.error('`source.items` should be array or callable.')end;a6.name=tostring(a6.name or'<No name>')if type(a6.cwd)=='string'then a6.cwd=b.full_path(a6.cwd)end;if a6.cwd==nil then a6.cwd=vim.fn.getcwd()end;if vim.fn.isdirectory(a6.cwd)==0 then b.error('`source.cwd` should be a valid directory path.')end;a6.match=a6.match or a.default_match;aY(a6.match,'source.match')a6.show=a6.show or a.default_show;aY(a6.show,'source.show')a6.preview=a6.preview or a.default_preview;aY(a6.preview,'source.preview')a6.choose=a6.choose or a.default_choose;aY(a6.choose,'source.choose')a6.choose_marked=a6.choose_marked or a.default_choose_marked;aY(a6.choose_marked,'source.choose_marked')for b0,b1 in pairs(h.delay)do local b2=type(b1)=='number'and b1>0;if not b2 then b.error(string.format('`delay.%s` should be a positive number.',b0))end end;local b3=b.default_config.mappings;for b4,q in pairs(h.mappings)do if type(b4)~='string'then b.error('`mappings` should have only string fields.')end;local b5=b3[b4]~=nil;if b5 and type(q)~='string'then b.error(string.format('Mapping for built-in action "%s" should be string.',b4))end;if not b5 and not(type(q)=='table'and type(q.char)=='string'and vim.is_callable(q.func))then b.error(string.format('Mapping for custom action "%s" should be table with `char` and `func`.',b4))end end;local b6=h.options;if type(b6.content_from_bottom)~='boolean'then b.error('`options.content_from_bottom` should be boolean.')end;if type(b6.use_cache)~='boolean'then b.error('`options.use_cache` should be boolean.')end;local b7=h.window.config;local b8=b7==nil or type(b7)=='table'or vim.is_callable(b7)if not b8 then b.error('`window.config` should be table or callable.')end;return h end;b.picker_new=function(h)local u=b.picker_new_buf()local S=vim.api.nvim_get_current_win()local av=b.picker_new_win(u,h.window.config)local i={opts=h,items=nil,stritems=nil,stritems_ignorecase=nil,buffers={main=u,preview=nil,info=nil},windows={main=av,target=S},query={},caret=1,match_inds=nil,marked_inds_map={},is_busy=false,cache={},view_state='main',visible_range={from=nil,to=nil},current_ind=nil}b.querytick=b.querytick+1;return i end;b.picker_advance=function(i)vim.schedule(function()vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStart'})end)local b9=b.picker_get_char_data(i)local ba,bb=false,false;for M=1,1000000 do if b.cache.is_force_stop_advance then break end;b.picker_update(i,ba)local ao=b.getcharstr(i.opts.delay.async)if b.cache.is_force_stop_advance then break end;bb=ao==nil;if bb then break end;local bc=b9[ao]or{}ba=bc.name==nil or vim.startswith(bc.name,'delete')or bc.name=='paste'bb=bc.name=='stop'local bd;if bc.is_custom then bd=bc.func()else bd=(bc.func or b.picker_query_add)(i,ao)end;if bd then break end end;local P;if not bb then P=b.picker_get_current_item(i)end;b.cache.is_force_stop_advance=nil;b.picker_stop(i)return P end;b.picker_update=function(i,ba,be)if ba then b.picker_match(i)end;if be then local c=b.picker_compute_win_config(i.opts.window.config)vim.api.nvim_win_set_config(i.windows.main,c)b.picker_set_current_ind(i,i.current_ind,true)end;b.picker_set_bordertext(i)b.picker_set_lines(i)b.redraw()end;b.picker_new_buf=function()local u=b.create_scratch_buf()vim.bo[u].filetype='minipick'return u end;b.picker_new_win=function(u,b7)if vim.fn.mode()=='n'then b.cache.cmdheight=vim.o.cmdheight;vim.o.cmdheight=1;vim.cmd('noautocmd normal! :')end;local av=vim.api.nvim_open_win(u,true,b.picker_compute_win_config(b7,true))vim.wo[av].foldenable=false;vim.wo[av].list=true;vim.wo[av].listchars='extends:…'vim.wo[av].scrolloff=0;vim.wo[av].wrap=false;b.win_update_hl(av,'NormalFloat','MiniPickNormal')b.win_update_hl(av,'FloatBorder','MiniPickBorder')return av end;b.picker_compute_win_config=function(b7,bf)local bg=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bh=vim.o.laststatus>0;local bi=vim.o.lines-vim.o.cmdheight-(bg and 1 or 0)-(bh and 1 or 0)local bj=vim.o.columns;local bk={relative='editor',anchor='SW',width=math.floor(0.618*bj),height=math.floor(0.618*bi),col=0,row=bi+(bg and 1 or 0),border='single',style='minimal',noautocmd=bf}local c=vim.tbl_deep_extend('force',bk,b.expand_callable(b7)or{})if c.border=='none'then c.border={'',' ','','','',' ','',''}end;c.height=math.min(c.height,bi-2)c.width=math.min(c.width,bj-2)return c end;b.picker_track_lost_focus=function(i)local bl=vim.schedule_wrap(function()local bm=vim.api.nvim_get_current_win()==i.windows.main;local bn=bm and(b.cache.is_in_getcharstr or vim.fn.mode()~='n')if bn then return end;b.picker_stop(i,true)end)b.timers.focus:start(1000,1000,bl)end;b.picker_set_items=function(i,j,h)local k,bo,bp={},{},b.tolower;local bq=b.poke_picker_throttle(h.querytick)for D,q in ipairs(j)do if not bq()then return end;local br=b.item_to_string(q)table.insert(k,br)table.insert(bo,bp(br))end;i.items,i.stritems,i.stritems_ignorecase=j,k,bo;i.cache,i.marked_inds_map={},{}b.picker_set_busy(i,false)b.picker_set_match_inds(i,b.seq_along(j))b.picker_update(i,h.do_match)end;b.item_to_string=function(P)P=b.expand_callable(P)if type(P)=='string'then return P end;if type(P)=='table'and type(P.text)=='string'then return P.text end;return vim.inspect(P,{newline=' ',indent=''})end;b.picker_set_busy=function(i,b1)i.is_busy=b1;local bs=function()b.timers.busy:stop()b.win_update_hl(i.windows.main,'FloatBorder',i.is_busy and'MiniPickBorderBusy'or'MiniPickBorder')end;if b1 then return b.timers.busy:start(i.opts.delay.busy,0,vim.schedule_wrap(bs))end;bs()end;b.picker_set_match_inds=function(i,l)if l==nil then return end;b.picker_set_busy(i,false)i.match_inds=l;local bt=table.concat(i.query)if i.opts.options.use_cache then i.cache[bt]={inds=l}end;b.picker_show_main(i)b.picker_set_current_ind(i,1)end;b.picker_set_current_ind=function(i,ax,bu)if i.items==nil or#i.match_inds==0 then i.current_ind,i.visible_range=nil,{}return end;local bv=#i.match_inds;ax=(ax-1)%bv+1;local bw,bx,by=i.visible_range.from,i.visible_range.to,i.visible_range.querytick;local bz=b.querytick~=by or bw==nil or bx==nil or not(bw<=ax and ax<=bx)if(bu or bz)and b.is_valid_win(i.windows.main)then local bA=vim.api.nvim_win_get_height(i.windows.main)bx=math.min(bv,math.floor(ax+0.5*bA))bw=math.max(1,bx-bA+1)bx=bw+math.min(bA,bv)-1 end;i.current_ind=ax;i.visible_range={from=bw,to=bx,querytick=b.querytick}end;b.picker_set_lines=function(i)local u,av=i.buffers.main,i.windows.main;if not(b.is_valid_buf(u)and b.is_valid_win(av))then return end;if i.is_busy then return end;local bB,m=i.visible_range,i.query;if i.items==nil or bB.from==nil or bB.to==nil then i.opts.source.show(u,{},m)b.clear_namespace(u,b.ns_id.matches)return end;local bC,j,t={},i.items,i.match_inds;local bD,bE=i.current_ind,nil;local bF,bG=i.marked_inds_map,{}local bH=i.opts.options.content_from_bottom;local bw=bH and bB.to or bB.from;local bx=bH and bB.from or bB.to;for D=bw,bx,bw<=bx and 1 or-1 do table.insert(bC,j[t[D]])if D==bD then bE=#bC end;if bF[t[D]]then table.insert(bG,#bC)end end;local bI=bH and vim.api.nvim_win_get_height(av)-#bC or 0;bE=bE+bI;bG=vim.tbl_map(function(q)return q+bI end,bG)i.opts.source.show(u,bC,m)if bI>0 then local bJ=vim.fn['repeat']({''},bI)vim.api.nvim_buf_set_lines(u,0,0,true,bJ)end;local E=b.ns_id.matches;b.clear_namespace(u,E)local bK={end_col=0,hl_group='MiniPickMatchMarked',priority=202}for M,bL in ipairs(bG)do bK.end_row=bL;b.set_extmark(u,E,bL-1,0,bK)end;if bE>vim.api.nvim_buf_line_count(u)then return end;local bM={end_row=bE,end_col=0,hl_eol=true,hl_group='MiniPickMatchCurrent',priority=201}b.set_extmark(u,E,bE-1,0,bM)local bN=vim.api.nvim_win_get_cursor(av)if i.view_state=='main'and bN[1]~=bE then b.set_cursor(av,bE,bN[2]+1)end end;b.picker_match=function(i)if i.items==nil then return end;local bO;if i.opts.options.use_cache then bO=i.cache[table.concat(i.query)]end;if bO~=nil then return b.picker_set_match_inds(i,bO.inds)end;local bP=b.query_is_ignorecase(i.query)local k=bP and i.stritems_ignorecase or i.stritems;local m=bP and vim.tbl_map(b.tolower,i.query)or i.query;b.picker_set_busy(i,true)local bQ=i.opts.source.match(k,i.match_inds,m)b.picker_set_match_inds(i,bQ)end;b.query_is_ignorecase=function(m)if not vim.o.ignorecase then return false end;if not vim.o.smartcase then return true end;local Z=table.concat(m)return Z==vim.fn.tolower(Z)end;b.picker_get_char_data=function(i,bR)local bS=b.replace_termcodes;local aw={}local bT={}if not bR then bT={move_down='<Down>',move_start='<Home>',move_up='<Up>'}end;for e,bU in pairs(i.opts.mappings)do local bV=type(bU)=='table'local ao=bV and bU.char or bU;local aG={char=ao,name=e,func=bV and bU.func or b.actions[e],is_custom=bV}aw[bS(ao)]=aG;local bW=bT[e]if bW~=nil then aw[bS(bW)]=aG end end;return aw end;b.picker_set_bordertext=function(i)local h=i.opts;local av=i.windows.main;if not b.is_valid_win(av)then return end;local bX=i.view_state;local c;if bX=='main'then local m,bY=i.query,i.caret;local bZ=table.concat(vim.list_slice(m,1,bY-1),'')local b_=table.concat(vim.list_slice(m,bY,#m),'')local c0=h.window.prompt_prefix..bZ..h.window.prompt_cursor..b_;local Z={{b.win_trim_to_width(av,c0),'MiniPickPrompt'}}c={title=Z}end;local c1=i.items~=nil;if bX=='preview'and c1 then local c2=i.stritems[i.match_inds[i.current_ind]]or''c2=c2:gsub('[%s%z]',' ')c={title={{b.win_trim_to_width(av,c2),'MiniPickBorderText'}}}end;if bX=='info'then c={title={{b.win_trim_to_width(av,'Info'),'MiniPickBorderText'}}}end;local c3=vim.fn.has('nvim-0.10')==1;if c3 and not i.is_busy then c.footer,c.footer_pos=b.picker_compute_footer(i,av),'left'end;if c3 and h.options.content_from_bottom then c.title,c.footer=c.footer,c.title end;vim.api.nvim_win_set_config(av,c)vim.wo[av].list=true end;if vim.fn.has('nvim-0.9')==0 then b.picker_set_bordertext=function()end end;b.picker_compute_footer=function(i,av)local c4=b.picker_get_general_info(i)local Y=string.format(' %s ',c4.source_name)local c5=c4.n_marked==0 and''or c4.n_marked..'/'local l=string.format(' %s|%s|%s%s ',c4.relative_current_ind,c4.n_matched,c5,c4.n_total)local c6,c7,c8=vim.api.nvim_win_get_width(av),vim.fn.strchars(Y),vim.fn.strchars(l)local c9={{Y,'MiniPickBorderText'}}local ca=c6-(c7+c8)if ca>0 then local cb=i.is_busy and'MiniPickBorderBusy'or'MiniPickBorder'c9[2]={b.win_get_bottom_border(av):rep(ca),cb}c9[3]={l,'MiniPickBorderText'}end;return c9 end;b.picker_stop=function(i,cc)vim.tbl_map(function(cd)pcall(vim.loop.timer_stop,cd)end,b.timers)pcall(function()vim.o.cmdheight=b.cache.cmdheight end)if i==nil then return end;vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStop'})if cc then b.pickers={}else local ce=vim.deepcopy(i)b.picker_free(b.pickers.latest)b.pickers={active=nil,latest=ce}end;b.set_curwin(i.windows.target)pcall(vim.api.nvim_win_close,i.windows.main,true)pcall(vim.api.nvim_buf_delete,i.buffers.main,{force=true})pcall(vim.api.nvim_buf_delete,i.buffers.info,{force=true})i.windows,i.buffers={},{}b.querytick=b.querytick+1 end;b.picker_free=function(i)if i==nil then return end;i.match_inds=nil;i.cache=nil;i.stritems,i.stritems_ignorecase,i.marked_inds_map=nil,nil,nil;i.items=nil;i=nil;vim.schedule(function()collectgarbage('collect')end)end;b.actions={caret_left=function(i,M)b.picker_move_caret(i,-1)end,caret_right=function(i,M)b.picker_move_caret(i,1)end,choose=function(i,M)return b.picker_choose(i,nil)end,choose_in_split=function(i,M)return b.picker_choose(i,'split')end,choose_in_tabpage=function(i,M)return b.picker_choose(i,'tabnew')end,choose_in_vsplit=function(i,M)return b.picker_choose(i,'vsplit')end,choose_marked=function(i,M)return not i.opts.source.choose_marked(a.get_picker_matches().marked)end,delete_char=function(i,M)b.picker_query_delete(i,1)end,delete_char_right=function(i,M)b.picker_query_delete(i,0)end,delete_left=function(i,M)b.picker_query_delete(i,i.caret-1)end,delete_word=function(i,M)local cf,cg=i.caret-1,0;if cf==0 then return end;local ch=vim.fn.match(i.query[cf],'[[:keyword:]]')>=0;for D=cf,1,-1 do local ci=vim.fn.match(i.query[D],'[[:keyword:]]')>=0;if ch and not ci or not ch and ci then break end;cg=cg+1 end;b.picker_query_delete(i,cg)end,mark=function(i,M)b.picker_mark_indexes(i,'current')end,mark_all=function(i,M)b.picker_mark_indexes(i,'all')end,move_down=function(i,M)b.picker_move_current(i,1)end,move_start=function(i,M)b.picker_move_current(i,nil,1)end,move_up=function(i,M)b.picker_move_current(i,-1)end,paste=function(i,M)local cj=b.getcharstr(i.opts.delay.async)local ck,cl=pcall(vim.fn.getreg,cj)if not ck then return end;cl=cl:gsub('[\n\t]',' ')for D=1,vim.fn.strchars(cl)do b.picker_query_add(i,vim.fn.strcharpart(cl,D-1,1))end end,refine=function(i,M)b.picker_refine(i,'all')end,refine_marked=function(i,M)b.picker_refine(i,'marked')end,scroll_down=function(i,M)b.picker_scroll(i,'down')end,scroll_up=function(i,M)b.picker_scroll(i,'up')end,scroll_left=function(i,M)b.picker_scroll(i,'left')end,scroll_right=function(i,M)b.picker_scroll(i,'right')end,toggle_info=function(i,M)if i.view_state=='info'then return b.picker_show_main(i)end;b.picker_show_info(i)end,toggle_preview=function(i,M)if i.view_state=='preview'then return b.picker_show_main(i)end;b.picker_show_preview(i)end,stop=function(M,M)return true end}b.picker_query_add=function(i,ao)if vim.fn.strchars(ao)>1 or vim.fn.char2nr(ao)<=31 then return end;table.insert(i.query,i.caret,ao)i.caret=i.caret+1;b.querytick=b.querytick+1;local cm=i.items~=nil and i.caret<=#i.query;if cm then i.match_inds=b.seq_along(i.items)end end;b.picker_query_delete=function(i,cn)local co=cn>0;local cp=co and math.max(i.caret-cn,1)or i.caret;local cq=co and i.caret-1 or math.min(i.caret+cn,#i.query)for D=cq,cp,-1 do table.remove(i.query,D)end;i.caret=cp;b.querytick=b.querytick+1;if i.items~=nil then i.match_inds=b.seq_along(i.items)end end;b.picker_choose=function(i,cr)local cs=b.picker_get_current_item(i)if cs==nil then return true end;local ct=i.windows.target;if cr~=nil and b.is_valid_win(ct)then vim.api.nvim_win_call(ct,function()vim.cmd(cr)i.windows.target=vim.api.nvim_get_current_win()end)end;return not i.opts.source.choose(cs)end;b.picker_mark_indexes=function(i,cu)if i.items==nil then return end;local cv=cu=='current'and{i.match_inds[i.current_ind]}or i.match_inds;local bF,cw=i.marked_inds_map,true;for M,ax in ipairs(cv)do cw=cw and bF[ax]end;local cx;if not cw then cx=true end;for M,ax in ipairs(cv)do bF[ax]=cx end;if i.view_state=='info'then b.picker_show_info(i)end end;b.picker_move_caret=function(i,cn)i.caret=math.min(math.max(i.caret+cn,1),#i.query+1)end;b.picker_move_current=function(i,cy,bx)if i.items==nil then return end;local bv=#i.match_inds;if bv==0 then return end;if bx==nil then cy=(i.opts.options.content_from_bottom and-1 or 1)*cy;bx=i.current_ind;if bx==1 and cy<0 then bx=bv elseif bx==bv and cy>0 then bx=1 else bx=bx+cy end;bx=math.min(math.max(bx,1),bv)end;b.picker_set_current_ind(i,bx)if i.view_state=='info'then b.picker_show_info(i)end;if i.view_state=='preview'then b.picker_show_preview(i)end end;b.picker_refine=function(i,cz)if i.items==nil then return end;i.opts.source.match=b.get_config().source.match or a.default_match;i.query,i.caret={},1;a.set_picker_items(a.get_picker_matches()[cz]or{})i._refine=i._refine or{orig_name=i.opts.source.name,count=0}i._refine.count=i._refine.count+1;local cA=i._refine.count==1 and''or' '..i._refine.count;i.opts.source.name=string.format('%s (Refine%s)',i._refine.orig_name,cA)end;b.picker_scroll=function(i,cB)local av=i.windows.main;if i.view_state=='main'and(cB=='down'or cB=='up')then local cn=(cB=='down'and 1 or-1)*vim.api.nvim_win_get_height(av)b.picker_move_current(i,cn)else local cC=({down='<C-f>',up='<C-b>',left='zH',right='zL'})[cB]vim.api.nvim_win_call(av,function()vim.cmd('normal! '..b.replace_termcodes(cC))end)end end;b.picker_get_current_item=function(i)if i.items==nil then return nil end;return i.items[i.match_inds[i.current_ind]]end;b.picker_show_main=function(i)b.set_winbuf(i.windows.main,i.buffers.main)i.view_state='main'end;b.picker_show_info=function(i)local c4=b.picker_get_general_info(i)local w={'General','Source name   │ '..c4.source_name,'Source cwd    │ '..c4.source_cwd,'Total items   │ '..c4.n_total,'Matched items │ '..c4.n_matched,'Marked items  │ '..c4.n_marked,'Current index │ '..c4.relative_current_ind}local cD={1}local cE=function(aG,cF)if#aG==0 then return end;table.insert(w,'')table.insert(w,cF)table.insert(cD,#w)local cG=0;for M,ai in ipairs(aG)do local aN=ai.name:gsub('[%s%p]',' ')ai.desc=vim.fn.toupper(aN:sub(1,1))..aN:sub(2)ai.width=vim.fn.strchars(ai.desc)cG=math.max(cG,ai.width)end;table.sort(aG,function(cH,cI)return cH.desc<cI.desc end)for M,ai in ipairs(aG)do table.insert(w,string.format('%s%s │ %s',ai.desc,string.rep(' ',cG-ai.width),ai.char))end end;local b9=b.picker_get_char_data(i,true)cE(vim.tbl_filter(function(q)return q.is_custom end,b9),'Mappings (custom)')cE(vim.tbl_filter(function(q)return not q.is_custom end,b9),'Mappings (built-in)')local cJ=i.buffers.info;if not b.is_valid_buf(cJ)then cJ=b.create_scratch_buf()end;i.buffers.info=cJ;b.set_buflines(cJ,w)b.set_winbuf(i.windows.main,cJ)i.view_state='info'local E=b.ns_id.headers;b.clear_namespace(cJ,E)for M,bL in ipairs(cD)do b.set_extmark(cJ,E,bL-1,0,{end_row=bL,end_col=0,hl_group='MiniPickHeader'})end end;b.picker_get_general_info=function(i)local c1=i.items~=nil;return{source_name=i.opts.source.name or'---',source_cwd=vim.fn.fnamemodify(i.opts.source.cwd,':~')or'---',n_total=c1 and#i.items or'-',n_matched=c1 and#i.match_inds or'-',n_marked=c1 and vim.tbl_count(i.marked_inds_map)or'-',relative_current_ind=c1 and i.current_ind or'-'}end;b.picker_show_preview=function(i)local a4=i.opts.source.preview;local P=b.picker_get_current_item(i)if P==nil then return end;local av,u=i.windows.main,b.create_scratch_buf()vim.bo[u].bufhidden='wipe'b.set_winbuf(av,u)a4(u,P)i.buffers.preview=u;i.view_state='preview'end;b.match_filter=function(l,k,m)local cK,cL,cM,cN=m[1]=='*',m[1]=="'",m[1]=='^',m[#m]=='$'local cO,cP=b.match_query_group(m)if cK or cL or cM or cN then local L=(cK or cL or cM)and 2 or 1;local cQ=#m-(not cK and not cL and cN and 1 or 0)m=vim.list_slice(m,L,cQ)elseif cO then m=cP end;if#m==0 then return{},'nosort',m end;local cR=not(cL or cM or cN)and#m>1;if cK or cR then return b.match_filter_fuzzy(l,k,m),'fuzzy',m end;local aW=cM and'^'or''local cS=cN and'$'or''local aa=aW..vim.pesc(table.concat(m))..cS;return b.match_filter_exact(l,k,m,aa),'exact',m end;b.match_filter_exact=function(l,k,m,aa)local cT=b.match_filter_exact_single;local bq=b.poke_picker_throttle(b.querytick)local r={}for M,ax in ipairs(l)do if not bq()then return nil end;local aG=cT(k[ax],ax,aa)if aG~=nil then table.insert(r,aG)end end;return r end;b.match_filter_exact_single=function(cU,cV,aa)local cW=string.find(cU,aa)if cW==nil then return nil end;return{0,cW,cV}end;b.match_ranges_exact=function(r,m)local cX,cY=0,{}for D=1,#m do cY[D]={cX,cX+m[D]:len()-1}cX=cY[D][2]+1 end;local aw={}for D=1,#r do local cW=r[D][2]aw[D]=vim.tbl_map(function(q)return{cW+q[1],cW+q[2]}end,cY)end;return aw end;b.match_filter_fuzzy=function(l,k,m)local cT,cZ=b.match_filter_fuzzy_single,b.match_find_query;local bq=b.poke_picker_throttle(b.querytick)local r={}for M,ax in ipairs(l)do if not bq()then return nil end;local aG=cT(k[ax],ax,m,cZ)if aG~=nil then table.insert(r,aG)end end;return r end;b.match_filter_fuzzy_single=function(cU,cV,m,cZ)local c_,d0=cZ(cU,m,1)if c_==nil then return nil end;if c_==d0 then return{0,c_,cV,{c_}}end;local d1,d2,d3=c_,d0,d0-c_;while d0 do local d4=d0-c_;if d4<d3 then d1,d2,d3=c_,d0,d4 end;c_,d0=cZ(cU,m,c_+1)end;return{d2-d1,d1,cV}end;b.match_ranges_fuzzy=function(r,m,k)local aw,d5,d6={},#m,vim.tbl_map(string.len,m)for d7,aG in ipairs(r)do local d8,bw,bx=k[aG[3]],aG[2],aG[2]+d6[1]-1;local K={{bw,bx}}for d9=2,d5 do bw,bx=string.find(d8,m[d9],bx+1,true)K[d9]={bw,bx}end;aw[d7]=K end;return aw end;b.match_find_query=function(d8,m,cf)local c_,bx=string.find(d8,m[1],cf,true)if c_==nil then return nil,nil end;local d0=c_;for D=2,#m do d0,bx=string.find(d8,m[D],bx+1,true)if not d0 then return nil,nil end end;return c_,d0 end;b.match_query_group=function(m)local da={{}}for M,q in ipairs(m)do local db=q:find('^%s+$')~=nil;if db then table.insert(da,{})end;if not db then table.insert(da[#da],q)end end;return#da>1,vim.tbl_map(table.concat,da)end;b.match_sort=function(r)local dc,bj,dd={},0,{}for D=1,#r do local aG,d4,cW=r[D],r[D][1],r[D][2]local de=dc[d4]or{}local df=de[cW]or{}table.insert(df,aG[3])de[cW]=df;dc[d4]=de;bj=math.max(bj,d4)dd[d4]=math.max(dd[d4]or 0,cW)end;local bq=b.poke_picker_throttle(b.querytick)for M,de in pairs(dc)do for M,df in pairs(de)do if not bq()then return nil end;table.sort(df)end end;local aw={}for d4=0,bj do local de=dc[d4]for cW=1,dd[d4]or 0 do local df=de[cW]or{}for D=1,#df do table.insert(aw,df[D])end end end;return aw end;b.get_icon=function(q,dg)local dh,di=b.parse_path(q)if dh==nil then return{text=''}end;if dh=='directory'then return{text=dg.directory,hl='MiniPickIconDirectory'}end;if dh=='none'then return{text=dg.none,hl='MiniPickNormal'}end;local dj,dk=pcall(require,'nvim-web-devicons')if not dj then return{text=dg.file,hl='MiniPickIconFile'}end;local dl,dm=dk.get_icon(vim.fn.fnamemodify(di,':t'),nil,{default=false})dl=type(dl)=='string'and dl..' 'or dg.file;return{text=dl,hl=dm or'MiniPickIconFile'}end;b.show_with_icons=function(u,j,m)a.default_show(u,j,m,{show_icons=true})end;b.parse_item=function(P)if type(P)=='table'then return b.parse_item_table(P)end;local dn=b.item_to_string(P)local dp,dq=pcall(tonumber,dn)if dp and b.is_valid_buf(dq)then return{type='buffer',buf_id=dq}end;local dh,di,bL,aT,dr=b.parse_path(dn)if dh~='none'then return{type=dh,path=di,lnum=bL,col=aT,text=dr}end;return{}end;b.parse_item_table=function(P)local u=P.bufnr or P.buf_id or P.buf;if b.is_valid_buf(u)then return{type='buffer',buf_id=u,lnum=P.lnum,end_lnum=P.end_lnum,col=P.col,end_col=P.end_col,text=P.text}end;if type(P.path)=='string'then local dh,di,bL,aT,dr=b.parse_path(P.path)if dh=='file'then return{type='file',path=di,lnum=bL or P.lnum,end_lnum=P.end_lnum,col=aT or P.col,end_col=P.end_col,text=dr~=''and dr or P.text}end;if dh=='directory'then return{type='directory',path=P.path}end end;return{}end;b.parse_path=function(q)if type(q)~='string'or q==''then return nil end;local ds=':(%d+):?(%d*):?(.*)$'local bL,aT,dr=q:match(ds)local di=q:gsub(ds,'',1)di=di:sub(1,1)=='~'and(vim.loop.os_homedir()or'~')..di:sub(2)or di;local dh=b.get_fs_type(di)if dh=='none'and di~=''then local dt=b.pickers.active==nil and vim.fn.getcwd()or b.pickers.active.opts.source.cwd;di=string.format('%s/%s',dt,di)dh=b.get_fs_type(di)end;return dh,di,tonumber(bL),tonumber(aT),dr or''end;b.get_fs_type=function(di)if di==''then return'none'end;if vim.fn.filereadable(di)==1 then return'file'end;if vim.fn.isdirectory(di)==1 then return'directory'end;return'none'end;b.preview_file=function(u,Q,h)if not b.is_file_text(Q.path)then return b.set_buflines(u,{'-Non-text-file-'})end;local du,w=pcall(vim.fn.readfile,Q.path,'',(Q.lnum or 1)+h.n_context_lines)if not du then return end;Q.line_position=h.line_position;b.preview_set_lines(u,w,Q)end;b.preview_directory=function(u,Q)local di=Q.path;local dv=function(q)return q..(vim.fn.isdirectory(di..'/'..q)==1 and'/'or'')end;local w=vim.tbl_map(dv,vim.fn.readdir(di))b.set_buflines(u,w)end;b.preview_buffer=function(u,Q,h)local dw=Q.buf_id;local dx=vim.o.eventignore;vim.o.eventignore='BufEnter'vim.fn.bufload(dw)vim.o.eventignore=dx;local w=vim.api.nvim_buf_get_lines(dw,0,(Q.lnum or 1)+h.n_context_lines,false)Q.filetype,Q.line_position=vim.bo[dw].filetype,h.line_position;b.preview_set_lines(u,w,Q)end;b.preview_inspect=function(u,dy)b.set_buflines(u,vim.split(vim.inspect(dy),'\n'))end;b.preview_set_lines=function(u,w,dz)b.set_buflines(u,w)b.preview_highlight_region(u,dz.lnum,dz.col,dz.end_lnum,dz.end_col)if b.preview_should_highlight(u)then local dA=dz.filetype or vim.filetype.match({buf=u,filename=dz.path})local dB,dC=pcall(vim.treesitter.language.get_lang,dA)local ak,M=pcall(vim.treesitter.start,u,dB and dC or dA)if not ak then vim.bo[u].syntax=dA end end;local dD=a.get_picker_state()local av=dD~=nil and dD.windows.main or vim.fn.bufwinid(u)b.set_cursor(av,dz.lnum,dz.col)local dE=({top='zt',center='zz',bottom='zb'})[dz.line_position]or'zt'pcall(vim.api.nvim_win_call,av,function()vim.cmd('normal! '..dE)end)end;b.preview_should_highlight=function(u)if vim.fn.has('nvim-0.8')==0 then return false end;local dF=vim.api.nvim_buf_call(u,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return dF<=1000000 and dF<=1000*vim.api.nvim_buf_line_count(u)end;b.preview_highlight_region=function(u,bL,aT,dG,dH)if bL==nil then return end;local dI={end_row=bL,end_col=0,hl_eol=true,hl_group='MiniPickPreviewLine',priority=201}b.set_extmark(u,b.ns_id.preview,bL-1,0,dI)if aT==nil then return end;local dJ,dK=bL-1,aT;if dG~=nil and dH~=nil then dJ,dK=dG-1,dH-1 end;dK=b.get_next_char_bytecol(vim.fn.getbufline(u,dJ+1)[1],dK)local dL={end_row=dJ,end_col=dK,priority=202}dL.hl_group='MiniPickPreviewRegion'b.set_extmark(u,b.ns_id.preview,bL-1,aT-1,dL)end;b.choose_path=function(S,Q)local di,dM=Q.path,nil;for M,u in ipairs(vim.api.nvim_list_bufs())do local dN=b.is_valid_buf(u)and vim.bo[u].buflisted and vim.api.nvim_buf_get_name(u)==di;if dN then dM=u end end;if dM~=nil then b.set_winbuf(S,dM)else local dO=vim.fn.fnameescape(vim.fn.fnamemodify(di,':.'))vim.api.nvim_win_call(S,function()pcall(vim.cmd,'edit '..dO)end)end;b.choose_set_cursor(S,Q.lnum,Q.col)end;b.choose_buffer=function(S,Q)b.set_winbuf(S,Q.buf_id)b.choose_set_cursor(S,Q.lnum,Q.col)end;b.choose_print=function(q)print(vim.inspect(q))end;b.choose_set_cursor=function(av,bL,aT)if bL==nil then return end;b.set_cursor(av,bL,aT)pcall(vim.api.nvim_win_call,av,function()vim.cmd('normal! zvzz')end)end;b.cli_postprocess=function(j)while j[#j]==''do j[#j]=nil end;return j end;b.is_executable=function(a7)if a7=='fallback'then return true end;return vim.fn.executable(a7)==1 end;b.files_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('fd')then return'fd'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.files_get_command=function(a7)if a7=='rg'then return{'rg','--files','--no-follow','--color=never'}end;if a7=='fd'then return{'fd','--type=f','--no-follow','--color=never'}end;if a7=='git'then return{'git','ls-files','--cached','--others','--exclude-standard'}end;b.error([[Wrong 'tool' for `files` builtin.]])end;b.files_fallback_items=function(dt)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `files` builtin needs Neovim>=0.9.')end;dt=dt or'.'local bq=b.poke_picker_throttle()local g=function()local j={}for di,dh in vim.fs.dir(dt,{depth=math.huge})do if not bq()then return end;if dh=='file'and b.is_file_text(string.format('%s/%s',dt,di))then table.insert(j,di)end end;a.set_picker_items(j)end;vim.schedule(coroutine.wrap(g))end;b.grep_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.grep_get_command=function(a7,aa)if a7=='rg'then return{'rg','--column','--line-number','--no-heading','--no-follow','--color=never','--',aa}end;if a7=='git'then local aw={'git','grep','--column','--line-number','--color=never','--',aa}if vim.o.ignorecase then table.insert(aw,6,'--ignore-case')end;return aw end;b.error([[Wrong 'tool' for `grep` builtin.]])end;b.grep_fallback_items=function(aa,dt)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `grep` builtin needs Neovim>=0.9.')end;dt=dt or'.'local bq=b.poke_picker_throttle()local g=function()local dP,dQ={},{}for di,dh in vim.fs.dir(dt,{depth=math.huge})do if not bq()then return end;local dR=string.format('%s/%s',dt,di)if dh=='file'and b.is_file_text(dR)then table.insert(dP,di)table.insert(dQ,dR)end end;local j={}for D,di in ipairs(dQ)do local dS=dP[D]if not bq()then return end;for bL,y in ipairs(vim.fn.readfile(di))do local aT=string.find(y,aa)if aT~=nil then table.insert(j,string.format('%s:%d:%d:%s',dS,bL,aT,y))end end end;a.set_picker_items(j)end;vim.schedule(coroutine.wrap(g))end;b.schedule_resume_is_active=vim.schedule_wrap(function(aH)coroutine.resume(aH,a.is_picker_active())end)b.poke_picker_throttle=function(dT)if not a.is_picker_active()then return function()return true end end;local dU,dV=vim.loop.hrtime(),dT==nil;local dW=1000000*b.get_config().delay.async;local dX=vim.loop.hrtime;local dY=a.poke_is_picker_active;return function()local dZ=dX()if dZ-dU<dW then return true end;dU=dZ;return dY()and(dV or dT==b.querytick)end end;b.error=function(d_)error(string.format('(mini.pick) %s',d_),0)end;b.is_valid_buf=function(u)return type(u)=='number'and vim.api.nvim_buf_is_valid(u)end;b.is_valid_win=function(av)return type(av)=='number'and vim.api.nvim_win_is_valid(av)end;b.is_array_of=function(q,e0)if not vim.tbl_islist(q)then return false end;for D=1,#q do if type(q[D])~=e0 then return false end end;return true end;b.create_scratch_buf=function()local u=vim.api.nvim_create_buf(false,true)vim.bo[u].matchpairs=''vim.b[u].minicursorword_disable=true;vim.b[u].miniindentscope_disable=true;return u end;b.get_first_valid_normal_window=function()for M,av in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(av).relative==''then return av end end end;b.set_buflines=function(u,w)pcall(vim.api.nvim_buf_set_lines,u,0,-1,false,w)end;b.set_winbuf=function(av,u)vim.api.nvim_win_set_buf(av,u)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.set_cursor=function(av,bL,aT)pcall(vim.api.nvim_win_set_cursor,av,{bL or 1,(aT or 1)-1})end;b.set_curwin=function(av)if not b.is_valid_win(av)then return end;local bN=vim.api.nvim_win_get_cursor(av)vim.api.nvim_set_current_win(av)b.set_cursor(av,bN[1],bN[2]+1)end;b.clear_namespace=function(u,E)pcall(vim.api.nvim_buf_clear_namespace,u,E,0,-1)end;b.replace_termcodes=function(q)if q==nil then return nil end;return vim.api.nvim_replace_termcodes(q,true,true,true)end;b.expand_callable=function(q,...)if vim.is_callable(q)then return q(...)end;return q end;b.expandcmd=function(q)local dp,aw=pcall(vim.fn.expandcmd,q)return dp and aw or q end;b.redraw=function()vim.cmd('redraw')end;b.redraw_scheduled=vim.schedule_wrap(b.redraw)b.getcharstr=function(e1)b.timers.getcharstr:start(0,e1,b.redraw_scheduled)b.cache.is_in_getcharstr=true;local dp,ao=pcall(vim.fn.getcharstr)b.cache.is_in_getcharstr=nil;b.timers.getcharstr:stop()local e2;if b.pickers.active~=nil then e2=b.pickers.active.windows.main end;local e3=vim.v.mouse_winid~=0 and vim.v.mouse_winid~=e2;if not dp or ao==''or ao=='\3'or e3 then return end;return ao end;b.tolower=(function()local bp=vim.fn.tolower;return function(q)local dp,aw=pcall(bp,q)return dp and aw or string.lower(q)end end)()b.win_update_hl=function(av,e4,e5)if not b.is_valid_win(av)then return end;local e6=e4 ..':'..e5;local e7=string.format('(%s:[^,]*)',vim.pesc(e4))local e8,e9=vim.wo[av].winhighlight:gsub(e7,e6)if e9==0 then e8=e8 ..','..e6 end;pcall(function()vim.wo[av].winhighlight=e8 end)end;b.win_trim_to_width=function(av,ea)local c6=vim.api.nvim_win_get_width(av)return vim.fn.strcharpart(ea,vim.fn.strchars(ea)-c6,c6)end;b.win_get_bottom_border=function(av)local eb=vim.api.nvim_win_get_config(av).border or{}local aw=eb[6]if type(aw)=='table'then aw=aw[1]end;return aw or' 'end;b.seq_along=function(ec)if ec==nil then return nil end;local aw={}for D=1,#ec do table.insert(aw,D)end;return aw end;b.get_next_char_bytecol=function(ed,aT)if type(ed)~='string'then return aT end;local ee=vim.str_utfindex(ed,math.min(ed:len(),aT))return vim.str_byteindex(ed,ee)end;b.is_file_text=function(di)local ef=vim.loop.fs_open(di,'r',1)local eg=vim.loop.fs_read(ef,1024):find('\0')==nil;vim.loop.fs_close(ef)return eg end;b.full_path=function(di)return vim.fn.fnamemodify(di,':p'):gsub('(.)/$','%1')end;return a
