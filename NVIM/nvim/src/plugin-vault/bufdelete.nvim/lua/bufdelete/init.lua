local a=vim.api;local b=vim.cmd;local c=vim.fn;local d=vim.bo;if c.has('nvim-0.8')==0 then a.nvim_err_writeln('bufdelete.nvim is only available for Neovim versions 0.8 and above')return end;local e={}local function f(g)local h=a.nvim_buf_get_name(g)if h==''then return"[No Name]"end;return h end;local function i(j,k)local l=c.confirm(j,table.concat(k,'\n'),'','Q')if l==0 then return'C'else return string.match(k[l],'&?(%a)')end end;local function m(n,o,p,q)local r={}for s,t in ipairs(n)do r[t]=true end;if not p then for g,s in pairs(r)do if d[g].modified then local l=i(string.format('No write since last change for buffer %d (%s).',g,f(g)),{'&Save','&Ignore','&Cancel'})if l=='s'or l=='S'then a.nvim_buf_call(g,function()b.write()end)elseif l~='i'and l~='I'then r[g]=nil end elseif d[g].buftype=='terminal'and c.jobwait({d[g].channel},0)[1]==-1 then local l=i(string.format('Terminal buffer %d (%s) is still running.',g,f(g)),{'&Ignore','&Cancel'})if l~='i'and l~='I'then r[g]=nil end end end end;if next(r)==nil then a.nvim_err_writeln('bufdelete.nvim: No buffers were deleted')return end;local u=vim.tbl_filter(function(v)return r[a.nvim_win_get_buf(v)]~=nil end,a.nvim_list_wins())if o~=nil then elseif vim.g.bufdelete_buf_filter~=nil then o=vim.g.bufdelete_buf_filter()else o=vim.tbl_filter(function(w)return a.nvim_buf_is_valid(w)and d[w].buflisted end,a.nvim_list_bufs())end;local x=vim.tbl_filter(function(w)return not r[w]end,o)local y;if#x>0 then local z=-1;for s,g in ipairs(x)do local A=c.getbufinfo(g)[1]if A.lastused>z then y=g;z=A.lastused end end else y=a.nvim_create_buf(true,false)if y==0 then a.nvim_err_writeln('bufdelete.nvim: Failed to create buffer')end end;for s,v in ipairs(u)do a.nvim_win_set_buf(v,y)end;for g,s in pairs(r)do if a.nvim_buf_is_valid(g)then local B=p or d[g].modified or d[g].buftype=='terminal'a.nvim_exec_autocmds('User',{pattern='BDeletePre '..tostring(g)})if q then b.bwipeout({count=g,bang=B})else b.bdelete({count=g,bang=B})end;a.nvim_exec_autocmds('User',{pattern='BDeletePost '..tostring(g)})end end end;local function C(D)for s,g in ipairs(a.nvim_list_bufs())do if a.nvim_buf_is_valid(g)and a.nvim_buf_get_name(g):match(D)then return g end end end;local function E(F)local g;if F==nil then g=0 elseif type(F)=='number'then g=F elseif type(F)=='string'then g=tonumber(F)if g~=nil and math.floor(g)==g then g=g else g=C(F)end end;if g==0 then g=a.nvim_get_current_buf()end;if g~=nil and a.nvim_buf_is_valid(g)then return g end end;local function G(H,I)local n={}for J=H,I do if a.nvim_buf_is_valid(J)then n[#n+1]=J end end;return n end;local function K(L)if type(L)~='table'then return{E(L)}end;local n={}for s,t in ipairs(L)do local g=E(t)if g~=nil then n[#n+1]=g end end;return n end;function e.bufdelete(L,p,o)m(K(L),o,p,false)end;function e.bufwipeout(L,p,o)m(K(L),o,p,true)end;function e._buf_kill_cmd(M,q)local n=K(M.fargs)if#M.fargs==0 or M.range>0 then local N=M.range==2 and M.line1 or M.line2;local O=M.line2;local P=G(N,O)for s,t in ipairs(P)do n[#n+1]=t end end;m(n,nil,M.bang,q)end;return e
