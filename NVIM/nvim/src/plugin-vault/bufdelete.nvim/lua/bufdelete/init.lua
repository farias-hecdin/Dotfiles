local a=vim.api;local b=vim.cmd;local c=vim.fn;local d=vim.bo;if c.has('nvim-0.8')==0 then a.nvim_err_writeln('bufdelete.nvim is only available for Neovim versions 0.8 and above')return end;local e={}local function f(g)local h=a.nvim_buf_get_name(g)if h==''then return"[No Name]"end;return h end;local function i(j,k)local l=c.confirm(j,table.concat(k,'\n'),'','Q')if l==0 then return'C'else return string.match(k[l],'&?(%a)')end end;local function m(n,o,p)local q={}for r,s in ipairs(n)do q[s]=true end;if not o then for g,r in pairs(q)do if d[g].modified then local l=i(string.format('No write since last change for buffer %d (%s).',g,f(g)),{'&Save','&Ignore','&Cancel'})if l=='s'or l=='S'then a.nvim_buf_call(g,function()b.write()end)elseif l~='i'and l~='I'then q[g]=nil end elseif d[g].buftype=='terminal'and c.jobwait({d[g].channel},0)[1]==-1 then local l=i(string.format('Terminal buffer %d (%s) is still running.',g,f(g)),{'&Ignore','&Cancel'})if l~='i'and l~='I'then q[g]=nil end end end end;if next(q)==nil then a.nvim_err_writeln('bufdelete.nvim: No buffers were deleted')return end;local t=vim.tbl_filter(function(u)return q[a.nvim_win_get_buf(u)]~=nil end,a.nvim_list_wins())local v=vim.tbl_filter(function(w)return a.nvim_buf_is_valid(w)and d[w].buflisted and not q[w]end,a.nvim_list_bufs())local x;if#v>0 then local y=-1;for r,g in ipairs(v)do local z=c.getbufinfo(g)[1]if z.lastused>y then x=g;y=z.lastused end end else x=a.nvim_create_buf(true,false)if x==0 then a.nvim_err_writeln('bufdelete.nvim: Failed to create buffer')end end;for r,u in ipairs(t)do a.nvim_win_set_buf(u,x)end;for g,r in pairs(q)do if a.nvim_buf_is_valid(g)then local A=o or d[g].modified or d[g].buftype=='terminal'a.nvim_exec_autocmds('User',{pattern='BDeletePre '..tostring(g)})if p then b.bwipeout({count=g,bang=A})else b.bdelete({count=g,bang=A})end;a.nvim_exec_autocmds('User',{pattern='BDeletePost '..tostring(g)})end end end;local function B(C)for r,g in ipairs(a.nvim_list_bufs())do if a.nvim_buf_is_valid(g)and a.nvim_buf_get_name(g):match(C)then return g end end end;local function D(E)local g;if E==nil then g=0 elseif type(E)=='number'then g=E elseif type(E)=='string'then g=tonumber(E)if g~=nil and math.floor(g)==g then g=g else g=B(E)end end;if g==0 then g=a.nvim_get_current_buf()end;if g~=nil and a.nvim_buf_is_valid(g)then return g end end;local function F(G,H)local n={}for I=G,H do if a.nvim_buf_is_valid(I)then n[#n+1]=I end end;return n end;local function J(K)if type(K)~='table'then return{D(K)}end;local n={}for r,s in ipairs(K)do local g=D(s)if g~=nil then n[#n+1]=g end end;return n end;function e.bufdelete(K,o)m(J(K),o,false)end;function e.bufwipeout(K,o)m(J(K),o,true)end;function e._buf_kill_cmd(L,p)local n=J(L.fargs)if#L.fargs==0 or L.range>0 then local M=L.range==2 and L.line1 or L.line2;local N=L.line2;local O=F(M,N)for r,s in ipairs(O)do n[#n+1]=s end end;m(n,L.bang,p)end;return e
