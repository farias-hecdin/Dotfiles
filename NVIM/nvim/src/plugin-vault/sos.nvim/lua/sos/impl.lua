local a={}local b=vim.api;local c=vim.loop;a.savable_cmds=setmetatable({["!"]=true,["="]=true,lua=true,luafile=true,make=true,runtime=true,source=true},{__index=function(d,e)return vim.startswith(e,"Plenary")end})a.savable_cmdline=vim.regex[=[system\|:lua\|[Jj][Oo][Bb]]=]local f=vim.regex[[\%(^$\)\|\%(^\%(acwrite\|help\|nofile\|nowrite\|quickfix\|terminal\|prompt\)$\)]]local function g(h)local i=vim.bo[h].bt;if not f:match_str(i)then vim.notify_once(('[sos.nvim]: ignoring buf with unknown buftype "%s"'):format(i),vim.log.levels.WARN)return false end;return i==""or i=="acwrite"end;local j;local function k()j=nil;local l,m=pcall(b.nvim_cmd,{cmd="write",mods={silent=true}},{output=false})if not l then j=m end end;local function n(h)b.nvim_buf_call(h,k)return not j,j end;function a.write_buf_if_needed(h)if vim.bo[h].mod and vim.o.write and not vim.bo[h].ro and b.nvim_buf_is_loaded(h)and g(h)then local o=b.nvim_buf_get_name(h)if o==""then return true end;local i=vim.bo[h].bt;if i=="acwrite"then return n(h)elseif i==""then local p,q,r=c.fs_stat(o)if p then if p.type=="file"then return n(h)end else return n(h)end end end;return true end;function a.should_observe_buf(h)return g(h)and vim.bo[h].ma and not vim.bo[h].ro end;function a.on_timer()local s={}for t,h in ipairs(b.nvim_list_bufs())do local l,m=a.write_buf_if_needed(h)if not l then table.insert(s,("[sos.nvim]: %s: %s"):format(m,b.nvim_buf_get_name(h)))end end;if s[1]~=nil then b.nvim_err_writeln(table.concat(s,"\n"))end end;return a
