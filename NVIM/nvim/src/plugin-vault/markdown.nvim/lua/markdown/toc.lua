local a=vim.api;local b=vim.treesitter;local c=require("markdown.section")local d=require("markdown.config")local e=require("markdown.link")local f=require("markdown.list")local g=require("markdown.treesitter")local h={}local i=b.query.parse("markdown",[[
	[
		(atx_heading
			(_) @atx_marker
			heading_content: (inline) @atx_content)
		(setext_heading
			heading_content: (_ (inline) @setext_content)
			(_) @setext_underline)
	] @heading
]])local j=b.query.parse("markdown","(html_block) @html")local k=b.query.parse("markdown_inline","(html_tag) @html")local function l(m)local type=m:type()return type=="list"or type=="block_quote"end;local function n(o)local p;if type(o)=="string"then p=o else p=b.get_node_text(o,0,nil)end;return#p>3 and p:sub(1,4)=="<!--"and p:sub(-3,-1)=="-->"end;local function q(o,r,s)local p=b.get_node_text(o,0,nil)if n(p)then if p:match(r)~=nil then return c.OMIT_LEVEL.section elseif p:match(s)~=nil then return c.OMIT_LEVEL.heading end end;return c.OMIT_LEVEL.none end;local function t(u,r,s)local v=b.get_parser(0,"markdown"):children().markdown_inline:parse()local w=g.find_tree_in_node(v,u)if w~=nil then for x,y,x in k:iter_captures(w:root(),0,0,-1)do local z=q(y,r,s)if z~=c.OMIT_LEVEL.none then return z end end end;return c.OMIT_LEVEL.none end;local function A()local w=b.get_parser(0,"markdown"):parse()[1]local B=d:get()local r=B.toc.omit_section;local s=B.toc.omit_heading;local C={}local D={}for x,E,x in j:iter_matches(w:root(),0,0,-1)do local o=E[1]local F=g.find_parent(o,l)if not F then local G=q(o,r,s)if G==c.OMIT_LEVEL.section then C[o:end_()]=true elseif G==c.OMIT_LEVEL.heading then D[o:end_()]=true end end end;local H=c:new()for x,E,x in i:iter_matches(w:root(),0,0,-1)do local I=E[5]local F=g.find_parent(I,l)if not F then local J=E[1]or E[4]local K=E[2]or E[3]local L=b.get_node_text(K,0,nil)local M=tonumber(J:type():match("(%d+)"))local N=I:start()+1;if M>H.level then H=H:add_subsection(L,M,N)else H=H:get_parent(M):add_subsection(L,M,N)end;local O=I:start()if C[O]then H.omit=c.OMIT_LEVEL.section elseif D[O]then H.omit=c.OMIT_LEVEL.heading else local P=t(K,r,s)if P==c.OMIT_LEVEL.section then H.omit=c.OMIT_LEVEL.section elseif P==c.OMIT_LEVEL.heading then H.omit=c.OMIT_LEVEL.heading end end end end;return H:get_root()end;local function Q(H,R,S,T,U,V)T=T or{}U=U or 0;V=V or""local J=R[U%#R+1]local W=V..string.rep(" ",#J+1)for x,X in pairs(H.children)do local Y=X.omit==c.OMIT_LEVEL.section or X.level>S;if not Y then local p,Z=e.get_heading_link(X.name)local _=X.omit==c.OMIT_LEVEL.heading or p==""if not _ then local N=V..J.." ["..p.."](#"..Z..")"table.insert(T,N)Q(X,R,S,T,U+1,W)else Q(X,R,S,T,U,V)end end end;return T end;function h.insert_toc(a0)local H=A()local R={}for a1,a2 in ipairs(a0.markers)do if a2=="."or a2==")"then R[a1]="1"..a2 else R[a1]=a2 end end;local S=a0.max_level or 6;local T=Q(H,R,S)local a3;if a0.end_row~=nil then a3=a0.end_row+1 else a3=a0.start_row end;a.nvim_buf_set_lines(0,a0.start_row,a3,true,T)f.reset_list_numbering(a0.start_row,a0.start_row+#T-1)end;local function a4(H,a0,a5,V)a5=a5 or{}V=V or""local W=V.."  "for x,X in pairs(H.children)do local Y=a0.omit_flagged and X.omit==c.OMIT_LEVEL.section;if not Y and X.level<=a0.max_level then local p=e.get_heading_link(X.name)local _=a0.omit_flagged and X.omit==c.OMIT_LEVEL.heading;if not _ and p~=""then table.insert(a5,{bufnr=a0.bufnr,lnum=X.line,text=V..p})a4(X,a0,a5,W)else a4(X,a0,a5,V)end end end;return a5 end;function h.set_loclist_toc(a0)a0=a0 or{}local H=A()local a6=a.nvim_win_get_buf(0)local a5=a4(H,{bufnr=a6,max_level=a0.max_level or 6,omit_flagged=a0.omit_flagged or false})vim.fn.setloclist(0,a5)vim.cmd.lopen()vim.cmd.setlocal("modifiable")for a1,a7 in ipairs(a5)do a.nvim_buf_set_lines(0,a1-1,a1,true,{a7.text})end;vim.cmd.setlocal("nomodified")vim.cmd.setlocal("nomodifiable")end;return h
