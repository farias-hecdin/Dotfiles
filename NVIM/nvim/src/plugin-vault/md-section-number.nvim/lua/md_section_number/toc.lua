local a=require("md_section_number.heading.parser")local b={}b.options={width=30,position="right",indent_space_number=2,header_prefix="- ",winopts={number=false,relativenumber=false,wrap=false,winfixwidth=true,list=false,spell=false},bufopts={bufhidden="wipe",filetype="msnumber",modifiable=false}}function b.setup(c)b.options=vim.tbl_deep_extend("force",b.options,c or{})end;b.viewBind={MdHeaders=nil,TocWin=nil,TocBuf=nil,BindBuf=nil,BindWin=nil,changeTick=nil}local d="MSNbindBufEventGroup"local e="MSNtocBufEventGroup"local f="MSNGlobalEventGroup"local g=vim.api.nvim_create_namespace("tocHlNameSpace")local h={markdown=true,md=true}local i={left="H",right="L"}local function j()local k=function(l)return l~=nil and vim.api.nvim_buf_is_valid(l)end;if k(b.viewBind.BindBuf)then vim.api.nvim_clear_autocmds({group=d,buffer=b.viewBind.BindBuf})end;if k(b.viewBind.TocBuf)then vim.api.nvim_clear_autocmds({group=e,buffer=b.viewBind.TocBuf})end;vim.api.nvim_clear_autocmds({group=f})end;function b.unbind()j()b.viewBind={}end;local function m()vim.cmd("vsplit")local n=vim.api.nvim_get_current_win()local o=i[b.options.position]vim.api.nvim_command("wincmd "..o)vim.api.nvim_win_set_width(n,b.options.width)local p=vim.api.nvim_create_buf(false,true)vim.api.nvim_win_set_buf(n,p)for q,r in pairs(b.options.bufopts)do vim.api.nvim_buf_set_option(p,q,r)end;for q,r in pairs(b.options.winopts)do vim.opt_local[q]=r end;return n,p end;local function s(t)local u=t[2]local v=string.rep(" ",b.options.indent_space_number)u=b.options.header_prefix..vim.trim(u:gsub("#","",t[3]))if t[3]>1 then u=string.rep(v,t[3]-1)..u end;return u end;local function w()local x=false;if not b.viewBind.BindBuf then return x end;local y=vim.api.nvim_buf_get_changedtick(b.viewBind.BindBuf)if b.viewBind.MdHeaders==nil or b.viewBind.changeTick~=y then b.viewBind.MdHeaders=a.get_heading_lines(vim.api.nvim_buf_get_lines(b.viewBind.BindBuf,0,-1,false))x=true end;b.viewBind.changeTick=y;return x end;local function z()local x=w()if not x then return end;vim.api.nvim_buf_set_option(b.viewBind.TocBuf,"modifiable",true)local A={}for B,t in ipairs(b.viewBind.MdHeaders)do table.insert(A,s(t))end;vim.api.nvim_buf_set_lines(b.viewBind.TocBuf,0,-1,false,{})vim.api.nvim_buf_set_lines(b.viewBind.TocBuf,0,-1,false,A)vim.api.nvim_buf_set_option(b.viewBind.TocBuf,"modifiable",false)end;local function C()if not b.viewBind.MdHeaders or#b.viewBind.MdHeaders==0 then return 1 end;local D=vim.api.nvim_win_get_cursor(b.viewBind.BindWin)[1]local E=1;local F=#b.viewBind.MdHeaders;if D<b.viewBind.MdHeaders[E][1]then return E end;if D>b.viewBind.MdHeaders[F][1]then return F end;while E<=F do local G=math.floor((E+F)/2)local H=b.viewBind.MdHeaders[G][1]+1;if H==D then return G elseif D>H then E=G+1 elseif D<H then F=G-1 end end;return math.max(math.min(E,F),1)end;local function I()local J=C()vim.api.nvim_win_set_cursor(b.viewBind.TocWin,{J,0})vim.api.nvim_buf_clear_namespace(b.viewBind.TocBuf,g,0,-1)vim.api.nvim_buf_add_highlight(b.viewBind.TocBuf,g,"Search",J-1,0,-1)end;local function K()if not b.viewBind.MdHeaders then w()end;local L=math.min(vim.api.nvim_win_get_cursor(0)[1],#b.viewBind.MdHeaders)local M=math.min(b.viewBind.MdHeaders[L][1]+1,vim.api.nvim_buf_line_count(b.viewBind.BindBuf))vim.api.nvim_win_set_buf(b.viewBind.BindWin,b.viewBind.BindBuf)vim.api.nvim_set_current_win(b.viewBind.BindWin)vim.api.nvim_win_set_cursor(b.viewBind.BindWin,{M,0})vim.api.nvim_feedkeys("zz","n",false)I()end;function b.closeToc()if not b.viewBind.TocWin then return end;vim.api.nvim_win_close(b.viewBind.TocWin,true)b.unbind()end;local function N()local O={["<cr>"]=K,q=function()b.closeToc()end,r=function()local P=vim.api.nvim_win_get_cursor(b.viewBind.TocWin)z()local Q=vim.api.nvim_buf_line_count(b.viewBind.TocBuf)if Q==0 then return end;local R=C()local S=vim.api.nvim_buf_get_lines(b.viewBind.TocBuf,R-1,R,false)[1]if S==nil then S=""end;local T=math.min(#S,P[2])vim.api.nvim_win_set_cursor(b.viewBind.TocWin,{R,T})end}for q,r in pairs(O)do vim.keymap.set("n",q,r,{buffer=b.viewBind.TocBuf,silent=true,noremap=true})end end;local function U()local V=vim.api.nvim_create_augroup(d,{clear=true})vim.api.nvim_create_autocmd({"BufWritePost"},{group=V,buffer=b.viewBind.BindBuf,callback=vim.schedule_wrap(function()z()I()end)})vim.api.nvim_create_autocmd("CursorHold",{group=V,buffer=b.viewBind.BindBuf,callback=vim.schedule_wrap(function()I()end)})vim.api.nvim_create_autocmd("WinClosed",{group=V,buffer=b.viewBind.BindBuf,callback=vim.schedule_wrap(function()if vim.api.nvim_get_current_win()==b.viewBind.TocWin then return end;b.closeToc()end)})end;local function W()local X=vim.api.nvim_create_augroup(e,{clear=true})vim.api.nvim_create_autocmd({"WinClosed","QuitPre"},{group=X,buffer=b.viewBind.TocBuf,callback=function()b.unbind()end})vim.api.nvim_create_autocmd("BufEnter",{group=X,buffer=b.viewBind.TocBuf,callback=vim.schedule_wrap(function()if b.viewBind.BindWin==nil or not vim.api.nvim_win_is_valid(b.viewBind.BindWin)then b.unbind()return end;local Y=vim.api.nvim_win_get_buf(b.viewBind.BindWin)if Y~=b.viewBind.BindBuf then return end;z()I()end)})end;local function Z()if not b.viewBind.TocBuf then return end;local _=vim.api.nvim_buf_get_option(0,"filetype")if not h[_]then return end;local a0=vim.api.nvim_get_current_buf()local a1=vim.api.nvim_get_current_win()if a0==b.viewBind.BindBuf and a1==b.viewBind.BindWin then return end;if a0~=b.viewBind.BindBuf then b.viewBind.BindBuf=a0;b.viewBind.MdHeaders=nil;z()end;if a0~=b.viewBind.BindWin then b.viewBind.BindWin=a1 end;U()I()end;local function a2()W()U()local a3=vim.api.nvim_create_augroup(f,{clear=true})vim.api.nvim_create_autocmd("BufEnter",{group=a3,pattern="*.md,*.markdown",callback=vim.schedule_wrap(Z)})vim.api.nvim_create_autocmd("WinEnter",{group=a3,pattern="*.md,*.markdown",callback=vim.schedule_wrap(function()local Y=vim.api.nvim_win_get_buf(0)if Y==b.viewBind.BindBuf then b.viewBind.BindWin=vim.api.nvim_get_current_win()return end end)})vim.api.nvim_create_autocmd("QuitPre",{group=a3,pattern="*.md,*.markdown",callback=vim.schedule_wrap(function()local a4=vim.api.nvim_tabpage_list_wins(vim.api.nvim_get_current_tabpage())local a5=#a4==1 and a4[1]==b.viewBind.TocWin;if a5 then local a6=b.viewBind.BindBuf;local a7=b.viewBind.TocWin;b.unbind()vim.api.nvim_set_current_buf(a6)vim.cmd(":quit")end end)})end;local function a8()if not b.viewBind.BindWin then return end;vim.api.nvim_set_current_win(b.viewBind.BindWin)end;function b.openToc()if b.viewBind.TocWin then return end;b.viewBind.BindBuf=vim.api.nvim_get_current_buf()b.viewBind.BindWin=vim.api.nvim_get_current_win()local n,p=m()b.viewBind.TocWin=n;b.viewBind.TocBuf=p;z()N()a2()a8()end;function b.toggle()if b.viewBind.TocWin then b.closeToc()else b.openToc()end end;return b
