local a=vim.api;local b=vim.treesitter.highlighter;local c=require'treesitter-context.cache'local d=require'nvim-treesitter.parsers'local e=vim.treesitter.query.get or vim.treesitter.query.get_query;local f=a.nvim_create_augroup;local g=a.nvim_create_user_command;local h={enable=true,max_lines=0,min_window_height=0,line_numbers=true,multiline_threshold=20,trim_scope='outer',zindex=20,mode='cursor',separator=nil}local i={}local j='^%s+'local k=false;local l=false;local m;local n;local o;local p;local q=a.nvim_create_namespace('nvim-treesitter-context')local r;local function s()local t=d.get_parser():parse()[1]return t:root()end;local function u(v)return table.concat({v:id(),v:symbol(),v:child_count(),v:type(),v:range()},',')end;local w=c.memoize(function(v,x)local y=a.nvim_get_current_buf()local z={v:range()}z[3]=z[1]z[4]=-1;local A=v:parent()or v;for B,C in x:iter_matches(A,y,0,-1)do local D=false;for E,F in pairs(C)do local G,H,I,J=F:range()if G<z[1]then break end;local K=x.captures[E]if not D and K=='context'then D=v==F elseif K=='context.final'then z[3]=I;z[4]=J elseif K=='context.end'then z[3]=G;z[4]=H end end;if D then return z end end end,u)local function L(z)if z[4]==0 then z[3]=z[3]-1;z[4]=-1 end;local M=a.nvim_buf_get_text(0,z[1],0,z[3],z[4],{})if M==nil then return nil,nil end;local N=z[1]local O=z[3]local P=z[4]M=vim.list_slice(M,1,O-N+1)M[#M]=M[#M]:sub(1,P)if#M>i.multiline_threshold then M=vim.list_slice(M,1,1)O=N;P=#M[1]end;z={N,0,O,P}return M,z end;local function Q(M)local R={M[1]}for S=2,#M do R[S]=M[S]:gsub(j,'')end;return table.concat(R,' ')end;local function T(M)local U=vim.tbl_map(function(V)local W=V:match(j)return W and#W or 0 end,M)U[1]=0;return U end;local function X()return vim.fn.getwininfo(vim.api.nvim_get_current_win())[1].textoff end;local Y;do local V;Y=function()local Z=vim.api.nvim_win_get_cursor(0)[1]if Z~=V then V=Z;return true end;return false end end;local function _()if not p or not a.nvim_buf_is_valid(p)then p=a.nvim_create_buf(false,true)end;if not o or not a.nvim_buf_is_valid(o)then o=a.nvim_create_buf(false,true)end;return o,p end;local function a0()if p and a.nvim_buf_is_valid(p)then a.nvim_buf_delete(p,{force=true})end;p=nil;if o and a.nvim_buf_is_valid(o)then a.nvim_buf_delete(o,{force=true})end;o=nil end;local function a1(y,a2,a3,a4,a5,a6,a7)if not a2 or not a.nvim_win_is_valid(a2)then local a8=i.separator;a2=a.nvim_open_win(y,false,{relative='win',width=a3,height=a4,row=0,col=a5,focusable=false,style='minimal',noautocmd=true,zindex=i.zindex,border=a8 and{'','','','',a8,a8,a8,''}or nil})a.nvim_win_set_var(a2,a6,true)a.nvim_win_set_option(a2,'wrap',false)a.nvim_win_set_option(a2,'foldenable',false)a.nvim_win_set_option(a2,'winhl','NormalFloat:'..a7)else a.nvim_win_set_config(a2,{win=a.nvim_get_current_win(),relative='win',width=a3,height=a4,row=0,col=a5})end;return a2 end;local a9={config=i}local function aa(v)local ab={}while v~=nil do ab[#ab+1]=v;v=v:parent()end;return ab end;local function ac()local ad,a5;if i.mode=='topline'then ad,a5=vim.fn.line('w0'),0 else ad,a5=unpack(a.nvim_win_get_cursor(0))end;return ad,a5 end;local function ae(af)if af==0 then return end;if not d.has_parser()then return end;local ag=d.ft_to_lang(vim.bo.filetype)local ah,x=pcall(e,ag,'context')if not ah then vim.notify_once(string.format('Unable to load context query for %s:\n%s',ag,x),vim.log.levels.ERROR,{title='nvim-treesitter-context'})return end;if not x then return end;local ai=s()local ad,a5=ac()local aj;local ak={}local al=0;repeat local am=ad+al-1;local v=ai:named_descendant_for_range(am,a5,am,a5)if not v then return end;aj=ak;ak={}local an=-1;local ao=vim.fn.line('w0')local ab=aa(v)for S=#ab,1,-1 do local ap=ab[S]local aq=ap:start()local a4=math.min(af,#ak)local z=w(ap,x)if z and aq>=0 and aq<ao+a4-1 then if aq==an then ak[#ak]=z else ak[#ak+1]=z;an=aq;local ar=math.min(af,#ak)if i.mode=='topline'and al<ar then al=al+1;break end end end end until i.mode~='topline'or#aj>=#ak;if i.trim_scope=='inner'then return vim.list_slice(ak,1,math.min(#ak,af))else return vim.list_slice(ak,math.max(1,#ak-af+1),#ak)end end;local function as(at)local au=false;local av=false;local function aw()if av then au=true else local ax=vim.loop.hrtime()at()local ay=math.floor((vim.loop.hrtime()-ax)/1e6)if ay>2 then av=true;vim.defer_fn(function()av=false;if au then au=false;aw()end end,20)end end end;return aw end;local function az()r=nil;if vim.fn.getcmdwintype()~=''then a0()return end;if n~=nil and a.nvim_win_is_valid(n)then a.nvim_win_close(n,true)end;n=nil;if m and a.nvim_win_is_valid(m)then a.nvim_win_close(m,true)end;m=nil end;local function aA(y,M)local aB=a.nvim_buf_get_lines(y,0,-1,false)local aC=false;if#aB~=#M then aC=true else for S,aD in ipairs(aB)do if aD~=M[S]then aC=true;break end end end;if aC then a.nvim_buf_set_lines(y,0,-1,false,M)a.nvim_buf_set_option(y,'modified',false)end;return aC end;local function aE(y,aF,aG)a.nvim_buf_clear_namespace(aF,q,0,-1)local aH=b.active[y]if not aH then local aI=vim.bo.filetype;if aI~=vim.bo[aF].filetype then vim.bo[aF].filetype=aI end;return end;local aJ=vim.bo.tabstop;if aJ~=vim.bo[aF].tabstop then vim.bo[aF].tabstop=aJ end;local aK=aH:get_query(d.ft_to_lang(vim.bo.filetype))local x=assert(aK:query())local aL=s()for S,aM in ipairs(aG)do local N=aM.range[1]local O=aM.range[3]local P=aM.range[4]local U=aM.indents;local M=aM.lines;for aN,v in x:iter_captures(aL,y,N,O+1)do local aO,aP,aQ,aR=v:range()if aQ>O or aQ==O and aR>P and P~=-1 then break end;if aO>=N then local aS=aO-N;local aT=aS;for aU=1,aS do aT=aT+#M[aU]-U[aU]end;aT=aT-U[aS+1]local aq=S-1;a.nvim_buf_set_extmark(aF,q,aq,aP+aT,{end_line=aq,end_col=aR+aT,hl_group=aK.hl_cache[aN]})end end end end;local function aV(aW,ad,aX,a3)local aY,aZ=pcall(a.nvim_get_option_value,'statuscolumn',{win=aW,scope="local"})if aY and aZ and aZ~=""then local ah,a_=pcall(a.nvim_eval_statusline,aZ,{winid=aW,use_statuscol_lnum=ad,highlights=true})if ah then return a_.str,a_.highlights end end;if aX then ad=aX end;return string.format('%'..a3 ..'d',ad)end;local function b0(b1,R,b2)for V,b3 in ipairs(b2)do for b4,a7 in ipairs(b3)do local a5=a7.start;local b5=b4<#b3 and b3[b4+1].start or#R[V]if a5~=b5 then a.nvim_buf_set_extmark(b1,q,V-1,a5,{end_col=b5,hl_group=a7.group})end end end;a.nvim_buf_set_extmark(b1,q,#R-1,0,{end_line=#R,hl_group='TreesitterContextBottom',hl_eol=true})end;local function b6(b7)local b8=vim.fn.line('.')local b9=0;local ba=b7;while ba<b8 do local bb=vim.fn.foldclosedend(ba)if bb==-1 then ba=ba+1 else b9=b9+bb-ba;ba=bb+1 end end;return b8-b7-b9 end;local function bc()if n==nil then return end;local bd=vim.fn.winsaveview()local be=a.nvim_win_call(n,vim.fn.winsaveview)if bd.leftcol~=be.leftcol then be.leftcol=bd.leftcol;a.nvim_win_call(n,function()return vim.fn.winrestview({leftcol=be.leftcol})end)end end;local function bf(bg)local y=a.nvim_get_current_buf()local aW=a.nvim_get_current_win()local bh=X()local bi=math.max(1,a.nvim_win_get_width(0)-bh)local bj=math.max(1,#bg)local bk,aF=_()if i.line_numbers and(vim.wo.number or vim.wo.relativenumber)then m=a1(bk,m,bh,bj,0,'treesitter_context_line_number','TreesitterContextLineNumber')end;n=a1(aF,n,bi,bj,bh,'treesitter_context','TreesitterContext')local bl={}local bm={}local bn={}local aG={}for B,bo in ipairs(bg)do local M,z=L(bo)if M==nil or z==nil or z[1]==nil then return end;local R=Q(M)aG[#aG+1]={lines=M,range=z,indents=T(M)}table.insert(bl,R)local bp=z[1]+1;local aX;if vim.wo[aW].relativenumber then aX=b6(bp)end;local bq,a7=aV(aW,bp,aX,bh-1)table.insert(bm,bq)table.insert(bn,a7)end;aA(bk,bm)b0(bk,bm,bn)if not aA(aF,bl)then return end;aE(y,aF,aG)a.nvim_buf_set_extmark(aF,q,#bm-1,0,{end_line=#bm,hl_group='TreesitterContextBottom',hl_eol=true})end;local function br(bs)local af=bs;af=af==0 and-1 or af;local bt=vim.fn.line('w0')local bu=vim.fn.line('.')local bv=bu-bt;if i.separator and bv>0 then bv=bv-1 end;if af~=-1 then af=math.min(af,bv)else af=bv end;return af end;local bw=as(function()if vim.bo.buftype~=''or vim.wo.previewwindow then az()return end;local aM=ae(br(i.max_lines))if aM and#aM~=0 then if aM==r then return end;r=aM;if a.nvim_win_get_height(0)<i.min_window_height then az()return end;bf(aM)bc()else az()end end)local function bx(by)local bz=f(by,{})return function(bA,bB)if bB then if type(bB)=='function'then bB={callback=bB}elseif bB[1]then bB.callback=bB[1]bB[1]=nil end else bB={}end;bB.group=bz;a.nvim_create_autocmd(bA,bB)end end;function a9.enable()local bC=bx('treesitter_context_update')bC({'WinScrolled','BufEnter','WinEnter','VimResized'},bw)bC('CursorMoved',function()if Y()then bw()end end)bC('WinLeave',az)bC('User',{az,pattern='SessionSavePre'})bC('User',{bw,pattern='SessionSavePost'})bw()l=true end;function a9.disable()f('treesitter_context_update',{})az()a0()l=false end;function a9.toggle()if l then a9.disable()else a9.enable()end end;function a9.setup(bD)if k then return end;k=true;local bE=bD or{}i=vim.tbl_deep_extend('force',{},h,bE)if i.enable then a9.enable()else a9.disable()end end;g('TSContextEnable',a9.enable,{})g('TSContextDisable',a9.disable,{})g('TSContextToggle',a9.toggle,{})a.nvim_set_hl(0,'TreesitterContext',{link='NormalFloat',default=true})a.nvim_set_hl(0,'TreesitterContextLineNumber',{link='LineNr',default=true})a.nvim_set_hl(0,'TreesitterContextBottom',{link='NONE',default=true})bx('treesitter_context')('VimEnter',function()a9.setup()end)return a9
