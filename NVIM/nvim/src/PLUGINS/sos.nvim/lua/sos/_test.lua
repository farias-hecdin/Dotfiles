local a={}local b=vim.api;local c=vim.loop.sleep;function a.write_file(d,e)assert(vim.fn.writefile(e,d,"b")==0,"Error: file write failed")end;function a.buf_empty(f)local e=b.nvim_buf_get_lines(f or 0,0,-1,true)local g=type(e)assert(g=="table","expected table, got "..g)local h=#e;return h<2 and(e[1]==""or h==0)end;function a.kill(i,j)vim.fn.system({"kill","-s",j,i})assert(vim.v.shell_error==0,"error: kill(): kill failed with exit code "..vim.v.shell_error)end;function a.start_nvim(k)local l={width=120,height=80,detach=false,clear_env=false,pty=true,stderr_buffered=true,stdout_buffered=true}local m=vim.fn.tempname()local n=vim.fn.jobstart({"nvim","--clean","--listen",m,unpack(k and k.xargs or{})},l)local o;do local p;for q=1,4 do p,o=pcall(function()return vim.fn.sockconnect("pipe",m,{rpc=true})end)if p then break end;c(500)end;assert(p,o)end;assert(o~=0,"ERROR: sockconnect(): invalid arguments or connection failure")local self={sock=m,chan=o,pid=vim.fn.jobpid(n)}function self:req(...)return vim.rpcrequest(self.chan,...)end;function self:suspend()assert(self:req("nvim_input","<C-Z>")>0)end;function self:cont()a.kill(self.pid,"SIGCONT")end;function self:stop()vim.fn.jobstop(n)end;assert(self:req("nvim_eval","v:vim_did_enter")==1,"ERROR: vim has not entered yet")return self end;function a.with_nvim(k,r)if r==nil then r=k;k=nil end;local s=a.start_nvim(k)r(s)s:stop()end;return a
