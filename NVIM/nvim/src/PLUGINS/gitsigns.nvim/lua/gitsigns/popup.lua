local a={HlMark={}}local b=a.HlMark;local c=vim.api;local function d(e,f)return c.nvim_buf_call(e,function()local g=0;for h,i in ipairs(f)do if vim.fn.type(i)==vim.v.t_string then local j=vim.fn.strdisplaywidth(i)if j>g then g=j end end end;return g+1 end)end;local function k(l,m)local n=0;for h=0,50 do local o=c.nvim_win_get_height(l)if n>o then break end;local p=c.nvim_win_call(l,function()return vim.fn.line('w$')end)if p>=m then break end;n=o+m-p;c.nvim_win_set_height(l,n)end end;local function q(r,s)for h,t in ipairs(r)do if t.start_row then t.start_row=t.start_row+s end;if t.end_row then t.end_row=t.end_row+s end end end;local function u(v)local f={}local w={}local x=0;for h,y in ipairs(v)do local z={}local A=0;for h,B in ipairs(y)do local C=B[1]local D=B[2]z[#z+1]=C;local E=x;local F=A;local G=vim.split(C,'\n')if#G>1 then A=0;x=x+#G-1 else A=A+#C end;if type(D)=="string"then w[#w+1]={hl_group=D,start_row=E,end_row=x,start_col=F,end_col=A}else q(D,E)vim.list_extend(w,D)end end;for h,i in ipairs(vim.split(table.concat(z,''),'\n'))do f[#f+1]=i end;x=x+1 end;return f,w end;local function H(I)for h,l in ipairs(c.nvim_list_wins())do if vim.w[l].gitsigns_preview~=nil and vim.w[l].gitsigns_preview~=I then pcall(c.nvim_win_close,l,true)end end end;function a.create0(f,J,I)H(I)local G=vim.bo.tabstop;local e=c.nvim_create_buf(false,true)assert(e,"Failed to create buffer")vim.bo[e].modifiable=true;c.nvim_buf_set_lines(e,0,-1,true,f)vim.bo[e].modifiable=false;vim.bo[e].tabstop=G;local K=vim.deepcopy(J or{})K.height=K.height or#f;K.width=K.width or d(e,f)local l=c.nvim_open_win(e,false,K)vim.w[l].gitsigns_preview=I or true;if not J.height then k(l,#f)end;if K.style=='minimal'then vim.wo[l].signcolumn='no'end;local L='gitsigns_popup'c.nvim_create_augroup(L,{})local M=c.nvim_win_get_cursor(0)c.nvim_create_autocmd({'CursorMoved','CursorMovedI'},{group=L,callback=function()local N=c.nvim_win_get_cursor(0)if(M[1]~=N[1]or M[2]~=N[2])and c.nvim_get_current_win()~=l then c.nvim_create_augroup(L,{})pcall(c.nvim_win_close,l,true)return end;M=N end})return l,e end;local O=c.nvim_create_namespace('gitsigns_popup')function a.create(P,J,I)local f,Q=u(P)local l,e=a.create0(f,J,I)for h,D in ipairs(Q)do local R,S=pcall(c.nvim_buf_set_extmark,e,O,D.start_row,D.start_col or 0,{hl_group=D.hl_group,end_row=D.end_row,end_col=D.end_col,hl_eol=true})if not R then error(vim.inspect(D)..'\n'..S)end end;return l,e end;function a.is_open(I)for h,l in ipairs(c.nvim_list_wins())do if vim.w[l].gitsigns_preview==I then return l end end;return nil end;function a.focus_open(I)local l=a.is_open(I)if l then c.nvim_set_current_win(l)end;return l end;return a
