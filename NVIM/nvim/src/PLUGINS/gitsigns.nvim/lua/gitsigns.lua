local a=require('gitsigns.async')local b=require('gitsigns.async').void;local c=require('gitsigns.async').scheduler;local d=require("gitsigns.status")local e=require('gitsigns.git')local f=require('gitsigns.manager')local g=require('gitsigns.util')local h=require('gitsigns.highlight')local i=require('gitsigns.cache')local j=i.cache;local k=i.CacheEntry;local l=require('gitsigns.config')local m=l.Config;local n=l.config;local o=require("gitsigns.debug")local p=o.dprintf;local q=o.dprint;local r=require("gitsigns.debounce")local s=r.debounce_trailing;local t=r.throttle_by_id;local u=vim.api;local v=vim.loop;local w=u.nvim_get_current_buf;local x={}x.detach_all=function()for y,z in pairs(j)do x.detach(y)end end;x.detach=function(A,B)A=A or w()q('Detached')local C=j[A]if not C then q('Cache was nil')return end;f.detach(A,B)d:clear(A)j:destroy(A)end;local function D(E)local z,z,F,G,H,I=E:find([[^fugitive://(.*)/%.git(.*/)/(%x-)/(.*)]])if H=='0'then H=nil end;if F then G=G:gsub("^/modules","")E=F..G..I end;return E,H end;local function J(E)local z,z,F,H,K=E:find([[^gitsigns://(.*)/%.git/(.*):(.*)]])if H==':0'then H=nil end;if F then E=F..'/'..K end;return E,H end;local function L(A)local M=v.fs_realpath(u.nvim_buf_get_name(A))or u.nvim_buf_call(A,function()return vim.fn.expand('%:p')end)if not vim.wo.diff then if vim.startswith(M,'fugitive://')then local N,H=D(M)p("Fugitive buffer for file '%s' from path '%s'",N,M)N=v.fs_realpath(N)if N then return N,H end end;if vim.startswith(M,'gitsigns://')then local N,H=J(M)p("Gitsigns buffer for file '%s' from path '%s'",N,M)N=v.fs_realpath(N)if N then return N,H end end end;return M end;local O=false;local function P(z,A,z,Q,R,S,T)if Q==R and R==S and T==0 then return end;return f.on_lines(A,Q,R,S)end;local function U(z,A)local V='on_reload'q('Reload')f.update_debounced(A)end;local function W(z,A)x.detach(A,true)end;local function X(A)local Y,Z;if n._on_attach_pre then local _=a.wrap(n._on_attach_pre,2)(A)p('ran on_attach_pre with result %s',vim.inspect(_))if type(_)=="table"then if type(_.gitdir)=='string'then Y=_.gitdir end;if type(_.toplevel)=='string'then Z=_.toplevel end end end;return Y,Z end;local function a0(a1,M,a2)if not n.worktrees then return end;for z,a3 in ipairs(n.worktrees)do local a4=e.Obj.new(M,a2,a3.gitdir,a3.toplevel)if a4 and a4.object_name then p('Using worktree %s',vim.inspect(a3))return a4 end end end;local a5=t(function(a6,a7)local V='attach'if O then q('attaching is disabled')return end;if j[a6]then q('Already attached')return end;if a7 then p('Attaching (trigger=%s)',a7)else q('Attaching')end;if not u.nvim_buf_is_loaded(a6)then q('Non-loaded buffer')return end;if u.nvim_buf_line_count(a6)>n.max_file_length then q('Exceeds max_file_length')return end;if vim.bo[a6].buftype~=''then q('Non-normal buffer')return end;local M,H=L(a6)local a2=vim.bo[a6].fileencoding;local a8=g.dirname(M)if not a8 or not g.path_exists(a8)then q('Not a path')return end;local a9,aa=X(a6)local a4=e.Obj.new(M,a2,a9,aa)if not a4 then a4=a0(a6,M,a2)c()end;if not a4 then q('Empty git obj')return end;local ab=a4.repo;c()d:update(a6,{head=ab.abbrev_head,root=ab.toplevel,gitdir=ab.gitdir})if vim.startswith(M,ab.gitdir..g.path_sep)then q('In non-standard git dir')return end;if not g.path_exists(M)or v.fs_stat(M).type=='directory'then q('Not a file')return end;if not a4.relpath then q('Cannot resolve file in repo')return end;if not n.attach_to_untracked and a4.object_name==nil then q('File is untracked')return end;c()if n.on_attach and n.on_attach(a6)==false then q('User on_attach() returned false')return end;j[a6]=k.new({base=n.base,file=M,commit=H,gitdir_watcher=f.watch_gitdir(a6,ab.gitdir),git_obj=a4})if not u.nvim_buf_is_loaded(a6)then q('Un-loaded buffer')return end;u.nvim_buf_attach(a6,false,{on_lines=P,on_reload=U,on_detach=W})f.update(a6,j[a6])if n.keymaps and not vim.tbl_isempty(n.keymaps)then require('gitsigns.mappings')(n.keymaps,a6)end end)x.attach=b(function(A,ac)a5(A or w(),ac)end)local ad=x;local function ae(af,ag)local ah=vim.split(ag,'%s+')local ai=#ah;local aj=require('gitsigns.actions')local ak={}if ai==2 then for z,al in ipairs({aj,ad})do for am,z in pairs(al)do if not am:match('^[a-z]')then elseif vim.startswith(am,af)then table.insert(ak,am)end end end elseif ai>2 then local an=aj._get_cmp_func(ah[2])if an then return an(af)end end;return ak end;local function ao(ap)if tonumber(ap)then return tonumber(ap)elseif ap=='false'or ap=='true'then return ap=='true'elseif ap=='nil'then return nil end;return ap end;local aq=b(function(ar)local as,at=require('gitsigns.argparse').parse_args(ar.args)local am=as[1]if not am then am=a.wrap(vim.ui.select,3)(ae('','Gitsigns '),{})end;local au=vim.tbl_map(ao,vim.list_slice(as,2))local av=vim.tbl_map(ao,at)local aw=vim.tbl_extend('error',au,av)local aj=require('gitsigns.actions')local ax=aj;p("Running action '%s' with arguments %s",am,vim.inspect(aw,{newline=' ',indent=''}))local ay=aj._get_cmd_func(am)if ay then ay(aw,ar)return end;if type(ax[am])=='function'then ax[am](unpack(au),av)return end;if type(ad[am])=='function'then ad[am](unpack(au))return end;error(string.format('%s is not a valid function or action',am))end)local function az()u.nvim_create_user_command('Gitsigns',aq,{force=true,nargs='*',range=true,complete=ae})end;local function aA(aB,...)local aw={...}local aC=select('#',...)return function()aB(unpack(aw,1,aC))end end;local function aD(aE,aF)local aG={}if type(aF)=="function"then aG.callback=aA(aF)else aG=aF end;aG.group='gitsigns'u.nvim_create_autocmd(aE,aG)end;local function aH(aB)if vim.v.vim_did_enter==1 then aB()else u.nvim_create_autocmd('VimEnter',{callback=aA(aB),once=true})end end;x.setup=b(function(aI)l.build(aI)if vim.fn.executable('git')==0 then print('gitsigns: git not in path. Aborting setup')return end;if n.yadm.enable and vim.fn.executable('yadm')==0 then print("gitsigns: yadm not in path. Ignoring 'yadm.enable' in config")n.yadm.enable=false;return end;o.debug_mode=n.debug_mode;o.verbose=n._verbose;if n.debug_mode then for aJ,aK in pairs(o.add_debug_functions(j))do ad[aJ]=aK end end;f.setup()d.formatter=n.status_formatter;aH(h.setup_highlights)az()e.enable_yadm=n.yadm.enable;e.set_version(n._git_version)c()for z,aL in ipairs(u.nvim_list_bufs())do if u.nvim_buf_is_loaded(aL)and u.nvim_buf_get_name(aL)~=''then x.attach(aL,'setup')c()end end;u.nvim_create_augroup('gitsigns',{})aD('VimLeavePre',x.detach_all)aD('ColorScheme',h.setup_highlights)aD('BufRead',aA(x.attach,nil,'BufRead'))aD('BufNewFile',aA(x.attach,nil,'BufNewFile'))aD('BufWritePost',aA(x.attach,nil,'BufWritePost'))aD('OptionSet',{pattern='fileformat',callback=function()require('gitsigns.actions').refresh()end})aD('QuickFixCmdPre',{pattern='*vimgrep*',callback=function()O=true end})aD('QuickFixCmdPost',{pattern='*vimgrep*',callback=function()O=false end})require('gitsigns.current_line_blame').setup()c()f.update_cwd_head()aD('DirChanged',s(100,f.update_cwd_head))end)if _TEST then x.parse_fugitive_uri=D end;return setmetatable(x,{__index=function(z,aK)return require('gitsigns.actions')[aK]end})
