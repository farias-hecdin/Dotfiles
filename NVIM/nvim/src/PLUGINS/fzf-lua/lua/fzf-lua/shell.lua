local a=vim.loop;local b=require"fzf-lua.path"local c=require"fzf-lua.libuv"local d={}local e=5;local f=0;local g={}function d.register_func(h)f=f%e+1;g[f]=h;return f end;function d.get_func(i)return g[i]end;function d.free_registry()f=0;g={}end;function d.raw_async_action(h,j,k)if not j then j="{+}"end;local l=function(m,...)local n=a.new_pipe(false)local o={...}pcall(function()local p=loadstring("return require'fzf-lua'")()if p then p.__INFO=vim.tbl_deep_extend("force",p.__INFO or{},{selected=o[1][1]})end end)a.pipe_connect(n,m,function(q)if q then error(string.format("pipe_connect(%s) failed with error: %s",m,q))else vim.schedule(function()h(n,unpack(o))end)end end)end;local i=d.register_func(l)local r=os.getenv("FZF_LUA_NVIM_BIN")or vim.v.progpath;local s=("fzf_lua_server=[[%s]], fnc_id=%d %s"):format(vim.g.fzf_lua_server,i,k and", debug=true"or"")local t=("%s -n --headless --clean --cmd %s -- %s"):format(c.shellescape(r),c.shellescape(("lua loadfile([[%s]])().rpc_nvim_exec_lua({%s})"):format(b.join{vim.g.fzf_lua_directory,"shell_helper.lua"},s)),j)return t,i end;function d.async_action(h,j,k)local u,i=d.raw_async_action(h,j,k)return vim.fn.shellescape(u),i end;function d.raw_action(h,j,k)local l=function(n,...)local v=h(...)local w=function(x)a.close(n)end;if type(v)=="string"then a.write(n,v,w)elseif type(v)==nil then w()elseif type(v)=="table"then if not vim.tbl_isempty(v)then a.write(n,vim.tbl_map(function(y)return y.."\n"end,v),w)else w()end else a.write(n,tostring(v).."\n",w)end end;return d.raw_async_action(l,j,k)end;function d.action(h,j,k)local u,i=d.raw_action(h,j,k)return vim.fn.shellescape(u),i end;d.preview_action_cmd=function(h,j,k)local u,i=d.raw_preview_action_cmd(h,j,k)return vim.fn.shellescape(u),i end;d.raw_preview_action_cmd=function(h,j,k)return d.raw_async_action(function(n,...)local function z(x,x)if n and not a.is_closing(n)then a.close(n)n=nil end end;local function A(B,C)if not n then C(true)else a.write(n,B,C)end end;c.process_kill(d.__pid_preview)d.__pid_preview=nil;return c.spawn({cmd=h(...),cb_finish=z,cb_write=A,cb_pid=function(D)d.__pid_preview=D end},false)end,j,k)end;d.reload_action_cmd=function(E,j)if E.fn_preprocess and type(E.fn_preprocess)=="function"then E=vim.tbl_deep_extend("keep",E,E.fn_preprocess(E))end;return d.raw_async_action(function(n,o)local F=E.__fn_reload(o[1])local G=0;local H=false;local z=function(x,x,x,x)if not n then return end;H=true;if G==0 then a.close(n)n=nil end end;local A=function(B,C,I)assert(not I or I and n and not a.is_closing(n))if not n then return end;if not B then z(nil,nil,5)if C then C(nil)end else G=G+1;a.write(n,tostring(B),function(q)G=G-1;if I then coroutine.resume(I)end;if C then C(q)end;if q then G=0;z(nil,nil,2)end;if G==0 and H then z(nil,nil,3)end end)if I and coroutine.yield()==1 then G=0;z(nil,nil,4)end end end;if type(F)=="string"then c.process_kill(d.__pid_reload)d.__pid_reload=nil;c.async_spawn({cwd=E.cwd,cmd=F,cb_finish=z,cb_write=A,cb_pid=function(D)d.__pid_reload=D end},E.__fn_transform or false)else coroutine.wrap(function()if E.__co then local J=coroutine.status(E.__co)if J~="dead"then coroutine.resume(E.__co,1)end;assert(coroutine.status(E.__co)=="dead")end;E.__co=coroutine.running()local K=function(B,C)B=B and tostring(B).."\n"or nil;return A(B,C)end;local L=function(B,C)B=B and tostring(B).."\n"or nil;return A(B,C,E.__co)end;local M=function(B,C)return A(B,C,E.__co)end;if type(F)=="table"then for x,N in ipairs(F)do L(N)end;z()elseif type(F)=="function"then if E.func_async_callback~=false then F(L,M)else F(K,A)end else end end)()end end,j,E.debug)end;return d
