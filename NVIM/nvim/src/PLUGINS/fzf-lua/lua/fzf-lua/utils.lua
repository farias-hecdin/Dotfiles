function _G.dump(...)local a=vim.tbl_map(vim.inspect,{...})print(unpack(a))end;local b={}function b.__FILE__()return debug.getinfo(2,"S").source end;function b.__LINE__()return debug.getinfo(2,"l").currentline end;function b.__FNC__()return debug.getinfo(2,"n").name end;function b.__FNCREF__()return debug.getinfo(2,"f").func end;b.nbsp="\xe2\x80\x82"if _VERSION and type(_VERSION)=="string"then local c=tonumber(_VERSION:match("%d+.%d+"))if c<5.2 then b.nbsp=b.nbsp:gsub("\\x(%x%x)",function(d)return string.char(tonumber(d,16))end)end end;b._if=function(e,f,g)if e then return f else return g end end;b.strsplit=function(h,i)local j={}for k in string.gmatch(h,"([^"..i.."]+)")do table.insert(j,k)end;return j end;local l=string.byte;b.find_last_char=function(k,m)for n=#k,1,-1 do if l(k,n)==m then return n end end end;b.find_next_char=function(k,m,o)for n=o or 1,#k do if l(k,n)==m then return n end end end;function b.round(p,q)if not p then return nil end;if not q then q=0.5 end;local r=p-math.floor(p)if r>q then return math.ceil(p)end;return math.floor(p)end;function b.nvim_has_option(s)return vim.fn.exists("&"..s)==1 end;function b._echo_multiline(t,u)vim.cmd("echohl "..u)for _,v in ipairs(vim.fn.split(t,"\n"))do vim.cmd("echom '"..v:gsub("'","''").."'")end;vim.cmd("echohl None")end;local w=function(t,u)if vim.in_fast_event()then vim.schedule(function()b._echo_multiline("[Fzf-lua] "..t,u)end)else b._echo_multiline("[Fzf-lua] "..t,u)end end;function b.info(t)w(t,"Directory")end;function b.warn(t)w(t,"WarningMsg")end;function b.err(t)w(t,"ErrorMsg")end;function b.shell_error()return vim.v.shell_error~=0 end;function b.is_darwin()return vim.loop.os_uname().sysname=="Darwin"end;function b.rg_escape(k)if not k then return k end;return k:gsub("[\\~$?*|{\\[()^%-%.%+]",function(d)return"\\"..d end)end;function b.sk_escape(k)if not k then return k end;return k:gsub('["`]',function(d)return"\\"..d end):gsub([[\\]],[[\\\\]]):gsub([[\%$]],[[\\\$]])end;function b.lua_escape(k)if not k then return k end;return k:gsub("[%%]",function(d)return"%"..d end)end;function b.lua_regex_escape(k)if not k then return nil end;return k:gsub("[%(%)%.%+%-%*%[%?%^%$%%]",function(d)return"%"..d end)end;function b.glob_escape(k)if not k then return k end;return k:gsub("[\\%{}]",function(d)return[[\]]..d end)end;function b.pcall_expand(x)local y,z=pcall(vim.fn.expand,x:gsub("%-","\\-"))if y and z and#z>0 then return z else return x end end;b.file_is_binary=function(x)x=b.pcall_expand(x)if vim.fn.executable("file")~=1 or not vim.loop.fs_stat(x)then return false end;local A=b.io_system({"file","--dereference","--mime",x})return A:match("charset=binary")~=nil end;b.perl_file_is_binary=function(x)x=b.pcall_expand(x)if vim.fn.executable("perl")~=1 or not vim.loop.fs_stat(x)then return false end;b.io_system({"perl","-E","exit((-B $ARGV[0])?0:1);",x})return not b.shell_error()end;b.read_file=function(x)local B=vim.loop.fs_open(x,"r",438)if B==nil then return""end;local C=assert(vim.loop.fs_fstat(B))if C.type~="file"then return""end;local D=assert(vim.loop.fs_read(B,C.size,0))assert(vim.loop.fs_close(B))return D end;b.read_file_async=function(x,E)vim.loop.fs_open(x,"r",438,function(F,B)if F then vim.schedule(function()b.warn(("Unable to open file '%s', error: %s"):format(x,F))end)return end;vim.loop.fs_fstat(B,function(G,C)assert(not G,G)if C.type~="file"then return E("")end;vim.loop.fs_read(B,C.size,0,function(H,D)assert(not H,H)vim.loop.fs_close(B,function(I)assert(not I,I)return E(D)end)end)end)end)end;function b.deepcopy(j)local y,J=pcall(vim.deepcopy,j)if y then return J else return b.tbl_deep_clone(j)end end;function b.tbl_deep_clone(j)if not j then return end;local K={}for L,M in pairs(j)do if type(M)=="table"then K[L]=b.tbl_deep_clone(M)else K[L]=M end end;return K end;function b.tbl_length(N)local O=0;for _ in pairs(N)do O=O+1 end;return O end;function b.tbl_isempty(N)if not N or not next(N)then return true end;return false end;function b.tbl_concat(...)local P={}local Q=0;for _,j in ipairs({...})do for n,M in ipairs(j)do P[Q+n]=M end;Q=Q+#j end;return P end;function b.tbl_extend(R,S)return table.move(S,1,#S,#R+1,R)end;function b.tbl_pack(...)return{n=select("#",...),...}end;function b.tbl_unpack(j,n,T)return unpack(j,n or 1,T or j.n or#j)end;function b.map_tolower(U)if not U then return end;local V={}for L,M in pairs(U)do V[L:lower()]=M end;return V end;b.ansi_codes={}b.ansi_colors={clear="[0m",bold="[1m",italic="[3m",underline="[4m",black="[0;30m",red="[0;31m",green="[0;32m",yellow="[0;33m",blue="[0;34m",magenta="[0;35m",cyan="[0;36m",white="[0;37m",grey="[0;90m",dark_grey="[0;97m"}b.add_ansi_code=function(W,X)b.ansi_codes[W]=function(string)if string==nil or#string==0 then return""end;return X..string..b.ansi_colors.clear end end;for Y,X in pairs(b.ansi_colors)do b.add_ansi_code(Y,X)end;local function Z(a0)local a1,a2,g=a0:match("#(..)(..)(..)")if not a1 or not a2 or not g then return end;a1,a2,g=tonumber(a1,16),tonumber(a2,16),tonumber(g,16)return a1,a2,g end;local function a3(u,a4)return vim.fn.synIDattr(vim.fn.synIDtrans(vim.fn.hlID(u)),a4)end;function b.is_hl_cleared(u)if vim.api.nvim_get_hl then local y,a5=pcall(vim.api.nvim_get_hl,0,{name=u,link=false})if not y or vim.tbl_isempty(a5)then return true end else local y,a5=pcall(vim.api.nvim_get_hl_by_name,u,true)if not y or a5[true]then return true end end end;function b.ansi_from_hl(u,v,a6)if vim.fn.hlexists(u)==1 then local a7={["fg"]={rgb=true,code=38},["bg"]={rgb=true,code=48},["bold"]={code=1},["italic"]={code=3},["underline"]={code=4},["inverse"]={code=7},["reverse"]={code=7},["strikethrough"]={code=9}}for a4,a8 in pairs(a7)do local X=nil;if a8.rgb then local a0=a3(u,a4)if a0 and not a0:match("^#")and a6 then local a9=a6[a0:sub(1,1):upper()..a0:sub(2)]if a9 then a0=("#%06x"):format(a9)end end;local a1,a2,g=Z(a0)if a1 and a2 and g then X=("[%d;2;%d;%d;%dm"):format(a8.code,a1,a2,g)end else local aa=a3(u,a4)if aa and tonumber(aa)==1 then X=("[%dm"):format(a8.code)end end;if X then v=("%s%s%s"):format(X,v,b.ansi_colors.clear)end end end;return v end;function b.strip_ansi_coloring(k)if not k then return k end;return k:gsub("%[[%d;]-m","")end;function b.get_visual_selection()local _,ab,ac,ad,ae;local af=vim.fn.mode()if af=="v"or af=="V"or af==""then _,ab,ac,_=unpack(vim.fn.getpos("."))_,ad,ae,_=unpack(vim.fn.getpos("v"))if af=="V"then ac,ae=0,999 end;vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>",true,false,true),"n",true)else _,ab,ac,_=unpack(vim.fn.getpos("'<"))_,ad,ae,_=unpack(vim.fn.getpos("'>"))end;if ad<ab then ab,ad=ad,ab end;if ae<ac then ac,ae=ae,ac end;local ag=vim.fn.getline(ab,ad)local Q=b.tbl_length(ag)if Q<=0 then return""end;ag[Q]=string.sub(ag[Q],1,ae)ag[1]=string.sub(ag[1],ac)return table.concat(ag,"\n")end;function b.fzf_exit()vim.cmd([[lua require('fzf-lua.win').win_leave()]])end;function b.fzf_winobj()return loadstring("return require'fzf-lua'.win.__SELF()")()end;function b.reset_info()pcall(loadstring("require'fzf-lua'.set_info(nil)"))end;function b.load_profile(ah,W,ai)local aj=W or ah:match("([^%p]+)%.lua$")or"<unknown>"local y,J=pcall(dofile,ah)if y and type(J)=="table"then if not ai then b.info(string.format("Succefully loaded profile '%s'",aj))end;return J elseif ai then return end;if not y then b.warn(string.format("Unable to load profile '%s': %s",aj,J:match("[^\n]+")))elseif type(J)~="table"then b.warn(string.format("Unable to load profile '%s': wrong type %s",aj,type(J)))end end;function b.send_ctrl_c()vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<C-c>",true,false,true),"n",true)end;function b.feed_keys_termcodes(ak)vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(ak,true,false,true),"n",true)end;function b.is_term_bufname(al)if al and al:match("term://")then return true end;return false end;function b.is_term_buffer(am)am=tonumber(am)or 0;am=am==0 and vim.api.nvim_get_current_buf()or am;local an=vim.fn.bufwinid(am)if tonumber(an)>0 and vim.api.nvim_win_is_valid(an)then return vim.fn.getwininfo(an)[1].terminal==1 end;local al=vim.api.nvim_buf_is_valid(am)and vim.api.nvim_buf_get_name(am)return b.is_term_bufname(al)end;function b.buffer_is_dirty(am,ao,ap)am=tonumber(am)or vim.api.nvim_get_current_buf()local aq=am and vim.fn.getbufinfo(am)[1]if aq and aq.changed~=0 then if ap and 1<b.tbl_length(vim.fn.win_findbuf(am))then return false end;if ao then b.warn(("buffer %d:%s has unsaved changes"):format(am,aq.name and#aq.name>0 and aq.name or"<unnamed>"))end;return true end;return false end;function b.save_dialog(am)am=tonumber(am)or vim.api.nvim_get_current_buf()local aq=am and vim.fn.getbufinfo(am)[1]if not aq.name or#aq.name==0 then b.warn(string.format("buffer %d has unsaved changes",am))return false end;local J=vim.fn.confirm(string.format([[Save changes to "%s"?]],aq.name),"&Yes\n&No\n&Cancel")if J==3 then return false end;if J==1 then local A=vim.api.nvim_cmd({cmd="update"},{output=true})b.info(A)end;return true end;function b.win_is_qf(an,ar)ar=ar or vim.api.nvim_win_is_valid(an)and vim.fn.getwininfo(an)[1]if ar and ar.quickfix==1 then return ar.loclist==1 and 2 or 1 end;return false end;function b.buf_is_qf(am,as)as=as or vim.api.nvim_buf_is_valid(am)and vim.fn.getbufinfo(am)[1]if as and as.variables and as.variables.current_syntax=="qf"and not vim.tbl_isempty(as.windows)then return b.win_is_qf(as.windows[1])end;return false end;function b.winid_from_tabh(at,am)for _,a4 in ipairs(vim.api.nvim_tabpage_list_wins(at))do if am==vim.api.nvim_win_get_buf(a4)then return a4 end end;return nil end;function b.winid_from_tabi(au,am)local at=vim.api.nvim_list_tabpages()[au]return b.winid_from_tabh(at,am)end;function b.nvim_buf_get_name(am,as)if not vim.api.nvim_buf_is_valid(am)then return end;if as and as.name and#as.name>0 then return as.name end;local al=vim.api.nvim_buf_get_name(am)if not al or#al==0 then local av=b.buf_is_qf(am,as)if av then al=av==1 and"[Quickfix List]"or"[Location List]"else al="[No Name]"end end;assert(#al>0)return al end;function b.zz()if b.is_term_buffer()then return end;local aw=vim.api.nvim_win_get_cursor(0)[1]local ax=vim.api.nvim_buf_line_count(0)local ay="keepj norm! %dzb"if aw==ax then vim.fn.execute(ay:format(aw))return end;vim.cmd("norm! zvzz")aw=vim.api.nvim_win_get_cursor(0)[1]vim.cmd("norm! L")local az=vim.api.nvim_win_get_cursor(0)[1]if az+vim.fn.getwinvar(0,"&scrolloff")>=ax then vim.fn.execute(ay:format(az))end;if aw~=az then vim.cmd("keepj norm! ``")end end;function b.win_set_buf_noautocmd(aA,aB)local aC=vim.o.eventignore;vim.o.eventignore="all"vim.api.nvim_win_set_buf(aA,aB)vim.o.eventignore=aC end;function b.nvim_win_close(aA,aD)local aC=vim.o.eventignore;vim.o.eventignore="all"vim.api.nvim_win_close(aA,aD)vim.o.eventignore=aC end;function b.nvim_win_call(an,aE)vim.validate({winid={an,function(a4)return a4 and vim.api.nvim_win_is_valid(a4)end,"a valid window"},func={aE,"function"}})local aF=vim.api.nvim_get_current_win()local aG="noa call nvim_set_current_win(%d)"if aF~=an then vim.cmd(aG:format(an))end;local V=aE()if aF~=an then vim.cmd(aG:format(aF))end;return V end;function b.keymap_set(af,aH,aI,aD)if vim.keymap then vim.keymap.set(af,aH,aI,aD)else assert(type(af)=="string"and type(aI)=="string")aD=aD or{}aD.noremap=not aD.remap;if aD.buffer then local am=type(aD.buffer)=="number"and aD.buffer or 0;aD.buffer=nil;vim.api.nvim_buf_set_keymap(am,af,aH,aI,aD)else vim.api.nvim_set_keymap(af,aH,aI,aD)end end end;function b.ft_detect(aJ)local aK=""if not aJ then return aK end;local aL=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_option(aL,"bufhidden","wipe")pcall(vim.api.nvim_buf_call,aL,function()local aM=vim.fn.tempname().."."..aJ;vim.cmd("file "..aM)vim.cmd("doautocmd BufEnter")vim.cmd("filetype detect")aK=vim.api.nvim_buf_get_option(aL,"filetype")end)if vim.api.nvim_buf_is_valid(aL)then vim.api.nvim_buf_delete(aL,{force=true})end;return aK end;local aN=false;function b.set_lua_io(g)aN=g;if aN then b.warn("using experimental feature 'lua_io'")end end;function b.io_systemlist(aO,aP)if not aP then aP=aN end;if aP and aO=="string"then local aQ=0;local aR=""local aS=io.popen(aO.." 2>&1; echo $?","r")if aS then aR={}for aT in aS:lines()do aR[#aR+1]=aT end;aQ=tonumber(aR[#aR])aR[#aR]=nil;aS:close()end;return aR,aQ else return vim.fn.systemlist(aO),vim.v.shell_error end end;function b.io_system(aO,aP)if not aP then aP=aN end;if aP then local aR,aQ=b.io_systemlist(aO,true)if type(aR)=="table"then aR=table.concat(aR,"\n")end;return aR,aQ else return vim.fn.system(aO),vim.v.shell_error end end;function b.input(aU)local y,J;if false then y,_=pcall(vim.ui.input,{prompt=aU},function(aV)J=aV end)else y,J=pcall(vim.fn.input,{prompt=aU,cancelreturn=3})if J==3 then y,J=false,nil end end;return y and J or nil end;function b.fzf_bind_to_neovim(ak)local aW={["alt"]="A",["ctrl"]="C",["shift"]="S"}ak=ak:lower()for L,M in pairs(aW)do ak=ak:gsub(L,M)end;return("<%s>"):format(ak)end;function b.neovim_bind_to_fzf(ak)local aW={["a"]="alt",["c"]="ctrl",["s"]="shift"}ak=ak:lower():gsub("[<>]","")for L,M in pairs(aW)do ak=ak:gsub(L.."%-",M.."-")end;return ak end;function b.git_version()local A=b.io_system({"git","--version"})return tonumber(A:match("(%d+.%d+)."))end;function b.find_version()local A,aQ=b.io_systemlist({"find","--version"})return aQ==0 and tonumber(A[1]:match("(%d+.%d+)"))or nil end;return b
