local a=require"fzf-lua.fzf"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.config"local e=require"fzf-lua.actions"local f=require"fzf-lua.win"local g=require"fzf-lua.libuv"local h=require"fzf-lua.shell"local i=require"fzf-lua.make_entry"local j={}local k={[e.grep_lgrep]={fn_reload="Fuzzy Search","Regex Search"},[e.sym_lsym]={fn_reload="Fuzzy Search","Live Query"},[e.buf_del]={fn_reload="close","close"}}local l=function(m)assert(m[1].contents)local n=type(m[1].contents)local o;if n=="table"then o={}for p,q in ipairs(m)do assert(type(q.contents)==n,"Unable to combine contents of different types")o=c.tbl_extend(o,q.prefix and vim.tbl_map(function(r)return q.prefix..r end,q.contents)or q.contents)end elseif n=="function"then o=function(s)coroutine.wrap(function()local t=coroutine.running()for p,q in ipairs(m)do assert(type(q.contents)==n,"Unable to combine contents of different types")local u=true;q.contents(function(v,w)u=t~=coroutine.running()if v then s(q.prefix and q.prefix..v or v,w)elseif u then coroutine.resume(t)end end)if u then coroutine.yield()end end;s()end)()end elseif n=="string"then assert(false,"Not yet supported")end;return o end;j.fzf_exec=function(o,x)if type(o)=="table"and type(o[1])=="table"then o=l(o)end;if not x or not x._normalized then x=d.normalize_opts(x or{},{})if not x then return end end;x.fn_selected=x.fn_selected or function(y)if not y then return end;e.act(x.actions,y,x)end;if type(o)=="string"and(x.fn_transform or x.fn_preprocess)then o=g.spawn_nvim_fzf_cmd({cmd=o,cwd=x.cwd,cb_pid=x._set_pid},x.fn_transform or function(r)return r end,x.fn_preprocess)end;if type(x.fn_reload)=="string"then if not x.fn_transform then x=j.setup_fzf_interactive_native(x.fn_reload,x)o=x.__fzf_init_cmd else local z=x.fn_reload;x.fn_reload=function(A)if z:match(j.fzf_query_placeholder)then return z:gsub(j.fzf_query_placeholder,A or"")else return string.format("%s %s",z,A or"")end end end end;if type(x.fn_reload)=="function"then x.__fn_transform=x.fn_transform;x.__fn_reload=function(B)if d.__resume_data then d.__resume_data.last_query=B end;return x.fn_reload(B)end;x=j.setup_fzf_interactive_wrap(x)o=x.__fzf_init_cmd end;return j.fzf_wrap(x,o)()end;j.fzf_live=function(o,x)assert(o)x=x or{}x.fn_reload=o;return j.fzf_exec(nil,x)end;j.fzf_resume=function(x)if not d.__resume_data or not d.__resume_data.opts then c.info("No resume data available, is 'global_resume' enabled?")return end;x=vim.tbl_deep_extend("force",d.__resume_data.opts,x or{})local C=d.__resume_data.last_query;if not C or#C==0 then C=false end;x.__resume=true;x.query=C;j.fzf_exec(d.__resume_data.contents,x)end;j.fzf_wrap=function(x,o,D)x=x or{}return coroutine.wrap(function()x.fn_selected=x.fn_selected or D;local y=j.fzf(o,x)if x.fn_selected then x.fn_selected(y,x)end end)end;j.fzf=function(o,x)if not x or not x._normalized then x=d.normalize_opts(x or{},{})if not x then return end end;if x.fn_pre_win then x.fn_pre_win(x)end;if x.global_resume then d.__resume_data=d.__resume_data or{}d.__resume_data.opts=c.deepcopy(x)d.__resume_data.contents=o and c.deepcopy(o)or nil;if not x.__resume then d.__resume_data.last_query=nil end;x.__resume_data=d.__resume_data;x.fzf_opts["--print-query"]=""x.actions=x.actions or{}x.keymap=x.keymap or{}x.keymap.fzf=x.keymap.fzf or{}for p,E in ipairs({"ctrl-c","ctrl-q","esc"})do if x.actions[E]==nil and(x.keymap.fzf[E]==nil or x.keymap.fzf[E]=="abort")then x.actions[E]=e.dummy_abort end end end;local F=f(x)if not F then return end;local G,H=nil,nil;if x.previewer and type(x.previewer)=="string"then H=d.globals.previewers[x.previewer]if not H then c.warn(("invalid previewer '%s'"):format(x.previewer))end elseif x.previewer and type(x.previewer)=="table"then H=x.previewer end;if H and type(H.new)=="function"then G=H:new(H,x,F)elseif H and type(H._new)=="function"then G=H._new()(H,x,F)elseif H and type(H._ctor)=="function"then G=H._ctor()(H,x,F)end;if G then x.preview=G:cmdline()if type(G.preview_window)=="function"then x.fzf_opts["--preview-window"]=G:preview_window(x.preview_window)end;if type(G.fzf_delimiter)=="function"then x.fzf_opts["--delimiter"]=G:fzf_delimiter()end;if type(G.preview_offset)=="function"then x.preview_offset=G:preview_offset()end elseif not x.preview and not x.fzf_opts["--preview"]then x.fzf_opts["--preview-window"]="hidden:right:0"end;if x.__fn_pre_fzf then x.__fn_pre_fzf(x)end;if x._fn_pre_fzf then x._fn_pre_fzf(x)end;if x.fn_pre_fzf then x.fn_pre_fzf(x)end;F:attach_previewer(G)F:create()x.winopts.preview=F.winopts.preview;local y,I=a.raw_fzf(o,j.build_fzf_cli(x),{fzf_bin=x.fzf_bin,cwd=x.cwd,silent_fail=x.silent_fail,is_fzf_tmux=x._is_fzf_tmux})if type(x._get_pid=="function")then g.process_kill(x._get_pid())end;if y and#y>0 and x.fzf_opts["--print-query"]~=nil then if not(x._is_skim and x.fn_reload)then local B=y[1]d.__resume_data=d.__resume_data or{}d.__resume_data.last_query=type(B)=="string"and B or nil end;table.remove(y,1)end;if x.__fn_post_fzf then x.__fn_post_fzf(x,y)end;if x._fn_post_fzf then x._fn_post_fzf(x,y)end;if x.fn_post_fzf then x.fn_post_fzf(x,y)end;F:check_exit_status(I)local J=e.normalize_selected(x.actions,y)local K=J and x.actions and x.actions[J]if not F:autoclose()==false and type(K)~="table"then F:close()end;return y end;j.preview_window=function(L)local M=("%s:%s:%s:"):format(L.winopts.preview.hidden,L.winopts.preview.border,L.winopts.preview.wrap)if L.winopts.preview.layout=="horizontal"or L.winopts.preview.layout=="flex"and vim.o.columns>L.winopts.preview.flip_columns then M=M..L.winopts.preview.horizontal else M=M..L.winopts.preview.vertical end;return M end;j.get_color=function(N,O)return vim.fn.synIDattr(vim.fn.synIDtrans(vim.fn.hlID(N)),O)end;j.create_fzf_colors=function(x)local P=x and x.fzf_colors;if type(P)=="function"then P=P(x)end;if not P then return end;local Q={}for R,S in pairs(P)do if type(S)=="table"then local T=j.get_color(S[2],S[1])local U=T:match("#[%x]+")or T:match("^[0-9]+")if U then table.insert(Q,("%s:%s"):format(R,U))end;for V=3,#S do table.insert(Q,("%s:%s"):format(R,S[V]))end elseif type(S)=="string"then table.insert(Q,("%s:%s"):format(R,S))end end;return not vim.tbl_isempty(Q)and table.concat(Q,",")end;j.create_fzf_binds=function(W)if not W or vim.tbl_isempty(W)then return end;local Q={}local X={}for E,Y in pairs(W)do if Y then local Z,K=Y:match("(.*):(.*)")if K then E,Y=Z,K end;X[E]=Y end end;for Z,K in pairs(X)do table.insert(Q,string.format("%s:%s",Z,K))end;return vim.fn.shellescape(table.concat(Q,","))end;j.build_fzf_cli=function(x)x.fzf_opts=vim.tbl_extend("force",d.globals.fzf_opts,x.fzf_opts or{})for p,L in ipairs({"fzf_ansi","fzf_colors","fzf_layout","keymap"})do x[L]=x[L]or d.globals[L]end;for p,L in ipairs({"query","preview"})do local _=string.format("--%s",L)if x[L]~=nil then x.fzf_opts[_]=x[L]and vim.fn.shellescape(x[L])else x.fzf_opts[_]=x.fzf_opts[_]end end;x.fzf_opts["--bind"]=j.create_fzf_binds(x.keymap.fzf)if x.fzf_colors then x.fzf_opts["--color"]=j.create_fzf_colors(x)end;x.fzf_opts["--expect"]=e.expect(x.actions)if x.fzf_opts["--preview-window"]==nil then x.fzf_opts["--preview-window"]=j.preview_window(x)end;if x.preview_offset and#x.preview_offset>0 then x.fzf_opts["--preview-window"]=x.fzf_opts["--preview-window"]..":"..x.preview_offset end;x.fzf_opts["--prompt"]=(x.prompt or x.fzf_opts["--prompt"])and vim.fn.shellescape(x.prompt or x.fzf_opts["--prompt"])if x.nomulti or x.fzf_opts["--no-multi"]then x.fzf_opts["--multi"]=nil;x.fzf_opts["--no-multi"]=""else x.fzf_opts["--multi"]=""x.fzf_opts["--no-multi"]=nil end;for E,Y in pairs({["--ansi"]="fzf_ansi",["--layout"]="fzf_layout"})do if x[Y]and#x[Y]==0 then x.fzf_opts[E]=nil elseif x[Y]then x.fzf_opts[E]=x[Y]end end;local a0=""for p,L in ipairs({"fzf_args","fzf_raw_args","fzf_cli_args","_fzf_cli_args"})do if x[L]then a0=a0 .." "..x[L]end end;if x._is_skim then local a1=x.fzf_opts["--info"]x.fzf_opts["--info"]=nil;if a1=="inline"then x.fzf_opts["--inline-info"]=""end;local a2=x.fzf_opts["--border"]if a2=="none"then x.fzf_opts["--border"]=nil else x.fzf_opts["--border"]=""end end;local a3=""if x._is_fzf_tmux then for E,Y in pairs(x.fzf_tmux_opts or{})do if Y then a3=a3 ..string.format(" %s %s",E,Y)end end end;for E,Y in pairs(x.fzf_opts)do if type(Y)=="table"then Y=nil elseif type(Y)=="number"then Y=string.format("%d",Y)end;if Y then Y=Y:gsub(E.."=","")a3=a3 ..(" %s%s"):format(E,#Y>0 and"="..Y or"")end end;return a3 ..a0 end;j.mt_cmd_wrapper=function(x)assert(x and x.cmd)local a4=function(a5)return"[["..a5:gsub("[%]]",function(r)return"\\"..r end).."]]"end;local a6=function(L)local a7={"debug","argv_expr","cmd","cwd","stdout","stderr","stderr_to_stdout","git_dir","git_worktree","git_icons","file_icons","color_icons","path_shorten","strip_cwd_prefix","file_ignore_patterns","rg_glob","__module__"}if L.rg_glob then table.insert(a7,"glob_flag")table.insert(a7,"glob_separator")end;local a8=""for p,a9 in ipairs(a7)do if L[a9]~=nil then if#a8>0 then a8=a8 ..","end;local aa=L[a9]if type(aa)=="string"then aa=a4(aa)end;if type(aa)=="table"then aa=vim.inspect(aa)end;a8=a8 ..("%s=%s"):format(a9,aa)end end;return"{"..a8 .."}"end;if not x.requires_processing and not x.git_icons and not x.file_icons then return x.cmd elseif x.multiprocess then assert(not x.__mt_transform or type(x.__mt_transform)=="string")assert(not x.__mt_preprocess or type(x.__mt_preprocess)=="string")local ab=x.__mt_preprocess or[[return require("make_entry").preprocess]]local ac=x.__mt_transform or[[return require("make_entry").file]]if not x.no_remote_config then ac=([[_G._fzf_lua_server=%s; %s]]):format(g.shellescape(vim.g.fzf_lua_server),ac)end;if d._devicons_setup then ac=([[_G._devicons_setup=%s; %s]]):format(g.shellescape(d._devicons_setup),ac)end;if d._devicons_path then ac=([[_G._devicons_path=%s; %s]]):format(g.shellescape(d._devicons_path),ac)end;local z=g.wrap_spawn_stdio(a6(x),ac,ab)if x.debug_cmd or x.debug and not(x.debug_cmd==false)then print(z)end;return z else assert(not x.__mt_transform or type(x.__mt_transform)=="function")assert(not x.__mt_preprocess or type(x.__mt_preprocess)=="function")return g.spawn_nvim_fzf_cmd(x,function(r)return x.__mt_transform and x.__mt_transform(r,x)or i.file(r,x)end,function(L)return x.__mt_preprocess and x.__mt_preprocess(L)or i.preprocess(L)end)end end;j.set_fzf_field_index=function(x,ad,ae)x.line_field_index=x.line_field_index or ad or 2;x.field_index_expr=x.field_index_expr or ae or"{1}"return x end;j.set_header=function(x,af)local function ag(ah)if b.starts_with_separator(ah)and ah~=vim.loop.cwd()then ah=b.relative(ah,vim.loop.cwd())end;return b.HOME_to_tilde(ah)end;if not x then x={}end;if x.cwd_prompt or x.show_cwd_prompt then x.prompt=ag(x.cwd or vim.loop.cwd())if not b.ends_with_separator(x.prompt)then x.prompt=x.prompt..b.separator()end end;if x.no_header or x.headers==false then return x end;local ai={cwd={hdr_txt_opt="cwd_header",hdr_txt_str="cwd: ",hdr_txt_col="red",val=function()if x.show_cwd_header==false or x.show_cwd_header==nil and(not x.cwd or x.cwd==vim.loop.cwd())then return end;return ag(x.cwd or vim.loop.cwd())end},search={hdr_txt_opt="grep_header",hdr_txt_str="Grep string: ",hdr_txt_col="red",val=function()return x.search and#x.search>0 and x.search end},lsp_query={hdr_txt_opt="lsp_query_header",hdr_txt_str="Query: ",hdr_txt_col="red",val=function()return x.lsp_query and#x.lsp_query>0 and x.lsp_query end},regex_filter={hdr_txt_opt="regex_header",hdr_txt_str="Regex filter: ",hdr_txt_col="red",val=function()return x.regex_filter and#x.regex_filter>0 and x.regex_filter end},actions={hdr_txt_opt="interactive_header",hdr_txt_str="",val=function()if x.no_header_i then return end;local aj=k;for E,Y in pairs(x.actions)do if type(Y)=="table"and aj[Y[1]]then local ak=x.fn_reload and aj[Y[1]].fn_reload or aj[Y[1]][1]return ak and(":: <%s> to %s"):format(c.ansi_codes.yellow(E),c.ansi_codes.red(ak))end end end}}if not x.headers then x.headers=af or{"cwd"}end;for p,al in ipairs(x.headers)do assert(ai[al])local am=x[ai[al].hdr_txt_opt]if am then ai[al].hdr_txt_str=am end end;local an;for p,al in ipairs(x.headers)do assert(ai[al])local ao=ai[al]local ap=ao.val()if ao and ap then an=not an and""or an..", "an=("%s%s%s"):format(an,ao.hdr_txt_str,not ao.hdr_txt_col and ap or c.ansi_codes[ao.hdr_txt_col](ap))end end;if an and#an>0 then x.fzf_opts["--header"]=g.shellescape(an)end;return x end;j.setup_fzf_interactive_flags=function(aq,ar,x)x.query=x.query or""local as=aq;if x.stderr_to_stdout~=false and not as:match("2>")then as=aq.." 2>&1"end;local at=as;if not x.exec_empty_query then at=("[ -z %s ] || %s"):format(ar,at)end;if x._is_skim then x.__fzf_init_cmd=nil;x.prompt=x.__prompt or x.prompt or x.fzf_opts["--prompt"]if x.prompt then x.fzf_opts["--prompt"]=x.prompt:match("[^%*]+")x.fzf_opts["--cmd-prompt"]=g.shellescape(x.prompt)x.__prompt=x.prompt;x.prompt=nil end;x.fzf_opts["--cmd-query"]=g.shellescape(c.sk_escape(x.query))x.fzf_opts["--query"]=nil;x.query=nil;x._fzf_cli_args=string.format("--interactive --cmd %s",g.shellescape(at))else x.__fzf_init_cmd="true"if x.exec_empty_query or x.query and#x.query>0 then x.__fzf_init_cmd=as:gsub(ar,g.shellescape(x.query:gsub("%%","%%%%")))end;x.fzf_opts["--disabled"]=""x.fzf_opts["--query"]=g.shellescape(x.query)if x.silent_fail~=false then at=("%s || true"):format(at)end;x._fzf_cli_args=string.format("--bind=%s",g.shellescape(("change:reload:%s"):format(("%s"):format(at))))end;return x end;j.fzf_query_placeholder="<query>"j.fzf_field_expression=function(x)return x and x._is_skim and[["{}"]]or"{q}"end;j.setup_fzf_interactive_wrap=function(x)assert(x and x.__fn_reload)local ar=j.fzf_field_expression(x)local aq=h.reload_action_cmd(x,ar)return j.setup_fzf_interactive_flags(aq,ar,x)end;j.setup_fzf_interactive_native=function(aq,x)local ar=j.fzf_field_expression(x)if aq:match(j.fzf_query_placeholder)then aq=x.fn_reload:gsub(j.fzf_query_placeholder,ar)else aq=("%s %s"):format(aq,ar)end;return j.setup_fzf_interactive_flags(aq,ar,x)end;return j
