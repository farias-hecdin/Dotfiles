local a=require"fzf-lua.utils"local b=require"fzf-lua.config"local c=require"fzf-lua.actions"local d=vim.api;local e=vim.fn;local f=vim.fn.has("nvim-0.9")==1;local g={}local h=nil;function g.__SELF()return h end;setmetatable(g,{__call=function(i,...)return i:new(...)end})local j={["toggle-preview"]={module="win",fnc="toggle_preview()"},["toggle-preview-wrap"]={module="win",fnc="toggle_preview_wrap()"},["toggle-preview-cw"]={module="win",fnc="toggle_preview_cw(1)"},["toggle-preview-ccw"]={module="win",fnc="toggle_preview_cw(-1)"},["preview-page-up"]={module="win",fnc="preview_scroll(-1)"},["preview-page-down"]={module="win",fnc="preview_scroll(1)"},["preview-page-reset"]={module="win",fnc="preview_scroll(0)"}}function g:setup_keybinds()if not self:validate()then return end;if not self.keymap or not self.keymap.builtin then return end;if self.keymap.fzf then for k,l in pairs(self.keymap.fzf)do if l=="toggle-preview"then self._fzf_toggle_prev_bind=a.fzf_bind_to_neovim(k)end end end;local m={["toggle-help"]={module="win",fnc="toggle_help()"},["toggle-fullscreen"]={module="win",fnc="toggle_fullscreen()"}}if self.previewer_is_builtin then m=vim.tbl_deep_extend("keep",m,j)end;local function n(o)return([[<Cmd>lua require('fzf-lua.%s').%s<CR>]]):format(o.module,o.fnc)end;for p,q in pairs(self.keymap.builtin)do local o=m[q]if o and not vim.tbl_isempty(o)and q~=false then a.keymap_set("t",p,n(o),{nowait=true,buffer=self.fzf_bufnr})end end;if self.actions["esc"]==c.dummy_abort then a.keymap_set("t","<Esc>","<Esc>",{buffer=0})end end;function g:generate_layout(r)local s,t=r.row,r.col;local u,v=r.height,r.width;local w=r.signcol_width or 0;local x=r.preview_pos;local y=r.preview_size;local z,A=s+1,t+1;local B,C;local D=2;local E;local F=r.split and r.split:match("vnew")~=nil;if x=="down"or x=="up"then u=u-D;C=v;B=a.round(u*y/100,0.6)u=u-B;if x=="up"then s=s+B+D;if r.split then E="NW"z=1;A=1;C=C-2;B=B-1 else E="SW"z=s-1 end else E="NW"if r.split then A=1;z=u+D;B=B-1;C=C-2 else z=s+u+3 end end elseif x=="left"or x=="right"then B=u;C=a.round(v*y/100)v=v-C-2;if x=="left"then E="NE"t=t+C+2;A=t-1;if r.split then z=1;C=C-1-w;B=B-D;if F then E="NW"A=1 else A=t-3-w end end else E="NW"if r.split then z=1;A=v+4-w;C=C-3+w;B=B-D else A=t+v+3 end end end;return{fzf={row=s,col=t,height=u,width=v},preview={anchor=E,row=z,col=A,height=B,width=C}}end;local G=function(H)local I=nil;if type(H)=="string"then I=b.globals.winopts._borderchars[H]end;if not I then I=b.globals.winopts._borderchars["rounded"]end;if not H or type(H)~="table"or#H<8 then return I end;local J={}for K=1,8 do if type(H[K])=="string"then table.insert(J,#H[K]>0 and H[K]or" ")elseif type(H[K])=="table"and type(H[K][1])=="string"then table.insert(J,#H[K][1]>0 and H[K][1]or" ")else table.insert(J,I[K])end end;return J end;local L=function(M)local N=M or{}N.winopts=vim.tbl_deep_extend("keep",N.winopts or{},b.globals.winopts)N.winopts_fn=N.winopts_fn or b.globals.winopts_fn;N.winopts_raw=N.winopts_raw or b.globals.winopts_raw;local r=a.tbl_deep_clone(N.winopts)if type(N.winopts_fn)=="function"then r=vim.tbl_deep_extend("force",r,N.winopts_fn())end;if type(N.winopts_raw)=="function"then r=vim.tbl_deep_extend("force",r,N.winopts_raw())end;r.__hl=vim.tbl_deep_extend("force",r.__hl,r.hl or{})local O=vim.o.columns-2;local P=vim.o.lines-vim.o.cmdheight-2;r.width=math.min(O,r.width)r.height=math.min(P,r.height)if not r.height or r.height<=1 then r.height=math.floor(P*r.height)end;if not r.width or r.width<=1 then r.width=math.floor(O*r.width)end;if r.relative=="cursor"then local Q=vim.api.nvim_win_get_cursor(0)local R=vim.fn.screenpos(0,Q[1],Q[2])r.row=math.floor((r.row or 0)+R.row-1)r.col=math.floor((r.col or 0)+R.col-1)r.relative=nil else if not r.row or r.row<=1 then r.row=math.floor((vim.o.lines-r.height)*r.row)end;if not r.col or r.col<=1 then r.col=math.floor((vim.o.columns-r.width)*r.col)end;r.col=math.min(r.col,O-r.width)r.row=math.min(r.row,P-r.height)end;if r.border==false then r.border="none"elseif not r.border or r.border==true then r.border="rounded"end;if type(r.border)=="string"then r._border=r.border;r.border=b.globals.winopts._borderchars[r.border]or b.globals.winopts._borderchars["rounded"]end;r.nohl_borderchars=G(r.border)local S;if r.preview.layout=="horizontal"or r.preview.layout=="flex"and vim.o.columns>r.preview.flip_columns then S=r.preview.horizontal else S=r.preview.vertical end;r.preview_pos=S:match("[^:]+")or"right"r.preview_size=tonumber(S:match(":(%d+)%%"))or 50;return r end;function g:reset_win_highlights(T,U)local V=("Normal:%s,FloatBorder:%s"):format(self.winopts.__hl.normal,self.winopts.__hl.border)if self._previewer then for W,X in ipairs({"CursorLine","CursorLineNr"})do if self.winopts.__hl[X:lower()]then V=V..(",%s:%s"):format(X,self.winopts.__hl[X:lower()])end end end;if U then V=("Normal:%s"):format(self.winopts.__hl.border)end;vim.api.nvim_win_set_option(T,"winhighlight",V)end;function g:check_exit_status(Y)if not self:validate()then return end;if Y~=0 and Y~=130 then local Z=vim.api.nvim_buf_get_lines(self.fzf_bufnr,0,1,false)if Y~=1 or Z and#Z[1]>0 then a.warn(("fzf error %s: %s"):format(Y or"<null>",Z and#Z[1]>0 and Z[1]or"<null>"))end end end;function g:_set_autoclose(_)if _~=nil then self._autoclose=_ else self._autoclose=true end;return self._autoclose end;function g.set_autoclose(_)if not h then return nil end;return h:_set_autoclose(_)end;function g.autoclose()if not h then return nil end;return h._autoclose end;local function a0(N,p,a1)local a2=N.winopts.preview[p]or b.globals.winopts.preview[p]return a2 and a2:match(a1)end;function g:new(M)if h then h._reuse=true;return h end;M=M or{}self._o=M;self=setmetatable({},{__index=self})self.actions=M.actions;self.winopts=L(M)self.fullscreen=self.winopts.fullscreen;self.preview_wrap=not a0(M,"wrap","nowrap")self.preview_hidden=not a0(M,"hidden","nohidden")self.preview_border=not a0(M,"border","noborder")self.keymap=M.keymap;self.previewer=M.previewer;self.prompt=M.prompt or M.fzf_opts["--prompt"]self._orphaned_bufs={}self:_set_autoclose(M.autoclose)h=self;return self end;function g:attach_previewer(a3)if self._previewer and self._previewer.close then self._previewer:close()end;if self._previewer and self._previewer.win_leave then self._previewer:win_leave()end;self._previewer=a3;self.previewer_is_builtin=a3 and type(a3.display_entry)=="function"end;function g:fs_preview_layout(a4)local a5=self.prev_winopts;local a6=self.border_winopts;if not a4 or self.winopts.split or not a5 or not a6 or vim.tbl_isempty(a5)or vim.tbl_isempty(a6)then return a5,a6 end;local x=self.winopts.preview_pos;local a7=0;local a8=0;if x=="down"or x=="up"then a8=vim.o.columns-a6.width;if x=="down"then a7=vim.o.lines-a6.row-a6.height-vim.o.cmdheight elseif x=="up"then a7=a6.row-a6.height end;a6.col=0;a5.col=a6.col+1 elseif x=="left"or x=="right"then a7=vim.o.lines-a6.height-vim.o.cmdheight;if x=="left"then a6.col=a6.col-1;a5.col=a5.col-1;a8=a6.col-a6.width elseif x=="right"then a8=vim.o.columns-a6.col-a6.width end;a6.row=0;a5.row=a6.row+1 end;a5.height=a5.height+a7;a6.height=a6.height+a7;a5.width=a5.width+a8;a6.width=a6.width+a8;return a5,a6 end;function g:preview_layout()if self.winopts.split and self.previewer_is_builtin then local a9=e.getwininfo(self.fzf_winid)[1]local w=vim.wo[self.fzf_winid].signcolumn=="no"and 1 or 0;self.layout=self:generate_layout({row=a9.winrow,col=a9.wincol,height=a9.height,width=d.nvim_win_get_width(self.fzf_winid),signcol_width=w,preview_pos=self.winopts.preview_pos,preview_size=self.winopts.preview_size,split=self.winopts.split})end;if not self.layout then return{},{}end;local E=self.layout.preview.anchor;local s,t=self.layout.preview.row,self.layout.preview.col;local v,u=self.layout.preview.width,self.layout.preview.height;if not E or not v or v<1 or not u or u<1 then return{},{}end;local r={relative="editor",focusable=false,style="minimal"}if self.winopts.split then r.relative="win"end;local aa=vim.tbl_extend("force",r,{focusable=true,anchor=E,width=v,height=u,col=t,row=s})local a6=vim.tbl_extend("force",r,{anchor=E,width=v+2,height=u+2,col=E:match("W")and t-1 or t+1,row=E:match("N")and s-1 or s+1})return aa,a6 end;function g:validate_preview()return not self.closing and self.preview_winid and self.preview_winid>0 and d.nvim_win_is_valid(self.preview_winid)and self.border_winid and self.border_winid>0 and d.nvim_win_is_valid(self.border_winid)end;function g:preview_winids()return self.preview_winid,self.border_winid end;function g:update_border_buf()local ab=self.border_buf;local a6=self.border_winopts;local J=self.winopts.nohl_borderchars;local v,u=a6.width,a6.height;local ac=J[1]..J[2]:rep(v-2)..J[3]local ad=J[8]..(" "):rep(v-2)..J[4]local ae=J[7]..J[6]:rep(v-2)..J[5]local Z={ac}for W=1,u-2 do table.insert(Z,ad)end;table.insert(Z,ae)if not ab then ab=d.nvim_create_buf(false,true)vim.bo[ab].modifiable=true;vim.bo[ab].bufhidden="wipe"end;d.nvim_buf_set_lines(ab,0,-1,1,Z)return ab end;function g:redraw_preview()if not self.previewer_is_builtin or self.preview_hidden then return end;self.prev_winopts,self.border_winopts=self:preview_layout()if vim.tbl_isempty(self.prev_winopts)or vim.tbl_isempty(self.border_winopts)then return-1,-1 end;if self.fullscreen then self.prev_winopts,self.border_winopts=self:fs_preview_layout(self.fullscreen)end;if self:validate_preview()then self.border_buf=d.nvim_win_get_buf(self.border_winid)self:update_border_buf()d.nvim_win_set_config(self.border_winid,self.border_winopts)d.nvim_win_set_config(self.preview_winid,self.prev_winopts)if self._previewer and self._previewer.display_last_entry then self._previewer:set_winopts(self.preview_winid)self._previewer:display_last_entry()end else local af=d.nvim_create_buf(false,true)self.prev_winopts.noautocmd=true;self.border_winopts.noautocmd=true;d.nvim_buf_set_option(af,"bufhidden","wipe")self.border_buf=self:update_border_buf()self.preview_winid=d.nvim_open_win(af,false,self.prev_winopts)self.border_winid=d.nvim_open_win(self.border_buf,false,self.border_winopts)d.nvim_win_set_option(self.border_winid,"wrap",false)d.nvim_win_set_var(self.preview_winid,"fzf_lua_preview",true)d.nvim_win_set_var(self.border_winid,"fzf_lua_preview",true)end;self:reset_win_highlights(self.border_winid,true)self:reset_win_highlights(self.preview_winid)return self.preview_winid,self.border_winid end;function g:validate()return self.fzf_winid and self.fzf_winid>0 and d.nvim_win_is_valid(self.fzf_winid)end;function g:fs_fzf_layout(a4,r)if not a4 or self.winopts.split then return r end;if not self.previewer_is_builtin or self.preview_hidden then r.col=0;r.row=0;r.width=vim.o.columns;r.height=vim.o.lines-vim.o.cmdheight-2 else local x=self.winopts.preview_pos;if x=="down"or x=="up"then r.col=0;r.width=vim.o.columns;if x=="down"then r.height=r.height+r.row;r.row=0 elseif x=="up"then r.height=r.height+vim.o.lines-r.row-r.height-vim.o.cmdheight-2 end elseif x=="left"or x=="right"then r.row=0;r.height=vim.o.lines-vim.o.cmdheight-2;if x=="right"then r.width=r.width+r.col;r.col=0 elseif x=="left"then r.width=r.width+vim.o.columns-r.col-r.width-1 end end end;return r end;function g:redraw()self.winopts=L(self._o)if not self.winopts.split and self.previewer_is_builtin then self.layout=self:generate_layout(self.winopts)end;if self:validate()then self:redraw_main()end;if self:validate_preview()then self:redraw_preview()end end;function g:redraw_main()if self.winopts.split then return end;local ag=self._previewer and self.preview_hidden and self._previewer.toggle_behavior~="extend"local ah=self.winopts.relative or"editor"local ai,Z=vim.o.columns,vim.o.lines;if ah=="win"then ai,Z=vim.api.nvim_win_get_width(0),vim.api.nvim_win_get_height(0)end;local r=a.tbl_deep_clone(self.winopts)if self.layout and not ag then r=a.tbl_deep_clone(self.layout.fzf)end;if self.fullscreen then r=self:fs_fzf_layout(self.fullscreen,r)end;local aj={width=r.width or math.min(ai-4,math.max(80,ai-20)),height=r.height or math.min(Z-4,math.max(20,Z-10)),style="minimal",relative=ah,border=self.winopts.border,title=f and self.winopts.title or nil,title_pos=f and self.winopts.title_pos or nil}aj.row=r.row or math.floor((Z-aj.height)/2-1)aj.col=r.col or math.floor((ai-aj.width)/2)if self.winopts._border and self.winopts._border=="none"then aj.border=self.winopts._border;aj.width=aj.width+2;aj.height=aj.height+2 end;if type(aj.border)=="table"then local function ak(al,am)for W,K in ipairs(am)do if al[K]and#al[K]>0 then return false end end;return true end;aj.height=aj.height+(ak(aj.border,{2})and 1 or 0)+(ak(aj.border,{6})and 1 or 0)aj.width=aj.width+(ak(aj.border,{4})and 1 or 0)+(ak(aj.border,{8})and 1 or 0)end;if self:validate()then if self._previewer and self._previewer.clear_on_redraw and self._previewer.clear_preview_buf then self._previewer:clear_preview_buf(true)self._previewer:clear_cached_buffers()end;d.nvim_win_set_config(self.fzf_winid,aj)else local an=vim.o.cursorline;self.fzf_bufnr=vim.api.nvim_create_buf(false,true)self.fzf_winid=vim.api.nvim_open_win(self.fzf_bufnr,true,aj)if vim.o.cursorline~=an then vim.o.cursorline=an end end end;function g:set_redraw_autocmd()vim.cmd("augroup FzfLua")vim.cmd([[au VimResized <buffer> lua require("fzf-lua").redraw()]])vim.cmd("augroup END")end;function g:set_winleave_autocmd()vim.cmd("augroup FzfLua")vim.cmd("au!")vim.cmd(("au WinLeave <buffer> %s"):format([[lua require('fzf-lua.win').win_leave()]]))vim.cmd("augroup END")end;function g:set_tmp_buffer()if not self:validate()then return end;local af=d.nvim_create_buf(false,true)vim.api.nvim_win_set_buf(self.fzf_winid,af)self:set_winleave_autocmd()self:set_redraw_autocmd()table.insert(self._orphaned_bufs,self.fzf_bufnr)self.fzf_bufnr=af;vim.api.nvim_win_set_option(self.fzf_winid,"cursorline",false)return self.fzf_bufnr end;function g:set_style_minimal(ao)if not tonumber(ao)or not d.nvim_win_is_valid(ao)then return end;vim.wo[ao].number=false;vim.wo[ao].relativenumber=false;vim.wo[ao].cursorline=false;vim.wo[ao].cursorcolumn=false;vim.wo[ao].spell=false;vim.wo[ao].list=false;vim.wo[ao].signcolumn="no"vim.wo[ao].foldcolumn="0"vim.wo[ao].colorcolumn=""end;function g:create()if self._o._is_fzf_tmux then return end;if self._reuse then self:set_tmp_buffer()self:setup_keybinds()if self.winopts.on_create and type(self.winopts.on_create)=="function"then self.winopts.on_create()end;vim.cmd("redraw")return end;if not self.winopts.split and self.previewer_is_builtin then self.layout=self:generate_layout(self.winopts)end;self.src_bufnr=vim.api.nvim_get_current_buf()self.src_winid=vim.api.nvim_get_current_win()if self.winopts.split then vim.cmd(self.winopts.split)self.fzf_bufnr=vim.api.nvim_get_current_buf()self.fzf_winid=vim.api.nvim_get_current_win()self:set_style_minimal(self.fzf_winid)else self:redraw_main()end;self:set_winleave_autocmd()self:set_redraw_autocmd()self:reset_win_highlights(self.fzf_winid)if self.winopts.on_create and type(self.winopts.on_create)=="function"then self.winopts.on_create()end;self:redraw_preview()self:setup_keybinds()return{src_bufnr=self.src_bufnr,src_winid=self.src_winid,fzf_bufnr=self.fzf_bufnr,fzf_winid=self.fzf_winid}end;function g:close_preview()if self._previewer and self._previewer.close then self._previewer:close()end;if self.border_winid and vim.api.nvim_win_is_valid(self.border_winid)then a.nvim_win_close(self.border_winid,true)end;if self.border_buf and vim.api.nvim_buf_is_valid(self.border_buf)then vim.api.nvim_buf_delete(self.border_buf,{force=true})end;if self.preview_winid and vim.api.nvim_win_is_valid(self.preview_winid)then a.nvim_win_close(self.preview_winid,true)end;if self._sbuf1 and vim.api.nvim_buf_is_valid(self._sbuf1)then vim.api.nvim_buf_delete(self._sbuf1,{force=true})end;if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then a.nvim_win_close(self._swin1,true)end;if self._sbuf2 and vim.api.nvim_buf_is_valid(self._sbuf2)then vim.api.nvim_buf_delete(self._sbuf2,{force=true})end;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then a.nvim_win_close(self._swin2,true)end;self._sbuf1,self._sbuf2,self._swin1,self._swin2=nil,nil,nil,nil;self.border_buf=nil;self.border_winid=nil;self.preview_winid=nil end;function g:close()self.closing=true;self.close_help()self:close_preview()if self.fzf_winid and vim.api.nvim_win_is_valid(self.fzf_winid)then pcall(vim.api.nvim_win_close,self.fzf_winid,true)end;if self.fzf_bufnr and vim.api.nvim_buf_is_valid(self.fzf_bufnr)then vim.api.nvim_buf_delete(self.fzf_bufnr,{force=true})end;if self._orphaned_bufs then for W,ap in ipairs(self._orphaned_bufs)do if vim.api.nvim_buf_is_valid(ap)then vim.api.nvim_buf_delete(ap,{force=true})end end end;if self.winopts and self.winopts.split and self.src_winid and self.src_winid>0 and self.src_winid~=vim.api.nvim_get_current_win()and vim.api.nvim_win_is_valid(self.src_winid)then vim.api.nvim_set_current_win(self.src_winid)end;self.closing=nil;self._reuse=nil;self._orphaned_bufs=nil;h=nil;a.reset_info()end;function g.win_leave()local self=h;if not self then return end;if self._previewer and self._previewer.win_leave then self._previewer:win_leave()end;if not self or self.closing then return end;h:close()end;function g:clear_border_highlights()if self.border_winid and vim.api.nvim_win_is_valid(self.border_winid)then vim.fn.clearmatches(self.border_winid)end end;function g:set_title_hl()if self.winopts.__hl.title and self._title_len and self._title_len>0 then pcall(vim.api.nvim_win_call,self.border_winid,function()e.matchaddpos(self.winopts.__hl.title,{{1,self._title_position,self._title_len+1}},11)end)end end;function g:update_scrollbar_border(M)if M.bar_height>=M.line_count then return end;local J=self.winopts.nohl_borderchars;local aq=self.winopts.preview.scrollchars;M.bar_offset=M.bar_offset+1;if type(self.winopts.preview.scrollchar)=="string"and#self.winopts.preview.scrollchar>0 then aq[1]=self.winopts.preview.scrollchar end;for K=1,2 do if not aq[K]or#aq[K]==0 then aq[K]=J[4]end end;local ar=function(al,as)local at=a.tbl_length(al)if at==0 or a.tbl_length(al[at])==8 then table.insert(al,{})at=at+1 end;table.insert(al[at],as)end;local au,av={},{}local Z=d.nvim_buf_get_lines(self.border_buf,1,-2,true)for K=1,#Z do local aw,ax=Z[K],e.strwidth(Z[K])local ay;if K>=M.bar_offset and K<M.bar_offset+M.bar_height then ay=aq[1]ar(au,{K+1,ax+2,1})else ay=aq[2]ar(av,{K+1,ax+2,1})end;Z[K]=e.strcharpart(aw,0,ax-1)..ay end;d.nvim_buf_set_lines(self.border_buf,1,-2,0,Z)if self.winopts.__hl.scrollborder_f or self.winopts.__hl.scrollborder_e then pcall(vim.api.nvim_win_call,self.border_winid,function()if self.winopts.hl.scrollborder_f then for K=1,#au do e.matchaddpos(self.winopts.__hl.scrollborder_f,au[K],11)end end;if self.winopts.__hl.scrollborder_e then for K=1,#av do e.matchaddpos(self.winopts.__hl.scrollborder_e,av[K],11)end end end)end end;local function az(aA)if aA and vim.api.nvim_buf_is_valid(aA)then return aA end;aA=d.nvim_create_buf(false,true)vim.bo[aA].modifiable=true;vim.bo[aA].bufhidden="wipe"return aA end;function g:hide_scrollbar()if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then vim.api.nvim_win_hide(self._swin1)self._swin1=nil end;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then vim.api.nvim_win_hide(self._swin2)self._swin2=nil end end;function g:update_scrollbar_float(M)if M.bar_height>=M.line_count then self:hide_scrollbar()else local aB=M.wininfo;local aC={}aC.relative="editor"aC.style="minimal"aC.width=1;aC.height=aB.height;aC.row=aB.winrow-1;aC.col=aB.wincol+aB.width+(tonumber(self.winopts.preview.scrolloff)or-2)aC.zindex=aB.zindex or 997;if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then vim.api.nvim_win_set_config(self._swin1,aC)else aC.noautocmd=true;self._sbuf1=az(self._sbuf1)self._swin1=vim.api.nvim_open_win(self._sbuf1,false,aC)local V=self.winopts.__hl.scrollfloat_e or"PmenuSbar"vim.api.nvim_win_set_option(self._swin1,"winhighlight",("Normal:%s,NormalNC:%s,NormalFloat:%s"):format(V,V,V))end;local aD=a.tbl_deep_clone(aC)aD.height=M.bar_height;aD.row=aC.row+M.bar_offset;aD.zindex=aC.zindex+1;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then vim.api.nvim_win_set_config(self._swin2,aD)else aD.noautocmd=true;self._sbuf2=az(self._sbuf2)self._swin2=vim.api.nvim_open_win(self._sbuf2,false,aD)local V=self.winopts.__hl.scrollfloat_f or"PmenuThumb"vim.api.nvim_win_set_option(self._swin2,"winhighlight",("Normal:%s,NormalNC:%s,NormalFloat:%s"):format(V,V,V))end end end;function g:update_scrollbar()if not self.winopts.preview.scrollbar or self.winopts.preview.scrollbar=="none"or not self:validate_preview()then return end;local aE=d.nvim_win_get_buf(self.preview_winid)local M={}M.wininfo=e.getwininfo(self.preview_winid)[1]M.line_count=d.nvim_buf_line_count(aE)local aF,u=M.wininfo.topline,M.wininfo.height;M.bar_height=math.min(u,math.ceil(u*u/M.line_count))M.bar_offset=math.min(u-M.bar_height,math.floor(u*aF/M.line_count))self:clear_border_highlights()self:set_title_hl()if self.winopts.preview.scrollbar=="float"then self:update_scrollbar_float(M)else self:update_scrollbar_border(M)end end;function g:update_title(aG)self:update_border_buf()local aH=7;local ab=d.nvim_win_get_buf(self.border_winid)local ac=d.nvim_buf_get_lines(ab,0,1,0)[1]local v=e.strwidth(ac)if#aG>v-aH then aG=aG:sub(1,v-aH).." "end;self._title_len=#aG;local aI=e.strwidth(aG)local aJ=e.strcharpart(ac,0,3)if self.winopts.preview.title_align=="center"then aJ=e.strcharpart(ac,0,a.round((v-aI)/2))elseif self.winopts.preview.title_align=="right"then aJ=e.strcharpart(ac,0,v-(aI+3))end;local aK=e.strcharpart(ac,aI+e.strwidth(aJ),v)aG=("%s%s%s"):format(aJ,aG,aK)d.nvim_buf_set_lines(ab,0,1,1,{aG})self._title_position=#aJ;self:set_title_hl()end;function g.toggle_fullscreen()if not h or h.winopts.split then return end;local self=h;self.fullscreen=not self.fullscreen;self:hide_scrollbar()if self and self:validate()then self:redraw_main()end;if self and self:validate_preview()then self:redraw_preview()end end;function g.toggle_preview()if not h then return end;local self=h;self.preview_hidden=not self.preview_hidden;if self.winopts.split and self._fzf_toggle_prev_bind then a.feed_keys_termcodes(self._fzf_toggle_prev_bind)end;if self.preview_hidden and self:validate_preview()then self:close_preview()self:redraw_main()elseif not self.preview_hidden then self:redraw_main()self:redraw_preview()if self._previewer and self._previewer.display_last_entry then self._previewer:display_last_entry()end end;h=self end;function g.toggle_preview_wrap()if not h then return end;local self=h;self.preview_wrap=not d.nvim_win_get_option(self.preview_winid,"wrap")if self and self:validate_preview()then d.nvim_win_set_option(self.preview_winid,"wrap",self.preview_wrap)end end;function g.toggle_preview_cw(aL)if not h or h.winopts.split or not h:validate_preview()then return end;local self=h;local Q={"up","right","down","left"}local aM;for K=1,#Q do if Q[K]==self.winopts.preview_pos then aM=K;break end end;if not aM then return end;local aN=aL>0 and aM+1 or aM-1;if aN<1 then aN=#Q end;if aN>#Q then aN=1 end;self.winopts.preview_pos=Q[aN]self.layout=self:generate_layout(self.winopts)self:close_preview()self:redraw_main()self:redraw_preview()if self._previewer and self._previewer.display_last_entry then self._previewer:display_last_entry()end end;function g.preview_scroll(aL)if not h then return end;local self=h;if self:validate_preview()and self._previewer and self._previewer.scroll then self._previewer:scroll(aL)end end;function g.close_help()if not h or not h.km_winid then return end;local self=h;if vim.api.nvim_win_is_valid(self.km_winid)then a.nvim_win_close(self.km_winid,true)end;if vim.api.nvim_buf_is_valid(self.km_bufnr)then vim.api.nvim_buf_delete(self.km_bufnr,{force=true})end;self.km_winid=nil;self.km_bufnr=nil end;function g.toggle_help()if not h then return end;local self=h;if self.km_winid then self.close_help()return end;local N={}N.max_height=N.max_height or math.floor(0.4*vim.o.lines)N.mode_width=N.mode_width or 10;N.name_width=N.name_width or 28;N.keybind_width=N.keybind_width or 14;N.normal_hl=N.normal_hl or self.winopts.__hl.help_normal;N.border_hl=N.border_hl or self.winopts.__hl.help_border;N.winblend=N.winblend or 0;N.column_padding=N.column_padding or"  "N.column_width=N.keybind_width+N.name_width+#N.column_padding+2;N.close_with_action=N.close_with_action or true;local function aO(aP,k,l,aQ,aR,aS)return("%s%%-%ds %%-%ds %%-%ds"):format(N.column_padding,aQ,aR,aS):format("`"..aP.."`","|"..k.."|","*"..l.."*")end;local aT={}local aU=self.previewer_is_builtin and"builtin"or"fzf"for W,aP in ipairs({"builtin","fzf"})do for k,l in pairs(self.keymap[aP])do if l and(not j[l]or aP==aU)then if aP=="builtin"then k=a.neovim_bind_to_fzf(k)end;table.insert(aT,aO(aP,k,l,N.mode_width,N.keybind_width,N.name_width))end end end;if self.actions then for k,l in pairs(self.actions)do if k=="default"then k="enter"end;if type(l)=="table"then l=b.get_action_helpstr(l[1])or l elseif l then l=b.get_action_helpstr(l)or l end;if l then table.insert(aT,aO("action",k,("%s"):format(l):gsub(" ",""),N.mode_width,N.keybind_width,N.name_width))end end end;table.sort(aT,function(aV,aW)if aV<aW then return true else return false end end)local function aX(al,aY)local aZ=#al>0 and al[#al]if not aZ or#aZ+#aY>vim.o.columns then table.insert(al,aY)else al[#al]=aZ..aY end end;local Z={}for W,a_ in ipairs(aT)do aX(Z,a_)end;local u=#Z<N.max_height and#Z or N.max_height;Z={}for b0=0,math.floor(vim.o.columns/(N.column_width+#N.column_padding))do for K=1,u do local aM=u*b0+K;Z[K]=b0==0 and aT[aM]or Z[K]..(aT[aM]or"")end end;local r={relative="editor",style="minimal",width=vim.o.columns,height=u,row=vim.o.lines-u-vim.o.cmdheight-2,col=1,border={" ","─"," "," "," "," "," "," "},zindex=999}self.km_bufnr=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_option(self.km_bufnr,"bufhidden","wipe")self.km_winid=vim.api.nvim_open_win(self.km_bufnr,false,r)vim.api.nvim_buf_set_name(self.km_bufnr,"_FzfLuaHelp")vim.api.nvim_win_set_option(self.km_winid,"winhl",string.format("Normal:%s,FloatBorder:%s",N.normal_hl,N.border_hl))vim.api.nvim_win_set_option(self.km_winid,"winblend",N.winblend)vim.api.nvim_win_set_option(self.km_winid,"foldenable",false)vim.api.nvim_win_set_option(self.km_winid,"wrap",false)vim.api.nvim_buf_set_option(self.km_bufnr,"filetype","help")vim.cmd(string.format("autocmd BufLeave <buffer> ++once lua %s",table.concat({string.format("pcall(vim.api.nvim_win_close, %s, true)",self.km_winid),string.format("pcall(vim.api.nvim_buf_delete, %s, {force=true})",self.km_bufnr)},";")))vim.api.nvim_buf_set_lines(self.km_bufnr,0,-1,false,Z)end;return g
