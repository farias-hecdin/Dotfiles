local a=require"fzf-lua.core"local b=require"fzf-lua.utils"local c=require"fzf-lua.config"local d=require"fzf-lua.make_entry"local e={}local f=vim.fn.has("nvim-0.8")==1;local function g()if not __CTX or not b.fzf_winobj()then __CTX={winid=vim.api.nvim_get_current_win(),bufnr=vim.api.nvim_get_current_buf(),bufname=vim.api.nvim_buf_get_name(0),cursor=vim.api.nvim_win_get_cursor(0)}end end;local function h(i)if f then return i.server_capability else return i.resolved_capability end end;local function j(k,l)g()local m=vim.lsp.buf_get_clients(__CTX and __CTX.bufnr or 0)local n=0;for _,o in pairs(m)do if f then if o.server_capabilities[k]then n=n+1 end else if o.resolved_capabilities[k]then n=n+1 end end end;if n>0 then return n end;if b.tbl_isempty(m)then if not l then b.info("LSP: no client attached")end;return nil else if not l then b.info("LSP: server does not support "..k)end;return false end end;local function p(q,r)local s=vim.lsp.util.locations_to_items({q},r)[1]return("%s:%d:%d:"):format(s.filename,s.lnum,s.col)end;local t=function(u,v,r)b.fzf_exit()local w=u.jump_to_single_result_action;if w then local x=p(v,r)return u.jump_to_single_result_action({x},u)end;return vim.lsp.util.jump_to_location(v,r)end;local function y(u,z,_,v,A,_)local B=vim.lsp.get_client_by_id(A.client_id).offset_encoding;v=vim.tbl_islist(v)and v or{v}if u.ignore_current_line then local C=__CTX.cursor[1]-1;v=vim.tbl_filter(function(D)if D.range and D.range.start and D.range.start.line==C then return false end;return true end,v)end;if u.jump_to_single_result and#v==1 then t(u,v[1],B)end;local E=vim.lsp.util.locations_to_items(v,B)for _,x in ipairs(E)do if not u.current_buffer_only or __CTX.bufname==x.filename then x=d.lcol(x,u)x=d.file(x,u)if x then z(x)end end end end;local function F(u,z,_,v,_,_)for _,G in pairs(v)do local H=G.from or G.to;for _,I in pairs(G.fromRanges)do local q={filename=assert(vim.uri_to_fname(H.uri)),text=H.name,lnum=I.start.line+1,col=I.start.character+1}local x=d.lcol(q,u)x=d.file(x,u)if x then z(x)end end end end;local function J(K,L,M)local function N(O,P,Q,R)for _,S in ipairs(O)do local T=vim.lsp.protocol.SymbolKind[S.kind]or"Unknown"if S.location then local I=S.location.range;table.insert(P,{filename=vim.uri_to_fname(S.location.uri),lnum=I.start.line+1,col=I.start.character+1,kind=T,text=R.."["..T.."] "..S.name})elseif S.selectionRange then table.insert(P,{filename=vim.api.nvim_buf_get_name(Q),lnum=S.selectionRange.start.line+1,col=S.selectionRange.start.character+1,kind=T,text=R.."["..T.."] "..S.name})if S.children then for _,U in ipairs(N(S.children,P,Q,R..M))do for _,V in ipairs(U)do table.insert(P,V)end end end end end;return P end;return N(K,{},L or 0,"")end;local function W(u,z,_,v,_,_)v=vim.tbl_islist(v)and v or{v}local E;if u.child_prefix then E=J(v,__CTX.bufnr,u.child_prefix==true and string.rep("\xc2\xa0",2)or u.child_prefix)else E=vim.lsp.util.symbols_to_items(v,__CTX.bufnr)end;for _,x in ipairs(E)do if(not u.current_buffer_only or __CTX.bufname==x.filename)and(not u.regex_filter or x.text:match(u.regex_filter))then if e._sym2style then local T=x.text:match("%[(.-)%]")if T and e._sym2style[T]then x.text=x.text:gsub("%[.-%]",e._sym2style[T],1)end end;x=d.lcol(x,u)x=d.file(x,u)if x then z(x)end end end end;local function X(u,z,_,Y,Z,_)if not u.code_actions then u.code_actions={}end;local a0=vim.tbl_count(u.code_actions)+1;for _,w in ipairs(Y)do local a1=string.format("%s %s",b.ansi_codes.magenta(string.format("%d:",a0)),w.title)local x={client_id=Z.client_id,command=w}u.code_actions[tostring(a0)]=x;z(a1)a0=a0+1 end end;local a2={["code_actions"]={label="Code Actions",resolved_capability="code_action",server_capability="codeActionProvider",method="textDocument/codeAction",handler=X},["references"]={label="References",resolved_capability="find_references",server_capability="referencesProvider",method="textDocument/references",handler=y},["definitions"]={label="Definitions",resolved_capability="goto_definition",server_capability="definitionProvider",method="textDocument/definition",handler=y},["declarations"]={label="Declarations",resolved_capability="goto_declaration",server_capability="declarationProvider",method="textDocument/declaration",handler=y},["typedefs"]={label="Type Definitions",resolved_capability="type_definition",server_capability="typeDefinitionProvider",method="textDocument/typeDefinition",handler=y},["implementations"]={label="Implementations",resolved_capability="implementation",server_capability="implementationProvider",method="textDocument/implementation",handler=y},["document_symbols"]={label="Document Symbols",resolved_capability="document_symbol",server_capability="documentSymbolProvider",method="textDocument/documentSymbol",handler=W},["workspace_symbols"]={label="Workspace Symbols",resolved_capability="workspace_symbol",server_capability="workspaceSymbolProvider",method="workspace/symbol",handler=W},["live_workspace_symbols"]={label="Workspace Symbols",resolved_capability="workspace_symbol",server_capability="workspaceSymbolProvider",method="workspace/symbol",handler=W},["incoming_calls"]={label="Incoming Calls",resolved_capability="call_hierarchy",server_capability="callHierarchyProvider",method="callHierarchy/incomingCalls",handler=F},["outgoing_calls"]={label="Outgoing Calls",resolved_capability="call_hierarchy",server_capability="callHierarchyProvider",method="callHierarchy/outgoingCalls",handler=F}}local a3=function(a4)return function(...)local a5=not select(4,...)or type(select(4,...))~="number"if a5 then a4(...)else local a6=select(1,...)local a7=select(2,...)local v=select(3,...)local a8=select(4,...)local L=select(5,...)local a9=select(6,...)a4(a6,v,{method=a7,client_id=a8,bufnr=L},a9)end end end;local function aa(ab,i,u)return a3(function(a6,v,Z,a9)u.num_callbacks=u.num_callbacks+1;u.num_results=(u.num_results or 0)+(v and vim.tbl_count(v)or 0)if a6 then if not u.silent then b.err(string.format("Error executing '%s': %s",i.method,a6))end;if not u.no_autoclose then b.fzf_exit()end;coroutine.resume(ab,true,a6)else local ac=u.num_callbacks==u.num_clients;if ac and u.num_results==0 then if not u.silent then b.info(string.format("No %s found",string.lower(i.label)))end;if not u.no_autoclose then b.fzf_exit()end end;coroutine.resume(ab,ac,a6,v,Z,a9)end end)end;local function ad(u)assert(u.lsp_handler)if u.async==nil then if type(u.async_or_timeout)=="number"then u.async=false elseif type(u.async_or_timeout)=="boolean"then u.async=u.async_or_timeout end end;local ae,af=u.lsp_params,u.lsp_handler;if not ae then ae=vim.lsp.util.make_position_params(__CTX.winid)ae.context={includeDeclaration=u.includeDeclaration==nil and true or u.includeDeclaration}end;if not u.async then local ag=5000;if type(u.async_or_timeout)=="number"then ag=u.async_or_timeout end;local ah,a6=vim.lsp.buf_request_sync(__CTX.bufnr,af.method,ae,ag)if a6 then b.err(string.format("Error executing '%s': %s",af.method,a6))else local ai={}local z=function(a1)table.insert(ai,a1)end;for a8,aj in pairs(ah)do if aj.result then local Z={client_id=a8}af.handler(u,z,af.method,aj.result,Z)end end;if vim.tbl_isempty(ai)then if not u.fn_reload and not u.silent then b.info(string.format("No %s found",string.lower(af.label)))else u.__contents={}end elseif not(u.jump_to_single_result and#ai==1)then u.__contents=function(ak)coroutine.wrap(function()local ab=coroutine.running()for _,al in ipairs(ai)do ak(al,function()coroutine.resume(ab)end)coroutine.yield()end;ak(nil)end)()end end end else local am=function(an)if an and an._cancel_all then an._cancel_all()an._cancel_all=nil end end;u._fn_post_fzf=am;u.__contents=function(ak)coroutine.wrap(function()local ab=coroutine.running()local ao={num_results=0,num_callbacks=0,num_clients=j(af.capability,u.silent),no_autoclose=u.no_autoclose or u.fn_reload,silent=u.silent or u.fn_reload}am(u)local ap=function()_,u._cancel_all=vim.lsp.buf_request(__CTX.bufnr,af.method,ae,aa(ab,af,ao))end;if vim.in_fast_event()then vim.schedule(function()ap()end)else ap()end;local a6,v,Z,a9,ac;repeat ac,a6,v,Z,a9=coroutine.yield()if not a6 and type(v)=="table"then local z=function(al)ak(al,function()coroutine.resume(ab)end)coroutine.yield()end;af.handler(u,z,af.method,v,Z,a9)end until ac or a6;ak(nil)u._cancel_all=nil end)()end end;return u,u.__contents end;local function aq(u)local ae=vim.lsp.util.make_position_params(__CTX and __CTX.winid or 0)local a7="textDocument/prepareCallHierarchy"local ar,a6=vim.lsp.buf_request_sync(0,a7,ae,2000)if a6 then b.err(("Error executing '%s': %s"):format(a7,a6))else local _,aj=next(ar)if vim.tbl_isempty(aj)or not aj.result[1]then if not u.silent then b.info(("No %s found"):format(u.lsp_handler.label:lower()))end;return end;assert(aj.result and aj.result[1])u.lsp_params={item=aj.result[1]}return ad(u)end end;local as=function(u,at)u=c.normalize_opts(u,at)if not u then return end;if not u.prompt and u.prompt_postfix then u.prompt=u.lsp_handler.label..(u.prompt_postfix or"")end;if not u.cwd or#u.cwd==0 then u.cwd=vim.loop.cwd()else u.cwd_only=true end;return u end;local function au(u,av)u=as(u,c.globals.lsp)if not u then return end;if u.force_uri==nil then u.force_uri=true end;u=a.set_fzf_field_index(u)u=av(u)if not u.__contents then return end;return a.fzf_exec(u.__contents,u)end;e.references=function(u)return au(u,ad)end;e.definitions=function(u)return au(u,ad)end;e.declarations=function(u)return au(u,ad)end;e.typedefs=function(u)return au(u,ad)end;e.implementations=function(u)return au(u,ad)end;e.incoming_calls=function(u)return au(u,aq)end;e.outgoing_calls=function(u)return au(u,aq)end;e.finder=function(u)u=as(u,c.globals.lsp.finder)if not u then return end;if u.force_uri==nil then u.force_uri=true end;local aw={}for _,ax in ipairs(u.providers)do local a7=ax[1]if not u._providers[a7]then b.warn(string.format("Unsupported provider: %s",a7))else u.silent=u.silent==nil and true or u.silent;u.no_autoclose=true;u.lsp_handler=a2[a7]u.lsp_handler.capability=h(u.lsp_handler)u.lsp_params=nil;local ay=j(u.lsp_handler.capability,true)if ay==nil then b.info("LSP: no client attached")return elseif ay then local _,az=(function()if a7=="incoming_calls"or a7=="outgoing_calls"then return aq(u)else return ad(u)end end)()if type(az)=="function"then table.insert(aw,{prefix=(ax.prefix or"")..(u.separator or""),contents=az})end end end end;if#aw==0 then b.info("LSP: no locations found")return end;u=a.set_fzf_field_index(u)return a.fzf_exec(aw,u)end;local function aA(u)assert(e._sym2style==nil)assert(u.symbol_style~=nil)e._sym2style={}local aB=vim.api.nvim_get_color_map()for T,aC in pairs(u.symbol_icons)do local V=nil;if u.symbol_style==1 and c._has_devicons then V=("%s %s"):format(aC,T)elseif u.symbol_style==2 and c._has_devicons then V=aC elseif u.symbol_style==3 then V=T end;if V and u.symbol_hl then e._sym2style[T]=b.ansi_from_hl(u.symbol_hl(T),V,aB)elseif V then e._sym2style[T]=V else e._sym2style[T]=T end end;if type(u.symbol_fmt)=="function"then for aD,U in pairs(e._sym2style)do e._sym2style[aD]=u.symbol_fmt(U,u)or U end end end;e.document_symbols=function(u)u=as(u,c.globals.lsp.symbols)if not u then return end;u.__MODULE__=u.__MODULE__ or e;u=a.set_header(u,u.headers or{"regex_filter"})u=a.set_fzf_field_index(u)if u.force_uri==nil then u.force_uri=true end;if not u.fzf_opts or u.fzf_opts["--with-nth"]==nil then u.fzf_opts=u.fzf_opts or{}u.fzf_opts["--with-nth"]="2.."u.fzf_opts["--tiebreak"]="index"end;u=ad(u)if not u.__contents then return end;if u.symbol_style or u.symbol_fmt then u.fn_pre_fzf=function()aA(u)end;u.fn_post_fzf=function()e._sym2style=nil end end;return a.fzf_exec(u.__contents,u)end;local function aE(_)return e.__last_ws_lsp_query end;local function aF(_,aG)e.__last_ws_lsp_query=aG;if c.__resume_data then c.__resume_data.last_query=aG end end;e.workspace_symbols=function(u)u=as(u,c.globals.lsp.symbols)if not u then return end;u.__MODULE__=u.__MODULE__ or e;if not u.lsp_query and u.resume then u.lsp_query=aE(u)end;aF(u,u.lsp_query)u.lsp_params={query=u.lsp_query or""}u=a.set_header(u,u.headers or{"actions","cwd","lsp_query","regex_filter"})u=a.set_fzf_field_index(u)if u.force_uri==nil then u.force_uri=true end;u=ad(u)if not u.__contents then return end;if u.symbol_style or u.symbol_fmt then u.fn_pre_fzf=function()aA(u)end;u.fn_post_fzf=function(an,_)e._sym2style=nil;local aH=aE(an)local aI=c.__resume_data and c.__resume_data.last_query;if not aH or#aH==0 and(aI and#aI>0)then aF(u,aI)end end end;return a.fzf_exec(u.__contents,u)end;e.live_workspace_symbols=function(u)u=as(u,c.globals.lsp.symbols)if not u then return end;u.__MODULE__=u.__MODULE__ or e;u.prompt=u.prompt and u.prompt:match("^%*")or"*"..u.prompt;if u.exec_empty_query==nil then u.exec_empty_query=true end;if not u.lsp_query and u.resume then u.lsp_query=aE(u)end;u.lsp_params={query=u.lsp_query or u.query or""}u.query=u.lsp_query or u.query;u.func_async_callback=false;u.fn_reload=function(aG)if aG and not(u.save_last_search==false)then aF(u,aG)end;u.lsp_params={query=aG or""}u=ad(u)return u.__contents end;u=a.set_header(u,u.headers or{"actions","cwd","regex_filter"})u=a.set_fzf_field_index(u)if u.force_uri==nil then u.force_uri=true end;if u.symbol_style or u.symbol_fmt then u.fn_pre_fzf=function()aA(u)end;u.fn_post_fzf=function()e._sym2style=nil end end;a.fzf_exec(nil,u)end;local function aJ(_)if not vim.diagnostic then return vim.lsp.diagnostic.get_line_diagnostics()end;local aK=vim.diagnostic.get(__CTX.bufnr,{lnum=vim.api.nvim_win_get_cursor(0)[1]-1})return aK and aK[1]and{{source=aK[1].source,message=aK[1].message,severity=aK[1].severity,code=aK[1].user_data and aK[1].user_data.lsp and aK[1].user_data.lsp.code,codeDescription=aK[1].user_data and aK[1].user_data.lsp and aK[1].user_data.lsp.codeDescription,range={["start"]={line=aK[1].lnum,character=aK[1].col},["end"]={line=aK[1].end_lnum,character=aK[1].end_col}},data=aK[1].user_data and aK[1].user_data.lsp and aK[1].user_data.lsp.data}}or{}end;e.code_actions=function(u)u=as(u,c.globals.lsp.code_actions)if not u then return end;if vim.fn.has("nvim-0.6")~=1 then b.info("LSP code actions requires neovim >= 0.6")return end;local aL=require"fzf-lua.providers.ui_select"local aM=aL.is_registered()if not aM then u.jump_to_single_result=false;u.lsp_params=vim.lsp.util.make_range_params(0)u.lsp_params.context={diagnostics=vim.lsp.diagnostic.get_line_diagnostics(__CTX and __CTX.bufnr or 0)or{}}u.async=false;local _,aN=ad(u)if not aN then return end end;u.previewer=false;u.actions=u.actions or{}u.actions.default=nil;if not aM then u.post_action_cb=function()aL.deregister({},true,true)end end;aL.register(u,true,u)vim.lsp.buf.code_action()end;local function aO(aP,a4)return function(u)u=u or{}u.lsp_handler=a2[aP]u.lsp_handler.capability=h(u.lsp_handler)if not j(u.lsp_handler.capability)then return end;a4(u)end end;return setmetatable({},{__index=function(_,aP)if a2[aP]then return aO(aP,e[aP])else return e[aP]end end})
