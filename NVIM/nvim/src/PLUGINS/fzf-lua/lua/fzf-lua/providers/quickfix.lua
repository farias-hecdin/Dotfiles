local a=require"fzf-lua.core"local b=require"fzf-lua.utils"local c=require"fzf-lua.config"local d=require"fzf-lua.make_entry"local e={}local f=function(g,h,i)if not i then return{}end;local j={}g=c.normalize_opts(g,h)if not g then return end;if not g.cwd then g.cwd=vim.loop.cwd()end;for k,l in ipairs(i)do table.insert(j,d.lcol(l,g))end;local m=function(n)for k,o in ipairs(j)do o=d.file(o,g)if o then n(o,function(p)if p then return end;n(nil)end)end end;n(nil)end;g=a.set_fzf_field_index(g)return a.fzf_exec(m,g)end;e.quickfix=function(g)local i=vim.fn.getqflist()if vim.tbl_isempty(i)then b.info("Quickfix list is empty.")return end;return f(g,c.globals.quickfix,i)end;e.loclist=function(g)local i=vim.fn.getloclist(0)for k,q in pairs(i)do q.filename=vim.api.nvim_buf_get_name(q.bufnr)end;if vim.tbl_isempty(i)then b.info("Location list is empty.")return end;return f(g,c.globals.loclist,i)end;local r=function(g,h,s)g=c.normalize_opts(g,h)if not g then return end;g.fn_pre_fzf=function()g.__history=vim.split(vim.fn.execute(s and"lhistory"or"chistory"),"\n")end;g.fn_pre_fzf()if vim.tbl_isempty(g.__history)or g.__history[2]=="No entries"then b.info(string.format("No %s",s and"location lists"or"quickfix lists"))return end;local m=function(n)coroutine.wrap(function()local t=coroutine.running()for k,u in ipairs(g.__history)do local v=u:match("^>")local w,x=u:match("list (%d+) of %d+; %d+ errors%s+(.*)$")if w and tonumber(w)>0 then local l=string.format("[%s] %s %s",b.ansi_codes.yellow(w),v and b.ansi_codes.red(g.marker)or" ",x)n(l,function(p)coroutine.resume(t)if p then n(nil)end end)coroutine.yield()end end;n(nil)end)()end;return a.fzf_exec(m,g)end;e.quickfix_stack=function(g)return r(g,c.globals.quickfix_stack)end;e.loclist_stack=function(g)g=g or{}g._is_loclist=true;return r(g,c.globals.loclist_stack,true)end;return e
