local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.7')==0 then vim.notify('(mini.pairs) Neovim<0.7 is soft deprecated (module works but not supported).'..' It will be deprecated after Neovim 0.9.0 release (module will not work).'..' Please update your Neovim version.')end;_G.MiniPairs=a;c=b.setup_config(c)b.apply_config(c)vim.api.nvim_exec([[augroup MiniPairs
        au!
        au FileType TelescopePrompt let b:minipairs_disable=v:true
        au FileType fzf let b:minipairs_disable=v:true
      augroup END]],false)end;a.config={modes={insert=true,command=false,terminal=false},mappings={['(']={action='open',pair='()',neigh_pattern='[^\\].'},['[']={action='open',pair='[]',neigh_pattern='[^\\].'},['{']={action='open',pair='{}',neigh_pattern='[^\\].'},[')']={action='close',pair='()',neigh_pattern='[^\\].'},[']']={action='close',pair='[]',neigh_pattern='[^\\].'},['}']={action='close',pair='{}',neigh_pattern='[^\\].'},['"']={action='closeopen',pair='""',neigh_pattern='[^\\].',register={cr=false}},["'"]={action='closeopen',pair="''",neigh_pattern='[^%a\\].',register={cr=false}},['`']={action='closeopen',pair='``',neigh_pattern='[^\\].',register={cr=false}}}}a.map=function(d,e,f,g)f=b.validate_pair_info(f)g=vim.tbl_deep_extend('force',g or{},{expr=true,noremap=true})g.desc=b.infer_mapping_description(f)b.map(d,e,b.pair_info_to_map_rhs(f),g)b.register_pair(f,d,'all')b.ensure_cr_bs(d)end;a.map_buf=function(h,d,e,f,g)f=b.validate_pair_info(f)g=vim.tbl_deep_extend('force',g or{},{expr=true,noremap=true})if vim.fn.has('nvim-0.7')==1 then g.desc=b.infer_mapping_description(f)end;vim.api.nvim_buf_set_keymap(h,d,e,b.pair_info_to_map_rhs(f),g)b.register_pair(f,d,h==0 and vim.api.nvim_get_current_buf()or h)b.ensure_cr_bs(d)end;a.unmap=function(d,e,i)vim.validate({pair={i,'string'}})pcall(vim.api.nvim_del_keymap,d,e)if i==''then return end;b.unregister_pair(i,d,'all')end;a.unmap_buf=function(h,d,e,i)vim.validate({pair={i,'string'}})pcall(vim.api.nvim_buf_del_keymap,h,d,e)if i==''then return end;b.unregister_pair(i,d,h==0 and vim.api.nvim_get_current_buf()or h)end;a.open=function(i,j)if b.is_disabled()or not b.neigh_match(j)then return i:sub(1,1)end;return('%s%s'):format(i,b.get_arrow_key('left'))end;a.close=function(i,j)if b.is_disabled()or not b.neigh_match(j)then return i:sub(2,2)end;local k=i:sub(2,2)if b.get_cursor_neigh(1,1)==k then return b.get_arrow_key('right')else return k end end;a.closeopen=function(i,j)if b.is_disabled()or b.get_cursor_neigh(1,1)~=i:sub(2,2)then return a.open(i,j)else return b.get_arrow_key('right')end end;a.bs=function(l)local m=l or b.keys.bs;local n=b.get_cursor_neigh(0,1)if not b.is_disabled()and b.is_pair_registered(n,vim.fn.mode(),0,'bs')then m=('%s%s'):format(m,b.keys.del)end;return m end;a.cr=function(l)local m=l or b.keys.cr;local n=b.get_cursor_neigh(0,1)if not b.is_disabled()and b.is_pair_registered(n,vim.fn.mode(),0,'cr')then m=('%s%s'):format(m,b.keys.above)end;return m end;b.default_config=a.config;b.default_pair_info={neigh_pattern='..',register={bs=true,cr=true}}b.registered_pairs={i={all={bs={},cr={}}},c={all={bs={},cr={}}},t={all={bs={},cr={}}}}local function o(p)return vim.api.nvim_replace_termcodes(p,true,true,true)end;b.keys={above=o('<C-o>O'),bs=o('<bs>'),cr=o('<cr>'),del=o('<del>'),keep_undo=o('<C-g>U'),left=o('<left>'),right=o('<right>')}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({modes={c.modes,'table'},mappings={c.mappings,'table'}})vim.validate({['modes.insert']={c.modes.insert,'boolean'},['modes.command']={c.modes.command,'boolean'},['modes.terminal']={c.modes.terminal,'boolean'}})b.validate_pair_info(c.mappings['('],"mappings['(']")b.validate_pair_info(c.mappings['['],"mappings['[']")b.validate_pair_info(c.mappings['{'],"mappings['{']")b.validate_pair_info(c.mappings[')'],"mappings[')']")b.validate_pair_info(c.mappings[']'],"mappings[']']")b.validate_pair_info(c.mappings['}'],"mappings['}']")b.validate_pair_info(c.mappings['"'],"mappings['\"']")b.validate_pair_info(c.mappings["'"],'mappings["\'"]')b.validate_pair_info(c.mappings['`'],"mappings['`']")return c end;b.apply_config=function(c)a.config=c;local q={insert='i',command='c',terminal='t'}local r={}for s,t in pairs(c.modes)do if t then table.insert(r,q[s])end end;for u,d in pairs(r)do for l,f in pairs(c.mappings)do a.map(d,l,f)end end end;b.is_disabled=function()return vim.g.minipairs_disable==true or vim.b.minipairs_disable==true end;b.register_pair=function(f,d,h)b.registered_pairs[d]=b.registered_pairs[d]or{all={bs={},cr={}}}local v=b.registered_pairs[d]v[h]=v[h]or{bs={},cr={}}local w,i=f.register,f.pair;if w.bs and not vim.tbl_contains(v[h].bs,i)then table.insert(v[h].bs,i)end;if w.cr and not vim.tbl_contains(v[h].cr,i)then table.insert(v[h].cr,i)end end;b.unregister_pair=function(i,d,h)local v=b.registered_pairs[d]if not(v and v[h])then return end;local x=v[h]for u,l in ipairs({'bs','cr'})do for y,z in ipairs(x[l])do if z==i then table.remove(x[l],y)end end end end;b.is_pair_registered=function(i,d,h,l)local v=b.registered_pairs[d]if not v then return false end;if vim.tbl_contains(v['all'][l],i)then return true end;h=h==0 and vim.api.nvim_get_current_buf()or h;local x=v[h]if not x then return false end;return vim.tbl_contains(x[l],i)end;b.ensure_cr_bs=function(d)local A,B=false,false;for u,C in pairs(b.registered_pairs[d])do A=A or not vim.tbl_isempty(C.cr)B=B or not vim.tbl_isempty(C.bs)end;if B then b.map(d,'<BS>','v:lua.MiniPairs.bs()',{expr=true,desc='MiniPairs <BS>'})end;if d=='i'and A then b.map(d,'<CR>','v:lua.MiniPairs.cr()',{expr=true,desc='MiniPairs <CR>'})end end;b.validate_pair_info=function(f,D)D=D or'pair_info'vim.validate({[D]={f,'table'}})f=vim.tbl_deep_extend('force',b.default_pair_info,f)vim.validate({[D..'.action']={f.action,'string'},[D..'.pair']={f.pair,'string'},[D..'.neigh_pattern']={f.neigh_pattern,'string'},[D..'.register']={f.register,'table'}})vim.validate({[D..'.register.bs']={f.register.bs,'boolean'},[D..'.register.cr']={f.register.cr,'boolean'}})return f end;b.pair_info_to_map_rhs=function(f)return('v:lua.MiniPairs.%s(%s, %s)'):format(f.action,vim.inspect(f.pair),vim.inspect(f.neigh_pattern))end;b.infer_mapping_description=function(f)local E=f.action:sub(1,1):upper()..f.action:sub(2)return('%s action for %s pair'):format(E,vim.inspect(f.pair))end;b.get_cursor_neigh=function(F,G)local H,I;if vim.fn.mode()=='c'then H=vim.fn.getcmdline()I=vim.fn.getcmdpos()F=F-1;G=G-1 else H=vim.api.nvim_get_current_line()I=vim.api.nvim_win_get_cursor(0)[2]end;return string.sub(('%s%s%s'):format('\r',H,'\n'),I+1+F,I+1+G)end;b.neigh_match=function(J)return J==nil or b.get_cursor_neigh(0,1):find(J)~=nil end;b.get_arrow_key=function(l)if vim.fn.mode()=='i'then return b.keys.keep_undo..b.keys[l]else return b.keys[l]end end;b.map=function(d,l,K,g)if l==''then return end;g=vim.tbl_deep_extend('force',{noremap=true},g or{})if vim.fn.has('nvim-0.7')==0 then g.desc=nil end;vim.api.nvim_set_keymap(d,l,K,g)end;return a
