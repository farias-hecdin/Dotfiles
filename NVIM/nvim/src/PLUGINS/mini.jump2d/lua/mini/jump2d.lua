local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.7')==0 then vim.notify('(mini.jump2d) Neovim<0.7 is soft deprecated (module works but not supported).'..' It will be deprecated after Neovim 0.9.0 release (module will not work).'..' Please update your Neovim version.')end;_G.MiniJump2d=a;c=b.setup_config(c)b.apply_config(c)if c.mappings.start_jumping=='<CR>'then vim.api.nvim_exec([[augroup MiniJump2d
          au!
          autocmd FileType qf nnoremap <buffer> <CR> <CR>
          autocmd CmdwinEnter * nnoremap <buffer> <CR> <CR>
        augroup END]],false)end;local d=vim.o.background=='light'local e=d and'white'or'black'local f=d and'black'or'white'local g=string.format('hi default MiniJump2dSpot guifg=%s guibg=%s gui=bold,nocombine',f,e)vim.cmd(g)local h=string.format('hi default MiniJump2dSpotAhead guifg=grey guibg=%s gui=nocombine',e)vim.cmd(h)vim.cmd('hi default link MiniJump2dSpotUnique MiniJump2dSpot')vim.cmd('hi default link MiniJump2dDim Comment')local i=string.format([[augroup MiniJump2d
        au ColorScheme * %s
        au ColorScheme * %s
      augroup END]],g,h)vim.api.nvim_exec(i,false)end;a.config={spotter=nil,labels='abcdefghijklmnopqrstuvwxyz',view={dim=false,n_steps_ahead=0},allowed_lines={blank=true,cursor_before=true,cursor_at=true,cursor_after=true,fold=true},allowed_windows={current=true,not_current=true},hooks={before_start=nil,after_jump=nil},mappings={start_jumping='<CR>'},silent=false}a.start=function(j)if b.is_disabled()then return end;j=j or{}local k=(j.hooks or{}).before_start or((vim.b.minijump2d_config or{}).hooks or{}).before_start or a.config.hooks.before_start;if k~=nil then k()end;j=b.get_config(j)j.spotter=j.spotter or a.default_spotter;j.hl_group=j.hl_group or'MiniJump2dSpot'j.hl_group_ahead=j.hl_group_ahead or'MiniJump2dSpotAhead'j.hl_group_unique=j.hl_group_unique or'MiniJump2dSpotUnique'j.hl_group_dim=j.hl_group_dim or'MiniJump2dDim'local l=b.spots_compute(j)local m=vim.split(j.labels,'')l=b.spots_add_steps(l,m,j.view.n_steps_ahead)b.spots_show(l,j)b.cache.spots=l;if b.is_operator_pending()then b.advance_jump(j)else vim.defer_fn(function()b.advance_jump(j)end,0)end end;a.stop=function()b.spots_unshow()b.cache.spots=nil;b.cache.msg_shown=false;vim.cmd('redraw')if b.cache.is_in_getcharstr then vim.api.nvim_input('<C-c>')end end;a.gen_pattern_spotter=function(n,o)n=n or'[^%s%p]+'o=o or'start'local p=n:sub(1,1)=='^'or n:sub(-1,-1)=='$'if p then return function(q,r)local s=vim.fn.getline(q)local t,u,v=s:find(n)return{({['start']=t,['end']=u,['none']=v})[o]}end end;local w=o=='none'and'(%s)'or'(()%s)'n=w:format(n)return function(q,r)local s=vim.fn.getline(q)local x={}for y,z in string.gmatch(s,n)do if o=='end'then z=z+math.max(y:len()-1,0)end;z=math.min(math.max(z,0),s:len())local A=vim.str_utfindex(s,z)z=vim.str_byteindex(s,A)if z~=x[#x]then table.insert(x,z)end end;return x end end;a.default_spotter=(function()local B=a.gen_pattern_spotter('%S+','start')local C=a.gen_pattern_spotter('%S+','end')local D=a.gen_pattern_spotter('[^%s%p]%p','start')local E=a.gen_pattern_spotter('%p[^%s%p]','end')local F=a.gen_pattern_spotter('%u+','start')return function(q,r)local G=b.merge_unique(B(q,r),C(q,r))local H=b.merge_unique(D(q,r),E(q,r))local x=b.merge_unique(G,H)return b.merge_unique(x,F(q,r))end end)()a.builtin_opts={}a.builtin_opts.default={spotter=a.default_spotter}a.builtin_opts.line_start={spotter=function(q,r)return{1}end,hooks={after_jump=function()vim.cmd('normal! ^')end}}a.builtin_opts.word_start={spotter=a.gen_pattern_spotter('[^%s%p]+')}local function I(J)local x={spotter=function()return{}end,allowed_lines={blank=false,fold=false}}x.hooks={before_start=function()local K=J()if K==nil then x.spotter=function()return{}end else local n=vim.pesc(K)x.spotter=a.gen_pattern_spotter(n)end end}return x end;a.builtin_opts.single_character=I(function()return b.getcharstr('Enter single character to search')end)a.builtin_opts.query=I(function()return b.input('Enter query to search')end)b.default_config=a.config;b.ns_id={dim=vim.api.nvim_create_namespace('MiniJump2dDim'),spots=vim.api.nvim_create_namespace('MiniJump2dSpots'),input=vim.api.nvim_create_namespace('MiniJump2dInput')}b.cache={spots=nil,is_in_getcharstr=false,msg_shown=false}b.keys={esc=vim.api.nvim_replace_termcodes('<Esc>',true,true,true),cr=vim.api.nvim_replace_termcodes('<CR>',true,true,true),block_operator_pending=vim.api.nvim_replace_termcodes('no<C-V>',true,true,true)}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({spotter={c.spotter,'function',true},labels={c.labels,'string'},view={c.view,'table'},allowed_lines={c.allowed_lines,'table'},allowed_windows={c.allowed_windows,'table'},hooks={c.hooks,'table'},mappings={c.mappings,'table'},silent={c.silent,'boolean'}})vim.validate({['view.dim']={c.view.dim,'boolean'},['view.n_steps_ahead']={c.view.n_steps_ahead,'number'},['allowed_lines.blank']={c.allowed_lines.blank,'boolean'},['allowed_lines.cursor_before']={c.allowed_lines.cursor_before,'boolean'},['allowed_lines.cursor_at']={c.allowed_lines.cursor_at,'boolean'},['allowed_lines.cursor_after']={c.allowed_lines.cursor_after,'boolean'},['allowed_lines.fold']={c.allowed_lines.fold,'boolean'},['allowed_windows.current']={c.allowed_windows.current,'boolean'},['allowed_windows.not_current']={c.allowed_windows.not_current,'boolean'},['hooks.before_start']={c.hooks.before_start,'function',true},['hooks.after_jump']={c.hooks.after_jump,'function',true},['mappings.start_jumping']={c.mappings.start_jumping,'string'}})return c end;b.apply_config=function(c)a.config=c;local L=c.mappings.start_jumping;b.map('n',L,'<Cmd>lua MiniJump2d.start()<CR>',{desc='Start 2d jumping'})b.map('x',L,'<Cmd>lua MiniJump2d.start()<CR>',{desc='Start 2d jumping'})b.map('o',L,'<Cmd>lua MiniJump2d.start()<CR>',{desc='Start 2d jumping'})end;b.is_disabled=function()return vim.g.minijump2d_disable==true or vim.b.minijump2d_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minijump2d_config or{},c or{})end;b.spots_compute=function(j)local M=vim.api.nvim_get_current_win()local N=vim.tbl_filter(function(O)if O==M then return j.allowed_windows.current end;return j.allowed_windows.not_current end,b.tabpage_list_wins(0))local x={}for P,O in ipairs(N)do vim.api.nvim_win_call(O,function()local Q=vim.api.nvim_win_get_cursor(O)local R={win_id=O,win_id_init=M}local S=vim.api.nvim_win_get_buf(O)for T=vim.fn.line('w0'),vim.fn.line('w$')do local U=b.spot_find_in_line(T,R,j,Q)for P,V in ipairs(U)do table.insert(x,{line=T,column=V,buf_id=S,win_id=O})end end end)end;return x end;b.spots_add_steps=function(l,m,W)local X={}for P=1,#l do table.insert(X,{})end;b.populate_spot_steps(X,m,1,W+1)for T,z in ipairs(l)do z.steps=X[T]end;return l end;b.populate_spot_steps=function(Y,m,Z,_)local a0,a1=#Y,#m;if a0<=1 or _<Z then return end;local a2,a3=math.floor(a0/a1),a0%a1;local a4,a5=1,{}local a6=a2+(a4<=a3 and 1 or 0)for P,a7 in ipairs(Y)do table.insert(a7,m[a4])table.insert(a5,a7)if#a5>=a6 then b.populate_spot_steps(a5,m,Z+1,_)a4,a5=a4+1,{}a6=a2+(a4<=a3 and 1 or 0)end end end;b.spots_show=function(l,j)l=l or b.cache.spots or{}if#l==0 then b.message('No spots to show.')return end;local a8=vim.api.nvim_buf_set_extmark;local a9={}for P,aa in ipairs(b.spots_to_extmarks(l,j))do local ab={hl_mode='combine',priority=1000,virt_text=aa.virt_text,virt_text_pos='overlay'}local S,s=aa.buf_id,aa.line;pcall(a8,S,b.ns_id.spots,s,aa.col,ab)local ac=a9[S]or{}ac[s]=true;a9[S]=ac end;if j.view.dim then local ab={end_col=0,hl_eol=true,hl_group=j.hl_group_dim,priority=999}for S,ac in pairs(a9)do for P,ad in ipairs(vim.tbl_keys(ac))do ab.end_line=ad+1;pcall(a8,S,b.ns_id.dim,ad,0,ab)end end end;if b.is_operator_pending()then vim.cmd('redraw')end end;b.spots_unshow=function(l)l=l or b.cache.spots or{}local ae={}for P,t in ipairs(l)do ae[t.buf_id]=true end;for P,S in ipairs(vim.tbl_keys(ae))do pcall(vim.api.nvim_buf_clear_namespace,S,b.ns_id.spots,0,-1)pcall(vim.api.nvim_buf_clear_namespace,S,b.ns_id.dim,0,-1)end end;b.spots_to_extmarks=function(l,j)if#l==0 then return{}end;local af,ag,ah=j.hl_group,j.hl_group_ahead,j.hl_group_unique;local ai={}for P,t in ipairs(l)do local aj=t.steps[1]local ak=ai[aj]or 0;ai[aj]=ak+1 end;local al=function(am,X,an)local ao=ai[X[1]]==1 and ah or af;table.insert(am,{X[1],ao})local ap=table.concat(X):sub(2,an)if ap~=''then table.insert(am,{ap,ag})end end;local x={}local S,s,V,aq=l[1].buf_id,l[1].line-1,l[1].column-1,{}for T=1,#l-1 do local ar,as=l[T],l[T+1]local at=#ar.steps;local au=ar.buf_id==as.buf_id and ar.line==as.line;local av=au and as.column-ar.column or math.huge;local an=math.min(at,av)al(aq,ar.steps,an)local aw=au and at==av;if not aw then table.insert(x,{buf_id=S,line=s,col=V,virt_text=aq})S,s,V,aq=as.buf_id,as.line-1,as.column-1,{}end end;local ax=l[#l].steps;al(aq,ax,#ax)table.insert(x,{buf_id=S,line=s,col=V,virt_text=aq})return x end;b.spot_find_in_line=function(q,R,j,Q)local ay=j.allowed_lines;local az=Q[1]if not ay.cursor_before and q<az or not ay.cursor_at and q==az or not ay.cursor_after and q>az then return{}end;local aA=vim.fn.foldclosed(q)if aA~=-1 then return ay.fold and aA==q and{1}or{}end;if vim.fn.prevnonblank(q)~=q then return ay.blank and{1}or{}end;return j.spotter(q,R)end;b.advance_jump=function(j)local m=vim.split(j.labels,'')local l=b.cache.spots;local W=j.view.n_steps_ahead;if type(l)~='table'or#l<1 then b.spots_unshow(l)b.cache.spots=nil;return end;local aB=b.getcharstr('Enter encoding symbol to advance jump')if vim.tbl_contains(m,aB)then b.spots_unshow(l)l=vim.tbl_filter(function(aC)return aC.steps[1]==aB end,l)if#l>1 then l=b.spots_add_steps(l,m,W)b.spots_show(l,j)b.cache.spots=l;if b.is_operator_pending()then b.advance_jump(j)else vim.defer_fn(function()b.advance_jump(j)end,0)return end end end;if#l==1 or aB==b.keys.cr then vim.cmd('normal! m`')local aD=l[1]vim.api.nvim_set_current_win(aD.win_id)vim.api.nvim_win_set_cursor(aD.win_id,{aD.line,aD.column-1})vim.cmd('normal! zv')if j.hooks.after_jump~=nil then j.hooks.after_jump()end end;a.stop()end;b.echo=function(aE,aF)if b.get_config().silent then return end;aE=type(aE)=='string'and{{aE}}or aE;table.insert(aE,1,{'(mini.jump2d) ','WarningMsg'})local aG=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local aH,aI={},0;for P,aJ in ipairs(aE)do local aK={vim.fn.strcharpart(aJ[1],0,aG-aI),aJ[2]}table.insert(aH,aK)aI=aI+vim.fn.strdisplaywidth(aK[1])if aI>=aG then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(aH,aF,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(aE)b.echo(aE,true)end;b.is_operator_pending=function()return vim.tbl_contains({'no','noV',b.keys.block_operator_pending},vim.fn.mode(1))end;b.getcharstr=function(aE)local aL=true;if aE~=nil then vim.defer_fn(function()if not aL then return end;b.echo(aE)b.cache.msg_shown=true end,1000)end;b.cache.is_in_getcharstr=true;local P,aM=pcall(vim.fn.getcharstr)b.cache.is_in_getcharstr=false;aL=false;b.unecho()return aM end;b.input=function(aN,aO)local aP=vim.on_key or vim.register_keystroke_callback;local aQ=false;aP(function(aB)if aB==b.keys.esc then aQ=true end end,b.ns_id.input)local j={prompt='(mini.jump2d) '..aN..': ',default=aO or''}local aR,x=pcall(vim.fn.input,j)aP(nil,b.ns_id.input)if not aR or aQ then return end;return x end;b.tabpage_list_wins=function(aS)local aT=vim.api.nvim_tabpage_list_wins(aS)local aU={}for P,O in ipairs(aT)do local aV=vim.api.nvim_win_get_position(O)local c=vim.api.nvim_win_get_config(O)aU[O]={row=aV[1],col=aV[2],zindex=c.zindex or 0}end;table.sort(aT,function(aW,aX)if aU[aW].zindex<aU[aX].zindex then return true end;if aU[aW].zindex>aU[aX].zindex then return false end;if aU[aW].col<aU[aX].col then return true end;if aU[aW].col>aU[aX].col then return false end;return aU[aW].row<aU[aX].row end)return aT end;b.map=function(aY,aB,aZ,j)if aB==''then return end;j=vim.tbl_deep_extend('force',{noremap=true,silent=true},j or{})if vim.fn.has('nvim-0.7')==0 then j.desc=nil end;vim.api.nvim_set_keymap(aY,aB,aZ,j)end;b.merge_unique=function(a_,b0)if not(type(a_)=='table'and type(b0)=='table')then return end;local b1,b2=#a_,#b0;local x,T,b3={},1,1;local b4;while T<=b1 and b3<=b2 do if a_[T]<b0[b3]then b4=a_[T]T=T+1 else b4=b0[b3]b3=b3+1 end;if x[#x]~=b4 then table.insert(x,b4)end end;while T<=b1 do b4=a_[T]if x[#x]~=b4 then table.insert(x,b4)end;T=T+1 end;while b3<=b2 do b4=b0[b3]if x[#x]~=b4 then table.insert(x,b4)end;b3=b3+1 end;return x end;return a
