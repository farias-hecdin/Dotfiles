local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.6')==0 then vim.notify('(mini.starter) Official support for Neovim<0.6 will soon be dropped. Update to a newer version of Neovim.')end;_G.MiniStarter=a;c=b.setup_config(c)b.apply_config(c)vim.api.nvim_exec([[augroup MiniStarter
        au!
        au VimEnter * ++nested ++once lua MiniStarter.on_vimenter()
      augroup END]],false)vim.api.nvim_exec([[hi default link MiniStarterCurrent    NONE
      hi default link MiniStarterFooter     Title
      hi default link MiniStarterHeader     Title
      hi default link MiniStarterInactive   Comment
      hi default link MiniStarterItem       Normal
      hi default link MiniStarterItemBullet Delimiter
      hi default link MiniStarterItemPrefix WarningMsg
      hi default link MiniStarterSection    Delimiter
      hi default link MiniStarterQuery      MoreMsg]],false)end;a.config={autoopen=true,evaluate_single=false,items=nil,header=nil,footer=nil,content_hooks=nil,query_updaters='abcdefghijklmnopqrstuvwxyz0123456789_-.'}a.on_vimenter=function()if a.config.autoopen and not b.is_something_shown()then b.is_in_vimenter=true;a.open()end end;a.open=function(d)if b.is_disabled()then return end;if b.is_in_vimenter then d=vim.api.nvim_get_current_buf()end;if d==nil or not vim.api.nvim_buf_is_valid(d)then d=vim.api.nvim_create_buf(false,true)end;b.buffer_data[d]={current_item_id=1,query=''}local e=vim.b.ministarter_config;vim.api.nvim_set_current_buf(d)vim.b.ministarter_config=e;b.make_buffer_autocmd(d)b.apply_buffer_options(d)b.apply_buffer_mappings(d)a.refresh()vim.cmd('doautocmd User MiniStarterOpened')b.is_in_vimenter=false end;a.refresh=function(d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'refresh()')then return end;local f=b.buffer_data[d]local c=b.get_config()f.header=b.normalize_header_footer(c.header or b.default_header)local g=b.normalize_items(c.items or b.default_items)f.footer=b.normalize_header_footer(c.footer or b.default_footer)local h=b.make_initial_content(f.header,g,f.footer)local i=c.content_hooks or b.default_content_hooks;for j,k in ipairs(i)do h=k(h,d)end;f.content=h;local l=f.items;f.items=a.content_to_items(h)if not vim.deep_equal(f.items,l)then f.current_item_id=1 end;vim.api.nvim_buf_set_option(d,'modifiable',true)vim.api.nvim_buf_set_lines(d,0,-1,false,a.content_to_lines(h))vim.api.nvim_buf_set_option(d,'modifiable',false)b.content_highlight(d)b.items_highlight(d)b.position_cursor_on_current_item(d)b.add_hl_current_item(d)b.make_query(d)end;a.close=function(d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'close()')then return end;pcall(vim.api.nvim_buf_delete,d,{})end;a.sections={}a.sections.builtin_actions=function()return{{name='Edit new buffer',action='enew',section='Builtin actions'},{name='Quit Neovim',action='qall',section='Builtin actions'}}end;a.sections.sessions=function(m,n)m=m or 5;n=n==nil and true or n;return function()if _G.MiniSessions==nil then return{{name=[['mini.sessions' is not set up]],action='',section='Sessions'}}end;local g={}for o,p in pairs(_G.MiniSessions.detected)do table.insert(g,{_session=p,name=('%s%s'):format(o,p.type=='local'and' (local)'or''),action=([[lua _G.MiniSessions.read('%s')]]):format(o),section='Sessions'})end;if vim.tbl_count(g)==0 then return{{name=[[There are no detected sessions in 'mini.sessions']],action='',section='Sessions'}}end;local q;if n then q=function(r,s)local t=r._session.type=='local'and math.huge or r._session.modify_time;local u=s._session.type=='local'and math.huge or s._session.modify_time;return t>u end else q=function(r,s)local v=r._session.type=='local'and''or r.name;local w=s._session.type=='local'and''or s.name;return v<w end end;table.sort(g,q)return vim.tbl_map(function(x)x._session=nil;return x end,vim.list_slice(g,1,m))end end;a.sections.recent_files=function(m,y,z)m=m or 5;y=y==nil and false or y;z=z==nil and true or z;if y then vim.cmd('au DirChanged * lua MiniStarter.refresh()')end;return function()local A=('Recent files%s'):format(y and' (current directory)'or'')local B=vim.tbl_filter(function(k)return vim.fn.filereadable(k)==1 end,vim.v.oldfiles or{})if#B==0 then return{{name='There are no recent files (`v:oldfiles` is empty)',action='',section=A}}end;if y then local C=vim.loop.cwd()local D=C:len()B=vim.tbl_filter(function(k)return k:sub(1,D)==C end,B)end;if#B==0 then return{{name='There are no recent files in current directory',action='',section=A}}end;local g={}local E=vim.fn.fnamemodify;for j,k in ipairs(vim.list_slice(B,1,m))do local F=z and(' (%s)'):format(E(k,':~:.'))or''local G=('%s%s'):format(E(k,':t'),F)table.insert(g,{action=('edit %s'):format(E(k,':p')),name=G,section=A})end;return g end end;a.sections.telescope=function()return function()return{{action='Telescope file_browser',name='Browser',section='Telescope'},{action='Telescope command_history',name='Command history',section='Telescope'},{action='Telescope find_files',name='Files',section='Telescope'},{action='Telescope help_tags',name='Help tags',section='Telescope'},{action='Telescope live_grep',name='Live grep',section='Telescope'},{action='Telescope oldfiles',name='Old files',section='Telescope'}}end end;a.gen_hook={}a.gen_hook.padding=function(H,I)H=math.max(H or 0,0)I=math.max(I or 0,0)return function(h,j)local J=string.rep(' ',H)for j,K in ipairs(h)do local L=#K==0 or#K==1 and K[1].string==''if not L then table.insert(K,1,b.content_unit(J,'empty',nil))end end;local M={}for j=1,I do table.insert(M,{b.content_unit('','empty',nil)})end;h=vim.list_extend(M,h)return h end end;a.gen_hook.adding_bullet=function(N,O)N=N or'â–‘ 'O=O==nil and true or O;return function(h)local P=a.content_coords(h,'item')for Q=#P,1,-1 do local R,S=P[Q].line,P[Q].unit;local T={string=N,type='item_bullet',hl='MiniStarterItemBullet',_item=h[R][S].item,_place_cursor=O}table.insert(h[R],S,T)end;return h end end;a.gen_hook.indexing=function(U,V)U=U or'all'V=V or{}local W=U=='section'return function(h,j)local X,Y,Z=nil,0,0;local P=a.content_coords(h,'item')for j,_ in ipairs(P)do local a0=h[_.line][_.unit]local a1=a0.item;if not vim.tbl_contains(V,a1.section)then Z=Z+1;if X~=a1.section then X=a1.section;Y=math.fmod(Y,26)+1;Z=W and 1 or Z end;local a2=W and string.char(96+Y)or''a0.string=('%s%s. %s'):format(a2,Z,a0.string)end end;return h end end;a.gen_hook.aligning=function(a3,a4)a3=a3==nil and'left'or a3;a4=a4==nil and'top'or a4;local a5=({left=0,center=0.5,right=1.0})[a3]local a6=({top=0,center=0.5,bottom=1.0})[a4]return function(h,d)local a7=vim.fn.bufwinid(d)if a7<0 then return end;local a8=a.content_to_lines(h)local a9=vim.tbl_map(function(aa)return vim.fn.strdisplaywidth(aa)end,a8)local ab=vim.api.nvim_win_get_width(a7)-math.max(unpack(a9))local J=math.max(math.floor(a5*ab),0)local ac=vim.api.nvim_win_get_height(a7)-#a8;local ad=math.max(math.floor(a6*ac),0)return a.gen_hook.padding(J,ad)(h)end end;a.get_content=function(d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'get_content()','error')then return end;return b.buffer_data[d].content end;a.content_coords=function(h,ae)h=h or a.get_content()if ae==nil then ae=function(j)return true end end;if type(ae)=='string'then local af=ae;ae=function(a0)return a0.type==af end end;local ag={}for R,K in ipairs(h)do for S,a0 in ipairs(K)do if ae(a0)then table.insert(ag,{line=R,unit=S})end end end;return ag end;a.content_to_lines=function(h)return vim.tbl_map(function(ah)return table.concat(vim.tbl_map(function(x)return x.string:gsub('\n',' ')end,ah),'')end,h or a.get_content())end;a.content_to_items=function(h)h=h or a.get_content()local g={}for R,K in ipairs(h)do local ai=0;for j,a0 in ipairs(K)do local aj={R,ai}if a0.type=='item'then local a1=a0.item;a1.name=a0.string:gsub('\n',' ')a1._line=R-1;a1._start_col=ai;a1._end_col=ai+a0.string:len()a1._cursorpos=a1._cursorpos or aj;table.insert(g,a1)end;if a0.type=='item_bullet'and a0._place_cursor then a0._item._cursorpos=aj end;ai=ai+a0.string:len()end end;local ak=vim.tbl_map(function(x)return x.name:lower()end,g)local al=b.unique_nprefix(ak)for Q,m in ipairs(al)do g[Q]._nprefix=m end;return g end;a.eval_current_item=function(d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'eval_current_item()')then return end;b.make_query(vim.api.nvim_get_current_buf(),'',false)local f=b.buffer_data[d]b.eval_fun_or_string(f.items[f.current_item_id].action,true)end;a.update_current_item=function(am,d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'update_current_item()')then return end;local f=b.buffer_data[d]local an=f.current_item_id;f.current_item_id=b.next_active_item_id(d,f.current_item_id,am)if f.current_item_id==an then return end;b.position_cursor_on_current_item(d)vim.api.nvim_buf_clear_namespace(d,b.ns.current_item,0,-1)b.add_hl_current_item(d)end;a.add_to_query=function(ao,d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'add_to_query()')then return end;local f=b.buffer_data[d]local ap;if ao==nil then ap=f.query:sub(0,f.query:len()-1)else ap=('%s%s'):format(f.query,ao)end;b.make_query(d,ap)end;a.set_query=function(aq,d)aq=aq or''if type(aq)~='string'then error('`query` should be either `nil` or string.')end;d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'add_to_query()')then return end;b.make_query(d,aq)end;a.on_cursormoved=function(d)d=d or vim.api.nvim_get_current_buf()if not b.validate_starter_buf_id(d,'on_cursormoved()')then return end;b.position_cursor_on_current_item(d)end;b.default_config=a.config;b.default_items={function()if _G.MiniSessions==nil then return{}end;return a.sections.sessions(5,true)()end,a.sections.recent_files(5,false,false),a.sections.builtin_actions()}b.default_header=function()local ar=tonumber(vim.fn.strftime('%H'))local as=math.floor((ar+4)/8)+1;local at=({'evening','morning','afternoon','evening'})[as]local au=vim.loop.os_get_passwd()['username']or'USERNAME'return('Good %s, %s'):format(at,au)end;b.default_footer=[[
Type query to filter items
<BS> deletes latest character from query
<Esc> resets current query
<Down/Up>, <C-n/p>, <M-j/k> move current item
<CR> executes action of current item
<C-c> closes this buffer]]b.default_content_hooks={a.gen_hook.adding_bullet(),a.gen_hook.aligning('center','center')}b.buffer_data={}b.buffer_number=0;b.ns={activity=vim.api.nvim_create_namespace(''),current_item=vim.api.nvim_create_namespace(''),general=vim.api.nvim_create_namespace('')}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({autoopen={c.autoopen,'boolean'},evaluate_single={c.evaluate_single,'boolean'},items={c.items,'table',true},content_hooks={c.content_hooks,'table',true},query_updaters={c.query_updaters,'string'}})return c end;b.apply_config=function(c)a.config=c end;b.is_disabled=function()return vim.g.ministarter_disable==true or vim.b.ministarter_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.ministarter_config or{},c or{})end;b.normalize_items=function(g)local ag=b.items_flatten(g)if#ag==0 then return{{name='`config.items` is empty',action='',section=''}}end;return b.items_sort(ag)end;b.normalize_header_footer=function(x)if type(x)=='function'then x=x()end;local ag=tostring(x)if ag==''then return{}end;return vim.split(ag,'\n')end;b.make_initial_content=function(av,g,aw)local h={}for j,aa in ipairs(av)do b.content_add_line(h,{b.content_unit(aa,'header','MiniStarterHeader')})end;b.content_add_empty_lines(h,#av>0 and 1 or 0)b.content_add_items(h,g)b.content_add_empty_lines(h,#aw>0 and 1 or 0)for j,aa in ipairs(aw)do b.content_add_line(h,{b.content_unit(aa,'footer','MiniStarterFooter')})end;return h end;b.content_unit=function(string,type,ax,ay)return vim.tbl_extend('force',{string=string,type=type,hl=ax},ay or{})end;b.content_add_line=function(h,ah)table.insert(h,ah)end;b.content_add_empty_lines=function(h,m)for j=1,m do b.content_add_line(h,{b.content_unit('','empty',nil)})end end;b.content_add_items=function(h,g)local X;for j,a1 in ipairs(g)do if X~=a1.section then b.content_add_empty_lines(h,X==nil and 0 or 1)b.content_add_line(h,{b.content_unit(a1.section,'section','MiniStarterSection')})X=a1.section end;b.content_add_line(h,{b.content_unit(a1.name,'item','MiniStarterItem',{item=a1})})end end;b.content_highlight=function(d)for R,ah in ipairs(a.get_content(d))do local ai=0;for j,a0 in ipairs(ah)do if a0.hl~=nil then b.buf_hl(d,b.ns.general,a0.hl,R-1,ai,ai+a0.string:len(),50)end;ai=ai+a0.string:len()end end end;b.items_flatten=function(g)local ag,k={},nil;k=function(x)local az=0;while type(x)=='function'and az<=100 do az=az+1;if az>100 then b.message('Too many nested functions in `config.items`.')end;x=x()end;if b.is_item(x)then table.insert(ag,vim.deepcopy(x))return end;if type(x)~='table'then return end;return vim.tbl_map(k,x)end;k(g)return ag end;b.items_sort=function(g)local aA,aB={},{}for j,a1 in ipairs(g)do local aC=a1.section;if aB[aC]==nil then table.insert(aA,{})aB[aC]=#aA end;table.insert(aA[aB[aC]],a1)end;local ag={}for j,aD in ipairs(aA)do for j,a1 in ipairs(aD)do table.insert(ag,a1)end end;return ag end;b.items_highlight=function(d)for j,a1 in ipairs(b.buffer_data[d].items)do b.buf_hl(d,b.ns.general,'MiniStarterItemPrefix',a1._line,a1._start_col,a1._start_col+a1._nprefix,51)end end;b.next_active_item_id=function(d,aE,am)local g=b.buffer_data[d].items;local aF=aE;local aG=vim.tbl_count(g)local aH=am=='next'and 1 or aG-1;aF=math.fmod(aF+aH-1,aG)+1;while not(g[aF]._active or aF==aE)do aF=math.fmod(aF+aH-1,aG)+1 end;return aF end;b.position_cursor_on_current_item=function(d)local f=b.buffer_data[d]local aj=f.items[f.current_item_id]._cursorpos;for j,a7 in ipairs(b.get_buffer_windows(d))do vim.api.nvim_win_set_cursor(a7,aj)end end;b.item_is_active=function(a1,aq)return vim.startswith(a1.name:lower(),aq)and a1.action~=''end;b.make_query=function(d,aq,aI)if aI==nil then aI=true end;local f=b.buffer_data[d]aq=(aq or f.query):lower()local aJ=0;for j,a1 in ipairs(f.items)do aJ=aJ+(b.item_is_active(a1,aq)and 1 or 0)end;if aJ==0 and aq~=''then b.message(('Query %s results into no active items. Current query: %s'):format(vim.inspect(aq),f.query))return end;f.query=aq;for j,a1 in ipairs(f.items)do a1._active=b.item_is_active(a1,aq)end;if not f.items[f.current_item_id]._active then a.update_current_item('next',d)end;vim.api.nvim_buf_clear_namespace(d,b.ns.activity,0,-1)b.add_hl_activity(d,aq)if b.get_config().evaluate_single and aJ==1 then a.eval_current_item(d)return end;if aI and not b.is_in_vimenter then vim.cmd('redraw')b.echo(('Query: %s'):format(aq))end end;b.make_buffer_autocmd=function(d)local aK=string.format([[augroup MiniStarterBuffer
        au!
        au VimResized <buffer=%s> lua MiniStarter.refresh()
        au CursorMoved <buffer=%s> lua MiniStarter.on_cursormoved()
        au BufLeave <buffer=%s> echo ''
        au BufLeave <buffer=%s> if &showtabline==1 | set showtabline=%s | endif
      augroup END]],d,d,d,d,vim.o.showtabline)vim.cmd(aK)end;b.apply_buffer_options=function(d)vim.cmd('normal! <ESC>')b.buffer_number=b.buffer_number+1;local G=b.buffer_number<=1 and'Starter'or'Starter_'..b.buffer_number;vim.api.nvim_buf_set_name(d,G)vim.cmd('noautocmd silent! set filetype=starter')local aL={'bufhidden=wipe','colorcolumn=','foldcolumn=0','matchpairs=','nobuflisted','nocursorcolumn','nocursorline','nolist','nonumber','noreadonly','norelativenumber','nospell','noswapfile','signcolumn=no','synmaxcol&','buftype=nofile','nomodeline','nomodifiable','foldlevel=999'}vim.cmd(('silent! noautocmd setlocal %s'):format(table.concat(aL,' ')))vim.o.showtabline=1;vim.b.minicursorword_disable=true;vim.b.minitrailspace_disable=true;if _G.MiniTrailspace~=nil then _G.MiniTrailspace.unhighlight()end end;b.apply_buffer_mappings=function(d)b.buf_keymap(d,'<CR>','MiniStarter.eval_current_item()')b.buf_keymap(d,'<Up>',[[MiniStarter.update_current_item('prev')]])b.buf_keymap(d,'<C-p>',[[MiniStarter.update_current_item('prev')]])b.buf_keymap(d,'<M-k>',[[MiniStarter.update_current_item('prev')]])b.buf_keymap(d,'<Down>',[[MiniStarter.update_current_item('next')]])b.buf_keymap(d,'<C-n>',[[MiniStarter.update_current_item('next')]])b.buf_keymap(d,'<M-j>',[[MiniStarter.update_current_item('next')]])for j,aM in ipairs(vim.split(b.get_config().query_updaters,''))do local aN=vim.inspect(tostring(aM))b.buf_keymap(d,aM,('MiniStarter.add_to_query(%s)'):format(aN))end;b.buf_keymap(d,'<Esc>',[[MiniStarter.set_query('')]])b.buf_keymap(d,'<BS>','MiniStarter.add_to_query()')b.buf_keymap(d,'<C-c>','MiniStarter.close()')end;b.add_hl_activity=function(d,aq)for j,a1 in ipairs(b.buffer_data[d].items)do local aa=a1._line;local aO=a1._start_col;local aP=a1._end_col;if a1._active then b.buf_hl(d,b.ns.activity,'MiniStarterQuery',aa,aO,aO+aq:len(),53)else b.buf_hl(d,b.ns.activity,'MiniStarterInactive',aa,aO,aP,53)end end end;b.add_hl_current_item=function(d)local f=b.buffer_data[d]local aQ=f.items[f.current_item_id]b.buf_hl(d,b.ns.current_item,'MiniStarterCurrent',aQ._line,aQ._start_col,aQ._end_col,52)end;b.is_fun_or_string=function(x,aR)if aR==nil then aR=true end;return aR and x==nil or type(x)=='function'or type(x)=='string'end;b.is_item=function(x)return type(x)=='table'and b.is_fun_or_string(x['action'],false)and type(x['name'])=='string'and type(x['section'])=='string'end;b.is_something_shown=function()local aS=vim.api.nvim_buf_get_lines(0,0,-1,true)if#aS>1 or#aS==1 and aS[1]:len()>0 then return true end;local aT=vim.tbl_filter(function(d)return vim.fn.buflisted(d)==1 end,vim.api.nvim_list_bufs())if#aT>1 then return true end;if vim.fn.argc()>0 then return true end;return false end;b.echo=function(aU,aV)aU=type(aU)=='string'and{{aU}}or aU;table.insert(aU,1,{'(mini.starter) ','WarningMsg'})local aW=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local aX,aY={},0;for j,aZ in ipairs(aU)do local a_={vim.fn.strcharpart(aZ[1],0,aW-aY),aZ[2]}table.insert(aX,a_)aY=aY+vim.fn.strdisplaywidth(a_[1])if aY>=aW then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(aX,aV,{})end;b.message=function(aU)b.echo(aU,true)end;b.error=function(aU)error(string.format('(mini.starter) %s',aU))end;b.validate_starter_buf_id=function(d,b0,b1)local b2=type(d)=='number'and vim.tbl_contains(vim.tbl_keys(b.buffer_data),d)and vim.api.nvim_buf_is_valid(d)if b2 then return true end;local aU=string.format('`buf_id` in `%s` is not an identifier of valid Starter buffer.',b0)if b1=='error'then b.error(aU)end;b.message(aU)return false end;b.eval_fun_or_string=function(x,b3)if type(x)=='function'then return x()end;if type(x)=='string'then if b3 then vim.cmd(x)else return x end end end;b.buf_keymap=function(d,aM,b4)vim.api.nvim_buf_set_keymap(d,'n',aM,('<Cmd>lua %s<CR>'):format(b4),{nowait=true,silent=true})end;if vim.fn.has('nvim-0.7')==1 then b.buf_hl=function(d,b5,b6,K,b7,b8,b9)vim.highlight.range(d,b5,b6,{K,b7},{K,b8},{priority=b9})end else b.buf_hl=function(d,b5,b6,K,b7,b8)vim.highlight.range(d,b5,b6,{K,b7},{K,b8})end end;b.get_buffer_windows=function(d)return vim.tbl_filter(function(a7)return vim.api.nvim_win_get_buf(a7)==d end,vim.api.nvim_list_wins())end;b.unique_nprefix=function(ak)local ba=vim.deepcopy(ak)local ag,bb={},0;while vim.tbl_count(ba)>0 do bb=bb+1;local bc,bd={},true;for aF,aO in pairs(ba)do bd=bd and#aO<bb;local be=aO:sub(1,bb)bc[be]=bc[be]==nil and{}or bc[be]table.insert(bc[be],aF)end;if bd then for bf,aO in pairs(ba)do ag[bf]=#aO end;break end;for j,bg in pairs(bc)do if#bg==1 then local bf=bg[1]ag[bf]=math.min(#ba[bf],bb)ba[bf]=nil end end end;return ag end;return a
