local a=require("which-key.tree")local b=require("which-key.util")local c=require("which-key.config")local d="Ãž"local e={}e.functions={}e.operators={}e.nowait={}e.blacklist={}function e.setup()local f=require("which-key.plugins.presets").operators;for g,h in pairs(f)do e.operators[g]=true end;local i={}for g,j in pairs(c.options.operators)do e.operators[g]=true;if f[g]then i[g]={name=j,i={name="inside"},a={name="around"}}end end;for h,k in pairs(c.options.triggers_nowait)do e.nowait[k]=true end;e.register(i,{mode="n",preset=true})e.register({i={name="inside"},a={name="around"}},{mode="v",preset=true})for l,m in pairs(c.options.triggers_blacklist)do for h,n in ipairs(m)do e.blacklist[l]=e.blacklist[l]or{}e.blacklist[l][n]=true end end end;function e.get_operator(o)for p,h in pairs(c.options.operators)do local q=b.t(p)if o:sub(1,#q)==q then return q,p end end end;function e.process_motions(r,l,o,s)local q,p="",""if l~="v"then q,p=e.get_operator(o)end;if(l=="n"or l=="v")and q then local t=o:sub(#q+1)local u=t:match("^(%d+)")if u=="0"then u=nil end;if c.options.motions.count==false then u=nil end;if u then t=t:sub(#u+1)end;local v=e.get_mappings("o",t,s)if not r.mapping and v.mapping then r.mapping=v.mapping;r.mapping.prefix=p..(u or"")..r.mapping.prefix;r.mapping.keys=b.parse_keys(r.mapping.prefix)end;for h,w in pairs(v.mappings)do w.prefix=p..(u or"")..w.prefix;w.keys=b.parse_keys(w.prefix)table.insert(r.mappings,w)end end end;function e.get_mappings(l,o,s)local r;r={mapping=nil,mappings={},mode=l,buf=s,prefix_i=o}local x=#b.parse_internal(o)local function y(z)if z then if z.mapping then r.mapping=vim.tbl_deep_extend("force",{},r.mapping or{},z.mapping)end;for A,B in pairs(z.children)do if B.mapping and B.mapping.label~="which_key_ignore"then r.mappings[A]=vim.tbl_deep_extend("force",{},r.mappings[A]or{},B.mapping)end end end end;local C={buf=s,mode=l}y(e.get_tree(l).tree:get(o,nil,C))y(e.get_tree(l,s).tree:get(o,nil,C))e.process_motions(r,l,o,s)local D={}for h,E in pairs(r.mappings)do E.key=E.keys.notation[x+1]if c.options.key_labels[E.key]then E.key=c.options.key_labels[E.key]end;local F=not E.label and c.options.ignore_missing==true;if b.t(E.key)==b.t("<esc>")then F=true end;if not F then if E.group then E.label=E.label or"+prefix"E.label=E.label:gsub("^%+","")E.label=c.options.icons.group..E.label elseif not E.label then E.label=E.desc or E.cmd or""for h,G in ipairs(c.options.hidden)do E.label=E.label:gsub(G,"")end end;if E.value then E.value=vim.fn.strtrans(E.value)end;table.insert(D,E)end end;table.sort(D,function(H,I)if H.order and I.order then return H.order<I.order end;if H.group==I.group then local J=(H.key or""):lower()local K=(I.key or""):lower()local L=J:match("[a-z]")and 1 or 0;local M=K:match("[a-z]")and 1 or 0;if L==M then return J<K end;return L<M else return(H.group and 1 or 0)<(I.group and 1 or 0)end end)r.mappings=D;return r end;e.mappings={}e.duplicates={}function e.map(l,n,N,s,O)local P=vim.api.nvim_buf_call(s or 0,function()local r=vim.fn.maparg(n,l,false,true)return r and r.lhs and r.rhs and r.rhs~=N and r or nil end)if P then table.insert(e.duplicates,{mode=l,prefix=n,cmd=N,buf=s,other=P})end;if s~=nil then pcall(vim.api.nvim_buf_set_keymap,s,l,n,N,O)else pcall(vim.api.nvim_set_keymap,l,n,N,O)end end;function e.register(i,O)O=O or{}i=require("which-key.mappings").parse(i,O)local Q={}for h,w in pairs(i)do if not Q[w.mode]then Q[w.mode]=true;e.get_tree(w.mode)end;if w.cmd~=nil then e.map(w.mode,w.prefix,w.cmd,w.buf,w.opts)end;e.get_tree(w.mode,w.buf).tree:add(w)end end;e.hooked={}function e.hook_id(n,l,s)return l..(s or"")..b.t(n)end;function e.is_hooked(n,l,s)return e.hooked[e.hook_id(n,l,s)]end;function e.hook_del(n,l,s)local R=e.hook_id(n,l,s)e.hooked[R]=nil;if s then pcall(vim.api.nvim_buf_del_keymap,s,l,n)pcall(vim.api.nvim_buf_del_keymap,s,l,n..d)else pcall(vim.api.nvim_del_keymap,l,n)pcall(vim.api.nvim_del_keymap,l,n..d)end end;function e.hook_add(n,l,s,S)if e.blacklist[l]and e.blacklist[l][n]then return end;if tonumber(n)then return end;if l=="i"and(n=="j"or n=="k")then return end;if l=="n"and n=="q"then return end;if l=="s"then return end;if l=="o"then return end;if b.t(n)==b.t("<esc>")then return end;if(l=="v"or l=="x")and e.operators[n]then return end;if type(c.options.triggers)=="string"and c.options.triggers~="auto"then if b.t(n)~=b.t(c.options.triggers)then return end end;if type(c.options.triggers)=="table"then local T=false;for h,U in pairs(c.options.triggers)do if b.t(U)==b.t(n)then T=true;break end end;if not T then return end end;local O={noremap=true,silent=true}local R=e.hook_id(n,l,s)local V=e.hook_id(n,l)if not e.hooked[R]and not e.hooked[V]then local N=[[<cmd>lua require("which-key").show(%q, {mode = %q, auto = true})<cr>]]N=string.format(N,b.t(n),l)local W=l=="v"and"x"or l;if S~=true then e.map(W,n,N,s,O)end;if not e.nowait[n]then e.map(W,n..d,"<nop>",s,O)end;e.hooked[R]=true end end;function e.update(s)for A,X in pairs(e.mappings)do if X.buf and not vim.api.nvim_buf_is_valid(X.buf)then e.mappings[A]=nil elseif not s or not X.buf or s==X.buf then e.update_keymaps(X.mode,X.buf)e.add_hooks(X.mode,X.buf,X.tree.root)end end end;function e.add_hooks(l,s,z,S)if not z.mapping then z.mapping={prefix=z.prefix_n,group=true,keys=b.parse_keys(z.prefix_n)}end;if z.prefix_n~=""and z.mapping.group==true and not z.mapping.cmd then e.hook_add(z.prefix_n,l,s,S)S=true end;for h,B in pairs(z.children)do e.add_hooks(l,s,B,S)end end;function e.dump()local T={}local Y={}for h,X in pairs(e.mappings)do e.update_keymaps(X.mode,X.buf)X.tree:walk(function(z)if z.mapping then if z.mapping.label then T[z.mapping.prefix]=true;Y[z.mapping.prefix]=nil elseif not T[z.mapping.prefix]then Y[z.mapping.prefix]={z.mapping.cmd or""}end end end)end;return Y end;function e.check_health()vim.health.report_start("WhichKey: checking conflicting keymaps")for h,X in pairs(e.mappings)do e.update_keymaps(X.mode,X.buf)X.tree:walk(function(z)local Z=0;for h in pairs(z.children)do Z=Z+1 end;local _=not z.mapping or z.mapping.group==true and not z.mapping.cmd;if z.prefix_i~=""and Z>0 and not _ then local a0=("conflicting keymap exists for mode **%q**, lhs: **%q**"):format(X.mode,z.mapping.prefix)vim.health.report_warn(a0)local N=z.mapping.cmd or" "vim.health.report_info(("rhs: `%s`"):format(N))end end)end;for h,a1 in pairs(e.duplicates)do local a0=""if a1.buf==a1.other.buffer then a0="duplicate keymap"else a0="buffer-local keymap overriding global"end;a0=(a0 .." for mode **%q**, buf: %d, lhs: **%q**"):format(a1.mode,a1.buf or 0,a1.prefix)if a1.buf==a1.other.buffer then vim.health.report_error(a0)else vim.health.report_warn(a0)end;vim.health.report_info(("old rhs: `%s`"):format(a1.other.rhs or""))vim.health.report_info(("new rhs: `%s`"):format(a1.cmd or""))end end;function e.get_tree(l,s)if l=="s"or l=="x"then l="v"end;b.check_mode(l,s)local a2=l..(s or"")if not e.mappings[a2]then e.mappings[a2]={mode=l,buf=s,tree=a:new()}end;return e.mappings[a2]end;function e.is_hook(a3,N)local a4=a3:find(d)local a5=N and N:find("which%-key")and N:find("auto")or false;return a5 or a4 end;function e.update_keymaps(l,s)local a6=s and vim.api.nvim_buf_get_keymap(s,l)or vim.api.nvim_get_keymap(l)local X=e.get_tree(l,s).tree;local function a7(a8)return not a8.callback and b.t(a8.rhs)==""end;for h,a8 in pairs(a6)do local F=e.is_hook(a8.lhs,a8.rhs)if a7(a8)then F=true end;if not F and b.t(a8.lhs)==b.t("<leader>")and l=="n"then if a7(a8)then F=true else b.warn(string.format("Your <leader> key for %q mode in buf %d is currently mapped to %q. ".."WhichKey automatically creates triggers, so please remove the mapping",l,s or 0,a8.rhs))end end;if not F then local w={id=b.t(a8.lhs),prefix=a8.lhs,cmd=a8.rhs,desc=a8.desc,keys=b.parse_keys(a8.lhs)}if w.keys.notation[1]:lower()~="<plug>"then X:add(w)end end end end;return e
