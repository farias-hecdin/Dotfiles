local a=require('cmp')local function b(c,d)local e=[[\%(]]..table.concat(c,[[\|]])..[[\)]]if d then e='^'..e end;return vim.regex(e)end;local f={ignore_cmds={'Man','!'}}local g=b({[=[\s*abo\%[veleft]\s*]=],[=[\s*bel\%[owright]\s*]=],[=[\s*bo\%[tright]\s*]=],[=[\s*bro\%[wse]\s*]=],[=[\s*conf\%[irm]\s*]=],[=[\s*hid\%[e]\s*]=],[=[\s*keepal\s*t]=],[=[\s*keeppa\%[tterns]\s*]=],[=[\s*lefta\%[bove]\s*]=],[=[\s*loc\%[kmarks]\s*]=],[=[\s*nos\%[wapfile]\s*]=],[=[\s*rightb\%[elow]\s*]=],[=[\s*sil\%[ent]\s*]=],[=[\s*tab\s*]=],[=[\s*to\%[pleft]\s*]=],[=[\s*verb\%[ose]\s*]=],[=[\s*vert\%[ical]\s*]=]},true)local h=b({[=[\s*\%(\d\+\|\$\)\%[,\%(\d\+\|\$\)]\s*]=],[=[\s*'\%[<,'>]\s*]=],[=[\s*\%(\d\+\|\$\)\s*]=]},true)local i=b({[=[se\%[tlocal]]=]},true)local j={{ctype='cmdline',regex=[=[[^[:blank:]]*$]=],kind=a.lsp.CompletionItemKind.Variable,isIncomplete=true,exec=function(k,l,m,n,o)local p,q=pcall(function()local r=m;local s,t=h:match_str(r)if s and t then r=r:sub(t+1)end;return vim.api.nvim_parse_cmd(r,{})or{}end)q=q or{}if vim.tbl_contains(k.ignore_cmds,q.cmd)then return{}end;if l~=m then while true do local s,t=g:match_str(m)if s==nil then break end;m=string.sub(m,t+1)end end;if l==m then while true do local s,t=h:match_str(m)if s==nil then break end;m=string.sub(m,t+1)end end;local u;do local v=vim.regex([[\h\w*$]]):match_str(l)u=string.sub(l,1,v or#l)end;if not o and m==''then return{}end;local w=i:match_str(m)~=nil;local x={}local y=m:gsub([[\\]],[[\\\\]])for p,z in ipairs(vim.fn.getcompletion(y,'cmdline'))do local A=type(z)=='string'and z or z.word;local B={word=A}table.insert(x,B)if w then table.insert(x,vim.tbl_deep_extend('force',{},B,{word='no'..B.word}))end end;for p,B in ipairs(x)do if not string.find(B.word,u,1,true)then B.word=u..B.word end end;return x end}}local C={}C.new=function()return setmetatable({before_line='',offset=-1,ctype='',items={}},{__index=C})end;C.get_keyword_pattern=function()return[=[[^[:blank:]]*]=]end;C.get_trigger_characters=function()return{' ','.','#','-'}end;C.complete=function(self,D,E)local F=0;local G=''local x={}local H=''local I=false;for p,J in ipairs(j)do local s,t=vim.regex(J.regex):match_str(D.context.cursor_before_line)if s and t then F=s;G=J.type;x=J.exec(vim.tbl_deep_extend('keep',D.option,f),string.sub(D.context.cursor_before_line,s+1),D.context.cursor_before_line,D.context.cursor.col,D.context:get_reason()==a.ContextReason.Manual)H=J.kind;I=J.isIncomplete;if not(#x==0 and J.fallback)then break end end end;local K={}x=vim.tbl_map(function(B)if type(B)=='string'then B={label=B,kind=H}else B={label=B.word,kind=H}end;K[B.label]=true;return B end,x)local L=false;if#D.context.cursor_before_line>#self.before_line then L=string.find(D.context.cursor_before_line,self.before_line,1,true)==1 elseif#D.context.cursor_before_line<#self.before_line then L=string.find(self.before_line,D.context.cursor_before_line,1,true)==1 end;if L and self.offset==F and self.ctype==G then for p,B in ipairs(self.items)do if not K[B.label]then table.insert(x,B)end end end;self.before_line=D.context.cursor_before_line;self.offset=F;self.ctype=G;self.items=x;E({isIncomplete=I,items=x})end;return C
