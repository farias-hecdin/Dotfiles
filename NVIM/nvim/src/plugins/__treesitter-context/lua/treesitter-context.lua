local a=vim.api;local b=require'nvim-treesitter.ts_utils'local c=vim.treesitter.highlighter;local d=require'nvim-treesitter.parsers'local e=a.nvim_create_augroup;local f=a.nvim_create_user_command;local function g(h)return'%f[%w]'..h..'%f[^%w]'end;local i={enable=true,max_lines=0,min_window_height=0,line_numbers=true,multiline_threshold=20,trim_scope='outer',zindex=20,mode='cursor',separator=nil}local j={}local k;local l=1;local m=2;do local function n(o)return{name=o,kind=l}end;local function p(o)return{name=o,kind=m}end;k={[g('function')]={c={n'declarator'},cpp={n'declarator'},lua={n'parameters'},teal={n'signature'},python={n'return_type',n'parameters'},rust={n'return_type',n'parameters'},javascript={n'parameters'},typescript={n'return_type',n'parameters'}},[g('method')]={lua={n'parameters'},javascript={n'parameters'},typescript={n'return_type',n'parameters'}},[g('class')]={cpp={p'base_class_clause',n'name'},python={n'superclasses'}}}end;local q={[g('class')]={php='attribute_list'},[g('method')]={php='attribute_list'}}local r={default={'class','function','method','for','while','if','switch','case','interface','struct','enum'},elixir={'anonymous_function','arguments','block','do_block','list','map','tuple','quoted_content'},haskell={'adt'},json={'pair'},markdown={'section'},python={'with_statement'},rust={'impl_item'},scala={'object_definition'},terraform={'block','object_elem','attribute'},tex={'chapter','section','subsection','subsubsection'},typescript={'export_statement'},verilog={'always_construct','statement_or_null'},vhdl={'process_statement','architecture_body','entity_declaration'},yaml={'block_mapping_pair'},exact_patterns={}}local s={default={},teal={'function_body'}}local t='^%s+'local u=false;local v=false;local w,x;local y,z;local A=a.nvim_create_namespace('nvim-treesitter-context')local B;local function C()local D=d.get_parser():parse()[1]return D:root()end;local function E(F,G)local H=F:type()for I,J in ipairs(j.exclude_patterns.default)do if H:find(J)then return true end end;local K=j.exclude_patterns[G]for I,J in ipairs(K or{})do if H:find(J)then return true end end;return false end;local function L(F,G)if E(F,G)then return false end;local H=F:type()for I,J in ipairs(j.patterns.default)do if H:find(J)then return true end end;local K=j.patterns[G]for I,J in ipairs(K or{})do if H:find(J)then return true end end;return false end;local function M(F,N)local H=F:type()for I,J in ipairs(N)do if H:find(J)then return J end end end;local function O(F,P)if P.kind==l then local Q=F:field(P.name)if Q and Q[1]then return Q[1]end elseif P.kind==m then local R=b.get_named_children(F)for I,S in ipairs(R)do if S:type()==P.name then return S end end end end;local function T(F)local type=M(F,j.patterns.default)or F:type()local G=vim.bo.filetype;local U,V=F:start()local W,X=F:end_()local Y=vim.treesitter.query.get_node_text(F,0)if Y==nil then return nil,nil end;local Z=vim.split(Y,'\n')if V~=0 then Z[1]=a.nvim_buf_get_lines(0,U,U+1,false)[1]end;V=0;local _=(k[type]or{})[G]local a0;if _ then local a1;for I,a2 in ipairs(_)do local a3=O(F,a2)if a3 then a1=a3;break end end;if a1 then a0={a1:end_()}W=a0[1]X=a0[2]local a4=W-U;Z=vim.list_slice(Z,1,a4+1)Z[#Z]=Z[#Z]:sub(1,X)end end;if not a0 or#Z>j.multiline_threshold then Z=vim.list_slice(Z,1,1)W=U;X=#Z[1]end;local a5={U,V,W,X}return Z,a5 end;local function a6(Z)local a7={Z[1]}for a8=2,#Z do a7[a8]=Z[a8]:gsub(t,'')end;return table.concat(a7,' ')end;local function a9(Z)local aa=vim.tbl_map(function(ab)local ac=ab:match(t)return ac and#ac or 0 end,Z)aa[1]=0;return aa end;local function ad()return vim.fn.getwininfo(vim.api.nvim_get_current_win())[1].textoff end;local ae;do local ab;ae=function()local af=vim.api.nvim_win_get_cursor(0)[1]if af~=ab then ab=af;return true end;return false end end;local function ag()if not z or not a.nvim_buf_is_valid(z)then z=a.nvim_create_buf(false,true)end;if not y or not a.nvim_buf_is_valid(y)then y=a.nvim_create_buf(false,true)end;return y,z end;local function ah()if z and a.nvim_buf_is_valid(z)then a.nvim_buf_delete(z,{force=true})end;z=nil;if y and a.nvim_buf_is_valid(y)then a.nvim_buf_delete(y,{force=true})end;y=nil end;local function ai(aj,ak,al,am,an,ao,ap)if not ak or not a.nvim_win_is_valid(ak)then local aq=j.separator;ak=a.nvim_open_win(aj,false,{relative='win',width=al,height=am,row=0,col=an,focusable=false,style='minimal',noautocmd=true,zindex=j.zindex,border=aq and{'','','','',aq,aq,aq,''}or nil})a.nvim_win_set_var(ak,ao,true)a.nvim_win_set_option(ak,'wrap',false)a.nvim_win_set_option(ak,'foldenable',false)a.nvim_win_set_option(ak,'winhl','NormalFloat:'..ap)else a.nvim_win_set_config(ak,{win=a.nvim_get_current_win(),relative='win',width=al,height=am,row=0,col=an})end;return ak end;local ar={config=j}local function as(at)if at==0 then return end;if not d.has_parser()then return end;local au=C()local av,an;if j.mode=='topline'then av,an=vim.fn.line('w0'),0 else av,an=unpack(a.nvim_win_get_cursor(0))end;local aw;local ax={}local ay=0;repeat local az=av+ay-1;local F=au:named_descendant_for_range(az,an,az,an)if not F then return end;aw=ax;ax={}local aA=-1;local aB=vim.fn.line('w0')local aC={}while F~=nil do aC[#aC+1]=F;F=F:parent()end;for a8=#aC,1,-1 do local aD=aC[a8]local aE=aD:start()local am=math.min(at,#ax)if L(aD,vim.bo.filetype)and aE>=0 and aE<aB+am-1 then if aE==aA then ax[#ax]=aD else table.insert(ax,aD)aA=aE;local aF=math.min(at,#ax)if j.mode=='topline'and ay<aF then ay=ay+1;break end end end end until j.mode~='topline'or#aw>=#ax;if j.trim_scope=='inner'then return vim.list_slice(ax,1,math.min(#ax,at))else return vim.list_slice(ax,math.max(1,#ax-at+1),#ax)end end;local function aG(aH)local aI=false;local aJ=false;local function aK()if aJ then aI=true else local aL=vim.loop.hrtime()aH()local aM=math.floor((vim.loop.hrtime()-aL)/1e6)if aM>2 then aJ=true;vim.defer_fn(function()aJ=false;if aI then aI=false;aK()end end,20)end end end;return aK end;local function aN()B=nil;if vim.fn.getcmdwintype()~=''then return end;if x~=nil and a.nvim_win_is_valid(x)then a.nvim_win_close(x,true)end;x=nil;if w and a.nvim_win_is_valid(w)then a.nvim_win_close(w,true)end;w=nil end;local function aO(aj,Z)local aP=a.nvim_buf_get_lines(aj,0,-1,false)local aQ=false;if#aP~=#Z then aQ=true else for a8,aR in ipairs(aP)do if aR~=Z[a8]then aQ=true;break end end end;if aQ then a.nvim_buf_set_lines(aj,0,-1,false,Z)a.nvim_buf_set_option(aj,'modified',false)end;return aQ end;local function aS(aj,aT,aU)a.nvim_buf_clear_namespace(aT,A,0,-1)local aV=c.active[aj]if not aV then local aW=vim.bo.filetype;if aW~=vim.bo[aT].filetype then vim.bo[aT].filetype=aW end;return end;local aX=vim.bo.tabstop;if aX~=vim.bo[aT].tabstop then vim.bo[aT].tabstop=aX end;local aY=aV:get_query(d.ft_to_lang(vim.bo.filetype))local P=aY:query()local aZ=C()for a8,a_ in ipairs(aU)do local U,I,W,X=unpack(a_.range)local aa=a_.indents;local Z=a_.lines;local b0=a_.node:start()for b1,F in P:iter_captures(aZ,aj,U,a_.node:end_())do local b2,b3,b4,b5=F:range()if b4>W or b4==W and b5>X then break end;if b2>=b0 then local b6=b2-b0;local b7=b6;for b8=1,b6 do b7=b7+#Z[b8]-aa[b8]end;b7=b7-aa[b6+1]local aE=a8-1;a.nvim_buf_set_extmark(aT,A,aE,b3+b7,{end_line=aE,end_col=b5+b7,hl_group=aY.hl_cache[b1]})end end end end;local function b9(av,al)return string.format('%'..al..'d',av)end;local function ba(bb)local bc=vim.fn.line('.')local bd=0;local be=bb;while be<bc do local bf=vim.fn.foldclosedend(be)if bf==-1 then be=be+1 else bd=bd+bf-be;be=bf+1 end end;return bc-bb-bd end;local function bg()if x==nil then return end;local bh=vim.fn.winsaveview()local bi=a.nvim_win_call(x,vim.fn.winsaveview)if bh.leftcol~=bi.leftcol then bi.leftcol=bh.leftcol;a.nvim_win_call(x,function()return vim.fn.winrestview({leftcol=bi.leftcol})end)end end;local function bj(F)local type=M(F,j.patterns.default)or F:type()local G=vim.bo.filetype;local bk=(q[type]or{})[G]if bk then local R=b.get_named_children(F)for I,a1 in ipairs(R)do if a1:type()~=bk then F=a1;break end end end;return F end;local function bl(bm)local aj=a.nvim_get_current_buf()local bn=ad()local bo=math.max(1,a.nvim_win_get_width(0)-bn)local bp=math.max(1,#bm)local bq,aT=ag()if j.line_numbers and(vim.wo.number or vim.wo.relativenumber)then w=ai(bq,w,bn,bp,0,'treesitter_context_line_number','TreesitterContextLineNumber')end;x=ai(aT,x,bo,bp,bn,'treesitter_context','TreesitterContext')local br={}local bs={}local aU={}for I,F in ipairs(bm)do F=bj(F)local Z,a5=T(F)if Z==nil or a5==nil or a5[1]==nil then return end;local a7=a6(Z)aU[#aU+1]={node=F,lines=Z,range=a5,indents=a9(Z)}table.insert(br,a7)local bt;local bu=a5[1]+1;if vim.o.relativenumber then bt=ba(bu)else bt=bu end;table.insert(bs,b9(bt,bn-1))end;aO(bq,bs)if not aO(aT,br)then return end;aS(aj,aT,aU)a.nvim_buf_set_extmark(aT,A,#bs-1,0,{end_line=#bs,hl_group='TreesitterContextBottom',hl_eol=true})a.nvim_buf_set_extmark(bq,A,#br-1,0,{end_line=#br,hl_group='TreesitterContextBottom',hl_eol=true})end;local function bv(bw)local at=bw;at=at==0 and-1 or at;local bx=vim.fn.line('w0')local by=vim.fn.line('.')local bz=by-bx;if j.separator and bz>0 then bz=bz-1 end;if at~=-1 then at=math.min(at,bz)else at=bz end;return at end;local bA=aG(function()if vim.bo.buftype~=''or vim.wo.previewwindow then aN()return end;local a_=as(bv(j.max_lines))if a_ and#a_~=0 then if a_==B then return end;B=a_;if a.nvim_win_get_height(0)<j.min_window_height then aN()return end;bl(a_)bg()else aN()end end)local function bB(bC)local bD=e(bC,{})return function(bE,bF)if bF then if type(bF)=='function'then bF={callback=bF}elseif bF[1]then bF.callback=bF[1]bF[1]=nil end else bF={}end;bF.group=bD;a.nvim_create_autocmd(bE,bF)end end;function ar.enable()local bG=bB('treesitter_context_update')bG({'WinScrolled','BufEnter','WinEnter','VimResized'},bA)bG('CursorMoved',function()if ae()then bA()end end)bG('WinLeave',aN)bG('User',{aN,pattern='SessionSavePre'})bG('User',{bA,pattern='SessionSavePost'})bA()v=true end;function ar.disable()e('treesitter_context_update',{})aN()ah()v=false end;function ar.toggle()if v then ar.disable()else ar.enable()end end;function ar.setup(bH)if u then return end;u=true;local bI=bH or{}j=vim.tbl_deep_extend('force',{},i,bI)j.patterns=vim.tbl_deep_extend('force',{},r,bI.patterns or{})j.exclude_patterns=vim.tbl_deep_extend('force',{},s,bI.exclude_patterns or{})j.exact_patterns=vim.tbl_deep_extend('force',{},bI.exact_patterns or{})for G,bJ in pairs(j.patterns)do if not j.exact_patterns[G]then j.patterns[G]=vim.tbl_map(g,bJ)end end;if j.enable then ar.enable()else ar.disable()end end;f('TSContextEnable',ar.enable,{})f('TSContextDisable',ar.disable,{})f('TSContextToggle',ar.toggle,{})a.nvim_set_hl(0,'TreesitterContext',{link='NormalFloat',default=true})a.nvim_set_hl(0,'TreesitterContextLineNumber',{link='LineNr',default=true})a.nvim_set_hl(0,'TreesitterContextBottom',{link='NONE',default=true})bB('treesitter_context')('VimEnter',function()ar.setup()end)return ar
