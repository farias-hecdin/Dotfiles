local a=require'mind.commands'local b=require'mind.highlight'local c=require'mind.keymap'local d=require'mind.node'local e=require'mind.state'local f=require'mind.ui'local g=require'mind.notify'.notify;local h=require'plenary.path'local i={}local function j()vim.api.nvim_create_user_command('MindOpenMain',function()require'mind'.open_main()end,{desc='Open the main Mind tree'})vim.api.nvim_create_user_command('MindOpenProject',function(k)require'mind'.open_project(k.fargs[1]=='global')end,{nargs='?',desc='Open the project Mind tree'})vim.api.nvim_create_user_command('MindOpenSmartProject',function()require'mind'.open_smart_project()end,{desc='Open the project Mind tree'})vim.api.nvim_create_user_command('MindReloadState',function()require'mind'.reload_state()end,{desc='Reload Mind internal state'})vim.api.nvim_create_user_command('MindClose',function(k)require'mind'.close()end,{desc='Close main or project Mind tree if open'})end;i.setup=function(k)i.opts=vim.tbl_deep_extend('force',require'mind.defaults',k or{})e.expand_opts_paths(i.opts)c.init_keymaps(i.opts)a.precompute_commands()j()b.create_highlight_groups(i.opts)end;i.close=function()a.close()end;i.open_main=function()i.wrap_main_tree_fn(function(l)a.open_tree(l.get_tree,l.opts.persistence.data_dir,function()e.save_main_state(l.opts)end,l.opts)end,i.opts)end;i.open_project=function(m)i.wrap_project_tree_fn(function(l)a.open_tree(l.get_tree,l.data_dir,m and function()e.save_main_state(l.opts)end or function()e.save_local_state()end,l.opts)end,m,i.opts)end;i.open_smart_project=function()i.wrap_smart_project_tree_fn(function(l,m)a.open_tree(l.get_tree,l.data_dir,m and function()e.save_main_state(l.opts)end or function()e.save_local_state()end,l.opts)end,i.opts)end;i.reload_state=function()e.load_state(i.opts)end;i.wrap_main_tree_fn=function(n,k)k=vim.tbl_deep_extend('force',i.opts,k or{})e.load_main_state(k)local l={get_tree=e.get_main_tree,data_dir=k.persistence.data_dir,save_tree=function()e.save_main_state(k)end,opts=k}n(l)end;i.wrap_project_tree_fn=function(n,m,k)k=vim.tbl_deep_extend('force',i.opts,k or{})local o=vim.fn.getcwd()if m then e.load_main_state(k)if e.state.projects[o]==nil then e.new_global_project_tree(o,k)end else e.load_local_state()if e.local_tree==nil then e.new_local_tree(o,k)end end;local p=m and function()e.save_main_state(k)end or function()e.save_local_state()end;local l={get_tree=function()return e.get_project_tree(m and o or nil)end,data_dir=e.get_project_data_dir(m,k),save_tree=p,opts=k}n(l)end;i.wrap_smart_project_tree_fn=function(n,k)k=vim.tbl_deep_extend('force',i.opts,k or{})local o=vim.fn.getcwd()local q=h:new(o,'.mind')if q:exists()and q:is_dir()then e.load_local_state()local l={get_tree=function()return e.get_project_tree()end,data_dir=e.get_project_data_dir(false,k),save_tree=function()e.save_local_state()end,opts=k}n(l,false)else e.load_main_state(k)local r=e.state.projects[o]if r~=nil then local l={get_tree=function()return e.get_project_tree(o)end,data_dir=e.get_project_data_dir(true,k),save_tree=function()e.save_main_state(k)end,opts=k}n(l,true)else f.with_input('What kind of project tree? (local/global) ','local',function(s)local t;local p;local m;if s=='local'then e.new_local_tree(o,k)t=function()return e.get_project_tree()end;p=function()e.save_local_state()end;m=false elseif s=='global'then e.new_global_project_tree(o,k)t=function()return e.get_project_tree(o)end;p=function()e.save_main_state(k)end;m=true end;if t==nil then g('unrecognized project tree type, aborting',vim.log.levels.WARN)return end;local l={get_tree=t,data_dir=e.get_project_data_dir(m,k),save_tree=p,opts=k}n(l,true)p()end)end end end;return i
