local a=require('gitsigns.async').void;local b=require('gitsigns.async').scheduler;local c=require('gitsigns.config').config;local d=require('gitsigns.repeat').mk_repeatable;local e=require('gitsigns.popup')local f=require('gitsigns.util')local g=require('gitsigns.manager')local h=require('gitsigns.git')local i=require('gitsigns.diff')local j=require('gitsigns.cache')local k=j.cache;local l=j.CacheEntry;local m=require('gitsigns.hunks')local n=m.Hunk;local o=m.Hunk_Public;local p=vim.api;local q=p.nvim_get_current_buf;local r={QFListOpts={}}local s={}local t={}local u=p.nvim_create_namespace('gitsigns_preview_inline')local function v(w)local x=vim.fn.systemlist({'git','rev-parse','--symbolic','--branches','--tags','--remotes'})return vim.tbl_filter(function(y)return vim.startswith(y,w)end,x)end;r.toggle_signs=function(z)if z~=nil then c.signcolumn=z else c.signcolumn=not c.signcolumn end;r.refresh()return c.signcolumn end;r.toggle_numhl=function(z)if z~=nil then c.numhl=z else c.numhl=not c.numhl end;r.refresh()return c.numhl end;r.toggle_linehl=function(z)if z~=nil then c.linehl=z else c.linehl=not c.linehl end;r.refresh()return c.linehl end;r.toggle_word_diff=function(z)if z~=nil then c.word_diff=z else c.word_diff=not c.word_diff end;p.nvim__buf_redraw_range(0,vim.fn.line('w0')-1,vim.fn.line('w$'))return c.word_diff end;r.toggle_current_line_blame=function(z)if z~=nil then c.current_line_blame=z else c.current_line_blame=not c.current_line_blame end;r.refresh()return c.current_line_blame end;r.toggle_deleted=function(z)if z~=nil then c.show_deleted=z else c.show_deleted=not c.show_deleted end;r.refresh()return c.show_deleted end;local function A(B,C)B=B or q()C=C or k[B].hunks;local D=p.nvim_win_get_cursor(0)[1]return m.find_hunk(D,C)end;local function E(B)g.update(B)b()if vim.wo.diff then require('gitsigns.diffthis').update(B)end end;local function F(G)local H;if G.range>0 then H={G.line1,G.line2}end;return H end;local function I(B,J,K)local C;if K then local L=f.buf_lines(B)C=i(J.compare_text,L,false)b()else C=J.hunks end;return C end;r.stage_hunk=d(a(function(H,M)M=M or{}local B=q()local J=k[B]if not J then return end;if not f.path_exists(J.file)then print("Error: Cannot stage lines. Please add the file to the working tree.")return end;local C=I(B,J,M.greedy~=false)local N;if H then table.sort(H)local O,P=H[1],H[2]N=m.create_partial_hunk(C,O,P)N.added.lines=p.nvim_buf_get_lines(B,O-1,P,false)N.removed.lines=vim.list_slice(J.compare_text,N.removed.start,N.removed.start+N.removed.count-1)else N=A(B,C)end;if not N then return end;J.git_obj:stage_hunks({N})table.insert(J.staged_diffs,N)J:invalidate()E(B)end))s.stage_hunk=function(Q,G)r.stage_hunk(F(G))end;r.reset_hunk=d(a(function(H,M)M=M or{}local B=q()local J=k[B]if not J then return end;local C=I(B,J,M.greedy~=false)local N;if H then table.sort(H)local O,P=H[1],H[2]N=m.create_partial_hunk(C,O,P)N.added.lines=p.nvim_buf_get_lines(B,O-1,P,false)N.removed.lines=vim.list_slice(J.compare_text,N.removed.start,N.removed.start+N.removed.count-1)else N=A(B,C)end;if not N then return end;local R,S;if N.type=='delete'then R=N.added.start;S=N.added.start else R=N.added.start-1;S=N.added.start-1+N.added.count end;f.set_lines(B,R,S,N.removed.lines)end))s.reset_hunk=function(Q,G)r.reset_hunk(F(G))end;r.reset_buffer=function()local B=q()local J=k[B]if not J then return end;f.set_lines(B,0,-1,J.compare_text)end;r.undo_stage_hunk=a(function()local B=q()local J=k[B]if not J then return end;local N=table.remove(J.staged_diffs)if not N then print("No hunks to undo")return end;J.git_obj:stage_hunks({N},true)J:invalidate()E(B)end)r.stage_buffer=a(function()local B=q()local J=k[B]if not J then return end;local C=J.hunks;if#C==0 then print("No unstaged changes in file to stage")return end;if not f.path_exists(J.git_obj.file)then print("Error: Cannot stage file. Please add it to the working tree.")return end;J.git_obj:stage_hunks(C)for Q,N in ipairs(C)do table.insert(J.staged_diffs,N)end;J:invalidate()E(B)end)r.reset_buffer_index=a(function()local B=q()local J=k[B]if not J then return end;J.staged_diffs={}J.git_obj:unstage_file()J:invalidate()E(B)end)local function T(M)if M.navigation_message==nil then M.navigation_message=not vim.opt.shortmess:get().S end;if M.wrap==nil then M.wrap=vim.opt.wrapscan:get()end;if M.foldopen==nil then M.foldopen=vim.tbl_contains(vim.opt.foldopen:get(),'search')end;if M.greedy==nil then M.greedy=true end end;local function U(V)if vim.in_fast_event()then vim.schedule(V)else vim.defer_fn(V,1)end end;local function W(B)return#p.nvim_buf_get_extmarks(B,u,0,-1,{limit=1})>0 end;local X=a(function(M)T(M)local B=q()local J=k[B]if not J then return end;local C=I(B,J,M.greedy)if not C or vim.tbl_isempty(C)then if M.navigation_message then p.nvim_echo({{'No hunks','WarningMsg'}},false,{})end;return end;local Y=p.nvim_win_get_cursor(0)[1]local N,Z=m.find_nearest_hunk(Y,C,M.forwards,M.wrap)if N==nil then if M.navigation_message then p.nvim_echo({{'No more hunks','WarningMsg'}},false,{})end;return end;local _=M.forwards and N.added.start or N.vend;if _ then if _==0 then _=1 end;vim.cmd([[ normal! m' ]])p.nvim_win_set_cursor(0,{_,0})if M.foldopen then vim.cmd('silent! foldopen!')end;if M.preview or e.is_open('hunk')~=nil then U(r.preview_hunk)elseif W(B)then U(r.preview_hunk_inline)end;if Z~=nil and M.navigation_message then p.nvim_echo({{string.format('Hunk %d of %d',Z,#C),'None'}},false,{})end end end)r.next_hunk=function(M)M=M or{}M.forwards=true;X(M)end;r.prev_hunk=function(M)M=M or{}M.forwards=false;X(M)end;local a0=e.HlMark;local function a1(a2,a3)local a4=vim.deepcopy(a2)for Q,Y in ipairs(a4)do for Q,a5 in ipairs(Y)do a5[1]=f.expand_format(a5[1],a3)end end;return a4 end;local function a6(N,a7)local a8={}local a9,aa=N.removed,N.added;if a7 then a8[#a8+1]={hl_group=a7,start_row=0,end_row=a9.count+aa.count}end;a8[#a8+1]={hl_group='GitSignsDeletePreview',start_row=0,end_row=a9.count}a8[#a8+1]={hl_group='GitSignsAddPreview',start_row=a9.count,end_row=a9.count+aa.count}if c.diff_opts.internal then local ab,ac=require('gitsigns.diff_int').run_word_diff(a9.lines,aa.lines)for Q,ad in ipairs(ab)do a8[#a8+1]={hl_group='GitSignsDeleteInline',start_row=ad[1]-1,start_col=ad[3],end_col=ad[4]}end;for Q,ad in ipairs(ac)do a8[#a8+1]={hl_group='GitSignsAddInline',start_row=ad[1]+a9.count-1,start_col=ad[3],end_col=ad[4]}end end;return a8 end;local function ae(a2,N)for Q,Y in ipairs(a2)do for Q,a5 in ipairs(Y)do local a7=a5[2]if a5[1]=='<hunk>'and type(a7)=="string"then a5[2]=a6(N,a7)end end end end;local function af(ag)return function()local ah=vim.o.eventignore;vim.o.eventignore='all'ag()vim.o.eventignore=ah end end;r.preview_hunk=af(function()if e.focus_open('hunk')then return end;local B=q()local J=k[B]if not J then return end;local N,Z=A(B,J.hunks)if not N then return end;local ai={{{'Hunk <hunk_no> of <num_hunks>','Title'}},{{'<hunk>','NormalFloat'}}}ae(ai,N)local aj=a1(ai,{hunk_no=Z,num_hunks=#J.hunks,hunk=m.patch_lines(N,vim.bo[B].fileformat)})e.create(aj,c.preview_config,'hunk')end)r.preview_hunk_inline=function()local B=q()local N=A(B)if not N then return end;g.show_added(B,u,N)g.show_deleted(B,u,N)p.nvim_create_autocmd({'CursorMoved','InsertEnter'},{callback=function()p.nvim_buf_clear_namespace(B,u,0,-1)end,once=true})end;r.select_hunk=function()local N=A()if not N then return end;vim.cmd('normal! '..N.added.start..'GV'..N.vend..'G')end;r.get_hunks=function(B)B=B or q()if not k[B]then return end;local a4={}for Q,ak in ipairs(k[B].hunks or{})do a4[#a4+1]={head=ak.head,lines=m.patch_lines(ak,vim.bo[B].fileformat),type=ak.type,added=ak.added,removed=ak.removed}end;return a4 end;local function al(am,a3)local an={}if a3.previous then an=am:get_show_text(a3.previous_sha..':'..a3.previous_filename)end;local ao=am:get_show_text(a3.sha..':'..a3.filename)local C=i(an,ao,false)local N,ap=m.find_hunk(a3.orig_lnum,C)return N,ap,#C end;local function aq(ar,as)if not ar then return{{{'<author>','Label'}}}end;local at={{'<abbrev_sha> ','Directory'},{'<author> ','MoreMsg'},{'(<author_time:%Y-%m-%d %H:%M>)','Label'},{':','NormalFloat'}}if as then return{at,{{'<body>','NormalFloat'}},{{'Hunk <hunk_no> of <num_hunks>','Title'},{' <hunk_head>','LineNr'}},{{'<hunk>','NormalFloat'}}}end;return{at,{{'<summary>','NormalFloat'}}}end;r.blame_line=a(function(M)if e.focus_open('blame')then return end;M=M or{}local B=q()local J=k[B]if not J then return end;local au=vim.defer_fn(function()e.create({{{'Loading...','Title'}}},c.preview_config)end,1000)b()local L=f.buf_lines(B)local av=vim.bo[B].fileformat;local D=p.nvim_win_get_cursor(0)[1]local aw=J.git_obj:run_blame(L,D,M.ignore_whitespace)pcall(function()au:close()end)local ar=aw.sha and tonumber('0x'..aw.sha)~=0;local ax=aq(ar,M.full)local a3=aw;if ar and M.full then a3.body=J.git_obj:command({'show','-s','--format=%B',aw.sha})local N;N,a3.hunk_no,a3.num_hunks=al(J.git_obj.repo,aw)a3.hunk=m.patch_lines(N,av)a3.hunk_head=N.head;ae(ax,N)end;b()e.create(a1(ax,a3),c.preview_config,'blame')end)local function ay(az,J,aA)J.base=aA;J:invalidate()E(az)end;r.change_base=a(function(aA,aB)aA=f.calc_base(aA)if aB then c.base=aA;for B,J in pairs(k)do ay(B,J,aA)end else local B=q()local J=k[B]if not J then return end;ay(B,J,aA)end end)s.change_base=function(aC,Q)r.change_base(aC[1],aC[2]or aC.global)end;t.change_base=v;r.reset_base=function(aB)r.change_base(nil,aB)end;s.reset_base=function(aC,Q)r.change_base(nil,aC[1]or aC.global)end;r.diffthis=function(aA,M)if aA~=nil then aA=tostring(aA)end;M=M or{}local aD=require('gitsigns.diffthis')if not M.vertical then M.vertical=c.diff_opts.vertical end;aD.diffthis(aA,M)end;s.diffthis=function(aC,G)local M={vertical=aC.vertical,split=aC.split}if G.smods then if G.smods.split~=''and M.split==nil then M.split=G.smods.split end;if M.vertical==nil then M.vertical=G.smods.vertical end end;r.diffthis(aC[1],M)end;t.diffthis=v;r.show=function(aE)local aD=require('gitsigns.diffthis')aD.show(aE)end;t.show=v;local function aF(aG,C,aH)for ap,N in ipairs(C)do aH[#aH+1]={bufnr=type(aG)=="number"and aG or nil,filename=type(aG)=="string"and aG or nil,lnum=N.added.start,text=string.format('Lines %d-%d (%d/%d)',N.added.start,N.vend,ap,#C)}end end;local function aI(aJ)aJ=aJ or q()if aJ==0 then aJ=q()end;local aH={}if type(aJ)=='number'then local B=aJ;if not k[B]then return end;aF(B,k[B].hunks,aH)elseif aJ=='attached'then for B,J in pairs(k)do aF(B,J.hunks,aH)end elseif aJ=='all'then local aK={}for Q,J in pairs(k)do local am=J.git_obj.repo;if not aK[am.gitdir]then aK[am.gitdir]=am end end;local am=h.Repo.new(vim.loop.cwd())if not aK[am.gitdir]then aK[am.gitdir]=am end;for Q,aL in pairs(aK)do for Q,ag in ipairs(aL:files_changed())do local aM=aL.toplevel..'/'..ag;local aN=vim.loop.fs_stat(aM)if aN and aN.type=='file'then local an=aL:get_show_text(':0:'..ag)b()local C=i(an,f.file_lines(aM))aF(aM,C,aH)end end end end;return aH end;r.setqflist=a(function(aJ,M)M=M or{}if M.open==nil then M.open=true end;local aO={items=aI(aJ),title='Hunks'}b()if M.use_location_list then local aP=M.nr or 0;vim.fn.setloclist(aP,{},' ',aO)if M.open then if c.trouble then require('trouble').open("loclist")else vim.cmd([[lopen]])end end else vim.fn.setqflist({},' ',aO)if M.open then if c.trouble then require('trouble').open("quickfix")else vim.cmd([[copen]])end end end end)r.setloclist=function(aP,aJ)r.setqflist(aJ,{nr=aP,use_location_list=true})end;r.get_actions=function()local B=q()local J=k[B]if not J then return end;local N=A(B,J.hunks)local aQ={}local function aR(aS)aQ[#aQ+1]=aS end;if N then aR('stage_hunk')aR('reset_hunk')aR('preview_hunk')aR('select_hunk')else aR('blame_line')end;if not vim.tbl_isempty(J.staged_diffs)then aR('undo_stage_hunk')end;local aT={}for Q,an in ipairs(aQ)do aT[an]=r[an]end;return aT end;r.refresh=a(function()g.reset_signs()require('gitsigns.highlight').setup_highlights()require('gitsigns.current_line_blame').setup()for aU,aV in pairs(k)do aV:invalidate()g.update(aU,aV)end end)function r._get_cmd_func(aW)return s[aW]end;function r._get_cmp_func(aW)return t[aW]end;return r
