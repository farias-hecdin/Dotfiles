local a=require"fzf-lua.core"local b=require"fzf-lua.utils"local c=require"fzf-lua.config"local d=require"fzf-lua.make_entry"local e={}local function f()if not __CTX or not b.fzf_winobj()then __CTX={winid=vim.api.nvim_get_current_win(),bufnr=vim.api.nvim_get_current_buf(),bufname=vim.api.nvim_buf_get_name(0),cursor=vim.api.nvim_win_get_cursor(0)}end end;local function g(h)f()local i=vim.lsp.buf_get_clients(__CTX and __CTX.bufnr or 0)local j=0;for k,l in pairs(i)do if vim.fn.has("nvim-0.8")==1 then if l.server_capabilities[h]then j=j+1 end else if l.resolved_capabilities[h]then j=j+1 end end end;if j>0 then return j end;if b.tbl_isempty(i)then b.info("LSP: no client attached")else b.info("LSP: server does not support "..h)end;return false end;local function m(n,o)local p=vim.lsp.util.locations_to_items({n},o)[1]return("%s:%d:%d:"):format(p.filename,p.lnum,p.col)end;local q=function(r,s,o)b.fzf_exit()local t=r.jump_to_single_result_action;if t then local u=m(s,o)return r.jump_to_single_result_action({u},r)end;return vim.lsp.util.jump_to_location(s,o)end;local function v(r,w,k,s,x,k)local y=vim.lsp.get_client_by_id(x.client_id).offset_encoding;s=vim.tbl_islist(s)and s or{s}if r.ignore_current_line then local z=__CTX.cursor[1]-1;s=vim.tbl_filter(function(A)if A.range and A.range.start and A.range.start.line==z then return false end;return true end,s)end;if r.jump_to_single_result and#s==1 then q(r,s[1],y)end;local B=vim.lsp.util.locations_to_items(s,y)for k,u in ipairs(B)do if not r.current_buffer_only or __CTX.bufname==u.filename then u=d.lcol(u,r)u=d.file(u,r)if u then w(u)end end end end;local function C(r,w,k,s,k,k)for k,D in pairs(s)do local E=D.from or D.to;for k,F in pairs(D.fromRanges)do local n={filename=assert(vim.uri_to_fname(E.uri)),text=E.name,lnum=F.start.line+1,col=F.start.character+1}local u=d.lcol(n,r)u=d.file(u,r)if u then w(u)end end end end;local function G(r,w,k,s,k,k)s=vim.tbl_islist(s)and s or{s}local B=vim.lsp.util.symbols_to_items(s,__CTX.bufnr)for k,u in ipairs(B)do if(not r.current_buffer_only or __CTX.bufname==u.filename)and(not r.regex_filter or u.text:match(r.regex_filter))then if e._sym2style then local H=u.text:match("%[(.-)%]")if H and e._sym2style[H]then u.text=u.text:gsub("%[.-%]",e._sym2style[H])end end;u=d.lcol(u,r)u=d.file(u,r)if u then w(u)end end end end;local function I(r,w,k,J,K,k)if not r.code_actions then r.code_actions={}end;local L=vim.tbl_count(r.code_actions)+1;for k,t in ipairs(J)do local M=string.format("%s %s",b.ansi_codes.magenta(string.format("%d:",L)),t.title)local u={client_id=K.client_id,command=t}r.code_actions[tostring(L)]=u;w(M)L=L+1 end end;local N=function(O)return function(...)local P=not select(4,...)or type(select(4,...))~="number"if P then O(...)else local Q=select(1,...)local R=select(2,...)local s=select(3,...)local S=select(4,...)local T=select(5,...)local U=select(6,...)O(Q,s,{method=R,client_id=S,bufnr=T},U)end end end;local function V(W,X,r)return N(function(Q,s,K,U)r.num_callbacks=r.num_callbacks+1;r.num_results=(r.num_results or 0)+(s and vim.tbl_count(s)or 0)if Q then b.err(string.format("Error executing '%s': %s",X.method,Q))b.fzf_exit()coroutine.resume(W,true,Q)else local Y=r.num_callbacks==r.num_clients;if Y and r.num_results==0 then if not r.fn_reload then b.info(string.format("No %s found",string.lower(X.label)))b.fzf_exit()end end;coroutine.resume(W,Y,Q,s,K,U)end end)end;local function Z(r)if r.async==nil then if type(r.async_or_timeout)=="number"then r.async=false elseif type(r.async_or_timeout)=="boolean"then r.async=r.async_or_timeout end end;if not r.lsp_params then r.lsp_params=vim.lsp.util.make_position_params(__CTX.winid)r.lsp_params.context={includeDeclaration=true}end;if not r.async then local _=5000;if type(r.async_or_timeout)=="number"then _=r.async_or_timeout end;local a0,Q=vim.lsp.buf_request_sync(__CTX.bufnr,r.lsp_handler.method,r.lsp_params,_)if Q then b.err(string.format("Error executing '%s': %s",r.lsp_handler.method,Q))else local a1={}local w=function(M)table.insert(a1,M)end;for S,a2 in pairs(a0)do if a2.result then local K={client_id=S}r.lsp_handler.handler(r,w,r.lsp_handler.method,a2.result,K)end end;if vim.tbl_isempty(a1)then if not r.fn_reload then b.info(string.format("No %s found",string.lower(r.lsp_handler.label)))else r.fzf_fn={}end elseif not(r.jump_to_single_result and#a1==1)then r.fzf_fn=function(a3)coroutine.wrap(function()local W=coroutine.running()for k,a4 in ipairs(a1)do a3(a4,function()coroutine.resume(W)end)coroutine.yield()end;a3(nil)end)()end end end else local a5=function(a6)if a6 and a6._cancel_all then a6._cancel_all()a6._cancel_all=nil end end;r._fn_post_fzf=a5;r.fzf_fn=function(a3)coroutine.wrap(function()local W=coroutine.running()r.num_results=0;r.num_callbacks=0;r.num_clients=g(r.lsp_handler.capability)a5(r)local k,a7=vim.lsp.buf_request(__CTX.bufnr,r.lsp_handler.method,r.lsp_params,V(W,r.lsp_handler,r))r._cancel_all=a7;local Q,s,K,U,Y;repeat Y,Q,s,K,U=coroutine.yield()if not Q and type(s)=="table"then local w=function(a4)a3(a4,function()coroutine.resume(W)end)coroutine.yield()end;r.lsp_handler.handler(r,w,r.lsp_handler.method,s,K,U)end until Y or Q;a3(nil)r._cancel_all=nil end)()end end;return r end;local a8=function(r,a9)r=c.normalize_opts(r,a9)if not r then return end;if not r.prompt and r.prompt_postfix then r.prompt=r.lsp_handler.label..(r.prompt_postfix or"")end;if not r.cwd or#r.cwd==0 then r.cwd=vim.loop.cwd()end;r.code_actions=nil;return r end;local function aa(r)r=a8(r,c.globals.lsp)if not r then return end;if r.force_uri==nil then r.force_uri=true end;r=a.set_fzf_field_index(r)r=Z(r)if not r.fzf_fn then return end;return a.fzf_exec(r.fzf_fn,r)end;e.references=function(r)return aa(r)end;e.definitions=function(r)return aa(r)end;e.declarations=function(r)return aa(r)end;e.typedefs=function(r)return aa(r)end;e.implementations=function(r)return aa(r)end;e.call_hierarchy=function(r)r.lsp_params=vim.lsp.util.make_position_params(__CTX and __CTX.winid or 0)local R="textDocument/prepareCallHierarchy"local ab,Q=vim.lsp.buf_request_sync(0,R,r.lsp_params,2000)if Q then b.err(("Error executing '%s': %s"):format(R,Q))else local k,a2=next(ab)if vim.tbl_isempty(a2)then b.info(("No %s found"):format(r.lsp_handler.label:lower()))return end;assert(a2.result and a2.result[1])local E=a2.result[1]r.lsp_params={item=E}return aa(r)end end;e.incoming_calls=function(r)return e.call_hierarchy(r)end;e.outgoing_calls=function(r)return e.call_hierarchy(r)end;local function ac(r)assert(e._sym2style==nil)assert(r.symbol_style~=nil)e._sym2style={}local ad=vim.api.nvim_get_color_map()for ae,af in pairs(vim.lsp.protocol.CompletionItemKind)do if type(ae)=="string"then local ag=vim.lsp.protocol.CompletionItemKind[af]local ah=nil;if r.symbol_style==1 then if ag~=ae then ah=("%s %s"):format(ag,ae)else ah=ae end elseif r.symbol_style==2 then ah=ag elseif r.symbol_style==3 then ah=ae end;if ah and r.symbol_hl_prefix then e._sym2style[ae]=b.ansi_from_hl(r.symbol_hl_prefix..ae,ah,ad)elseif ah then e._sym2style[ae]=ah else e._sym2style[ae]=ae end end end;if type(r.symbol_fmt)=="function"then for ae,af in pairs(e._sym2style)do e._sym2style[ae]=r.symbol_fmt(af)or af end end end;e.document_symbols=function(r)r=a8(r,c.globals.lsp.symbols)if not r then return end;r.__MODULE__=r.__MODULE__ or e;r=a.set_header(r,r.headers or{"regex_filter"})r=a.set_fzf_field_index(r)if r.force_uri==nil then r.force_uri=true end;if not r.fzf_opts or r.fzf_opts["--with-nth"]==nil then r.fzf_opts=r.fzf_opts or{}r.fzf_opts["--with-nth"]="2.."r.fzf_opts["--tiebreak"]="index"end;r=Z(r)if not r.fzf_fn then return end;if r.symbol_style or r.symbol_fmt then r.fn_pre_fzf=function()ac(r)end;r.fn_post_fzf=function()e._sym2style=nil end end;return a.fzf_exec(r.fzf_fn,r)end;local function ai(r)if r.__MODULE__ and r.__MODULE__.get_last_search then return r.__MODULE__.get_last_lspquery(r)end;return e.__last_ws_lsp_query end;local function aj(r,ak)if r.__MODULE__ and r.__MODULE__.set_last_search then r.__MODULE__.set_last_lspquery(r,ak)return end;e.__last_ws_lsp_query=ak;if c.__resume_data then c.__resume_data.last_query=ak end end;e.workspace_symbols=function(r)r=a8(r,c.globals.lsp.symbols)if not r then return end;r.__MODULE__=r.__MODULE__ or e;if not r.lsp_query and r.resume then r.lsp_query=ai(r)end;aj(r,r.lsp_query)r.lsp_params={query=r.lsp_query or""}r=a.set_header(r,r.headers or{"actions","cwd","lsp_query","regex_filter"})r=a.set_fzf_field_index(r)if r.force_uri==nil then r.force_uri=true end;r=Z(r)if not r.fzf_fn then return end;if r.symbol_style or r.symbol_fmt then r.fn_pre_fzf=function()ac(r)end;r.fn_post_fzf=function(a6,k)e._sym2style=nil;local al=ai(a6)local am=c.__resume_data and c.__resume_data.last_query;if not al or#al==0 and(am and#am>0)then aj(r,am)end end end;return a.fzf_exec(r.fzf_fn,r)end;e.live_workspace_symbols=function(r)r=a8(r,c.globals.lsp.symbols)if not r then return end;r.__MODULE__=r.__MODULE__ or e;r.prompt=r.prompt and r.prompt:match("^%*")or"*"..r.prompt;if r.exec_empty_query==nil then r.exec_empty_query=true end;if not r.lsp_query and r.resume then r.lsp_query=ai(r)end;r.lsp_params={query=r.lsp_query or r.query or""}r.query=r.lsp_query or r.query;r.func_async_callback=false;r.fn_reload=function(ak)if ak and not(r.save_last_search==false)then aj(r,ak)end;r.lsp_params={query=ak or""}r=Z(r)return r.fzf_fn end;r=a.set_header(r,r.headers or{"actions","cwd","regex_filter"})r=a.set_fzf_field_index(r)if r.force_uri==nil then r.force_uri=true end;if r.symbol_style or r.symbol_fmt then r.fn_pre_fzf=function()ac(r)end;r.fn_post_fzf=function()e._sym2style=nil end end;a.fzf_exec(nil,r)end;local function an(k)if not vim.diagnostic then return vim.lsp.diagnostic.get_line_diagnostics()end;local ao=vim.diagnostic.get(__CTX.bufnr,{lnum=vim.api.nvim_win_get_cursor(0)[1]-1})return ao and ao[1]and{{source=ao[1].source,message=ao[1].message,severity=ao[1].severity,code=ao[1].user_data and ao[1].user_data.lsp and ao[1].user_data.lsp.code,codeDescription=ao[1].user_data and ao[1].user_data.lsp and ao[1].user_data.lsp.codeDescription,range={["start"]={line=ao[1].lnum,character=ao[1].col},["end"]={line=ao[1].end_lnum,character=ao[1].end_col}},data=ao[1].user_data and ao[1].user_data.lsp and ao[1].user_data.lsp.data}}or nil end;local function ap(l)local aq;if vim.fn.has("nvim-0.8")==1 then aq=l.server_capabilities.codeActionProvider else aq=l.resolved_capabilities.code_action end;return type(aq)=="table"and aq.resolveProvider end;e.code_actions=function(r)r=a8(r,c.globals.lsp.code_actions)if not r then return end;r.jump_to_single_result=false;r.lsp_params=vim.lsp.util.make_range_params(0)r.lsp_params.context={diagnostics=an(r)}if vim.fn.has("nvim-0.6")==1 then r.async=false end;r=Z(r)if not r.fzf_fn then return end;if r.ui_select and vim.fn.has("nvim-0.6")==1 then local ar=require"fzf-lua.providers.ui_select"local as=ar.is_registered()r.previewer=false;r.actions=r.actions or{}r.actions.default=nil;if not as then r.post_action_cb=function()ar.deregister({},true,true)end end;ar.register(r,true,r)vim.lsp.buf.code_action()return end;local function at(au)if au and au.documentChanges then for k,av in pairs(au.documentChanges)do local aw=av.textDocument;if aw and aw.version and aw.version==0 then aw.version=nil end end end;return au end;local ax=r.transform_action or function(t)local ay=t.command and t.command.command or t.command;if not(ay=="java.apply.workspaceEdit")then return t end;local az=t.command and t.command.arguments or t.arguments;t.edit=at(az[1])return t end;local aA=r.execute_action or function(t,o)if t.edit or type(t.command)=="table"then if t.edit then vim.lsp.util.apply_workspace_edit(t.edit,o)end;if type(t.command)=="table"then vim.lsp.buf.execute_command(t.command)end else vim.lsp.buf.execute_command(t)end end;if not r.actions then r.actions={}end;r.actions.default=function(aB)local aC=aB[1]:match("(%d+)")local u=r.code_actions[aC]local t=u.command;local l=u.client or vim.lsp.get_client_by_id(u.client_id)local aD=l and l.offset_encoding;if not t.edit and l and ap(l)then local aE="codeAction/resolve"l.request(aE,t,function(aF,aG)if aF then b.err(("Error %d executing '%s': %s"):format(aF.code,aE,aF.message))return end;if aG then aA(ax(aG),aD)else aA(ax(t),aD)end end)else aA(ax(t),aD)end end;r.previewer=false;r.fzf_opts["--no-multi"]=""r.fzf_opts["--preview-window"]="right:0"a.fzf_exec(r.fzf_fn,r)end;local aH={["code_actions"]={label="Code Actions",resolved_capability="code_action",server_capability="codeActionProvider",method="textDocument/codeAction",handler=I},["references"]={label="References",resolved_capability="find_references",server_capability="referencesProvider",method="textDocument/references",handler=v},["definitions"]={label="Definitions",resolved_capability="goto_definition",server_capability="definitionProvider",method="textDocument/definition",handler=v},["declarations"]={label="Declarations",resolved_capability="goto_declaration",server_capability="declarationProvider",method="textDocument/declaration",handler=v},["typedefs"]={label="Type Definitions",resolved_capability="type_definition",server_capability="typeDefinitionProvider",method="textDocument/typeDefinition",handler=v},["implementations"]={label="Implementations",resolved_capability="implementation",server_capability="implementationProvider",method="textDocument/implementation",handler=v},["document_symbols"]={label="Document Symbols",resolved_capability="document_symbol",server_capability="documentSymbolProvider",method="textDocument/documentSymbol",handler=G},["workspace_symbols"]={label="Workspace Symbols",resolved_capability="workspace_symbol",server_capability="workspaceSymbolProvider",method="workspace/symbol",handler=G},["live_workspace_symbols"]={label="Workspace Symbols",resolved_capability="workspace_symbol",server_capability="workspaceSymbolProvider",method="workspace/symbol",handler=G},["incoming_calls"]={label="Incoming Calls",resolved_capability="call_hierarchy",server_capability="callHierarchyProvider",method="callHierarchy/incomingCalls",handler=C},["outgoing_calls"]={label="Outgoing Calls",resolved_capability="call_hierarchy",server_capability="callHierarchyProvider",method="callHierarchy/outgoingCalls",handler=C}}local function aI(aJ)for ae,af in pairs(aJ)do aJ[ae]=function(r)r=r or{}if not r.lsp_handler then r.lsp_handler=aH[ae]end;if not r.lsp_handler then b.err(string.format("No LSP handler defined for %s",ae))return end;if r.lsp_handler and not r.lsp_handler.capability then if vim.fn.has("nvim-0.8")==1 then r.lsp_handler.capability=r.lsp_handler.server_capability else r.lsp_handler.capability=r.lsp_handler.resolved_capability end end;if r.lsp_handler.capability and not g(r.lsp_handler.capability)then return end;af(r)end end;return aJ end;return aI(e)
