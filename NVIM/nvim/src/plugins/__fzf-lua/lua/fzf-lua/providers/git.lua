local a=require"fzf-lua.core"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.config"local e=require"fzf-lua.libuv"local f=require"fzf-lua.shell"local g=require"fzf-lua.make_entry"local h={}local function i(j)local k=b.git_root(j)if not j.cwd or not k then j.cwd=k end;if j.git_dir or j.git_worktree then j.cmd=b.git_cwd(j.cmd,j)end;return j end;h.files=function(j)j=d.normalize_opts(j,d.globals.git.files)if not j then return end;j=i(j)if not j.cwd then return end;local l=a.mt_cmd_wrapper(j)j=a.set_header(j,j.headers or{"cwd"})return a.fzf_exec(l,j)end;h.status=function(j)j=d.normalize_opts(j,d.globals.git.status)if not j then return end;j=i(j)if not j.cwd then return end;if j.preview then j.preview=b.git_cwd(j.preview,j)end;j.git_icons=false;if not j.no_header then local m=c.ansi_codes.yellow("<left>")local n=c.ansi_codes.yellow("<right>")j.fzf_opts["--header"]=vim.fn.shellescape(("+ - :: %s to stage, %s to unstage"):format(m,n))end;local function o(p)local q=p;local r=d.globals.git.icons[p]if r then q=r.icon;if j.color_icons then q=c.ansi_codes[r.color or"dark_grey"](q)end end;return q end;local l=e.spawn_nvim_fzf_cmd(j,function(p)if not p or#p<4 then return p end;local s,t=p:sub(4):gsub('"',""),nil;if s:match("%s%->%s")then s,t=s:match("(.*)%s%->%s(.*)")end;s=s and g.file(s,j)if not s then return end;t=t and g.file(t,j)local u=o(p:sub(1,1):gsub("?"," "))local v=o(p:sub(2,2))local w=("%s%s%s%s%s"):format(u,c.nbsp,v,c.nbsp..c.nbsp,t and("%s -> %s"):format(s,t)or s)return w end,function(x)return g.preprocess(x)end)j=a.set_header(j,j.headers or{"cwd"})return a.fzf_exec(l,j)end;local function y(j)j=i(j)if not j.cwd then return end;j=a.set_header(j,j.headers or{"cwd"})a.fzf_exec(j.cmd,j)end;h.commits=function(j)j=d.normalize_opts(j,d.globals.git.commits)if not j then return end;if j.preview then j.preview=b.git_cwd(j.preview,j)if j.preview_pager then j.preview=string.format("%s | %s",j.preview,j.preview_pager)end end;return y(j)end;h.bcommits=function(j)j=d.normalize_opts(j,d.globals.git.bcommits)if not j then return end;local z=vim.api.nvim_buf_get_name(0)if not z or#z==0 then c.info("'bcommits' is not available for unnamed buffers.")return end;if not j.cwd and not j.git_dir then j.cwd=b.git_root({cwd=vim.fn.expand("%:p:h")},true)end;local k=b.git_root(j)if not k then return end;local A=b.relative(vim.fn.expand("%:p"),k)if j.cmd:match("<file")then j.cmd=j.cmd:gsub("<file>",A)else j.cmd=j.cmd.." "..A end;if type(j.preview)=="string"then j.preview=j.preview:gsub("<file>",vim.fn.shellescape(A))j.preview=b.git_cwd(j.preview,j)if j.preview_pager then j.preview=string.format("%s | %s",j.preview,j.preview_pager)end end;return y(j)end;h.branches=function(j)j=d.normalize_opts(j,d.globals.git.branches)if not j then return end;j.fzf_opts["--no-multi"]=""if j.preview then j.__preview=b.git_cwd(j.preview,j)j.preview=f.raw_preview_action_cmd(function(B)local C=B[1]:match("[^%s%*]*$"):gsub("%)$","")return j.__preview:gsub("{.*}",C)end,nil,j.debug)end;return y(j)end;h.stash=function(j)j=d.normalize_opts(j,d.globals.git.stash)if not j then return end;if j.preview then j.preview=b.git_cwd(j.preview,j)end;if j.fzf_opts["--header"]==nil then j.fzf_opts["--header"]=vim.fn.shellescape((":: %s to drop selected stash(es)"):format(c.ansi_codes.yellow("<Ctrl-x>")))end;j.cmd=e.spawn_nvim_fzf_cmd({cmd=j.cmd,cwd=j.cwd},function(p)local D,E=p:match("([^:]+)(.*)")if D then D=c.ansi_codes.yellow(D)D=D:gsub("{%d+}",function(F)return("%s"):format(c.ansi_codes.green(tostring(F)))end)end;return(not D or not E)and p or D..E end)return y(j)end;return h
