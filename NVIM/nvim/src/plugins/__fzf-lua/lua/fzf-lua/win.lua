local a=require"fzf-lua.utils"local b=require"fzf-lua.config"local c=vim.api;local d=vim.fn;local e={}local f=nil;function e.__SELF()return f end;setmetatable(e,{__call=function(g,...)return g:new(...)end})function e.save_query(h)local self=f;if not self then return end;local i=vim.api.nvim_buf_get_lines(self.fzf_bufnr,0,1,false)if not i or vim.tbl_isempty(i)then return end;local j=nil;if not self.prompt then j=i[1]:match(".->%s(.*)")else j=i[1]:gsub("^%*+",""):gsub("^"..a.lua_escape(self.prompt:match("[^%*]+")),"")end;if j then j=j:gsub("[<%-]%s%d+/%d+.*$","")j=j:gsub("<%s%[Command failed:.*$","")j=j:gsub("%s*$","")end;if self.fn_save_query then self.fn_save_query(j)end;a.feed_keys_termcodes(a.fzf_bind_to_neovim(h))end;local k={["toggle-preview"]={module="win",fnc="toggle_preview()"},["toggle-preview-wrap"]={module="win",fnc="toggle_preview_wrap()"},["toggle-preview-cw"]={module="win",fnc="toggle_preview_cw(1)"},["toggle-preview-ccw"]={module="win",fnc="toggle_preview_cw(-1)"},["preview-page-up"]={module="win",fnc="preview_scroll(-1)"},["preview-page-down"]={module="win",fnc="preview_scroll(1)"},["preview-page-reset"]={module="win",fnc="preview_scroll(0)"}}function e:setup_keybinds()if not self:validate()then return end;if not self.keymap or not self.keymap.builtin then return end;if self.keymap.fzf then for l,m in pairs(self.keymap.fzf)do if m=="toggle-preview"then self._fzf_toggle_prev_bind=a.fzf_bind_to_neovim(l)end end end;local n={["toggle-help"]={module="win",fnc="toggle_help()"},["toggle-fullscreen"]={module="win",fnc="toggle_fullscreen()"}}if self.previewer_is_builtin then n=vim.tbl_deep_extend("keep",n,k)end;local function o(p)return([[<Cmd>lua require('fzf-lua.%s').%s<CR>]]):format(p.module,p.fnc)end;for h,q in pairs(self.keymap.builtin)do local p=n[q]if p and not vim.tbl_isempty(p)and q~=false then c.nvim_buf_set_keymap(self.fzf_bufnr,"t",h,o(p),{nowait=true,noremap=true})end end;if self.fn_save_query then for r,h in ipairs({"ctrl-c","esc"})do c.nvim_buf_set_keymap(self.fzf_bufnr,"t",a.fzf_bind_to_neovim(h),("<Cmd>lua require('fzf-lua.win').save_query('%s')<CR>"):format(h),{nowait=true,noremap=true})end end end;function e:generate_layout(s)local t,u=s.row,s.col;local v,w=s.height,s.width;local x=s.signcol_width or 0;local y=s.preview_pos;local z=s.preview_size;local A,B=t+1,u+1;local C,D;local E=2;local F;local G=s.split and s.split:match("vnew")~=nil;if y=="down"or y=="up"then v=v-E;D=w;C=a.round(v*z/100,0.6)v=v-C;if y=="up"then t=t+C+E;if s.split then F="NW"A=1;D=D-2;C=C-1;if G then B=1 else B=B-1 end else F="SW"A=t-1 end else F="NW"if s.split then B=1;A=v+E;C=C-1;D=D-2 else A=t+v+3 end end elseif y=="left"or y=="right"then C=v;D=a.round(w*z/100)w=w-D-2;if y=="left"then F="NE"u=u+D+2;B=u-1;if s.split then A=1;D=D-1-x;C=C-E;if G then F="NW"B=1 else B=u-3-x end end else F="NW"if s.split then A=1;B=w+4-x;D=D-3+x;C=C-E else B=u+w+3 end end end;return{fzf={row=t,col=u,height=v,width=w},preview={anchor=F,row=A,col=B,height=C,width=D}}end;local H=function(I)local J=nil;if type(I)=="string"then J=b.globals.winopts._borderchars[I]end;if not J then J=b.globals.winopts._borderchars["rounded"]end;if not I or type(I)~="table"or#I<8 then return J end;local K={}for L=1,8 do if type(I[L])=="string"then table.insert(K,#I[L]>0 and I[L]or" ")elseif type(I[L])=="table"and type(I[L][1])=="string"then table.insert(K,#I[L][1]>0 and I[L][1]or" ")else table.insert(K,J[L])end end;return K end;local M=function(N)local O=N or{}O.winopts=vim.tbl_deep_extend("keep",O.winopts or{},b.globals.winopts)O.winopts_fn=O.winopts_fn or b.globals.winopts_fn;O.winopts_raw=O.winopts_raw or b.globals.winopts_raw;local s=a.tbl_deep_clone(O.winopts)if type(O.winopts_fn)=="function"then s=vim.tbl_deep_extend("force",s,O.winopts_fn())end;if type(O.winopts_raw)=="function"then s=vim.tbl_deep_extend("force",s,O.winopts_raw())end;s.__hl=vim.tbl_deep_extend("force",s.__hl,s.hl or{})local P=vim.o.columns-2;local Q=vim.o.lines-vim.o.cmdheight-2;s.width=math.min(P,s.width)s.height=math.min(Q,s.height)if not s.height or s.height<=1 then s.height=math.floor(Q*s.height)end;if not s.width or s.width<=1 then s.width=math.floor(P*s.width)end;if s.relative=="cursor"then local R=vim.api.nvim_win_get_cursor(0)local S=vim.fn.screenpos(0,R[1],R[2])s.row=math.floor((s.row or 0)+S.row-1)s.col=math.floor((s.col or 0)+S.col-1)s.relative=nil else if not s.row or s.row<=1 then s.row=math.floor((vim.o.lines-s.height)*s.row)end;if not s.col or s.col<=1 then s.col=math.floor((vim.o.columns-s.width)*s.col)end;s.col=math.min(s.col,P-s.width)s.row=math.min(s.row,Q-s.height)end;if s.border==false then s.border="none"elseif not s.border or s.border==true then s.border="rounded"end;if type(s.border)=="string"then s._border=s.border;s.border=b.globals.winopts._borderchars[s.border]or b.globals.winopts._borderchars["rounded"]end;s.nohl_borderchars=H(s.border)local T;if s.preview.layout=="horizontal"or s.preview.layout=="flex"and vim.o.columns>s.preview.flip_columns then T=s.preview.horizontal else T=s.preview.vertical end;s.preview_pos=T:match("[^:]+")or"right"s.preview_size=tonumber(T:match(":(%d+)%%"))or 50;return s end;function e:reset_win_highlights(U,V)local W=("Normal:%s,FloatBorder:%s"):format(self.winopts.__hl.normal,self.winopts.__hl.border)if self._previewer then for r,X in ipairs({"CursorLine","CursorLineNr"})do if self.winopts.__hl[X:lower()]then W=W..(",%s:%s"):format(X,self.winopts.__hl[X:lower()])end end end;if V then W=("Normal:%s"):format(self.winopts.__hl.border)end;vim.api.nvim_win_set_option(U,"winhighlight",W)end;function e:check_exit_status(Y)if not self:validate()then return end;if Y~=0 and Y~=130 then local i=vim.api.nvim_buf_get_lines(self.fzf_bufnr,0,1,false)if Y~=1 or i and#i[1]>0 then a.warn(("fzf error %s: %s"):format(Y or"<null>",i and#i[1]>0 and i[1]or"<null>"))end end end;function e:_set_autoclose(Z)if Z~=nil then self._autoclose=Z else self._autoclose=true end;return self._autoclose end;function e.set_autoclose(Z)if not f then return nil end;return f:_set_autoclose(Z)end;function e.autoclose()if not f then return nil end;return f._autoclose end;local function _(O,h,a0)local a1=O.winopts.preview[h]or b.globals.winopts.preview[h]return a1 and a1:match(a0)end;function e:new(N)if f then f._reuse=true;return f end;N=N or{}self._o=N;self=setmetatable({},{__index=self})self.actions=N.actions;self.winopts=M(N)self.fullscreen=self.winopts.fullscreen;self.preview_wrap=not _(N,"wrap","nowrap")self.preview_hidden=not _(N,"hidden","nohidden")self.preview_border=not _(N,"border","noborder")self.keymap=N.keymap;self.previewer=N.previewer;self.prompt=N.prompt or N.fzf_opts["--prompt"]self.fn_save_query=N.fn_save_query;self._orphaned_bufs={}self:_set_autoclose(N.autoclose)f=self;return self end;function e:attach_previewer(a2)if self._previewer and self._previewer.close then self._previewer:close()end;if self._previewer and self._previewer.win_leave then self._previewer:win_leave()end;self._previewer=a2;self.previewer_is_builtin=a2 and type(a2.display_entry)=="function"end;function e:fs_preview_layout(a3)local a4=self.prev_winopts;local a5=self.border_winopts;if not a3 or self.winopts.split or not a4 or not a5 or vim.tbl_isempty(a4)or vim.tbl_isempty(a5)then return a4,a5 end;local y=self.winopts.preview_pos;local a6=0;local a7=0;if y=="down"or y=="up"then a7=vim.o.columns-a5.width;if y=="down"then a6=vim.o.lines-a5.row-a5.height-vim.o.cmdheight elseif y=="up"then a6=a5.row-a5.height end;a5.col=0;a4.col=a5.col+1 elseif y=="left"or y=="right"then a6=vim.o.lines-a5.height-vim.o.cmdheight;if y=="left"then a5.col=a5.col-1;a4.col=a4.col-1;a7=a5.col-a5.width elseif y=="right"then a7=vim.o.columns-a5.col-a5.width end;a5.row=0;a4.row=a5.row+1 end;a4.height=a4.height+a6;a5.height=a5.height+a6;a4.width=a4.width+a7;a5.width=a5.width+a7;return a4,a5 end;function e:preview_layout()if self.winopts.split and self.previewer_is_builtin then local a8=d.getwininfo(self.fzf_winid)[1]local x=vim.wo[self.fzf_winid].signcolumn=="no"and 1 or 0;self.layout=self:generate_layout({row=a8.winrow,col=a8.wincol,height=a8.height,width=c.nvim_win_get_width(self.fzf_winid),signcol_width=x,preview_pos=self.winopts.preview_pos,preview_size=self.winopts.preview_size,split=self.winopts.split})end;if not self.layout then return{},{}end;local F=self.layout.preview.anchor;local t,u=self.layout.preview.row,self.layout.preview.col;local w,v=self.layout.preview.width,self.layout.preview.height;if not F or not w or w<1 or not v or v<1 then return{},{}end;local s={relative="editor",focusable=false,style="minimal"}if self.winopts.split then s.relative="win"end;local a9=vim.tbl_extend("force",s,{focusable=true,anchor=F,width=w,height=v,col=u,row=t})local a5=vim.tbl_extend("force",s,{anchor=F,width=w+2,height=v+2,col=F:match("W")and u-1 or u+1,row=F:match("N")and t-1 or t+1})return a9,a5 end;function e:validate_preview()return not self.closing and self.preview_winid and self.preview_winid>0 and c.nvim_win_is_valid(self.preview_winid)and self.border_winid and self.border_winid>0 and c.nvim_win_is_valid(self.border_winid)end;function e:preview_winids()return self.preview_winid,self.border_winid end;function e:update_border_buf()local aa=self.border_buf;local a5=self.border_winopts;local K=self.winopts.nohl_borderchars;local w,v=a5.width,a5.height;local ab=K[1]..K[2]:rep(w-2)..K[3]local ac=K[8]..(" "):rep(w-2)..K[4]local ad=K[7]..K[6]:rep(w-2)..K[5]local i={ab}for r=1,v-2 do table.insert(i,ac)end;table.insert(i,ad)if not aa then aa=c.nvim_create_buf(false,true)vim.bo[aa].modifiable=true;vim.bo[aa].bufhidden="wipe"end;c.nvim_buf_set_lines(aa,0,-1,1,i)return aa end;function e:redraw_preview()if not self.previewer_is_builtin or self.preview_hidden then return end;self.prev_winopts,self.border_winopts=self:preview_layout()if vim.tbl_isempty(self.prev_winopts)or vim.tbl_isempty(self.border_winopts)then return-1,-1 end;if self.fullscreen then self.prev_winopts,self.border_winopts=self:fs_preview_layout(self.fullscreen)end;if self:validate_preview()then self.border_buf=c.nvim_win_get_buf(self.border_winid)self:update_border_buf()c.nvim_win_set_config(self.border_winid,self.border_winopts)c.nvim_win_set_config(self.preview_winid,self.prev_winopts)if self._previewer and self._previewer.display_last_entry then self._previewer:set_winopts(self.preview_winid)self._previewer:display_last_entry()end else local ae=c.nvim_create_buf(false,true)c.nvim_buf_set_option(ae,"bufhidden","wipe")self.border_buf=self:update_border_buf()self.preview_winid=c.nvim_open_win(ae,false,self.prev_winopts)self.border_winid=c.nvim_open_win(self.border_buf,false,self.border_winopts)c.nvim_win_set_option(self.border_winid,"wrap",false)end;self:reset_win_highlights(self.border_winid,true)self:reset_win_highlights(self.preview_winid)return self.preview_winid,self.border_winid end;function e:validate()return self.fzf_winid and self.fzf_winid>0 and c.nvim_win_is_valid(self.fzf_winid)end;function e:fs_fzf_layout(a3,s)if not a3 or self.winopts.split then return s end;if not self.previewer_is_builtin or self.preview_hidden then s.col=0;s.row=0;s.width=vim.o.columns;s.height=vim.o.lines-vim.o.cmdheight-2 else local y=self.winopts.preview_pos;if y=="down"or y=="up"then s.col=0;s.width=vim.o.columns;if y=="down"then s.height=s.height+s.row;s.row=0 elseif y=="up"then s.height=s.height+vim.o.lines-s.row-s.height-vim.o.cmdheight-2 end elseif y=="left"or y=="right"then s.row=0;s.height=vim.o.lines-vim.o.cmdheight-2;if y=="right"then s.width=s.width+s.col;s.col=0 elseif y=="left"then s.width=s.width+vim.o.columns-s.col-s.width-1 end end end;return s end;function e:redraw()self.winopts=M(self._o)if not self.winopts.split and self.previewer_is_builtin then self.layout=self:generate_layout(self.winopts)end;if self:validate()then self:redraw_main()end;if self:validate_preview()then self:redraw_preview()end end;function e:redraw_main()if self.winopts.split then return end;local af=self._previewer and self.preview_hidden;local ag=self.winopts.relative or"editor"local ah,i=vim.o.columns,vim.o.lines;if ag=="win"then ah,i=vim.api.nvim_win_get_width(0),vim.api.nvim_win_get_height(0)end;local s=a.tbl_deep_clone(self.winopts)if self.layout and not af then s=a.tbl_deep_clone(self.layout.fzf)end;if self.fullscreen then s=self:fs_fzf_layout(self.fullscreen,s)end;local ai={width=s.width or math.min(ah-4,math.max(80,ah-20)),height=s.height or math.min(i-4,math.max(20,i-10)),style="minimal",relative=ag,border=self.winopts.border}ai.row=s.row or math.floor((i-ai.height)/2-1)ai.col=s.col or math.floor((ah-ai.width)/2)if self.winopts._border and self.winopts._border=="none"then ai.border=self.winopts._border;ai.width=ai.width+2;ai.height=ai.height+2 end;if type(ai.border)=="table"then local function aj(ak,al)for r,L in ipairs(al)do if ak[L]and#ak[L]>0 then return false end end;return true end;ai.height=ai.height+(aj(ai.border,{2})and 1 or 0)+(aj(ai.border,{6})and 1 or 0)ai.width=ai.width+(aj(ai.border,{4})and 1 or 0)+(aj(ai.border,{8})and 1 or 0)end;if self:validate()then if self._previewer and self._previewer.clear_on_redraw and self._previewer.clear_preview_buf then self._previewer:clear_preview_buf(true)self._previewer:clear_cached_buffers()end;c.nvim_win_set_config(self.fzf_winid,ai)else local am=vim.o.cursorline;self.fzf_bufnr=vim.api.nvim_create_buf(false,true)self.fzf_winid=vim.api.nvim_open_win(self.fzf_bufnr,true,ai)if vim.o.cursorline~=am then vim.o.cursorline=am end end end;function e:set_redraw_autocmd()vim.cmd("augroup FzfLua")vim.cmd('au VimResized <buffer> lua require("fzf-lua").redraw()')vim.cmd("augroup END")end;function e:set_winleave_autocmd()vim.cmd("augroup FzfLua")vim.cmd("au!")vim.cmd(("au WinLeave <buffer> %s"):format([[lua require('fzf-lua.win').win_leave()]]))vim.cmd("augroup END")end;function e:set_tmp_buffer()if not self:validate()then return end;local ae=c.nvim_create_buf(false,true)vim.api.nvim_win_set_buf(self.fzf_winid,ae)self:set_winleave_autocmd()self:set_redraw_autocmd()table.insert(self._orphaned_bufs,self.fzf_bufnr)self.fzf_bufnr=ae;vim.api.nvim_win_set_option(self.fzf_winid,"cursorline",false)return self.fzf_bufnr end;function e:set_style_minimal(an)if not tonumber(an)or not c.nvim_win_is_valid(an)then return end;vim.wo[an].number=false;vim.wo[an].relativenumber=false;vim.wo[an].cursorline=false;vim.wo[an].cursorcolumn=false;vim.wo[an].spell=false;vim.wo[an].list=false;vim.wo[an].signcolumn="no"vim.wo[an].foldcolumn="0"vim.wo[an].colorcolumn=""end;function e:create()if self._reuse then self:set_tmp_buffer()self:setup_keybinds()if self.winopts.on_create and type(self.winopts.on_create)=="function"then self.winopts.on_create()end;vim.cmd("redraw")return end;if not self.winopts.split and self.previewer_is_builtin then self.layout=self:generate_layout(self.winopts)end;self.src_bufnr=vim.api.nvim_get_current_buf()self.src_winid=vim.api.nvim_get_current_win()if self.winopts.split then vim.cmd(self.winopts.split)self.fzf_bufnr=vim.api.nvim_get_current_buf()self.fzf_winid=vim.api.nvim_get_current_win()self:set_style_minimal(self.fzf_winid)else self:redraw_main()end;self:set_winleave_autocmd()self:set_redraw_autocmd()self:reset_win_highlights(self.fzf_winid)if self.winopts.on_create and type(self.winopts.on_create)=="function"then self.winopts.on_create()end;self:redraw_preview()self:setup_keybinds()return{src_bufnr=self.src_bufnr,src_winid=self.src_winid,fzf_bufnr=self.fzf_bufnr,fzf_winid=self.fzf_winid}end;function e:close_preview()if self._previewer and self._previewer.close then self._previewer:close()end;if self.border_winid and vim.api.nvim_win_is_valid(self.border_winid)then c.nvim_win_close(self.border_winid,true)end;if self.border_buf and vim.api.nvim_buf_is_valid(self.border_buf)then vim.api.nvim_buf_delete(self.border_buf,{force=true})end;if self.preview_winid and vim.api.nvim_win_is_valid(self.preview_winid)then c.nvim_win_close(self.preview_winid,true)end;if self._sbuf1 and vim.api.nvim_buf_is_valid(self._sbuf1)then vim.api.nvim_buf_delete(self._sbuf1,{force=true})end;if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then c.nvim_win_close(self._swin1,true)end;if self._sbuf2 and vim.api.nvim_buf_is_valid(self._sbuf2)then vim.api.nvim_buf_delete(self._sbuf2,{force=true})end;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then c.nvim_win_close(self._swin2,true)end;self._sbuf1,self._sbuf2,self._swin1,self._swin2=nil,nil,nil,nil;self.border_buf=nil;self.border_winid=nil;self.preview_winid=nil end;function e:close()self.closing=true;self:close_preview()if self.fzf_winid and vim.api.nvim_win_is_valid(self.fzf_winid)then pcall(vim.api.nvim_win_close,self.fzf_winid,{force=true})end;if self.fzf_bufnr and vim.api.nvim_buf_is_valid(self.fzf_bufnr)then vim.api.nvim_buf_delete(self.fzf_bufnr,{force=true})end;if self._orphaned_bufs then for r,ao in ipairs(self._orphaned_bufs)do if vim.api.nvim_buf_is_valid(ao)then vim.api.nvim_buf_delete(ao,{force=true})end end end;if self.winopts and self.winopts.split and self.src_winid and self.src_winid>0 and self.src_winid~=vim.api.nvim_get_current_win()and vim.api.nvim_win_is_valid(self.src_winid)then vim.api.nvim_set_current_win(self.src_winid)end;self.closing=nil;self._reuse=nil;self._orphaned_bufs=nil;f=nil;a.reset_info()end;function e.win_leave()local self=f;if not self then return end;if self._previewer and self._previewer.win_leave then self._previewer:win_leave()end;if not self or self.closing then return end;f:close()end;function e:clear_border_highlights()if self.border_winid and vim.api.nvim_win_is_valid(self.border_winid)then vim.fn.clearmatches(self.border_winid)end end;function e:set_title_hl()if self.winopts.__hl.title and self._title_len and self._title_len>0 then pcall(vim.api.nvim_win_call,self.border_winid,function()d.matchaddpos(self.winopts.__hl.title,{{1,self._title_position,self._title_len+1}},11)end)end end;function e:update_scrollbar_border(N)if N.bar_height>=N.line_count then return end;local K=self.winopts.nohl_borderchars;local ap=self.winopts.preview.scrollchars;N.bar_offset=N.bar_offset+1;if type(self.winopts.preview.scrollchar)=="string"and#self.winopts.preview.scrollchar>0 then ap[1]=self.winopts.preview.scrollchar end;for L=1,2 do if not ap[L]or#ap[L]==0 then ap[L]=K[4]end end;local aq=function(ak,ar)local as=a.tbl_length(ak)if as==0 or a.tbl_length(ak[as])==8 then table.insert(ak,{})as=as+1 end;table.insert(ak[as],ar)end;local at,au={},{}local i=c.nvim_buf_get_lines(self.border_buf,1,-2,true)for L=1,#i do local av,aw=i[L],d.strwidth(i[L])local ax;if L>=N.bar_offset and L<N.bar_offset+N.bar_height then ax=ap[1]aq(at,{L+1,aw+2,1})else ax=ap[2]aq(au,{L+1,aw+2,1})end;i[L]=d.strcharpart(av,0,aw-1)..ax end;c.nvim_buf_set_lines(self.border_buf,1,-2,0,i)if self.winopts.__hl.scrollborder_f or self.winopts.__hl.scrollborder_e then pcall(vim.api.nvim_win_call,self.border_winid,function()if self.winopts.hl.scrollborder_f then for L=1,#at do d.matchaddpos(self.winopts.__hl.scrollborder_f,at[L],11)end end;if self.winopts.__hl.scrollborder_e then for L=1,#au do d.matchaddpos(self.winopts.__hl.scrollborder_e,au[L],11)end end end)end end;local function ay(az)if az and vim.api.nvim_buf_is_valid(az)then return az end;az=c.nvim_create_buf(false,true)vim.bo[az].modifiable=true;vim.bo[az].bufhidden="wipe"return az end;function e:hide_scrollbar()if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then vim.api.nvim_win_hide(self._swin1)self._swin1=nil end;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then vim.api.nvim_win_hide(self._swin2)self._swin2=nil end end;function e:update_scrollbar_float(N)if N.bar_height>=N.line_count then self:hide_scrollbar()else local aA=N.wininfo;local aB={}aB.relative="editor"aB.style="minimal"aB.width=1;aB.height=aA.height;aB.row=aA.winrow-1;aB.col=aA.wincol+aA.width+(tonumber(self.winopts.preview.scrolloff)or-2)aB.zindex=aA.zindex or 997;if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then vim.api.nvim_win_set_config(self._swin1,aB)else aB.noautocmd=true;self._sbuf1=ay(self._sbuf1)self._swin1=vim.api.nvim_open_win(self._sbuf1,false,aB)local W=self.winopts.__hl.scrollfloat_e or"PmenuSbar"vim.api.nvim_win_set_option(self._swin1,"winhighlight",("Normal:%s,NormalNC:%s,NormalFloat:%s"):format(W,W,W))end;local aC=a.tbl_deep_clone(aB)aC.height=N.bar_height;aC.row=aB.row+N.bar_offset;aC.zindex=aB.zindex+1;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then vim.api.nvim_win_set_config(self._swin2,aC)else aC.noautocmd=true;self._sbuf2=ay(self._sbuf2)self._swin2=vim.api.nvim_open_win(self._sbuf2,false,aC)local W=self.winopts.__hl.scrollfloat_f or"PmenuThumb"vim.api.nvim_win_set_option(self._swin2,"winhighlight",("Normal:%s,NormalNC:%s,NormalFloat:%s"):format(W,W,W))end end end;function e:update_scrollbar()if not self.winopts.preview.scrollbar or self.winopts.preview.scrollbar=="none"or not self:validate_preview()then return end;local aD=c.nvim_win_get_buf(self.preview_winid)local N={}N.wininfo=d.getwininfo(self.preview_winid)[1]N.line_count=c.nvim_buf_line_count(aD)local aE,v=N.wininfo.topline,N.wininfo.height;N.bar_height=math.min(v,math.ceil(v*v/N.line_count))N.bar_offset=math.min(v-N.bar_height,math.floor(v*aE/N.line_count))self:clear_border_highlights()self:set_title_hl()if self.winopts.preview.scrollbar=="float"then self:update_scrollbar_float(N)else self:update_scrollbar_border(N)end end;function e:update_title(aF)self:update_border_buf()local aG=7;local aa=c.nvim_win_get_buf(self.border_winid)local ab=c.nvim_buf_get_lines(aa,0,1,0)[1]local w=d.strwidth(ab)if#aF>w-aG then aF=aF:sub(1,w-aG).." "end;self._title_len=#aF;local aH=d.strwidth(aF)local aI=d.strcharpart(ab,0,3)if self.winopts.preview.title_align=="center"then aI=d.strcharpart(ab,0,a.round((w-aH)/2))elseif self.winopts.preview.title_align=="right"then aI=d.strcharpart(ab,0,w-(aH+3))end;local aJ=d.strcharpart(ab,aH+d.strwidth(aI),w)aF=("%s%s%s"):format(aI,aF,aJ)c.nvim_buf_set_lines(aa,0,1,1,{aF})self._title_position=#aI;self:set_title_hl()end;function e.toggle_fullscreen()if not f or f.winopts.split then return end;local self=f;self.fullscreen=not self.fullscreen;self:hide_scrollbar()if self and self:validate()then self:redraw_main()end;if self and self:validate_preview()then self:redraw_preview()end end;function e.toggle_preview()if not f then return end;local self=f;self.preview_hidden=not self.preview_hidden;if self.winopts.split and self._fzf_toggle_prev_bind then a.feed_keys_termcodes(self._fzf_toggle_prev_bind)end;if self.preview_hidden and self:validate_preview()then self:close_preview()self:redraw_main()elseif not self.preview_hidden then self:redraw_main()self:redraw_preview()if self._previewer and self._previewer.display_last_entry then self._previewer:display_last_entry()end end;f=self end;function e.toggle_preview_wrap()if not f then return end;local self=f;self.preview_wrap=not self.preview_wrap;if self and self:validate_preview()then c.nvim_win_set_option(self.preview_winid,"wrap",self.preview_wrap)end end;function e.toggle_preview_cw(aK)if not f or f.winopts.split or not f:validate_preview()then return end;local self=f;local R={"up","right","down","left"}local aL;for L=1,#R do if R[L]==self.winopts.preview_pos then aL=L;break end end;if not aL then return end;local aM=aK>0 and aL+1 or aL-1;if aM<1 then aM=#R end;if aM>#R then aM=1 end;self.winopts.preview_pos=R[aM]self.layout=self:generate_layout(self.winopts)self:close_preview()self:redraw_main()self:redraw_preview()if self._previewer and self._previewer.display_last_entry then self._previewer:display_last_entry()end end;function e.preview_scroll(aK)if not f then return end;local self=f;if self:validate_preview()and self._previewer and self._previewer.scroll then self._previewer:scroll(aK)end end;function e.toggle_help()if not f then return end;local self=f;if self.km_winid then if vim.api.nvim_win_is_valid(self.km_winid)then vim.api.nvim_win_close(self.km_winid,true)end;if vim.api.nvim_buf_is_valid(self.km_bufnr)then vim.api.nvim_buf_delete(self.km_bufnr,{force=true})end;self.km_winid=nil;self.km_bufnr=nil;return end;local O={}O.max_height=O.max_height or math.floor(0.4*vim.o.lines)O.mode_width=O.mode_width or 10;O.name_width=O.name_width or 28;O.keybind_width=O.keybind_width or 14;O.normal_hl=O.normal_hl or self.winopts.__hl.help_normal;O.border_hl=O.border_hl or self.winopts.__hl.help_border;O.winblend=O.winblend or 0;O.column_padding=O.column_padding or"  "O.column_width=O.keybind_width+O.name_width+#O.column_padding+2;O.close_with_action=O.close_with_action or true;local function aN(aO,l,m,aP,aQ,aR)return("%s%%-%ds %%-%ds %%-%ds"):format(O.column_padding,aP,aQ,aR):format("`"..aO.."`","|"..l.."|","*"..m.."*")end;local aS={}local aT=self.previewer_is_builtin and"builtin"or"fzf"for r,aO in ipairs({"builtin","fzf"})do for l,m in pairs(self.keymap[aO])do if not k[m]or aO==aT then if aO=="builtin"then l=a.neovim_bind_to_fzf(l)end;table.insert(aS,aN(aO,l,m,O.mode_width,O.keybind_width,O.name_width))end end end;if self.actions then for l,m in pairs(self.actions)do if l=="default"then l="enter"end;if type(m)=="table"then m=b.get_action_helpstr(m[1])or m elseif m then m=b.get_action_helpstr(m)or m end;if m then table.insert(aS,aN("action",l,("%s"):format(m):gsub(" ",""),O.mode_width,O.keybind_width,O.name_width))end end end;table.sort(aS,function(aU,aV)if aU<aV then return true else return false end end)local function aW(ak,aX)local aY=#ak>0 and ak[#ak]if not aY or#aY+#aX>vim.o.columns then table.insert(ak,aX)else ak[#ak]=aY..aX end end;local i={}for r,aZ in ipairs(aS)do aW(i,aZ)end;local v=#i<O.max_height and#i or O.max_height;i={}for a_=0,math.floor(vim.o.columns/(O.column_width+#O.column_padding))do for L=1,v do local aL=v*a_+L;i[L]=a_==0 and aS[aL]or i[L]..(aS[aL]or"")end end;local s={relative="editor",style="minimal",width=vim.o.columns,height=v,row=vim.o.lines-v-vim.o.cmdheight-2,col=1,border={" ","─"," "," "," "," "," "," "},zindex=999}self.km_bufnr=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_option(self.km_bufnr,"bufhidden","wipe")self.km_winid=vim.api.nvim_open_win(self.km_bufnr,false,s)vim.api.nvim_buf_set_name(self.km_bufnr,"_FzfLuaHelp")vim.api.nvim_win_set_option(self.km_winid,"winhl",string.format("Normal:%s,FloatBorder:%s",O.normal_hl,O.border_hl))vim.api.nvim_win_set_option(self.km_winid,"winblend",O.winblend)vim.api.nvim_win_set_option(self.km_winid,"foldenable",false)vim.api.nvim_win_set_option(self.km_winid,"wrap",false)vim.api.nvim_buf_set_option(self.km_bufnr,"filetype","help")vim.cmd(string.format("autocmd BufLeave <buffer> ++once lua %s",table.concat({string.format("pcall(vim.api.nvim_win_close, %s, true)",self.km_winid),string.format("pcall(vim.api.nvim_buf_delete, %s, {force=true})",self.km_bufnr)},";")))vim.api.nvim_buf_set_lines(self.km_bufnr,0,-1,false,i)end;return e
