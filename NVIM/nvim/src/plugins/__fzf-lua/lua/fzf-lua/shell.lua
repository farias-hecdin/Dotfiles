local a=vim.loop;local b=require"fzf-lua.path"local c=require"fzf-lua.libuv"local d={}local e=0;local f={}function d.register_func(g)e=e+1;f[e]=g;return e end;function d.get_func(h)return f[h]end;function d.raw_async_action(g,i,j)if not i then i="{+}"end;local k=function(l,...)local m=a.new_pipe(false)local n={...}pcall(function()local o=loadstring("return require'fzf-lua'")()if o then o.__INFO=vim.tbl_deep_extend("force",o.__INFO or{},{selected=n[1][1]})end end)a.pipe_connect(m,l,function(p)if p then error(string.format("pipe_connect(%s) failed with error: %s",l,p))else vim.schedule(function()g(m,unpack(n))end)end end)end;local q=d.register_func(k)local r=vim.v.progpath;local s=("fzf_lua_server=[[%s]], fnc_id=%d %s"):format(vim.g.fzf_lua_server,q,j and", debug=true"or"")local t=("%s -n --headless --clean --cmd %s -- %s"):format(c.shellescape(r),c.shellescape(("lua loadfile([[%s]])().rpc_nvim_exec_lua({%s})"):format(b.join{vim.g.fzf_lua_directory,"shell_helper.lua"},s)),i)return t,q end;function d.async_action(g,i,j)local u,q=d.raw_async_action(g,i,j)return vim.fn.shellescape(u),q end;function d.raw_action(g,i,j)local k=function(m,...)local v=g(...)local w=function(x)a.close(m)end;if type(v)=="string"then a.write(m,v,w)elseif type(v)==nil then w()elseif type(v)=="table"then if not vim.tbl_isempty(v)then a.write(m,vim.tbl_map(function(y)return y.."\n"end,v),w)else w()end else a.write(m,tostring(v).."\n",w)end end;return d.raw_async_action(k,i,j)end;function d.action(g,i,j)local u,q=d.raw_action(g,i,j)return vim.fn.shellescape(u),q end;d.preview_action_cmd=function(g,i,j)local u,q=d.raw_preview_action_cmd(g,i,j)return vim.fn.shellescape(u),q end;d.raw_preview_action_cmd=function(g,i,j)return d.raw_async_action(function(m,...)local function z(x,x)if m and not a.is_closing(m)then a.close(m)m=nil end end;local function A(B,C)if not m then C(true)else a.write(m,B,C)end end;return c.spawn({cmd=g(...),cb_finish=z,cb_write=A},false)end,i,j)end;d.reload_action_cmd=function(D,i)if D.fn_preprocess and type(D.fn_preprocess)=="function"then D=vim.tbl_deep_extend("keep",D,D.fn_preprocess(D))end;return d.raw_async_action(function(m,n)local E=D.__fn_reload(n[1])local F=0;local G=false;local z=function(x,x,x,x)if not m then return end;G=true;if F==0 then a.close(m)m=nil end end;local A=function(B,C,H)assert(not H or H and m and not a.is_closing(m))if not m then return end;if not B then z(nil,nil,5)if C then C(nil)end else F=F+1;a.write(m,tostring(B),function(p)F=F-1;if H then coroutine.resume(H)end;if C then C(p)end;if p then F=0;z(nil,nil,2)end;if F==0 and G then z(nil,nil,3)end end)if H and coroutine.yield()==1 then F=0;z(nil,nil,4)end end end;if type(E)=="string"then c.process_kill(D.__pid)D.__pid=nil;c.async_spawn({cwd=D.cwd,cmd=E,cb_finish=z,cb_write=A,cb_pid=function(I)D.__pid=I end},D.__fn_transform or false)else coroutine.wrap(function()if D.__co then local J=coroutine.status(D.__co)if J~="dead"then coroutine.resume(D.__co,1)end;assert(coroutine.status(D.__co)=="dead")end;D.__co=coroutine.running()local K=function(B,C)B=B and tostring(B).."\n"or nil;return A(B,C)end;local L=function(B,C)B=B and tostring(B).."\n"or nil;return A(B,C,D.__co)end;local M=function(B,C)return A(B,C,D.__co)end;if type(E)=="table"then for x,N in ipairs(E)do L(N)end;z()elseif type(E)=="function"then if D.func_async_callback~=false then E(L,M)else E(K,A)end else end end)()end end,i,D.debug)end;return d
