local a=require"fzf-lua.path"local b=require"fzf-lua.shell"local c=require"fzf-lua.utils"local d=require"fzf-lua.class"local e=vim.api;local f=vim.loop;local g=vim.fn;local h={}h.base=d:extend()function h.base:new(i,j,k)local function l(m,n)if m~=nil then return m else return n end end;i=i or{}self.type="builtin"self.opts=j;self.win=k;self.delay=self.win.winopts.preview.delay or 100;self.title=self.win.winopts.preview.title;self.title_align=self.win.winopts.preview.title_align;self.winopts=self.win.winopts.preview.winopts;self.syntax=l(i.syntax,true)self.syntax_delay=l(i.syntax_delay,0)self.syntax_limit_b=l(i.syntax_limit_b,1024*1024)self.syntax_limit_l=l(i.syntax_limit_l,0)self.limit_b=l(i.limit_b,1024*1024*10)self.backups={}if i.extensions then self.extensions={}for o,p in pairs(i.extensions)do self.extensions[o:lower()]=p end end;local q={["crop"]="crop",["distort"]="distort",["contain"]="contain",["fit_contain"]="fit_contain",["cover"]="cover",["forced_cover"]="forced_cover"}self.ueberzug_scaler=i.ueberzug_scaler and q[i.ueberzug_scaler]if i.ueberzug_scaler and not self.ueberzug_scaler then c.warn(("Invalid ueberzug image scaler '%s', option will be omitted."):format(i.ueberzug_scaler))end;self.cached_buffers={}self.listed_buffers=(function()local r={}vim.tbl_map(function(s)if vim.fn.buflisted(s)==1 then r[tostring(s)]=true end end,vim.api.nvim_list_bufs())return r end)()return self end;function h.base:close()self:restore_winopts(self.win.preview_winid)self:clear_preview_buf()self:clear_cached_buffers()self.backups={}end;function h.base:gen_winopts()local t={wrap=self.win.preview_wrap}return vim.tbl_extend("keep",t,self.winopts)end;function h.base:backup_winopts(u)if not u or not e.nvim_win_is_valid(u)then return end;for v,w in pairs(self:gen_winopts())do if c.nvim_has_option(v)then self.backups[v]=e.nvim_win_get_option(u,v)end end end;function h.base:restore_winopts(u)if not u or not e.nvim_win_is_valid(u)then return end;for v,x in pairs(self.backups)do vim.api.nvim_win_set_option(u,v,x)end end;function h.base:set_winopts(u)if self.do_not_set_winopts then return end;if not u or not e.nvim_win_is_valid(u)then return end;for v,p in pairs(self:gen_winopts())do if c.nvim_has_option(v)then e.nvim_win_set_option(u,v,p)end end end;function h.base:preview_is_terminal()if not self.win or not self.win:validate_preview()then return end;return vim.fn.getwininfo(self.win.preview_winid)[1].terminal==1 end;function h.base:get_tmp_buffer()local y=e.nvim_create_buf(false,true)e.nvim_buf_set_option(y,"bufhidden","wipe")return y end;function h.base:set_preview_buf(z)if not self.win or not self.win:validate_preview()then return end;e.nvim_win_set_buf(self.win.preview_winid,z)self.preview_bufnr=z;self:set_winopts(self.win.preview_winid)end;local function A(B)if tonumber(B)and vim.api.nvim_buf_is_valid(B)then e.nvim_buf_call(B,function()vim.cmd('delm \\"')end)vim.api.nvim_buf_delete(B,{force=true})end end;function h.base:cache_buffer(B,C,D)if not C then return end;if not B then return end;local E=self.cached_buffers[C]if E then if E.bufnr==B then return else if not E.do_not_unload then A(E.bufnr)end end end;self.cached_buffers[C]={bufnr=B,do_not_unload=D}e.nvim_buf_set_option(B,"bufhidden","hide")end;function h.base:clear_cached_buffers()for w,F in pairs(self.cached_buffers)do if not F.do_not_unload then A(F.bufnr)end end;self.cached_buffers={}end;function h.base:clear_preview_buf(z)local G=nil;if(self.win and self.win._reuse or z)and self.win and self.win.preview_winid and tonumber(self.win.preview_winid)>0 and e.nvim_win_is_valid(self.win.preview_winid)then G=self:get_tmp_buffer()e.nvim_win_set_buf(self.win.preview_winid,G)end;if not self.do_not_unload then A(self.preview_bufnr)end;self.preview_bufnr=nil;self.loaded_entry=nil;return G end;function h.base:display_last_entry()self:display_entry(self.last_entry)end;function h.base:display_entry(H)if not H then return else self.last_entry=H end;if not self.win or not self.win:validate_preview()then return end;if rawequal(next(self.backups),nil)then self:backup_winopts(self.win.src_winid)end;local I=e.nvim_win_get_buf(self.win.preview_winid)assert(not self.preview_bufnr or I==self.preview_bufnr)if self.should_clear_preview and self:should_clear_preview(H)then self.preview_bufnr=self:clear_preview_buf(true)end;local J=function(K)if not self.win or not self.win:validate_preview()then return end;self:populate_preview_buf(K)if not self.do_not_set_winopts then self:set_winopts(self.win.preview_winid)else self.win:set_style_minimal(self.win.preview_winid)end;self.win:reset_win_highlights(self.win.preview_winid)end;if tonumber(self.delay)>0 then if not self._entry_count then self._entry_count=1 else self._entry_count=self._entry_count+1 end;local L=self._entry_count;vim.defer_fn(function()if self._entry_count==L then J(H)end end,self.delay)else J(H)end end;function h.base:cmdline(w)local M=b.raw_action(function(N,w,w)self:display_entry(N[1])return""end,"{}",self.opts.debug)return M end;function h.base:preview_window(w)if self.win and not self.win.winopts.split then return"nohidden:right:0"else return nil end end;function h.base:scroll(O)local P=self.win.preview_winid;if P<0 or not O then return end;if not e.nvim_win_is_valid(P)then return end;if O==0 then pcall(vim.api.nvim_win_call,P,function()e.nvim_win_set_cursor(0,{1,0})if self.orig_pos then e.nvim_win_set_cursor(0,self.orig_pos)end;c.zz()end)elseif not self:preview_is_terminal()then local Q=("%c"):format(c._if(O>0,0x04,0x15))pcall(vim.api.nvim_win_call,P,function()vim.cmd([[norm! ]]..Q)c.zz()end)else local Q=O>0 and"<C-d>"or"<C-u>"vim.cmd("stopinsert")c.feed_keys_termcodes((":noa lua vim.api.nvim_win_call("..'%d, function() vim.cmd("norm! <C-v>%s") vim.cmd("startinsert") end)<CR>'):format(tonumber(P),Q))end;if self.orig_pos and self.winopts.cursorline then local R=vim.fn.getwininfo(P)if R and R[1]and self.orig_pos[1]>=R[1].topline and self.orig_pos[1]<=R[1].botline then vim.api.nvim_win_set_cursor(P,self.orig_pos)vim.api.nvim_win_set_option(P,"cursorline",true)else vim.api.nvim_win_set_option(P,"cursorline",false)end end;self.win:update_scrollbar()end;h.buffer_or_file=h.base:extend()function h.buffer_or_file:new(i,j,k)h.buffer_or_file.super.new(self,i,j,k)return self end;function h.buffer_or_file:close()self:restore_winopts(self.win.preview_winid)self:clear_preview_buf()self:clear_cached_buffers()self:stop_ueberzug()self.backups={}end;function h.buffer_or_file:parse_entry(H)local S=a.entry_to_file(H,self.opts)return S end;function h.buffer_or_file:should_clear_preview(w)return false end;function h.buffer_or_file:should_load_buffer(S)if not self.loaded_entry then return true end;if type(S)=="string"then S=self:parse_entry(S)end;if S.bufnr and S.bufnr==self.loaded_entry.bufnr or not S.bufnr and S.path and S.path==self.loaded_entry.path then return false end;return true end;function h.buffer_or_file:start_ueberzug()if self._ueberzug_fifo then return self._ueberzug_fifo end;local T=("fzf-lua-%d-ueberzug"):format(vim.fn.getpid())self._ueberzug_fifo=vim.fn.systemlist({"mktemp","--dry-run","--suffix",T})[1]vim.fn.system({"mkfifo",self._ueberzug_fifo})self._ueberzug_job=vim.fn.jobstart({"sh","-c",("tail --follow %s | ueberzug layer --parser json"):format(vim.fn.shellescape(self._ueberzug_fifo))},{on_exit=function(w,U,w)if U~=0 and U~=143 then c.warn(("ueberzug exited with error %d"):format(U)..", run ':messages' to see the detailed error.")end end,on_stderr=function(w,V,w)for w,W in ipairs(V or{})do if#W>0 then c.info(W)end end;if self.preview_bufnr and self.preview_bufnr>0 and vim.api.nvim_buf_is_valid(self.preview_bufnr)then local X=vim.api.nvim_buf_get_lines(self.preview_bufnr,0,-1,false)for w,W in ipairs(V or{})do table.insert(X,W)end;vim.api.nvim_buf_set_lines(self.preview_bufnr,0,-1,false,X)end end})self._ueberzug_pid=vim.fn.jobpid(self._ueberzug_job)return self._ueberzug_fifo end;function h.buffer_or_file:stop_ueberzug()if self._ueberzug_job then vim.fn.jobstop(self._ueberzug_job)if type(f.os_getpriority(self._ueberzug_pid))=="number"then f.kill(self._ueberzug_pid,9)end;self._ueberzug_job=nil;self._ueberzug_pid=nil end;if self._ueberzug_fifo and f.fs_stat(self._ueberzug_fifo)then vim.fn.delete(self._ueberzug_fifo)self._ueberzug_fifo=nil end end;function h.buffer_or_file:populate_terminal_cmd(Y,Z,S)if not Z then return end;Z=type(Z)=="table"and c.deepcopy(Z)or{Z}if not Z[1]or vim.fn.executable(Z[1])~=1 then return false end;self.loaded_entry=nil;self.do_not_cache=true;self.do_not_set_winopts=true;self.clear_on_redraw=true;self:set_preview_buf(Y)if Z[1]:match("ueberzug")then local T=self:start_ueberzug()if not T then return end;local _=vim.api.nvim_win_get_config(self.win.preview_winid)local a0=vim.api.nvim_win_get_position(self.win.preview_winid)local a1={action="add",identifier="preview",x=a0[2],y=a0[1],width=_.width,height=_.height,scaler=self.ueberzug_scaler,path=a.starts_with_separator(S.path)and S.path or a.join({self.opts.cwd or f.cwd(),S.path})}local a2=vim.json.encode(a1)local a3=f.fs_open(self._ueberzug_fifo,"a",-1)if a3 then f.fs_write(a3,a2 .."\n",nil,function(w)f.fs_close(a3)end)end else table.insert(Z,S.path)vim.bo[Y].modifiable=true;vim.api.nvim_buf_call(Y,function()self._job_id=vim.fn.termopen(Z,{cwd=self.opts.cwd,on_exit=function()if self._job_id then self:preview_buf_post(S)self._job_id=nil end end})end)end;self:preview_buf_post(S)return true end;function h.buffer_or_file:populate_from_cache(S)local C=S and(S.path or S.uri)local E=self.cached_buffers[C]if E and vim.api.nvim_buf_is_valid(E.bufnr)then self:set_preview_buf(E.bufnr)self:preview_buf_post(S)return true end;return false end;function h.buffer_or_file:populate_preview_buf(H)if not self.win or not self.win:validate_preview()then return end;local S=self:parse_entry(H)if vim.tbl_isempty(S)then return end;if not self:should_load_buffer(S)then self:preview_buf_post(S)return end;self:stop_ueberzug()if self._job_id and self._job_id>0 then vim.fn.jobstop(self._job_id)self._job_id=nil end;self.clear_on_redraw=false;self.do_not_cache=false;self.do_not_unload=false;self.do_not_set_winopts=S.terminal;if self:populate_from_cache(S)then return elseif S.bufnr and e.nvim_buf_is_loaded(S.bufnr)then S.filetype=vim.api.nvim_buf_get_option(S.bufnr,"filetype")local X=vim.api.nvim_buf_get_lines(S.bufnr,0,-1,false)local Y=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(Y,0,-1,false,X)self:set_preview_buf(Y)self:preview_buf_post(S)elseif S.uri then pcall(vim.api.nvim_win_call,self.win.preview_winid,function()vim.lsp.util.jump_to_location(S,"utf-16",false)self.preview_bufnr=vim.api.nvim_get_current_buf()if self.listed_buffers[tostring(self.preview_bufnr)]then self.do_not_unload=true end end)self:preview_buf_post(S)else if S.bufnr and vim.api.nvim_buf_is_valid(S.bufnr)then S.path=a.relative(vim.api.nvim_buf_get_name(S.bufnr),vim.loop.cwd())end;assert(S.path)if self:populate_from_cache(S)then return end;local Y=self:get_tmp_buffer()if self.extensions and not vim.tbl_isempty(self.extensions)then local a4=a.extension(S.path)local Z=a4 and self.extensions[a4:lower()]if Z and self:populate_terminal_cmd(Y,Z,S)then return end end;do local X=nil;local a5=vim.loop.fs_stat(S.path)if not S.path or not a5 then X={string.format("Unable to stat file %s",S.path)}elseif a5.size>0 and c.perl_file_is_binary(S.path)then X={"Preview is not supported for binary files."}elseif tonumber(self.limit_b)>0 and a5.size>self.limit_b then X={("Preview file size limit (>%dMB) reached, file size %dMB."):format(self.limit_b/(1024*1024),a5.size/(1024*1024))}end;if X then vim.api.nvim_buf_set_lines(Y,0,-1,false,X)self:set_preview_buf(Y)self:preview_buf_post(S)return end end;c.read_file_async(S.path,vim.schedule_wrap(function(V)local X=vim.split(V,"[\r]?\n")if V:sub(#V,#V)=="\n"or V:sub(#V-1,#V)=="\r\n"then table.remove(X)end;vim.api.nvim_buf_set_lines(Y,0,-1,false,X)self:set_preview_buf(Y)self:preview_buf_post(S)end))end end;function h.buffer_or_file:do_syntax(S)if not self.preview_bufnr then return end;if not S or not S.path then return end;local B=self.preview_bufnr;local P=self.win.preview_winid;if e.nvim_buf_is_valid(B)and vim.bo[B].filetype==""then if g.bufwinid(B)==P then local a6=e.nvim_buf_line_count(B)local a7=e.nvim_buf_get_offset(B,a6)local a8=0;if self.syntax_limit_l>0 and a6>self.syntax_limit_l then a8=1 end;if self.syntax_limit_b>0 and a7>self.syntax_limit_b then a8=2 end;if a8>0 then c.info(string.format("syntax disabled for '%s' (%s), consider increasing '%s(%d)'",S.path,c._if(a8==1,("%d lines"):format(a6),("%db"):format(a7)),c._if(a8==1,"syntax_limit_l","syntax_limit_b"),c._if(a8==1,self.syntax_limit_l,self.syntax_limit_b)))end;if a8==0 then if S.filetype=="help"then pcall(e.nvim_buf_set_option,B,"filetype",S.filetype)else local a9=a.join({tostring(B),S.path})pcall(e.nvim_buf_set_name,B,a9)end;local aa,w=pcall(e.nvim_buf_call,B,function()vim.cmd("filetype detect")end)if not aa then c.warn(("syntax highlighting failed for filetype '%s', "):format(S.path and a.extension(S.path)or"<null>").."open the file and run ':filetype detect' for more info.")end end end end end;function h.buffer_or_file:set_cursor_hl(S)pcall(vim.api.nvim_win_call,self.win.preview_winid,function()local ab,ac=tonumber(S.line),tonumber(S.col)local ad=S.pattern or S.text;if not ab or ab<1 then e.nvim_win_set_cursor(0,{1,0})if ad~=""then g.search(ad,"c")end else if not pcall(e.nvim_win_set_cursor,0,{ab,math.max(0,ac-1)})then return end end;c.zz()self.orig_pos=e.nvim_win_get_cursor(0)g.clearmatches()if self.win.winopts.__hl.cursor and not(ab<=1 and ac<=1)then g.matchaddpos(self.win.winopts.__hl.cursor,{{ab,math.max(1,ac)}},11)end end)end;function h.buffer_or_file:update_border(S)if self.title then local ae=S.path;if ae then if self.opts.cwd then ae=a.relative(S.path,self.opts.cwd)end;ae=a.HOME_to_tilde(ae)end;local af=(" %s "):format(ae or S.uri)if S.bufnr then local ag=("buf %d:"):format(S.bufnr)af=(" %s %s "):format(ag,S.path)end;self.win:update_title(af)end;self.win:update_scrollbar()end;function h.buffer_or_file:preview_buf_post(S)if not self.win or not self.win:validate_preview()then return end;if not self:preview_is_terminal()then self:set_cursor_hl(S)if self.syntax then if self.syntax_delay>0 then vim.defer_fn(function()self:do_syntax(S)end,self.syntax_delay)else self:do_syntax(S)end end end;self:update_border(S)self.loaded_entry=S;if not self.do_not_cache then local C=self.loaded_entry and(self.loaded_entry.path or self.loaded_entry.uri)self:cache_buffer(self.preview_bufnr,C,self.do_not_unload)end end;h.help_tags=h.base:extend()function h.help_tags:should_clear_preview(w)return false end;function h.help_tags:new(i,j,k)h.help_tags.super.new(self,i,j,k)self.split=i.split;self.help_cmd=i.help_cmd or"help"self.filetype="help"self.do_not_unload=true;self:init_help_win()return self end;function h.help_tags:gen_winopts()local t={wrap=self.win.preview_wrap,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.help_tags:exec_cmd(ah)ah=ah or""vim.cmd(("noauto %s %s %s"):format(self.split,self.help_cmd,ah))end;function h.help_tags:parse_entry(H)return H:match("[^%s]+")end;local function ai()for w,aj in ipairs(vim.api.nvim_tabpage_list_wins(0))do local B=vim.api.nvim_win_get_buf(aj)local ak=vim.fn.getbufinfo(B)[1]if ak.variables and ak.variables.current_syntax=="help"then return B,aj end end;return nil,nil end;function h.help_tags:init_help_win(ah)if not self.split or self.split~="topleft"and self.split~="botright"then self.split="botright"end;local al=e.nvim_get_current_win()self.help_bufnr,self.help_winid=ai()if not self.help_bufnr then self:exec_cmd(ah)self.help_bufnr=e.nvim_get_current_buf()self.help_winid=e.nvim_get_current_win()pcall(vim.api.nvim_win_set_height,0,0)pcall(vim.api.nvim_win_set_width,0,0)e.nvim_set_current_win(al)end end;function h.help_tags:populate_preview_buf(H)local S=self:parse_entry(H)pcall(vim.api.nvim_win_call,self.help_winid,function()self.prev_help_bufnr=e.nvim_get_current_buf()self:exec_cmd(S)vim.api.nvim_buf_set_option(0,"filetype",self.filetype)self.preview_bufnr=e.nvim_get_current_buf()self.orig_pos=e.nvim_win_get_cursor(0)end)e.nvim_win_set_buf(self.win.preview_winid,self.preview_bufnr)e.nvim_win_set_cursor(self.win.preview_winid,self.orig_pos)self.win:update_scrollbar()if self.prev_help_bufnr~=self.preview_bufnr and e.nvim_buf_is_valid(self.prev_help_bufnr)then e.nvim_buf_delete(self.prev_help_bufnr,{force=true})self.prev_help_bufnr=self.preview_bufnr end end;function h.help_tags:win_leave()if self.help_winid and vim.api.nvim_win_is_valid(self.help_winid)then e.nvim_win_close(self.help_winid,true)end;if self.help_bufnr and vim.api.nvim_buf_is_valid(self.help_bufnr)then vim.api.nvim_buf_delete(self.help_bufnr,{force=true})end;if self.prev_help_bufnr and vim.api.nvim_buf_is_valid(self.prev_help_bufnr)then vim.api.nvim_buf_delete(self.prev_help_bufnr,{force=true})end;self.help_winid=nil;self.help_bufnr=nil;self.prev_help_bufnr=nil end;h.help_file=h.buffer_or_file:extend()function h.help_file:new(i,j,k)h.help_file.super.new(self,i,j,k)return self end;function h.help_file:parse_entry(H)local am,an=H:match("(.*)%s+(.*)$")return{htag=am,hregex=([[\V*%s*]]):format(am:gsub([[\]],[[\\]])),path=an,filetype="help"}end;function h.help_file:gen_winopts()local t={wrap=self.win.preview_wrap,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.help_file:set_cursor_hl(S)pcall(e.nvim_win_call,self.win.preview_winid,function()e.nvim_win_set_cursor(0,{1,0})g.clearmatches()g.search(S.hregex,"W")if self.win.winopts.__hl.search then g.matchadd(self.win.winopts.__hl.search,S.hregex)end;self.orig_pos=e.nvim_win_get_cursor(0)c.zz()end)end;h.man_pages=h.base:extend()function h.man_pages:should_clear_preview(w)return false end;function h.man_pages:gen_winopts()local t={wrap=self.win.preview_wrap,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.man_pages:new(i,j,k)h.man_pages.super.new(self,i,j,k)self.filetype="man"self.cmd=i.cmd or"man -c %s | col -bx"return self end;function h.man_pages:parse_entry(H)return H:match("[^[,( ]+")end;function h.man_pages:populate_preview_buf(H)local S=self:parse_entry(H)local Z=self.cmd:format(S)if type(Z)=="string"then Z={"sh","-c",Z}end;local ao,w=c.io_systemlist(Z)local Y=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(Y,0,-1,false,ao)vim.api.nvim_buf_set_option(Y,"filetype",self.filetype)self:set_preview_buf(Y)self.win:update_scrollbar()end;h.marks=h.buffer_or_file:extend()function h.marks:new(i,j,k)h.marks.super.new(self,i,j,k)return self end;function h.marks:parse_entry(H)local B=nil;local ap,ab,ac,ae=H:match("(.)%s+(%d+)%s+(%d+)%s+(.*)")local aq=vim.api.nvim_buf_get_mark(self.win.src_bufnr,ap)if aq and aq[1]>0 and aq[1]==tonumber(ab)then B=self.win.src_bufnr;ae=e.nvim_buf_get_name(B)end;if ae and#ae>0 then local aa,ar=pcall(vim.fn.expand,ae)if not aa then ae=""else ae=ar end;ae=a.relative(ae,vim.loop.cwd())end;return{bufnr=B,path=ae,line=tonumber(ab)or 1,col=tonumber(ac)or 1}end;h.jumps=h.buffer_or_file:extend()function h.jumps:new(i,j,k)h.jumps.super.new(self,i,j,k)return self end;function h.jumps:parse_entry(H)local B=nil;local w,ab,ac,ae=H:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")if ae then local aa,ar=pcall(vim.fn.expand,ae)if aa then ae=a.relative(ar,vim.loop.cwd())end;if not vim.loop.fs_stat(ae)then B=self.win.src_bufnr;ae=vim.api.nvim_buf_get_name(self.win.src_bufnr)end end;return{bufnr=B,path=ae,line=tonumber(ab)or 1,col=tonumber(ac)+1 or 1}end;h.tags=h.buffer_or_file:extend()function h.tags:new(i,j,k)h.tags.super.new(self,i,j,k)return self end;function h.tags:parse_entry(H)local S=self.super.parse_entry(self,H)S.ctag=a.entry_to_ctag(H)return S end;function h.tags:set_cursor_hl(S)pcall(e.nvim_win_call,self.win.preview_winid,function()e.nvim_win_set_cursor(0,{1,0})g.clearmatches()g.search(S.ctag,"W")if self.win.winopts.__hl.search then g.matchadd(self.win.winopts.__hl.search,S.ctag)end;self.orig_pos=e.nvim_win_get_cursor(0)c.zz()end)end;h.highlights=h.base:extend()function h.highlights:should_clear_preview(w)return false end;function h.highlights:gen_winopts()local t={wrap=self.win.preview_wrap,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.highlights:new(i,j,k)h.highlights.super.new(self,i,j,k)self.ns_previewer=vim.api.nvim_create_namespace("fzf-lua.previewer.hl")return self end;function h.highlights:close()h.highlights.super.close(self)self.tmpbuf=nil end;function h.highlights:populate_preview_buf(H)if not self.tmpbuf then local ao=vim.split(vim.fn.execute"highlight","\n")local as={}for w,p in ipairs(ao)do if p~=""then if p:sub(1,1)==" "then local at=p:match"%s+(.*)"as[#as]=as[#as]..at else table.insert(as,p)end end end;self.tmpbuf=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(self.tmpbuf,0,-1,false,as)for o,p in ipairs(as)do local au=string.find(p,"xxx",1,true)-1;local av=au+3;local aw=string.match(p,"([^ ]*)%s+.*")pcall(vim.api.nvim_buf_add_highlight,self.tmpbuf,0,aw,o-1,au,av)end;self:set_preview_buf(self.tmpbuf)end;local ax="^"..c.strip_ansi_coloring(H).."\\>"pcall(vim.api.nvim_buf_clear_namespace,self.tmpbuf,self.ns_previewer,0,-1)pcall(e.nvim_win_call,self.win.preview_winid,function()e.nvim_win_set_cursor(0,{1,0})g.clearmatches()g.search(ax,"W")if self.win.winopts.__hl.search then g.matchadd(self.win.winopts.__hl.search,ax)end;self.orig_pos=e.nvim_win_get_cursor(0)c.zz()end)self.win:update_scrollbar()end;return h
