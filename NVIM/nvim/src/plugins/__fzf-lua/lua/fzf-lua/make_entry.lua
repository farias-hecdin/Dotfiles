local a={}local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=nil;do local e,f=pcall(require,"fzf-lua.config")if e then d=f end end;a._fzf_lua_server=_G._fzf_lua_server;a._devicons_path=_G._devicons_path;a._devicons_setup=_G._devicons_setup;local function g(h,i,j)if d then local k=c.strsplit(h,".")local l,m=d,nil;for n=1,#k do l=l[k[n]]if not l then break end;if n==#k and type(l)==i then m=l end end;return m elseif a._fzf_lua_server then local o=nil;local p=false;local q,r=nil,nil;if i=="function"then p=true;r={h,i}q=("return require'fzf-lua'.config.bytecode(...)"):format(h)else r={}q=("return require'fzf-lua'.config.%s"):format(h)end;local e,s=pcall(function()local t=vim.fn.sockconnect("pipe",a._fzf_lua_server,{rpc=true})o=vim.rpcrequest(t,"nvim_exec_lua",q,r)vim.fn.chanclose(t)end)if e and p then e,o=pcall(loadstring,o)end;if not e and not j then io.stderr:write(("Error loading remote config section '%s': %s\n"):format(h,s))elseif e and type(o)==i then return o end end end;local function u(h,v)if a._fzf_lua_server then local e,s=pcall(function()local t=vim.fn.sockconnect("pipe",a._fzf_lua_server,{rpc=true})vim.rpcrequest(t,"nvim_exec_lua",([[
        local data = select(1, ...)
        require'fzf-lua'.config.%s = data
      ]]):format(h),{v})vim.fn.chanclose(t)end)if not e then io.stderr:write(("Error setting remote config section '%s': %s\n"):format(h,s))end;return e elseif d then local k=c.strsplit(h,".")local l=d;for n=1,#k do l=l[k[n]]if not l then break end;if n==#k-1 then l[k[n+1]]=v;return l end end end end;local w=function()local function x(y)local z,A,B=y:match(".(..)(..)(..)")z,A,B=tonumber(z,16),tonumber(A,16),tonumber(B,16)return z,A,B end;for C,D in pairs(a._devicons.get_icons())do local z,A,B=x(D.color)c.add_ansi_code("DevIcon"..D.name,string.format("[38;2;%s;%s;%sm",z,A,B))end end;local function E()if d and d._has_devicons then a._devicons=d._devicons elseif a._devicons_path and vim.loop.fs_stat(a._devicons_path)then package.path=(";%s/?.lua;"):format(vim.fn.fnamemodify(a._devicons_path,":h"))..package.path;a._devicons=require("nvim-web-devicons")a._devicons_setup=a._devicons_setup and vim.fn.expand(a._devicons_setup)if a._devicons and a._devicons_setup and vim.loop.fs_stat(a._devicons_setup)then local F=loadfile(a._devicons_setup)if F then F()end end end;if a._devicons and a._devicons.setup and not a._devicons.has_loaded()then a._devicons.setup()end;if a._devicons and a._devicons.has_loaded()then w()end end;pcall(E)if not d then local G={globals={git={},files={},grep={}}}G.globals.git.icons=g("globals.git.icons","table")or{}G.globals.file_icon_colors=g("globals.file_icon_colors","table")or{}G.globals.file_icon_padding=g("globals.file_icon_padding","string")G.globals.files.git_status_cmd=g("globals.files.git_status_cmd","table")G.globals.grep.rg_glob_fn=g("globals.grep.rg_glob_fn","function",true)G.globals.nbsp=g("globals.nbsp","string")if G.globals.nbsp then c.nbsp=G.globals.nbsp end;d=G end;a.get_devicon=function(F,H)local I,J;if a._devicons then I,J=a._devicons.get_icon(F,H:lower(),{default=true})else I,J="ïƒ¶","dark_grey"end;local K=d.globals.file_icon_colors and d.globals.file_icon_colors[H]if K then J=K end;if d.globals.file_icon_padding and#d.globals.file_icon_padding>0 then I=I..d.globals.file_icon_padding end;return I,J end;a.get_diff_files=function(L)local M={}local N=L.git_status_cmd or d.globals.files.git_status_cmd;if not N then return{}end;local e,O,P=pcall(c.io_systemlist,b.git_cwd(N,L))if e and P==0 then for n=1,#O do local I=O[n]:match("[MUDARCT?]+")local F=O[n]:match("[^ ]*$")if I and F then M[F]=I:gsub("%?%?","?")end end end;return M end;a.glob_parse=function(Q,L)if not Q or not Q:find(L.glob_separator)then return Q,nil end;if d.globals.grep.rg_glob_fn then return d.globals.grep.rg_glob_fn(Q,L)end;local R=""local S,T=Q:match("(.*)"..L.glob_separator.."(.*)")for C,h in ipairs(c.strsplit(T,"%s"))do R=R..("%s %s "):format(L.glob_flag,vim.fn.shellescape(h))end;return S,R end;a.preprocess=function(L)if L.cwd_only and not L.cwd then L.cwd=vim.loop.cwd()end;if L.git_icons then L.diff_files=a.get_diff_files(L)end;local U=function(n,V)local W=tonumber(n)and tonumber(n)+6 or#vim.v.argv;if V then io.stdout:write(("[DEBUG]: argv(%d) = %s\n"):format(W,vim.fn.shellescape(vim.v.argv[W])))end;return vim.v.argv[W]end;local X="{argvz}"local Y=L.cmd and L.cmd:match(X)if L.argv_expr and Y then local Q=U(nil,L.debug)u("__resume_data.last_query",Q)if L.__module__ then u(("globals.%s._last_search"):format(L.__module__),{query=Q,no_esc=true})end end;if L.rg_glob and Y then local Q=U()local S,R=a.glob_parse(Q,L)if R then S=S:gsub("%%","%%%%")L.cmd=L.cmd:gsub(X,R..vim.fn.shellescape(S))end end;if L.argv_expr then L.cmd=L.cmd:gsub("{argv.*}",function(Z)local W=Z:match("{argv(.*)}")return vim.fn.shellescape(U(W))end)end;return L end;a.lcol=function(_,L)if not _ then return nil end;local a0=_.filename or vim.api.nvim_buf_get_name(_.bufnr)return string.format("%s:%s:%s:%s%s",a0,c.ansi_codes.green(tostring(_.lnum)),c.ansi_codes.blue(tostring(_.col)),_.text and#_.text>0 and" "or"",not _.text and""or L and L.trim_entry and vim.trim(_.text)or _.text)end;local a1=string.byte(":")a.file=function(Z,L)L=L or{}local a2={}local I,J;local a3=c.find_next_char(Z,a1)or 0;local a4=a3>1 and Z:sub(1,a3-1)or Z;local a5=a3>1 and Z:sub(a3)or nil;local a6,a7=c.strip_ansi_coloring(a4)if not(L.strip_cwd_prefix==false)and b.starts_with_cwd(a6)then a6=b.strip_cwd_prefix(a6)end;if L.cwd and#L.cwd>0 then a6=b.relative(a6,L.cwd)end;if b.starts_with_separator(a6)then if L.cwd_only then local a8=L.cwd or vim.loop.cwd()if not b.is_relative(a6,a8)then return nil end end;a6=b.HOME_to_tilde(a6)end;if L.file_ignore_patterns then for C,a9 in ipairs(L.file_ignore_patterns)do if#a9>0 and a6:match(a9)then return nil end end end;local aa=a6;if L.path_shorten then a6=b.shorten(a6,tonumber(L.path_shorten))end;if L.git_icons then local ab=L.diff_files and L.diff_files[aa]or c.nbsp;for n=1,#ab do I=ab:sub(n,n)local ac=d.globals.git.icons[I]if ac then I=ac.icon;if L.color_icons then I=c.ansi_codes[ac.color or"dark_grey"](I)end end;a2[#a2+1]=I end;a2[#a2+1]=c.nbsp end;if L.file_icons then local a0=b.tail(aa)local H=b.extension(a0)I,J=a.get_devicon(a0,H)if L.color_icons then local ad=c.ansi_codes[J]or c.ansi_codes["dark_grey"]I=ad(I)end;a2[#a2+1]=I;a2[#a2+1]=c.nbsp end;a2[#a2+1]=a7>0 and a4 or a6;a2[#a2+1]=a5;return table.concat(a2)end;a.tag=function(Z,L)local ae,F,af=Z:match("([^\t]+)\t([^\t]+)\t(.*)")if not F or not ae or not af then return Z end;af=af:match('(.*);"')or af;for C,h in ipairs({"/","\\"})do af=af:gsub([[\]]..h,h)end;local ag,ah=af:match("(%d-);?(/.*/)")ag=ag and#ag>0 and tonumber(ag)return("%s%s: %s %s"):format(a.file(F,L),not ag and""or":"..c.ansi_codes.green(tostring(ag)),c.ansi_codes.magenta(ae),c.ansi_codes.green(ah)),ag end;return a
