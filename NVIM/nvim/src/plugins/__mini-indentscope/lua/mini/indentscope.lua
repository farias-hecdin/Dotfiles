local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.7')==0 then vim.notify('(mini.indentscope) Neovim<0.7 is soft deprecated (module works but not supported).'..' It will be deprecated after Neovim 0.9.0 release (module will not work).'..' Please update your Neovim version.')end;_G.MiniIndentscope=a;c=b.setup_config(c)b.apply_config(c)vim.api.nvim_exec([[augroup MiniIndentscope
        au!
        au CursorMoved,CursorMovedI                          * lua MiniIndentscope.auto_draw({ lazy = true })
        au TextChanged,TextChangedI,TextChangedP,WinScrolled * lua MiniIndentscope.auto_draw()
      augroup END]],false)if vim.fn.exists('##ModeChanged')==1 then vim.api.nvim_exec([[augroup MiniIndentscope
          au ModeChanged *:* lua MiniIndentscope.auto_draw({ lazy = true })
        augroup END]],false)end;vim.api.nvim_exec('hi default link MiniIndentscopeSymbol Delimiter',false)end;a.config={draw={delay=100,animation=function(d,e)return 20 end},mappings={object_scope='ii',object_scope_with_border='ai',goto_top='[i',goto_bottom=']i'},options={border='both',indent_at_cursor=true,try_as_border=false},symbol='â•Ž'}a.get_scope=function(f,g,h)h=b.get_config({options=h}).options;if not(f and g)then local i=vim.fn.getcurpos()f=f or i[2]f=h.try_as_border and b.border_correctors[h.border](f,h)or f;g=g or(h.indent_at_cursor and i[5]or math.huge)end;local j=b.get_line_indent(f,h)local k=math.min(g,j)local l={indent=k}if k<=0 then l.top,l.bottom,l.indent=1,vim.fn.line('$'),j else local m,n;l.top,m=b.cast_ray(f,k,'up',h)l.bottom,n=b.cast_ray(f,k,'down',h)l.indent=math.min(j,m,n)end;return{body=l,border=b.border_from_body[h.border](l,h),buf_id=vim.api.nvim_get_current_buf(),reference={line=f,column=g,indent=k}}end;a.auto_draw=function(h)if b.is_disabled()then b.undraw_scope()return end;h=h or{}local o=a.get_scope()if h.lazy and b.current.draw_status~='none'and b.scope_is_equal(o,b.current.scope)then return end;local p=b.current.event_id+1;b.current.event_id=p;local q=b.make_autodraw_opts(o)if q.delay>0 then b.undraw_scope(q)end;vim.defer_fn(function()if b.current.event_id~=p then return end;b.undraw_scope(q)b.current.scope=o;b.draw_scope(o,q)end,q.delay)end;a.draw=function(o,h)o=o or a.get_scope()local q=vim.tbl_deep_extend('force',{animation_fun=b.get_config().draw.animation},h or{})b.undraw_scope()b.current.scope=o;b.draw_scope(o,q)end;a.undraw=function()b.undraw_scope()end;a.gen_animation={}local r=0;setmetatable(a.gen_animation,{__call=function(s,t,h)if r<1 then vim.notify('(mini.indentscope) `MiniIndentscope.gen_animation` is now a table '..[[(for consistency with other `gen_*` functions in 'mini.nvim').]]..' See "Migrate from function type" section of `:h MiniIndentscope.gen_animation`.'..' Calling it as function will be available until next release.')r=r+1 end;if t=='none'then return function()return 0 end end;h=vim.tbl_deep_extend('force',{duration=20,unit='step'},h or{})if not vim.tbl_contains({'total','step'},h.unit)then b.error([[In `gen_animation()` argument `opts.unit` should be one of 'step' or 'total'.]])end;local u,v=b.animation_arithmetic_powers,b.animation_geometrical_powers;local w,x=h.duration,h.unit;local y={linear={impl=u,args={0,{easing='in',duration=w,unit=x}}},quadraticIn={impl=u,args={1,{easing='in',duration=w,unit=x}}},quadraticOut={impl=u,args={1,{easing='out',duration=w,unit=x}}},quadraticInOut={impl=u,args={1,{easing='in-out',duration=w,unit=x}}},cubicIn={impl=u,args={2,{easing='in',duration=w,unit=x}}},cubicOut={impl=u,args={2,{easing='out',duration=w,unit=x}}},cubicInOut={impl=u,args={2,{easing='in-out',duration=w,unit=x}}},quarticIn={impl=u,args={3,{easing='in',duration=w,unit=x}}},quarticOut={impl=u,args={3,{easing='out',duration=w,unit=x}}},quarticInOut={impl=u,args={3,{easing='in-out',duration=w,unit=x}}},exponentialIn={impl=v,args={{easing='in',duration=w,unit=x}}},exponentialOut={impl=v,args={{easing='out',duration=w,unit=x}}},exponentialInOut={impl=v,args={{easing='in-out',duration=w,unit=x}}}}local z=vim.tbl_keys(y)table.sort(z)if not vim.tbl_contains(z,t)then local A='In `gen_animation()` argument `easing` should be one of: '..table.concat(z,', ')..'.'b.error(A)end;local B=y[t]return B.impl(unpack(B.args))end})a.gen_animation.none=function()return function()return 0 end end;a.gen_animation.linear=function(h)return b.animation_arithmetic_powers(0,b.normalize_animation_opts(h))end;a.gen_animation.quadratic=function(h)return b.animation_arithmetic_powers(1,b.normalize_animation_opts(h))end;a.gen_animation.cubic=function(h)return b.animation_arithmetic_powers(2,b.normalize_animation_opts(h))end;a.gen_animation.quartic=function(h)return b.animation_arithmetic_powers(3,b.normalize_animation_opts(h))end;a.gen_animation.exponential=function(h)return b.animation_geometrical_powers(b.normalize_animation_opts(h))end;a.move_cursor=function(C,D,o)o=o or a.get_scope()local E=D and o.border[C]or o.body[C]E=math.min(math.max(E,1),vim.fn.line('$'))vim.api.nvim_win_set_cursor(0,{E,0})vim.cmd('normal! ^')end;a.operator=function(C,F)local o=a.get_scope()if b.scope_get_draw_indent(o)<0 then return end;local G=vim.v.count1;if F then vim.cmd('normal! m`')end;for s=1,G do a.move_cursor(C,true,o)o=a.get_scope(nil,nil,{try_as_border=false})if b.scope_get_draw_indent(o)<0 then return end end end;a.textobject=function(D)local o=a.get_scope()if b.scope_get_draw_indent(o)<0 then return end;local G=D and vim.v.count1 or 1;for s=1,G do local H,I='top','bottom'if D and o.border.bottom==nil then H,I='bottom','top'end;b.exit_visual_mode()a.move_cursor(H,D,o)vim.cmd('normal! V')a.move_cursor(I,D,o)o=a.get_scope(nil,nil,{try_as_border=false})if b.scope_get_draw_indent(o)<0 then return end end end;b.default_config=a.config;b.ns_id=vim.api.nvim_create_namespace('MiniIndentscope')b.timer=vim.loop.new_timer()b.current={event_id=0,scope={},draw_status='none'}b.indent_funs={['min']=function(J,K)return math.min(J,K)end,['max']=function(J,K)return math.max(J,K)end,['top']=function(J,K)return J end,['bottom']=function(J,K)return K end}b.blank_indent_funs={['none']=b.indent_funs.min,['top']=b.indent_funs.bottom,['bottom']=b.indent_funs.top,['both']=b.indent_funs.max}b.border_from_body={['none']=function(l,h)return{}end,['top']=function(l,h)return{top=l.top-1,indent=b.get_line_indent(l.top-1,h)}end,['bottom']=function(l,h)return{bottom=l.bottom+1,indent=b.get_line_indent(l.bottom+1,h)}end,['both']=function(l,h)return{top=l.top-1,bottom=l.bottom+1,indent=math.max(b.get_line_indent(l.top-1,h),b.get_line_indent(l.bottom+1,h))}end}b.border_correctors={['none']=function(f,h)return f end,['top']=function(f,h)local L,M=b.get_line_indent(f,h),b.get_line_indent(f+1,h)return L<M and f+1 or f end,['bottom']=function(f,h)local N,L=b.get_line_indent(f-1,h),b.get_line_indent(f,h)return L<N and f-1 or f end,['both']=function(f,h)local N,L,M=b.get_line_indent(f-1,h),b.get_line_indent(f,h),b.get_line_indent(f+1,h)if N<=L and M<=L then return f end;if N<=M then return f+1 end;return f-1 end}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({draw={c.draw,'table'},mappings={c.mappings,'table'},options={c.options,'table'},symbol={c.symbol,'string'}})vim.validate({['draw.delay']={c.draw.delay,'number'},['draw.animation']={c.draw.animation,'function'},['mappings.object_scope']={c.mappings.object_scope,'string'},['mappings.object_scope_with_border']={c.mappings.object_scope_with_border,'string'},['mappings.goto_top']={c.mappings.goto_top,'string'},['mappings.goto_bottom']={c.mappings.goto_bottom,'string'},['options.border']={c.options.border,'string'},['options.indent_at_cursor']={c.options.indent_at_cursor,'boolean'},['options.try_as_border']={c.options.try_as_border,'boolean'}})return c end;b.apply_config=function(c)a.config=c;local O=c.mappings;b.map('n',O.goto_top,[[<Cmd>lua MiniIndentscope.operator('top', true)<CR>]],{desc='Go to indent scope top'})b.map('n',O.goto_bottom,[[<Cmd>lua MiniIndentscope.operator('bottom', true)<CR>]],{desc='Go to indent scope bottom'})b.map('x',O.goto_top,[[<Cmd>lua MiniIndentscope.operator('top')<CR>]],{desc='Go to indent scope top'})b.map('x',O.goto_bottom,[[<Cmd>lua MiniIndentscope.operator('bottom')<CR>]],{desc='Go to indent scope bottom'})b.map('x',O.object_scope,'<Cmd>lua MiniIndentscope.textobject(false)<CR>',{desc='Object scope'})b.map('x',O.object_scope_with_border,'<Cmd>lua MiniIndentscope.textobject(true)<CR>',{desc='Object scope with border'})b.map('o',O.goto_top,[[<Cmd>lua MiniIndentscope.operator('top')<CR>]],{desc='Go to indent scope top'})b.map('o',O.goto_bottom,[[<Cmd>lua MiniIndentscope.operator('bottom')<CR>]],{desc='Go to indent scope bottom'})b.map('o',O.object_scope,'<Cmd>lua MiniIndentscope.textobject(false)<CR>',{desc='Object scope'})b.map('o',O.object_scope_with_border,'<Cmd>lua MiniIndentscope.textobject(true)<CR>',{desc='Object scope with border'})end;b.is_disabled=function()return vim.g.miniindentscope_disable==true or vim.b.miniindentscope_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.miniindentscope_config or{},c or{})end;b.get_line_indent=function(f,h)local P=vim.fn.prevnonblank(f)local Q=vim.fn.indent(P)if f~=P then local M=vim.fn.indent(vim.fn.nextnonblank(f))local R=b.blank_indent_funs[h.border]Q=R(Q,M)end;return Q end;b.cast_ray=function(f,k,S,h)local T,U=1,-1;if S=='down'then T,U=vim.fn.line('$'),1 end;local V=math.huge;for W=f,T,U do local X=b.get_line_indent(W+U,h)if X<k then return W,V end;if X<V then V=X end end;return T,V end;b.scope_get_draw_indent=function(o)return o.border.indent or o.body.indent-1 end;b.scope_is_equal=function(Y,Z)if type(Y)~='table'or type(Z)~='table'then return false end;return Y.buf_id==Z.buf_id and b.scope_get_draw_indent(Y)==b.scope_get_draw_indent(Z)and Y.body.top==Z.body.top and Y.body.bottom==Z.body.bottom end;b.scope_has_intersect=function(Y,Z)if type(Y)~='table'or type(Z)~='table'then return false end;if Y.buf_id~=Z.buf_id or b.scope_get_draw_indent(Y)~=b.scope_get_draw_indent(Z)then return false end;local _,a0=Y.body,Z.body;return a0.top<=_.top and _.top<=a0.bottom or _.top<=a0.top and a0.top<=_.bottom end;b.indicator_compute=function(o)o=o or b.current.scope;local k=b.scope_get_draw_indent(o)if k<0 then return{}end;local g=k-vim.fn.winsaveview().leftcol;if g<0 then return{}end;local a1={{b.get_config().symbol,'MiniIndentscopeSymbol'}}return{buf_id=vim.api.nvim_get_current_buf(),virt_text=a1,virt_text_win_col=g,top=o.body.top,bottom=o.body.bottom}end;b.draw_scope=function(o,h)o=o or{}h=h or{}local a2=b.indicator_compute(o)if a2.virt_text==nil or#a2.virt_text==0 then b.current.draw_status='finished'return end;local a3=b.make_draw_function(a2,h)b.current.draw_status='drawing'b.draw_indicator_animation(a2,a3,h.animation_fun)end;b.draw_indicator_animation=function(a2,a3,a4)local a5,a6=a2.top,a2.bottom;local a7=math.min(math.max(vim.fn.line('.'),a5),a6)local a8=0;local a9=math.max(a7-a5,a6-a7)local aa=0;local ab;ab=vim.schedule_wrap(function()local ac=a3(a7-a8)if a8>0 then ac=ac and a3(a7+a8)end;if not ac or a8==a9 then b.current.draw_status=a8==a9 and'finished'or b.current.draw_status;b.timer:stop()return end;a8=a8+1;aa=aa+a4(a8,a9)if aa<1 then b.timer:set_repeat(0)return ab()else b.timer:set_repeat(aa)aa=aa-b.timer:get_repeat()b.timer:again()end end)b.timer:start(10000000,0,ab)ab()end;b.undraw_scope=function(h)h=h or{}if h.event_id and h.event_id~=b.current.event_id then return end;pcall(vim.api.nvim_buf_clear_namespace,b.current.scope.buf_id or 0,b.ns_id,0,-1)b.current.draw_status='none'b.current.scope={}end;b.make_autodraw_opts=function(o)local c=b.get_config()local Q={event_id=b.current.event_id,type='animation',delay=c.draw.delay,animation_fun=c.draw.animation}if b.current.draw_status=='none'then return Q end;if b.scope_has_intersect(o,b.current.scope)then Q.type='immediate'Q.delay=0;Q.animation_fun=a.gen_animation.none()return Q end;return Q end;b.make_draw_function=function(a2,h)local ad={hl_mode='combine',priority=2,right_gravity=false,virt_text=a2.virt_text,virt_text_win_col=a2.virt_text_win_col,virt_text_pos='overlay'}local ae=h.event_id;return function(W)if b.current.event_id~=ae and ae~=nil then return false end;if b.is_disabled()then return false end;if not(a2.top<=W and W<=a2.bottom)then return true end;return pcall(vim.api.nvim_buf_set_extmark,a2.buf_id,b.ns_id,W-1,0,ad)end end;b.animation_arithmetic_powers=function(af,h)local ag=({[0]=function(a9)return a9 end,[1]=function(a9)return a9*(a9+1)/2 end,[2]=function(a9)return a9*(a9+1)*(2*a9+1)/6 end,[3]=function(a9)return a9^2*(a9+1)^2/4 end})[af]local ah,ai=h.unit,h.duration;local aj=function(a9,ak)local al=ah=='total'and ai or ai*a9;local am;if ak then am=2*ag(math.ceil(0.5*a9))-(a9%2==1 and 1 or 0)else am=ag(a9)end;return al/am end;return({['in']=function(d,e)return aj(e)*(e-d+1)^af end,['out']=function(d,e)return aj(e)*d^af end,['in-out']=function(d,e)local an=math.ceil(0.5*e)local ao;if e%2==0 then ao=d<=an and an-d+1 or d-an else ao=d<an and an-d+1 or d-an+1 end;return aj(e,true)*ao^af end})[h.easing]end;b.animation_geometrical_powers=function(h)local ah,ai=h.unit,h.duration;local aj=function(a9,ak)local al=ah=='step'and ai*a9 or ai;if a9==1 then return al+1 end;if ak then local an=math.ceil(0.5*a9)if a9%2==1 then al=al+math.pow(0.5*al+1,1/an)-1 end;return math.pow(0.5*al+1,1/an)end;return math.pow(al+1,1/a9)end;return({['in']=function(d,e)local ap=aj(e)return(ap-1)*ap^(e-d)end,['out']=function(d,e)local ap=aj(e)return(ap-1)*ap^(d-1)end,['in-out']=function(d,e)local an,ap=math.ceil(0.5*e),aj(e,true)local ao;if e%2==0 then ao=d<=an and an-d or d-an-1 else ao=d<an and an-d or d-an end;return(ap-1)*ap^ao end})[h.easing]end;b.normalize_animation_opts=function(aq)aq=vim.tbl_deep_extend('force',{easing='in-out',duration=20,unit='step'},aq or{})if not vim.tbl_contains({'in','out','in-out'},aq.easing)then b.error([[In `gen_animation` option `easing` should be one of 'in', 'out', or 'in-out'.]])end;if type(aq.duration)~='number'or aq.duration<0 then b.error([[In `gen_animation` option `duration` should be a positive number.]])end;if not vim.tbl_contains({'total','step'},aq.unit)then b.error([[In `gen_animation` option `unit` should be one of 'step' or 'total'.]])end;return aq end;b.error=function(A)error(('(mini.indentscope) %s'):format(A))end;b.map=function(ar,as,at,h)if as==''then return end;h=vim.tbl_deep_extend('force',{noremap=true,silent=true},h or{})if vim.fn.has('nvim-0.7')==0 then h.desc=nil end;vim.api.nvim_set_keymap(ar,as,at,h)end;b.exit_visual_mode=function()local au=vim.api.nvim_replace_termcodes('<C-v>',true,true,true)local av=vim.fn.mode()if av=='v'or av=='V'or av==au then vim.cmd('normal! '..av)end end;return a
