local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.7')==0 then vim.notify('(mini.ai) Neovim<0.7 is soft deprecated (module works but not supported).'..' It will be deprecated after Neovim 0.9.0 release (module will not work).'..' Please update your Neovim version.')end;_G.MiniAi=a;c=b.setup_config(c)b.apply_config(c)end;a.config={custom_textobjects=nil,mappings={around='a',inside='i',around_next='an',inside_next='in',around_last='al',inside_last='il',goto_left='g[',goto_right='g]'},n_lines=50,search_method='cover_or_next'}a.find_textobject=function(d,e,f)if not(d=='a'or d=='i')then b.error([[`ai_type` should be one of 'a' or 'i'.]])end;f=vim.tbl_deep_extend('force',b.get_default_opts(),f or{})b.validate_search_method(f.search_method)local g=b.get_textobject_spec(e,{d,e,f})if g==nil then return end;if b.is_region(g)then return g end;local h=b.find_textobject_region(g,d,f)if h==nil then local i=string.format([[No textobject %s found covering region%s within %d line%s and `search_method = '%s'`.]],vim.inspect(d..e),f.n_times==1 and''or(' %s times'):format(f.n_times),f.n_lines,f.n_lines==1 and''or's',f.search_method)b.message(i)end;return h end;a.move_cursor=function(j,d,e,f)if not(j=='left'or j=='right')then b.error([[`side` should be one of 'left' or 'right'.]])end;f=f or{}local k=vim.api.nvim_win_get_cursor(0)local l=vim.tbl_deep_extend('force',f,{n_times=1})local m=a.find_textobject(d,e,l)if m==nil then return end;local n=j=='left'and'from'or'to'm.to=m.to or m.from;l.n_times=f.n_times or 1;if k[1]==m[n].line and k[2]==m[n].col-1 then l.n_times=l.n_times+1 end;local o=m[n]if l.n_times>1 then local p=a.find_textobject(d,e,l)if p==nil then return end;p.to=p.to or p.from;o=p[n]end;vim.api.nvim_win_set_cursor(0,{o.line,o.col-1})vim.cmd('normal! zv')end;a.gen_spec={}a.gen_spec.argument=function(f)f=vim.tbl_deep_extend('force',{brackets={'%b()','%b[]','%b{}'},separator=',',exclude_regions={'%b""',"%b''",'%b()','%b[]','%b{}'}},f or{})local q,r,s=f.brackets,f.separator,f.exclude_regions;if f.separators~=nil then vim.notify('(mini.ai) The `separators` option (plural) for `gen_spec.argument` is soft deprecated'..' in favor of `separator` option (singular).'..' The `separators` option will work for some time, but will eventually get removed.'..' See `:h MiniAi.gen_spec.argument`.')local t=vim.tbl_map(vim.pesc,f.separators)r='['..table.concat(t,'')..']'end;local h={}h[1]=q;h[2]=function(u,v)b.cache.argument_sep_spans=b.cache.argument_sep_spans or{}b.cache.argument_sep_spans[h]=b.cache.argument_sep_spans[h]or{}local w=b.cache.argument_sep_spans[h][u]or b.arg_get_separator_spans(u,r,s)b.cache.argument_sep_spans[h][u]=w;for x=1,#w-1 do if v<=w[x][1]then return w[x][1],w[x+1][2]end end;return nil end;local y='^'..r;local z=function(u)local A,B=u:find(y)if B==nil then return nil end;return B+1 end;local C=function(u)local D=z(u)if D~=nil then return nil end;return 2 end;local E=r..'$'local F=function(u)local G,A=u:find(E)if G==nil then return nil end;return G-1 end;local H=function(u)local I=F(u)if I~=nil then return nil end;return u:len()-1 end;local J=function(K,L,M,N)local O=K=='bracket'and C or z;local P=M=='bracket'and H or F;return function(u,v)if v>1 then return nil end;local Q,R=O(u),P(u)if Q==nil or R==nil then return nil end;local S=L and 1 or Q;local T=N and u:len()or R;return S,T end end;local U='^%s*()().-()%s*'..r..'()$'local V='^()'..r..'%s*().-()()%s*$'local W='^%s*().-()%s*$'h[3]={{J('bracket',false,'separator',true),U},{J('separator',true,'separator',false),V},{J('separator',true,'bracket',false),V},{J('bracket',false,'bracket',false),W}}return h end;a.gen_spec.function_call=function(f)f=vim.tbl_deep_extend('force',{name_pattern='[%w_%.]'},f or{})return{'%f'..f.name_pattern..f.name_pattern..'+%b()','^.-%(().*()%)$'}end;a.gen_spec.pair=function(S,T,f)if not(type(S)=='string'and type(T)=='string')then b.error('Both `left` and `right` should be strings.')end;f=vim.tbl_deep_extend('force',{type='non-balanced'},f or{})if(f.type=='balanced'or f.type=='greedy')and not(S:len()==1 and T:len()==1)then local i=string.format([[Both `left` and `right` should be single character for `opts.type == '%s'`.]],f.type)b.error(i)end;local X=vim.pesc(S)local Y=vim.pesc(T)if f.type=='balanced'then return{string.format('%%b%s%s',S,T),'^.().*().$'}end;if f.type=='non-balanced'then return{string.format('%s().-()%s',X,Y)}end;if f.type=='greedy'then return{string.format('%%f[%s]%s+()[^%s]-()%s+%%f[^%s]',X,X,X,Y,Y)}end;b.error([[`opts.type` should be one of 'balanced', 'non-balanced', 'greedy'.]])end;a.gen_spec.treesitter=function(Z,f)f=vim.tbl_deep_extend('force',{use_nvim_treesitter=true},f or{})Z=b.prepare_ai_captures(Z)return function(d,A,A)local _=Z[d]local a0,A=pcall(require,'nvim-treesitter')local a1=a0 and f.use_nvim_treesitter and b.get_matched_nodes_plugin or b.get_matched_nodes_builtin;local a2=a1(_)return vim.tbl_map(function(a3)local a4,a5,a6,a7=a3:range()return{from={line=a4+1,col=a5+1},to={line=a6+1,col=a7}}end,a2)end end;a.select_textobject=function(d,e,f)if b.is_disabled()then return end;f=f or{}b.exit_to_normal_mode()local p=a.find_textobject(d,e,f)if p==nil then return end;local a8=function(a9)vim.api.nvim_win_set_cursor(0,{a9.line,a9.col-1})end;local aa=p.to==nil;p.to=p.to or p.from;local ab=vim.fn.visualmode()ab=ab==''and'v'or ab;local ac=f.vis_mode and vim.api.nvim_replace_termcodes(f.vis_mode,true,true,true)or ab;local ad=vim.o.virtualedit;local ae=vim.o.eventignore;pcall(function()if aa and f.operator_pending and not(vim.v.operator=='c'or vim.v.operator=='d')then b.message('Textobject region is empty. Nothing is done.')return end;vim.o.virtualedit='onemore'a8(p.from)vim.cmd('normal! zv')a8(p.to)vim.cmd('normal! zv')if vim.o.selection=='exclusive'then vim.cmd('normal! l')end;vim.cmd('normal! '..ac)a8(p.from)if aa and f.operator_pending then vim.o.eventignore='all'vim.cmd([[silent! execute "normal! \<Esc>i \<Esc>v"]])end end)vim.o.virtualedit=ad;vim.o.eventignore=ae end;a.expr_textobject=function(af,d,f)local ag=b.user_textobject_id(d)if ag==nil then return''end;if b.is_disabled()or not b.is_valid_textobject_id(ag)then local ah=b.get_config().mappings;local ai=ah[d=='a'and'around'or'inside']local h=ai..ag;if vim.fn.maparg(h,af)~=''then h=b.keys.ignore..h end;return h end;f=vim.tbl_deep_extend('force',b.get_default_opts(),f or{})b.cache={}local aj,ak,al='nil','nil','nil'if af=='x'then aj=vim.inspect(b.get_visual_region(),{newline='',indent=''})end;if af=='o'then ak='true'al=vim.fn.mode(1):gsub('^no','')al=vim.inspect(al==''and'v'or al)end;return b.keys.cmd_lua..string.format([[MiniAi.select_textobject('%s', '%s', { search_method = '%s', n_times = %d, reference_region = %s, operator_pending = %s, vis_mode = %s })]],d,vim.fn.escape(ag,"'"),f.search_method,vim.v.count1,aj,ak,al)..b.keys.cr end;a.expr_motion=function(j)if b.is_disabled()then return''end;if not(j=='left'or j=='right')then b.error([[`side` should be one of 'left' or 'right'.]])end;local ag=b.user_textobject_id('a')if ag==nil then return end;b.cache={}return b.keys.cmd_lua..string.format([[MiniAi.move_cursor('%s', 'a', '%s', { n_times = %d })]],j,vim.fn.escape(ag,"'"),vim.v.count1)..b.keys.cr end;b.default_config=a.config;b.cache={}b.builtin_textobjects={['(']={'%b()','^.%s*().-()%s*.$'},[')']={'%b()','^.().*().$'},['[']={'%b[]','^.%s*().-()%s*.$'},[']']={'%b[]','^.().*().$'},['{']={'%b{}','^.%s*().-()%s*.$'},['}']={'%b{}','^.().*().$'},['<']={'%b<>','^.%s*().-()%s*.$'},['>']={'%b<>','^.().*().$'},["'"]={"%b''",'^.().*().$'},['"']={'%b""','^.().*().$'},['`']={'%b``','^.().*().$'},['?']=function()if b.cache.prompted_textobject~=nil then return b.cache.prompted_textobject end;local S=b.user_input('Left edge')if S==nil or S==''then return end;local T=b.user_input('Right edge')if T==nil or T==''then return end;vim.cmd([[echo '' | redraw]])local X,Y=vim.pesc(S),vim.pesc(T)local h={string.format('%s().-()%s',X,Y)}b.cache.prompted_textobject=h;return h end,['a']=a.gen_spec.argument(),['b']={{'%b()','%b[]','%b{}'},'^.().*().$'},['f']=a.gen_spec.function_call(),['t']={'<(%w-)%f[^<%w][^<>]->.-</%1>','^<.->().*()</[^/]->$'},['q']={{"%b''",'%b""','%b``'},'^.().*().$'}}b.ns_id={input=vim.api.nvim_create_namespace('MiniAiInput')}b.keys={ignore=vim.api.nvim_replace_termcodes('<Ignore>',true,true,true),cmd_lua=vim.api.nvim_replace_termcodes('<Cmd>lua ',true,true,true),cr=vim.api.nvim_replace_termcodes('<CR>',true,true,true)}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({custom_textobjects={c.custom_textobjects,'table',true},mappings={c.mappings,'table'},n_lines={c.n_lines,'number'},search_method={c.search_method,b.is_search_method}})vim.validate({['mappings.around']={c.mappings.around,'string'},['mappings.inside']={c.mappings.inside,'string'},['mappings.around_next']={c.mappings.around_next,'string'},['mappings.inside_next']={c.mappings.inside_next,'string'},['mappings.around_last']={c.mappings.around_last,'string'},['mappings.inside_last']={c.mappings.inside_last,'string'},['mappings.goto_left']={c.mappings.goto_left,'string'},['mappings.goto_right']={c.mappings.goto_right,'string'}})return c end;b.apply_config=function(c)a.config=c;local am=c.mappings;local an=function(af,ao,ap,f)f.expr=true;f.noremap=false;b.map(af,ao,ap,f)end;an('n',am.goto_left,[[v:lua.MiniAi.expr_motion('left')]],{desc='Move to left "around"'})an('n',am.goto_right,[[v:lua.MiniAi.expr_motion('right')]],{desc='Move to right "around"'})an('x',am.goto_left,[[v:lua.MiniAi.expr_motion('left')]],{desc='Move to left "around"'})an('x',am.goto_right,[[v:lua.MiniAi.expr_motion('right')]],{desc='Move to right "around"'})an('o',am.goto_left,[[v:lua.MiniAi.expr_motion('left')]],{desc='Move to left "around"'})an('o',am.goto_right,[[v:lua.MiniAi.expr_motion('right')]],{desc='Move to right "around"'})an('x',am.around,[[v:lua.MiniAi.expr_textobject('x', 'a')]],{desc='Around textobject'})an('x',am.inside,[[v:lua.MiniAi.expr_textobject('x', 'i')]],{desc='Inside textobject'})an('o',am.around,[[v:lua.MiniAi.expr_textobject('o', 'a')]],{desc='Around textobject'})an('o',am.inside,[[v:lua.MiniAi.expr_textobject('o', 'i')]],{desc='Inside textobject'})an('x',am.around_next,[[v:lua.MiniAi.expr_textobject('x', 'a', {'search_method': 'next'})]],{desc='Around next textobject'})an('x',am.around_last,[[v:lua.MiniAi.expr_textobject('x', 'a', {'search_method': 'prev'})]],{desc='Around last textobject'})an('x',am.inside_next,[[v:lua.MiniAi.expr_textobject('x', 'i', {'search_method': 'next'})]],{desc='Inside next textobject'})an('x',am.inside_last,[[v:lua.MiniAi.expr_textobject('x', 'i', {'search_method': 'prev'})]],{desc='Inside last textobject'})an('o',am.around_next,[[v:lua.MiniAi.expr_textobject('o', 'a', {'search_method': 'next'})]],{desc='Around next textobject'})an('o',am.around_last,[[v:lua.MiniAi.expr_textobject('o', 'a', {'search_method': 'prev'})]],{desc='Around last textobject'})an('o',am.inside_next,[[v:lua.MiniAi.expr_textobject('o', 'i', {'search_method': 'next'})]],{desc='Inside next textobject'})an('o',am.inside_last,[[v:lua.MiniAi.expr_textobject('o', 'i', {'search_method': 'prev'})]],{desc='Inside last textobject'})end;b.is_disabled=function()return vim.g.miniai_disable==true or vim.b.miniai_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.miniai_config or{},c or{})end;b.is_search_method=function(aq,ar)aq=aq or b.get_config().search_method;ar=ar or'`config.search_method`'local as=vim.tbl_keys(b.span_compare_methods)if vim.tbl_contains(as,aq)then return true end;table.sort(as)local at=table.concat(vim.tbl_map(vim.inspect,as),', ')local i=([[%s should be one of %s.]]):format(ar,at)return false,i end;b.validate_search_method=function(aq,ar)local au,i=b.is_search_method(aq,ar)if not au then b.error(i)end end;b.make_textobject_table=function()local av=vim.tbl_extend('force',b.builtin_textobjects,b.get_config().custom_textobjects or{})return setmetatable(av,{__index=function(A,aw)if not(type(aw)=='string'and string.find(aw,'^[%p%s%d]$'))then return end;local ax=vim.pesc(aw)return{string.format('%s()()[^%s]-()%s+%%f[^%s]()',ax,ax,ax,ax)}end})end;b.get_textobject_spec=function(e,ay)local az=b.make_textobject_table()local aA=az[e]if vim.is_callable(aA)then aA=aA(unpack(ay))end;if b.is_composed_pattern(aA)then return vim.tbl_map(b.wrap_callable_table,aA)end;if not(b.is_region(aA)or b.is_region_array(aA))then return nil end;return aA end;b.is_valid_textobject_id=function(e)local aA=b.make_textobject_table()[e]return type(aA)=='table'or vim.is_callable(aA)end;b.is_region=function(aq)if type(aq)~='table'then return false end;local aB=type(aq.from)=='table'and type(aq.from.line)=='number'and type(aq.from.col)=='number'local aC=true;if aq.to~=nil then aC=type(aq.to)=='table'and type(aq.to.line)=='number'and type(aq.to.col)=='number'end;return aB and aC end;b.is_region_array=function(aq)if not vim.tbl_islist(aq)then return false end;for A,aD in ipairs(aq)do if not b.is_region(aD)then return false end end;return true end;b.is_composed_pattern=function(aq)if not(vim.tbl_islist(aq)and#aq>0)then return false end;for A,aE in ipairs(aq)do local aF=type(aE)if not(aF=='table'or aF=='string'or vim.is_callable(aE))then return false end end;return true end;b.find_textobject_region=function(g,d,f)local aG,aH,aI=f.reference_region,f.n_times,f.n_lines;if aH==0 then return end;local aJ=b.get_neighborhood(aG,0)local aK=aJ.region_to_span(aG)local aL=function(aM)local h=b.find_best_match(aJ,g,aM,f)if h.span==nil then if aI==0 or aJ.n_neighbors>0 then return{}end;local aN=aJ.span_to_region(aM)aJ=b.get_neighborhood(aG,aI)aK=aJ.region_to_span(aG)aM=aJ.region_to_span(aN)h=b.find_best_match(aJ,g,aM,f)end;return h end;local aO={span=aK}for A=1,aH do aO=aL(aO.span)if aO.span==nil then return end end;local aP=function(aQ,aR)if aR==nil then return aQ end;local u=aJ['1d']:sub(aQ.from,aQ.to-1)local aS=b.extract_span(u,aR,d)local aT=aQ.from-1;return{from=aS.from+aT,to=aS.to+aT}end;local aU=aP(aO.span,aO.extract_pattern)if b.is_span_covering(aK,aU)then aO=aL(aO.span)if aO.span==nil then return end;aU=aP(aO.span,aO.extract_pattern)if b.is_span_covering(aK,aU)then return end end;return aJ.span_to_region(aU)end;b.get_default_opts=function()local c=b.get_config()local aV=vim.api.nvim_win_get_cursor(0)return{n_lines=c.n_lines,n_times=vim.v.count1,reference_region={from={line=aV[1],col=aV[2]+1}},search_method=c.search_method}end;b.arg_get_separator_spans=function(u,aW,s)if u:len()<=2 then return{}end;local aX={1,1}local aY={u:len(),u:len()}local w={}u:gsub('()'..aW..'()',function(aZ,a_)table.insert(w,{aZ,a_-1})end)if#w==0 then return{aX,aY}end;local b0,b1=u:sub(2,-2),{}local b2=function(aZ,a_)table.insert(b1,{aZ+1,a_})end;for A,b3 in ipairs(s)do local b4=string.format('()%s()',b3)b0:gsub(b4,b2)end;local h=vim.tbl_filter(function(aq)return not b.is_span_inside_spans(aq,b1)end,w)table.insert(h,1,aX)table.insert(h,aY)return h end;b.prepare_ai_captures=function(Z)local b5=function(aq)if type(aq)=='string'then aq={aq}end;if not vim.tbl_islist(aq)then return false end;for A,aD in ipairs(aq)do if not(type(aD)=='string'and aD:sub(1,1)=='@')then return false end end;return true end;if not(type(Z)=='table'and b5(Z.a)and b5(Z.i))then b.error('Wrong format for `ai_captures`. See `MiniAi.gen_spec.treesitter()` for details.')end;local b6=function(aq)if type(aq)=='string'then return{aq}end;return aq end;return{a=b6(Z.a),i=b6(Z.i)}end;b.get_matched_nodes_plugin=function(b7)local b8=require('nvim-treesitter.query')return vim.tbl_map(function(b9)return b9.node end,b8.get_capture_matches_recursively(0,b7,'textobjects'))end;b.get_matched_nodes_builtin=function(b7)local ba=vim.bo.filetype;local bb,bc=pcall(vim.treesitter.get_parser,0,ba)if not bb then b.error_treesitter('parser',ba)end;local bd=vim.treesitter.get_query(ba,'textobjects')if bd==nil then b.error_treesitter('query',ba)end;b7=vim.tbl_map(function(aq)return aq:sub(2)end,b7)local h={}for A,be in ipairs(bc:trees())do for bf,a3,A in bd:iter_captures(be:root(),0)do if vim.tbl_contains(b7,bd.captures[bf])then table.insert(h,a3)end end end;return h end;b.error_treesitter=function(bg,ba)local bh=vim.api.nvim_get_current_buf()local i=string.format([[Can not get %s for buffer %d and language '%s'.]],bg,bh,ba)b.error(i)end;b.find_best_match=function(bi,g,aK,f)local bj,bk,bl;local bm=function(aQ)if b.is_better_span(aQ,bj,aK,f)then bj=aQ;bk=bl end end;if b.is_region_array(g)then for A,bn in ipairs(g)do if bi.is_region_inside(bn)then bm(bi.region_to_span(bn))end end else for A,bo in ipairs(b.cartesian_product(g))do bl=bo;b.iterate_matched_spans(bi['1d'],bo,bm)end end;local aR;if bk~=nil then aR=bk[#bk]end;return{span=bj,extract_pattern=aR}end;b.iterate_matched_spans=function(bp,bo,bm)local bq=#bo;local br={}local bs;bs=function(bt,bu,bv)local bw=bo[bt]local bx=function(u,v)return b.string_find(u,bw,v)end;if vim.is_callable(bw)then bx=bw end;local by=type(bw)=='string'and bw:match('^%%b(.)%1$')~=nil;local v=1;while v<=bu:len()do local bz,bA=bx(bu,v)if bz==nil then break end;if bt==bq then local bB=b.new_span(bz+bv,bA+bv)local bC=string.format('%s_%s',bB.from,bB.to)if not br[bC]then bm(bB)br[bC]=true end else local bD=bu:sub(bz,bA)local bE=bv+bz-1;bs(bt+1,bD,bE)end;v=(by and bA or bz)+1 end end;bs(1,bp,0)end;b.new_span=function(bz,bA)return{from=bz,to=bA==nil and bz or bA+1}end;b.is_better_span=function(bF,bG,bH,f)if b.is_span_covering(bH,bF)or b.is_span_equal(bF,bH)then return false end;return b.span_compare_methods[f.search_method](bF,bG,bH)end;b.span_compare_methods={cover=function(bF,bG,bH)local h=b.is_better_covering_span(bF,bG,bH)if h~=nil then return h end;return false end,cover_or_next=function(bF,bG,bH)local h=b.is_better_covering_span(bF,bG,bH)if h~=nil then return h end;if not b.is_span_on_left(bH,bF)then return false end;if bG==nil then return true end;local bI=b.span_distance.next;return bI(bF,bH)<bI(bG,bH)end,cover_or_prev=function(bF,bG,bH)local h=b.is_better_covering_span(bF,bG,bH)if h~=nil then return h end;if not b.is_span_on_left(bF,bH)then return false end;if bG==nil then return true end;local bI=b.span_distance.prev;return bI(bF,bH)<bI(bG,bH)end,cover_or_nearest=function(bF,bG,bH)local h=b.is_better_covering_span(bF,bG,bH)if h~=nil then return h end;if bG==nil then return true end;local bI=b.span_distance.near;return bI(bF,bH)<bI(bG,bH)end,next=function(bF,bG,bH)if b.is_span_covering(bF,bH)then return false end;if not b.is_span_on_left(bH,bF)then return false end;if bG==nil then return true end;local bI=b.span_distance.next;return bI(bF,bH)<bI(bG,bH)end,prev=function(bF,bG,bH)if b.is_span_covering(bF,bH)then return false end;if not b.is_span_on_left(bF,bH)then return false end;if bG==nil then return true end;local bI=b.span_distance.prev;return bI(bF,bH)<bI(bG,bH)end,nearest=function(bF,bG,bH)if b.is_span_covering(bF,bH)then return false end;if bG==nil then return true end;local bI=b.span_distance.near;return bI(bF,bH)<bI(bG,bH)end}b.span_distance={next=function(bJ,bK)return math.abs(bJ.from-bK.from)end,prev=function(bJ,bK)return math.abs(bJ.to-bK.to)end,near=function(bJ,bK)return math.min(math.abs(bJ.from-bK.from),math.abs(bJ.to-bK.to))end}b.is_better_covering_span=function(bF,bG,bH)local bL=b.is_span_covering(bF,bH)local bM=b.is_span_covering(bG,bH)if bL and bM then return bF.to-bF.from<bG.to-bG.from end;if bL and not bM then return true end;if not bL and bM then return false end;return nil end;b.is_span_covering=function(aQ,bN)if aQ==nil or bN==nil then return false end;if aQ.from==aQ.to then return aQ.from==bN.from and bN.to==aQ.to end;if bN.from==bN.to then return aQ.from<=bN.from and bN.to<aQ.to end;return aQ.from<=bN.from and bN.to<=aQ.to end;b.is_span_equal=function(bJ,bK)if bJ==nil or bK==nil then return false end;return bJ.from==bK.from and bJ.to==bK.to end;b.is_span_on_left=function(bJ,bK)if bJ==nil or bK==nil then return false end;return bJ.from<=bK.from and bJ.to<=bK.to end;b.is_span_inside_spans=function(bO,bP)for A,aQ in ipairs(bP)do if aQ[1]<=bO[1]and bO[2]<=aQ[2]then return true end end;return false end;b.extract_span=function(u,aR,d)local bQ={u:match(aR)}if#bQ==1 and type(bQ[1])=='string'then if u:len()==0 then return b.new_span(0,0)end;return b.new_span(1,u:len())end;local bR=true;for A,o in ipairs(bQ)do if type(o)~='number'then bR=false end end;local bS=bR and(#bQ==2 or#bQ==4)if not bS then local i='Could not extract proper positions (two or four empty captures) from '..string.format([[string '%s' with extraction pattern '%s'.]],u,aR)b.error(i)end;local bT;if#bQ==2 then bT={a=b.new_span(1,u:len()),i=b.new_span(bQ[1],bQ[2]-1)}else bT={a=b.new_span(bQ[1],bQ[4]-1),i=b.new_span(bQ[2],bQ[3]-1)}end;return bT[d]end;b.get_neighborhood=function(aG,bU)local bV,bW=aG.from.line,(aG.to or aG.from).line;local bX=math.max(1,bV-bU)local bY=math.min(vim.api.nvim_buf_line_count(0),bW+bU)local bZ=vim.api.nvim_buf_get_lines(0,bX-1,bY,false)for b_,aD in pairs(bZ)do bZ[b_]=aD..'\n'end;local c0=table.concat(bZ,'')local c1=function(o)if o==nil then return nil end;local c2=bX;local aT=0;while c2<o.line do aT=aT+bZ[c2-bX+1]:len()c2=c2+1 end;return aT+o.col end;local c3=function(aT)if aT==nil then return nil end;local c2=1;local c4=0;while c2<=#bZ and c4+bZ[c2]:len()<aT do c4=c4+bZ[c2]:len()c2=c2+1 end;return{line=bX+c2-1,col=aT-c4}end;local c5=function(bn)if bn==nil then return nil end;local c6=bn.to==nil;local bA=bn.to or bn.from;return{from=c1(bn.from),to=c1(bA)+(c6 and 0 or 1)}end;local c7=function(aQ)if aQ==nil then return nil end;local h={from=c3(aQ.from)}if aQ.from<aQ.to then h.to=c3(aQ.to-1)end;return h end;local c8=function(bn)local h=bX<=bn.from.line;if bn.to~=nil then h=h and bn.to.line<=bY end;return h end;return{n_neighbors=bU,region=aG,['1d']=c0,['2d']=bZ,pos_to_offset=c1,offset_to_pos=c3,region_to_span=c5,span_to_region=c7,is_region_inside=c8}end;b.user_textobject_id=function(d)local c9=true;vim.defer_fn(function()if not c9 then return end;local i=string.format('Enter `%s` textobject identifier (single character) ',d)b.echo(i)b.cache.msg_shown=true end,1000)local bb,ca=pcall(vim.fn.getcharstr)c9=false;b.unecho()if not bb or ca=='\27'then return nil end;if ca:find('^[%w%p%s]$')==nil then b.message('Input must be single character: alphanumeric, punctuation, or space.')return nil end;return ca end;b.user_input=function(cb,cc)local cd=vim.on_key or vim.register_keystroke_callback;local ce=false;cd(function(aw)if aw==vim.api.nvim_replace_termcodes('<Esc>',true,true,true)then ce=true end end,b.ns_id.input)local f={prompt='(mini.ai) '..cb..': ',default=cc or''}vim.cmd('echohl Question')local bb,h=pcall(vim.fn.input,f)vim.cmd([[echohl None | echo '' | redraw]])cd(nil,b.ns_id.input)if not bb or ce then return end;return h end;b.is_visual_mode=function()local cf=vim.fn.mode()return cf=='v'or cf=='V'or cf=='\22',cf end;b.exit_to_normal_mode=function()if vim.fn.getcmdwintype()~=''then local cg,cf=b.is_visual_mode()if cg then vim.cmd('normal! '..cf)end else vim.cmd('normal! \28\14')end end;b.get_visual_region=function()local cg,A=b.is_visual_mode()if not cg then return end;local h={from={line=vim.fn.line('v'),col=vim.fn.col('v')},to={line=vim.fn.line('.'),col=vim.fn.col('.')}}if h.from.line>h.to.line or h.from.line==h.to.line and h.from.col>h.to.col then h={from=h.to,to=h.from}end;return h end;b.echo=function(i,ch)i=type(i)=='string'and{{i}}or i;table.insert(i,1,{'(mini.ai) ','WarningMsg'})local ci=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local cj,ck={},0;for A,cl in ipairs(i)do local cm={vim.fn.strcharpart(cl[1],0,ci-ck),cl[2]}table.insert(cj,cm)ck=ck+vim.fn.strdisplaywidth(cm[1])if ck>=ci then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(cj,ch,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(i)b.echo(i,true)end;b.error=function(i)error(string.format('(mini.ai) %s',i),0)end;b.map=function(af,aw,ap,f)if aw==''then return end;f=vim.tbl_deep_extend('force',{noremap=true,silent=true},f or{})if vim.fn.has('nvim-0.7')==0 then f.desc=nil end;vim.api.nvim_set_keymap(af,aw,ap,f)end;b.string_find=function(u,bw,v)v=v or 1;if bw:sub(1,1)=='^'then if v>1 then return nil end;return string.find(u,bw)end;local cn,A,co=string.find(bw,'(.)%.%-')local cp=cn~=nil and co~='%'if not cp then return string.find(u,bw,v)end;local bz,bA=string.find(u,bw,v)if bz==nil then return end;local cq,cr=bz,bA;while cr==bA do bz,bA=cq,cr;cq,cr=string.find(u,bw,cq+1)end;return bz,bA end;b.cartesian_product=function(cs)if not(type(cs)=='table'and#cs>0)then return{}end;cs=vim.tbl_map(function(aq)return vim.tbl_islist(aq)and aq or{aq}end,cs)local h,ct={},{}local bs;bs=function(bt)for x=1,#cs[bt]do table.insert(ct,cs[bt][x])if bt==#cs then table.insert(h,vim.tbl_flatten(ct))else bs(bt+1)end;table.remove(ct,#ct)end end;bs(1)return h end;b.wrap_callable_table=function(aq)if vim.is_callable(aq)and type(aq)=='table'then return function(...)return aq(...)end end;return aq end;return a
