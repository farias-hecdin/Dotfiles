local a={}local b={}a.setup=function(c)_G.MiniAlign=a;c=b.setup_config(c)b.apply_config(c)end;a.config={mappings={start='ga',start_with_preview='gA'},modifiers={['s']=function(d,e)local f=b.user_input('Enter split Lua pattern')if f==nil then return end;e.split_pattern=f end,['j']=function(d,e)b.echo({{'Select justify: ','ModeMsg'},{'l','Question'},{'eft, '},{'c','Question'},{'enter, '},{'r','Question'},{'ight, '},{'n','Question'},{'one'}})local g,h=pcall(vim.fn.getcharstr)if not g or h=='\27'then return end;local i=({l='left',c='center',r='right',n='none'})[h]if i==nil then return end;e.justify_side=i end,['m']=function(d,e)local f=b.user_input('Enter merge delimiter')if f==nil then return end;e.merge_delimiter=f end,['f']=function(j,d)local f=b.user_input('Enter filter expression')local k=a.gen_step.filter(f)if k==nil then return end;table.insert(j.pre_justify,k)end,['i']=function(j,d)table.insert(j.pre_split,a.gen_step.ignore_split())end,['p']=function(j,d)table.insert(j.pre_justify,a.gen_step.pair())end,['t']=function(j,d)table.insert(j.pre_justify,a.gen_step.trim())end,[vim.api.nvim_replace_termcodes('<BS>',true,true,true)]=function(j,d)local l={}for d,m in ipairs({'pre_split','pre_justify','pre_merge'})do if#j[m]>0 then table.insert(l,m)end end;if#l==0 then return end;if#l==1 then local m=j[l[1]]table.remove(m,#m)return end;b.echo({{'Select pre-step to remove: ','ModeMsg'},{'s','Question'},{'plit, '},{'j','Question'},{'ustify, '},{'m','Question'},{'erge'}})local g,h=pcall(vim.fn.getcharstr)if not g or h=='\27'then return end;if h=='s'then table.remove(j.pre_split,#j.pre_split)end;if h=='j'then table.remove(j.pre_justify,#j.pre_justify)end;if h=='m'then table.remove(j.pre_merge,#j.pre_merge)end end,['=']=function(j,e)e.split_pattern='%p*=+[<>~]*'table.insert(j.pre_justify,a.gen_step.trim())e.merge_delimiter=' 'end,[',']=function(j,e)e.split_pattern=','table.insert(j.pre_justify,a.gen_step.trim())table.insert(j.pre_justify,a.gen_step.pair())e.merge_delimiter=' 'end,[' ']=function(j,e)table.insert(j.pre_split,a.new_step('squash',function(n)for o,p in ipairs(n)do n[o]=p:gsub('()(%s+)',function(q,r)return q==1 and r or' 'end)end end))e.split_pattern='%s+'end},options={split_pattern='',justify_side='left',merge_delimiter=''},steps={pre_split={},split=nil,pre_justify={},justify=nil,pre_merge={},merge=nil},silent=false}a.align_strings=function(n,e,j)if not b.is_array_of(n,b.is_string)then b.error('First argument of `MiniAlign.align_strings()` should be array of strings.')end;e=b.normalize_opts(e)j=b.normalize_steps(j,'steps')n=vim.deepcopy(n)for d,k in ipairs(j.pre_split)do b.apply_step(k,n,e,'pre_split')end;local s=b.apply_step(j.split,n,e,'split')if not b.is_parts(s)then if b.can_be_parts(s)then s=a.as_parts(s)else b.error('Output of `split` step should be convertible to parts. See `:h MiniAlign.as_parts()`.')end end;for d,k in ipairs(j.pre_justify)do b.apply_step(k,s,e,'pre_justify')end;b.apply_step(j.justify,s,e,'justify')for d,k in ipairs(j.pre_merge)do b.apply_step(k,s,e,'pre_merge')end;local t=b.apply_step(j.merge,s,e,'merge')if not b.is_array_of(t,b.is_string)then b.error('Output of `merge` step should be array of strings.')end;return t end;a.align_user=function(u)local v=b.get_config().modifiers;local w=b.cache.with_preview;local e=b.cache.opts or b.normalize_opts()local j=b.cache.steps or b.normalize_steps()local x=b.cache.steps~=nil;b.cache.region=nil;local y=false;y=b.process_current_region(y,u,e,j)if x or not w and e.split_pattern~=''then return end;local z=0;while true do local A=b.user_modifier(w,b.make_status_msg_chunks(e,j))z=z+1;if A==nil or z>1000 then if y then b.undo()end;if z>1000 then b.echo({{'Too many modifiers typed.','WarningMsg'}},true)end;break end;if w and A=='\r'then break end;local B=v[A]if B==nil then e.split_pattern=vim.pesc(A)else local g,C=pcall(B,j,e)if not g then local D=string.format('Modifier %s should be properly callable. Reason: %s',vim.inspect(A),C)b.echo({{D,'WarningMsg'}},true)vim.cmd('redraw')vim.loop.sleep(500)end end;e=b.normalize_opts(e)j=b.normalize_steps(j,e)local E=b.process_current_region(y,u,e,j)y=y or E;if not w and e.split_pattern~=''then break end end;b.unecho()end;a.as_parts=function(F)local g,D=b.can_be_parts(F)if not g then b.error('Input of `as_parts()` '..D)end;local s=vim.deepcopy(F)local G={}G.apply=function(H)local I={}for o,J in ipairs(s)do I[o]={}for K,p in ipairs(J)do I[o][K]=H(p,{row=o,col=K})end end;return I end;G.apply_inplace=function(H)for o,J in ipairs(s)do for K,p in ipairs(J)do local L=H(p,{row=o,col=K})if type(L)~='string'then b.error('Input of `apply_inplace()` method should always return string.')end;s[o][K]=L end end;return s end;G.get_dims=function()local M=0;for d,J in ipairs(s)do M=math.max(M,#J)end;return{row=#s,col=M}end;G.group=function(N,i)i=i or'left'for o,J in ipairs(s)do local O=b.group_by_mask(J,N[o],i)s[o]=vim.tbl_map(table.concat,O)end;return s end;G.pair=function(i)i=i or'left'local N={}for o,J in ipairs(s)do N[o]={}for K,d in ipairs(J)do local P=i=='left'and K or#J-K+1;N[o][K]=P%2==0 end end;s.group(N,i)return s end;G.slice_col=function(K)return vim.tbl_map(function(J)return J[K]end,s)end;G.slice_row=function(o)return s[o]or{}end;G.trim=function(i,Q)i=i or'both'Q=Q or'keep'local R=b.trim_functions[i]if not vim.is_callable(R)then local S=vim.tbl_map(vim.inspect,vim.tbl_keys(b.trim_functions))table.sort(S)b.error('`direction` should be one of '..table.concat(S,', ')..'.')end;local T=b.indent_functions[Q]if not vim.is_callable(T)then local S=vim.tbl_map(vim.inspect,vim.tbl_keys(b.indent_functions))table.sort(S)b.error('`indent` should be one of '..table.concat(S,', ')..'.')end;local U=vim.tbl_map(function(J)return J[1]:match('^(%s*)')end,s)U=T(U)s.apply_inplace(R)if vim.tbl_contains({'both','left'},i)then for o,J in ipairs(s)do J[1]=string.format('%s%s',U[o],J[1])end end;return s end;return setmetatable(s,{class='parts',__index=G})end;a.new_step=function(V,W)if type(V)~='string'then b.error('Step name should be string.')end;if not vim.is_callable(W)then b.error('Step action should be callable.')end;return{name=V,action=W}end;a.gen_step={}a.gen_step.default_split=function()return a.new_step('split',b.default_action_split)end;a.gen_step.default_justify=function()return a.new_step('justify',b.default_action_justify)end;a.gen_step.default_merge=function()return a.new_step('merge',b.default_action_merge)end;a.gen_step.filter=function(X)local W=b.make_filter_action(X)if W==nil then return end;return a.new_step('filter',W)end;a.gen_step.ignore_split=function(Y,Z)Y=Y or{'".-"'}if Z==nil then Z=true end;if not b.is_array_of(Y,b.is_string)then b.error('Argument `patterns` of `ignore_split()` should be array of strings.')end;if type(Z)~='boolean'then b.error('Argument `exclude_comment` of `ignore_split()` should be boolean.')end;local W=function(d,e)local _=e.split_exclude_patterns or{}for d,a0 in ipairs(Y)do if not vim.tbl_contains(_,a0)then table.insert(_,a0)end end;if Z then local a1=vim.pesc(vim.o.commentstring):gsub('%%%%s','.-')a1=a1:gsub('%.%-%s*$','.*')if not vim.tbl_contains(_,a1)then table.insert(_,a1)end end;e.split_exclude_patterns=_ end;return a.new_step('ignore',W)end;a.gen_step.pair=function(i)return a.new_step('pair',function(s,d)s.pair(i)end)end;a.gen_step.trim=function(i,Q)return a.new_step('trim',function(s,d)s.trim(i,Q)end)end;b.default_config=vim.deepcopy(a.config)b.cache={}b.ns_id={input=vim.api.nvim_create_namespace('MiniAlignInput')}b.pad_functions={left=function(a2,a3,a4)if a4 or b.is_infinite(a3)then return a2 end;return string.format('%s%s',a2,string.rep(' ',a3))end,center=function(a2,a3,a4)local a5=math.floor(0.5*a3)return b.pad_functions.right(b.pad_functions.left(a2,a5,a4),a3-a5,a4)end,right=function(a2,a3,a4)if a4 and b.is_whitespace(a2)or b.is_infinite(a3)then return a2 end;return string.format('%s%s',string.rep(' ',a3),a2)end,none=function(a2,d,d)return a2 end}b.trim_functions={both=function(a2)return b.trim_functions.left(b.trim_functions.right(a2))end,left=function(a2)return string.gsub(a2,'^%s*','')end,right=function(a2)return string.gsub(a2,'%s*$','')end,none=function(a2)return a2 end}b.indent_functions={keep=function(a6)return a6 end,high=function(a6)local a7=a6[1]for o=2,#a6 do a7=a7:len()<a6[o]:len()and a6[o]or a7 end;return vim.tbl_map(function()return a7 end,a6)end,low=function(a6)local a8=a6[1]for o=2,#a6 do a8=a6[o]:len()<a8:len()and a6[o]or a8 end;return vim.tbl_map(function()return a8 end,a6)end,remove=function(a6)return vim.tbl_map(function()return''end,a6)end}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({mappings={c.mappings,'table'},modifiers={c.modifiers,b.is_valid_modifiers},steps={c.steps,b.is_valid_steps},options={c.options,'table'},silent={c.silent,'boolean'}})vim.validate({['mappings.start']={c.mappings.start,'string'},['mappings.start_with_preview']={c.mappings.start_with_preview,'string'}})return c end;b.apply_config=function(c)a.config=c;b.map('n',c.mappings.start,b.make_action_normal(false),{expr=true,desc='Align'})b.map('x',c.mappings.start,b.make_action_visual(false),{desc='Align'})b.map('n',c.mappings.start_with_preview,b.make_action_normal(true),{expr=true,desc='Align with preview'})b.map('x',c.mappings.start_with_preview,b.make_action_visual(true),{desc='Align with preview'})end;b.is_disabled=function()return vim.g.minialign_disable==true or vim.b.minialign_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minialign_config or{},c or{})end;b.make_action_normal=function(w)return function()if b.is_disabled()then return end;b.cache={with_preview=w}vim.o.operatorfunc='v:lua.MiniAlign.align_user'return'g@'end end;b.make_action_visual=function(w)return function()if b.is_disabled()then return end;b.cache={with_preview=w}local u=({['v']='char',['V']='line',['\22']='block'})[vim.fn.mode(1)]a.align_user(u)vim.cmd('normal! \27')end end;b.is_valid_steps=function(a2,a9)a9=a9 or'config.steps'if type(a2)~='table'then return false,string.format('`%s` should be table.',a9)end;local aa=function(ab)return b.is_array_of(ab,b.is_step)end;local ac='should be array of steps (see `:h MiniAlign.new_step()`).'local ad=function(ab)return ab==nil or b.is_step(ab)end;local ae='should be step (see `:h MiniAlign.new_step()`).'if not aa(a2.pre_split)then return false,b.msg_bad_steps(a9,'pre_split',ac)end;if not ad(a2.split)then return false,b.msg_bad_steps(a9,'split',ae)end;if not aa(a2.pre_justify)then return false,b.msg_bad_steps(a9,'pre_justify',ac)end;if not ad(a2.justify)then return false,b.msg_bad_steps(a9,'justify',ae)end;if not aa(a2.pre_merge)then return false,b.msg_bad_steps(a9,'pre_merge',ac)end;if not ad(a2.merge)then return false,b.msg_bad_steps(a9,'merge',ae)end;return true end;b.validate_steps=function(a2,a9)local af,D=b.is_valid_steps(a2,a9)if not af then b.error(D)end end;b.normalize_steps=function(j,ag)local I=vim.tbl_deep_extend('force',b.get_config().steps,j or{})b.validate_steps(I,ag)I.split=I.split or a.gen_step.default_split()I.justify=I.justify or a.gen_step.default_justify()I.merge=I.merge or a.gen_step.default_merge()return vim.deepcopy(I)end;b.normalize_opts=function(e)local I=vim.tbl_deep_extend('force',b.get_config().options,e or{})return vim.deepcopy(I)end;b.msg_bad_steps=function(ag,ah,D)return string.format('`%s.%s` %s',ag,ah,D)end;b.apply_step=function(k,ai,e,aj)local ak,al,am='parts',b.is_parts,' See `:h MiniAlign.as_parts()`.'if not b.is_parts(ai)then ak='strings'al=function(a2)return b.is_array_of(a2,b.is_string)end;am=''end;local I=k.action(ai,e)if not al(ai)then local D=string.format('Step `%s` of `%s` should preserve structure of `%s`.%s',k.name,aj,ak,am)b.error(D)end;return I end;b.default_action_split=function(an,e)local ao=e.split_pattern;if not(b.is_string(ao)or b.is_array_of(ao,b.is_string))then b.error('Option `split_pattern` should be string or array of strings.')end;if type(ao)=='string'then ao={ao}end;local ap=e.split_exclude_patterns or{}if not b.is_array_of(ap,b.is_string)then b.error('Option `split_exclude_patterns` should be array of strings.')end;local aq=vim.tbl_map(function(a2)local a0=a2;a0=a2:sub(1,1)=='^'and'^()'..a0:sub(2)or'()'..a0;a0=a2:sub(-1,-1)=='$'and a0:sub(1,-2)..'()$'or a0 ..'()'return a0 end,ap)local ar={}local as=function(at,au)table.insert(ar,{at,au-1})end;local av=function(p)ar={}for d,aw in ipairs(aq)do p:gsub(aw,as)end;return ar end;local I=vim.tbl_map(function(p)return b.default_action_split_string(p,ao,av)end,an)return a.as_parts(I)end;b.default_action_split_string=function(p,ax,av)local ar=av(p)local I={}local ay,az,aA=p:len(),0,0;local aB=1;while true do local aC=b.slice_mod(ax,aB)local aD,aE=b.string_find(p,aC,aA)if aD==nil then local aF=p:sub(az,ay)if not(aF==''and#I>0)then table.insert(I,aF)end;break end;local aG=#ar==0 or not b.is_any_point_inside_any_span({aD,aE},ar)if aG then table.insert(I,p:sub(az,aD-1))table.insert(I,p:sub(aD,aE))az=aE+1;aB=aB+1 end;if aE+1<=aA then b.error(string.format('Pattern %s can not advance search.',vim.inspect(aC)))end;aA=aE+1 end;return I end;b.default_action_justify=function(s,e)local aH=e.justify_side;if not(b.is_justify_side(aH)or b.is_array_of(aH,b.is_justify_side))then b.error([[Option `justify_side` should be one of 'left', 'center', 'right', 'none', or array of those.]])end;if type(aH)=='string'then aH={aH}end;local aI=e.justify_offsets or b.tbl_repeat(0,#s)local aJ=s.get_dims()local aK,aL={},{}for K=1,aJ.col do local p=b.slice_mod(aH,K)aL[K]=p;aK[K]=b.pad_functions[p]end;local aM={}for K=1,aJ.col do aM[K]=0 end;local aN={}for o,J in ipairs(s)do aN[o]={}for K,p in ipairs(J)do local aO=vim.fn.strdisplaywidth(p)aN[o][K]=aO;local aP=K==1 and aI[o]or 0;if not(K==#J and aL[K]=='left')then aM[K]=math.max(aP+aO,aM[K])end end end;for o,J in ipairs(s)do for K,p in ipairs(J)do local aP=K==1 and aI[o]or 0;local aQ=aM[K]-aN[o][K]-aP;s[o][K]=aK[K](p,aQ,K==#J)end end end;b.default_action_merge=function(s,e)local aR=e.merge_delimiter;if not(b.is_string(aR)or b.is_array_of(aR,b.is_string))then b.error('Option `merge_delimiter` should be string or array of strings.')end;if type(aR)=='string'then aR={aR}end;local aJ=s.get_dims()local aS={}for K=1,aJ.col-1 do aS[K]=b.slice_mod(aR,K)end;return vim.tbl_map(function(J)local aT=vim.tbl_filter(function(p)return p~=''end,J)return b.concat_array(aT,aS)end,s)end;b.is_valid_modifiers=function(a2,a9)a9=a9 or'config.modifiers'if type(a2)~='table'then return false,string.format('`%s` should be table.',a9)end;for aU,aV in pairs(a2)do if not vim.is_callable(aV)then return false,string.format('`%s[%s]` should be callable.',a9,vim.inspect(aU))end end;return true end;b.make_filter_action=function(X)if X==nil then return nil end;if X==''then X='true'end;local aW,H=pcall(function()return assert(loadstring('return '..X))end)if not(aW and vim.is_callable(H))then b.error(vim.inspect(X)..' is not a valid filter expression.')end;local al=function(aX)local aY=setmetatable(aX,{__index=_G})debug.setfenv(H,aY)return H()end;return function(s,d)local N={}local aX={ROW=#s}for o,J in ipairs(s)do aX.row=o;N[o]={}for K,p in ipairs(J)do aX.col,aX.COL=K,#J;aX.s=p;aX.n=math.ceil(0.5*K)aX.N=math.ceil(0.5*#J)N[o][K]=al(aX)end end;s.group(N)end end;b.process_current_region=function(y,u,e,j)b.cache.opts,b.cache.steps=e,j;if y then b.undo()end;local aZ=b.cache.region or b.get_current_region()b.cache.region=aZ;e.region=aZ;e.mode=u;e.justify_offsets=b.tbl_repeat(0,aZ.to.line-aZ.from.line+1)if u=='char'then local a_=vim.fn.getline(aZ.from.line):sub(1,aZ.from.col-1)e.justify_offsets[1]=vim.fn.strdisplaywidth(a_)end;local n=b.region_get_text(aZ,u)local b0=a.align_strings(n,e,j)b.region_set_text(aZ,u,b0)vim.cmd('redraw')return true end;b.get_current_region=function()local b1,b2="'[","']"if b.is_visual_mode()then b1,b2='.','v'end;local b3=vim.fn.getpos(b1)local b4={line=b3[2],col=b3[3]+b3[4]}local b5=vim.fn.getpos(b2)local b6={line=b5[2],col=b5[3]+b5[4]}if b6.line<b4.line or b6.line==b4.line and b6.col<b4.col then b4,b6=b6,b4 end;return{from=b4,to=b6}end;b.region_get_text=function(aZ,u)local b4,b6=aZ.from,aZ.to;if u=='char'then local b7=vim.o.selection=='exclusive'and 1 or 0;return b.get_text(b4.line-1,b4.col-1,b6.line-1,b6.col-b7)end;if u=='line'then return b.get_lines(b4.line-1,b6.line)end;if u=='block'then local b8,b9=b.region_virtcols(aZ)local M=b9-b8+1;return vim.tbl_map(function(at)return vim.fn.strcharpart(at,b8-1,M)end,b.get_lines(b4.line-1,b6.line))end end;b.region_set_text=function(aZ,u,ba)local b4,b6=aZ.from,aZ.to;if u=='char'then local bb=vim.fn.col({b6.line,'$'})-1;local bc=math.min(b6.col,bb)local b7=vim.o.selection=='exclusive'and 1 or 0;b.set_text(b4.line-1,b4.col-1,b6.line-1,bc-b7,ba)end;if u=='line'then b.set_lines(b4.line-1,b6.line,ba)end;if u=='block'then if#ba~=b6.line-b4.line+1 then b.error('Number of replacement lines should fit the region in blockwise mode')end;local b8,b9=b.region_virtcols(aZ)local bd=b.get_lines(b4.line-1,b6.line)for o,at in ipairs(bd)do local be=b4.line+o-2;local bf=vim.fn.virtcol({be+1,'$'})-1;if b8<=bf then local bg,bh=b8,math.min(b9,bf)local bi,bj=vim.fn.byteidx(at,bg-1),vim.fn.byteidx(at,bh)bi,bj=math.max(bi,0),math.max(bj,0)b.set_text(be,bi,be,bj,{ba[o]})end end end end;b.region_virtcols=function(aZ)local bk=b.pos_to_virtcol(aZ.from)local bl=b.pos_to_virtcol(aZ.to)local b8,b9=math.min(bk,bl),math.max(bk,bl)b9=b9-(vim.o.selection=='exclusive'and 1 or 0)return b8,b9 end;b.pos_to_virtcol=function(bm)local bn=vim.fn.col({bm.line,'$'})if bn<bm.col then return vim.fn.virtcol({bm.line,'$'})+bm.col-bn end;return vim.fn.virtcol({bm.line,bm.col})end;b.user_modifier=function(w,bo)local bp=true;local bq=(b.cache.msg_shown or w)and 0 or 1000;vim.defer_fn(function()if not bp then return end;table.insert(bo,{' Enter modifier'})b.echo(bo)b.cache.msg_shown=true end,bq)local g,h=pcall(vim.fn.getcharstr)bp=false;if not g or h=='\27'then return nil end;return h end;b.user_input=function(br,ba)local bs=vim.on_key or vim.register_keystroke_callback;local bt=false;bs(function(ah)if ah=='\27'then bt=true end end,b.ns_id.input)local e={prompt='(mini.align) '..br..': ',default=ba or''}vim.cmd('echohl Question')local g,I=pcall(vim.fn.input,e)vim.cmd('echohl None | redraw')bs(nil,b.ns_id.input)if not g or bt then return end;return I end;b.make_status_msg_chunks=function(e,j)local bu=function(bv,bw)local bx=''if#bv>0 then local by=vim.tbl_map(function(a2)return a2.name end,bv)bx=string.format('(%s) ',table.concat(by,', '))end;return bx..vim.inspect(bw)end;return{{'Split: ','ModeMsg'},{bu(j.pre_split,e.split_pattern)},{' | ','Question'},{'Justify: ','ModeMsg'},{bu(j.pre_justify,e.justify_side)},{' | ','Question'},{'Merge: ','ModeMsg'},{bu(j.pre_merge,e.merge_delimiter)},{' |','Question'}}end;b.is_array_of=function(a2,al)if not b.islist(a2)then return false end;for d,aV in ipairs(a2)do if not al(aV)then return false end end;return true end;b.is_step=function(a2)return type(a2)=='table'and type(a2.name)=='string'and vim.is_callable(a2.action)end;b.is_string=function(aV)return type(aV)=='string'end;b.is_justify_side=function(a2)return a2=='left'or a2=='center'or a2=='right'or a2=='none'end;b.is_parts=function(a2)return b.can_be_parts(a2)and(getmetatable(a2)or{}).class=='parts'end;b.can_be_parts=function(a2)if type(a2)~='table'then return false,'should be table'end;for o=1,#a2 do if not b.is_array_of(a2[o],b.is_string)then return false,'values should be an array of strings'end end;return true end;b.is_infinite=function(a2)return a2==math.huge or a2==-math.huge end;b.is_visual_mode=function()return vim.tbl_contains({'v','V','\22'},vim.fn.mode(1))end;b.is_whitespace=function(a2)return type(a2)=='string'and a2:find('^%s*$')~=nil end;b.get_text=function(bz,bi,bA,bj)return vim.api.nvim_buf_get_text(0,bz,bi,bA,bj,{})end;b.get_lines=function(bz,bA)return vim.api.nvim_buf_get_lines(0,bz,bA,true)end;b.set_text=function(bz,bi,bA,bj,bB)local bC=string.format('lockmarks lua vim.api.nvim_buf_set_text(0, %d, %d, %d, %d, %s)',bz,bi,bA,bj,vim.inspect(bB))vim.cmd(bC)end;b.set_lines=function(bz,bA,bB)local bC=string.format('lockmarks lua vim.api.nvim_buf_set_lines(0, %d, %d, true, %s)',bz,bA,vim.inspect(bB))vim.cmd(bC)end;b.echo=function(D,bD)if b.get_config().silent then return end;D=type(D)=='string'and{{D}}or D;table.insert(D,1,{'(mini.align) ','WarningMsg'})local bE=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local bF,bG={},0;for d,bH in ipairs(D)do local bI={vim.fn.strcharpart(bH[1],0,bE-bG),bH[2]}table.insert(bF,bI)bG=bG+vim.fn.strdisplaywidth(bI[1])if bG>=bE then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(bF,bD,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.error=function(D)error(string.format('(mini.align) %s',D),0)end;b.map=function(u,bJ,bK,e)if bJ==''then return end;e=vim.tbl_deep_extend('force',{silent=true},e or{})vim.keymap.set(u,bJ,bK,e)end;b.slice_mod=function(a2,o)return a2[(o-1)%#a2+1]end;b.tbl_repeat=function(bL,q)local I={}for o=1,q do I[o]=bL end;return I end;b.group_by_mask=function(ai,N,i)local I,bM={},{}local b4,b6,bN=1,#ai,1;local bO=function(bP,aV)table.insert(bP,aV)end;if i=='right'then b4,b6,bN=b6,b4,-1;bO=function(bP,aV)table.insert(bP,1,aV)end end;for o=b4,b6,bN do bO(bM,ai[o])if N[o]or o==b6 then bO(I,bM)bM={}end end;return I end;b.concat_array=function(bQ,bR)local bS={}for o=1,#bQ-1 do table.insert(bS,bQ[o])table.insert(bS,bR[o])end;table.insert(bS,bQ[#bQ])return table.concat(bS,'')end;b.string_find=function(p,ao,bT)bT=bT or 1;if ao:sub(1,1)=='^'and bT>1 then return nil end;if ao==''then return nil end;return string.find(p,ao,bT)end;b.is_any_point_inside_any_span=function(bU,bV)for d,bW in ipairs(bU)do for d,bX in ipairs(bV)do if bX[1]<=bW and bW<=bX[2]then return true end end end;return false end;b.undo=function()if b.is_visual_mode()then local bY=vim.fn.mode(1)vim.cmd('silent! normal! \27')vim.cmd('silent! lockmarks undo')local aZ=b.cache.region;vim.api.nvim_win_set_cursor(0,{aZ.from.line,aZ.from.col-1})vim.cmd('silent! normal!'..bY)vim.api.nvim_win_set_cursor(0,{aZ.to.line,aZ.to.col-1})else vim.cmd('silent! lockmarks normal! u')end end;b.islist=vim.fn.has('nvim-0.10')==1 and vim.islist or vim.tbl_islist;return a
