local a={}local b=vim.api;local c=vim.loop;a.savable_cmds=setmetatable({["!"]=true,["="]=true,lua=true,luafile=true,make=true,runtime=true,source=true},{__index=function(d,e)return vim.startswith(e,"Plenary")end})a.savable_cmdline=vim.regex[=[system\|:lua\|[Jj][Oo][Bb]]=]local f=vim.regex[[\%(^$\)\|\%(^\%(acwrite\|help\|nofile\|nowrite\|quickfix\|terminal\|prompt\)$\)]]local function g(h)return h==true or h==1 end;local function i(j)local k=vim.bo[j].bt;if not f:match_str(k)then vim.notify_once(('[sos.nvim]: ignoring buf with unknown buftype "%s"'):format(k),vim.log.levels.WARN)return false end;return k==""or k=="acwrite"end;local l;local function m()l=nil;local n,o=pcall(b.nvim_cmd,{cmd="write",mods={silent=true}},{output=false})if not n then l=o end end;local function p(j)b.nvim_buf_call(j,m)return not l,l end;function a.write_buf_if_needed(j)if vim.bo[j].mod and vim.o.write and not vim.bo[j].ro and b.nvim_buf_is_loaded(j)and i(j)then local q=b.nvim_buf_get_name(j)if q==""then return true end;local k=vim.bo[j].bt;if k=="acwrite"then return p(j)elseif k==""then local r,s,t=c.fs_stat(q)if r then if vim.fn.filewritable(q)==1 and not r.type:find"^dir"then return p(j)end;return true elseif t=="ENOENT"then if q:find"[\\/]$"then return true end;local u=vim.fn.fnamemodify(q,":h")local v,w,x=c.fs_stat(u)if v then if vim.fn.filewritable(u)==2 then return p(j)end;return true elseif x=="ENOENT"then if g(vim.fn.mkdir(u,"p"))then return p(j)end;return true end end end end;return true end;function a.should_observe_buf(j)return i(j)and vim.bo[j].ma and not vim.bo[j].ro end;function a.on_timer()local y={}for z,j in ipairs(b.nvim_list_bufs())do local n,o=a.write_buf_if_needed(j)if not n then table.insert(y,("[sos.nvim]: %s: %s"):format(o,b.nvim_buf_get_name(j)))end end;if y[1]~=nil then b.nvim_err_writeln(table.concat(y,"\n"))end end;return a
