local a={}local b={}a.setup=function(c)_G.MiniNotify=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()end;a.config={content={format=nil,sort=nil},lsp_progress={enable=true,duration_last=1000},window={config={},max_width_share=0.382,winblend=25}}a.make_notify=function(d)local e={}for f,g in pairs(vim.log.levels)do e[g]=f end;local h={ERROR={duration=5000,hl_group='DiagnosticError'},WARN={duration=5000,hl_group='DiagnosticWarn'},INFO={duration=5000,hl_group='DiagnosticInfo'},DEBUG={duration=0,hl_group='DiagnosticHint'},TRACE={duration=0,hl_group='DiagnosticOk'},OFF={duration=0,hl_group='MiniNotifyNormal'}}d=vim.tbl_deep_extend('force',h,d or{})for i,j in pairs(d)do if h[i]==nil then b.error('Keys should be log level names.')end;if type(j)~='table'then b.error('Level data should be table.')end;if type(j.duration)~='number'then b.error('`duration` in level data should be number.')end;if type(j.hl_group)~='string'then b.error('`hl_group` in level data should be string.')end end;local k=function(l,m)m=m or vim.log.levels.INFO;local n=e[m]if n==nil then b.error('Only valid values of `vim.log.levels` are supported.')end;local o=d[n]if o.duration<=0 then return end;local p=a.add(l,n,o.hl_group)vim.defer_fn(function()a.remove(p)end,o.duration)end;return function(l,m)if not vim.in_fast_event()then return k(l,m)end;vim.schedule(function()k(l,m)end)end end;a.add=function(l,m,q)b.validate_msg(l)m=m or'INFO'b.validate_level(m)q=q or'MiniNotifyNormal'b.validate_hl_group(q)local r=b.get_timestamp()local s={msg=l,level=m,hl_group=q,ts_add=r,ts_update=r}local t=#b.history+1;b.history[t],b.active[t]=s,s;a.refresh()return t end;a.update=function(p,u)local v=b.active[p]if v==nil then b.error('`id` is not an identifier of active notification.')end;if type(u)~='table'then b.error('`new_data` should be table.')end;if u.msg~=nil then b.validate_msg(u.msg)end;if u.level~=nil then b.validate_level(u.level)end;if u.hl_group~=nil then b.validate_hl_group(u.hl_group)end;v.msg=u.msg or v.msg;v.level=u.level or v.level;v.hl_group=u.hl_group or v.hl_group;v.ts_update=b.get_timestamp()a.refresh()end;a.remove=function(p)local v=b.active[p]if v==nil then return end;v.ts_remove=b.get_timestamp()b.active[p]=nil;a.refresh()end;a.clear=function()local r=b.get_timestamp()for p,w in pairs(b.active)do b.active[p].ts_remove=r end;b.active={}a.refresh()end;a.refresh=function()if b.is_disabled()or type(vim.v.exiting)=='number'then return b.window_close()end;local x=vim.deepcopy(vim.tbl_values(b.active))local y=b.get_config().content;local z=vim.is_callable(y.sort)and y.sort or a.default_sort;x=z(x)if not b.is_notification_array(x)then b.error('Output of `content.sort` should be notification array.')end;if#x==0 then return b.window_close()end;local A=vim.is_callable(y.format)and y.format or a.default_format;x=b.notif_apply_format(x,A)local B=b.cache.buf_id;if not b.is_valid_buf(B)then B=b.buffer_create()end;b.buffer_refresh(B,x)local C=b.cache.win_id;if not(b.is_valid_win(C)and b.is_win_in_tabpage(C))then b.window_close()C=b.window_open(B)else local D=b.window_compute_config(B)vim.api.nvim_win_set_config(C,D)end;vim.cmd('redraw')b.cache.buf_id,b.cache.win_id=B,C end;a.get=function(p)return vim.deepcopy(b.history[p])end;a.get_all=function()return vim.deepcopy(b.history)end;a.show_history=function()local y=b.get_config().content;local x=a.get_all()table.sort(x,function(E,F)return E.ts_update<F.ts_update end)local A=vim.is_callable(y.format)and y.format or a.default_format;x=b.notif_apply_format(x,A)local B;for w,p in ipairs(vim.api.nvim_list_bufs())do if vim.bo[p].filetype=='mininotify-history'then B=p end end;if B==nil then B=vim.api.nvim_create_buf(true,true)vim.bo[B].filetype='mininotify-history'end;b.buffer_refresh(B,x)vim.api.nvim_win_set_buf(0,B)end;a.default_format=function(v)local G=vim.fn.strftime('%H:%M:%S',math.floor(v.ts_update))return string.format('%s â”‚ %s',G,v.msg)end;a.default_sort=function(x)local H=vim.deepcopy(x)table.sort(H,b.notif_compare)return H end;b.default_config=a.config;b.active={}b.history={}b.lsp_progress={}b.level_priority={ERROR=6,WARN=5,INFO=4,DEBUG=3,TRACE=2,OFF=1}b.ns_id={highlight=vim.api.nvim_create_namespace('MiniNotifyHighlight')}b.cache={buf_id=nil,win_id=nil}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({content={c.content,'table'},lsp_progress={c.lsp_progress,'table'},window={c.window,'table'}})local I=function(J)return type(J)=='table'or vim.is_callable(J)end;vim.validate({['content.format']={c.content.format,'function',true},['content.sort']={c.content.sort,'function',true},['lsp_progress.enable']={c.lsp_progress.enable,'boolean'},['lsp_progress.duration_last']={c.lsp_progress.duration_last,'number'},['window.config']={c.window.config,I,'table or callable'},['window.max_width_share']={c.window.max_width_share,'number'},['window.winblend']={c.window.winblend,'number'}})return c end;b.apply_config=function(c)a.config=c;if c.lsp_progress.enable then vim.schedule(function()if vim.lsp.handlers['$/progress before mini.notify']==nil then vim.lsp.handlers['$/progress before mini.notify']=vim.lsp.handlers['$/progress']end;vim.lsp.handlers['$/progress']=b.lsp_progress_handler end)end end;b.create_autocommands=function(c)local K=vim.api.nvim_create_augroup('MiniNotify',{})local L=function(M,N,O,P)vim.api.nvim_create_autocmd(M,{group=K,pattern=N,callback=O,desc=P})end;L({'TabEnter','VimResized'},'*',function()a.refresh()end,'Refresh notifications')end;b.create_default_hl=function()local Q=function(R,d)d.default=true;vim.api.nvim_set_hl(0,R,d)end;Q('MiniNotifyBorder',{link='FloatBorder'})Q('MiniNotifyNormal',{link='NormalFloat'})Q('MiniNotifyTitle',{link='FloatTitle'})end;b.is_disabled=function()return vim.g.mininotify_disable==true or vim.b.mininotify_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.mininotify_config or{},c or{})end;b.lsp_progress_handler=function(S,T,U,c)if vim.is_callable(vim.lsp.handlers['$/progress before mini.notify'])then vim.lsp.handlers['$/progress before mini.notify'](S,T,U,c)end;local V=b.get_config().lsp_progress;if not V.enable then return end;if S~=nil then return vim.notify(vim.inspect(S),vim.log.levels.ERROR)end;if not(type(T)=='table'and type(T.value)=='table')then return end;local W=T.value;local X=vim.lsp.get_client_by_id(U.client_id).name;if type(X)~='string'then X=string.format('LSP[id=%s]',U.client_id)end;local B=U.bufnr or'nil'local Y=B..X..(T.token or'')local Z=b.lsp_progress[Y]or{}Z.percentage=W.percentage or Z.percentage or 0;if W.kind=='end'then b.lsp_progress[Y]=nil;local _=math.max(V.duration_last,0)vim.defer_fn(function()a.remove(Z.notif_id)end,_)return end;if W.kind=='begin'then Z.title=W.title end;local l=string.format('%s: %s %s (%s%%)',X,Z.title or'',W.message or'',Z.percentage)if Z.notif_id==nil then Z.notif_id=a.add(l)else a.update(Z.notif_id,{msg=l})end;b.lsp_progress[Y]=Z end;b.buffer_create=function()local B=vim.api.nvim_create_buf(false,true)vim.bo[B].filetype='mininotify'return B end;b.buffer_refresh=function(B,x)local a0=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(B,a0,0,-1)vim.api.nvim_buf_set_lines(B,0,-1,true,{})local a1,a2={},{}for w,v in ipairs(x)do local a3=vim.split(v.msg,'\n')for w,a4 in ipairs(a3)do table.insert(a1,a4)end;table.insert(a2,{group=v.hl_group,from_line=#a1-#a3+1,to_line=#a1})end;vim.api.nvim_buf_set_lines(B,0,-1,true,a1)local a5={end_col=0,hl_eol=true,hl_mode='combine'}for w,a6 in ipairs(a2)do a5.end_row,a5.hl_group=a6.to_line,a6.group;vim.api.nvim_buf_set_extmark(B,a0,a6.from_line-1,0,a5)end end;b.buffer_default_dimensions=function(B,a7)local a8=vim.tbl_map(vim.fn.strdisplaywidth,vim.api.nvim_buf_get_lines(B,0,-1,true))local a9=1;for w,aa in ipairs(a8)do a9=math.max(a9,aa)end;a7=math.min(math.max(a7,0),1)local ab=math.max(math.floor(a7*vim.o.columns),1)a9=math.min(a9,ab)local ac=0;for w,aa in ipairs(a8)do ac=ac+math.floor(math.max(aa-1,0)/a9)+1 end;return a9,ac end;b.window_open=function(B)local c=b.window_compute_config(B,true)local C=vim.api.nvim_open_win(B,false,c)vim.wo[C].foldenable=false;vim.wo[C].wrap=true;vim.wo[C].winblend=b.get_config().window.winblend;vim.wo[C].winhighlight='NormalFloat:MiniNotifyNormal,FloatBorder:MiniNotifyBorder,FloatTitle:MiniNotifyTitle'return C end;b.window_compute_config=function(B,ad)local ae=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local af=vim.o.laststatus>0;local ag=vim.o.lines-vim.o.cmdheight-(ae and 1 or 0)-(af and 1 or 0)local ab=vim.o.columns;local ah=b.get_config().window;local ai={relative='editor',style='minimal',noautocmd=ad,zindex=999}ai.anchor,ai.col,ai.row='NE',vim.o.columns,ae and 1 or 0;ai.width,ai.height=b.buffer_default_dimensions(B,ah.max_width_share)ai.border='single'ai.focusable=false;local aj=ah.config;if vim.is_callable(aj)then aj=aj(B)end;local c=vim.tbl_deep_extend('force',ai,aj or{})local ak=c.border=='none'and 0 or 2;c.height=math.min(c.height,ag-ak)c.width=math.min(c.width,ab-ak)return c end;b.window_close=function()if b.is_valid_win(b.cache.win_id)then vim.api.nvim_win_close(b.cache.win_id,true)end;b.cache.win_id=nil end;b.validate_msg=function(J)if type(J)~='string'then b.error('`msg` should be string.')end end;b.validate_level=function(J)if vim.log.levels[J]==nil then b.error('`level` should be key of `vim.log.levels`.')end end;b.validate_hl_group=function(J)if type(J)~='string'then b.error('`hl_group` should be string.')end end;b.is_notification=function(J)return type(J)=='table'and type(J.msg)=='string'and vim.log.levels[J.level]~=nil and type(J.hl_group)=='string'and type(J.ts_add)=='number'and type(J.ts_update)=='number'and(J.ts_remove==nil or type(J.ts_remove)=='number')end;b.is_notification_array=function(J)if not b.islist(J)then return false end;for w,al in ipairs(J)do if not b.is_notification(al)then return false end end;return true end;b.notif_apply_format=function(x,A)for w,v in ipairs(x)do local H=A(v)if type(H)~='string'then b.error('Output of `content.format` should be string.')end;v.msg=H end;return x end;b.notif_compare=function(E,F)local am,an=b.level_priority[E.level],b.level_priority[F.level]return am>an or am==an and E.ts_update>F.ts_update end;b.error=function(l)error(string.format('(mini.notify) %s',l),0)end;b.is_valid_buf=function(B)return type(B)=='number'and vim.api.nvim_buf_is_valid(B)end;b.is_valid_win=function(C)return type(C)=='number'and vim.api.nvim_win_is_valid(C)end;b.is_win_in_tabpage=function(C)return vim.api.nvim_win_get_tabpage(C)==vim.api.nvim_get_current_tabpage()end;b.get_timestamp=function()local ao,ap=vim.loop.gettimeofday()return ao+0.000001*ap end;b.islist=vim.fn.has('nvim-0.10')==1 and vim.islist or vim.tbl_islist;return a
