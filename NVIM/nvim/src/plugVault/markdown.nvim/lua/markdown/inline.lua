local a=vim.api;local b=vim.treesitter;local c=require("markdown.config")local d=require("markdown.treesitter")local e=require("markdown.notify")local f=require("markdown.util")local g={}local h=b.query.parse("markdown","(inline) @inline")local function i(j)return b.query.parse("markdown_inline","("..j..") @e")end;local k="emphasis"local l="strong_emphasis"local m="strikethrough"local n="code_span"local o="emphasis_delimiter"local p="code_span_delimiter"local q={[k]=i(k),[l]=i(l),[m]=i(m),[n]=i(n)}local function r()local s=c:get().inline_surround;return{[s.emphasis.key]={type=k,text=s.emphasis.txt},[s.strong.key]={type=l,text=s.strong.txt},[s.strikethrough.key]={type=m,text=s.strikethrough.txt},[s.code.key]={type=n,text=s.code.txt}}end;local function t(u)return u:type()=="inline"end;local function v(u)local w=u:type()return w==o or w==p end;local function x(y)local z=y;local A=z:parent()while A~=nil do local B=d.child_count(A,v)/2;if B==0 or not d.spans_parent_range(z,B)then break end;z=A;A=z:parent()end;local C,D;local E=y;while E~=nil and E~=C do local B=d.child_count(E,v)/2;if B==0 then break end;C=E;D=B;local F,G,H,I=C:range()E=C:named_descendant_for_range(F,G+B,H,I-B)end;if C==nil then C=y end;local J,K,L,M=z:range()local N,O,P,Q=C:range()return{J,K,N,O+D},{P,Q-D,L,M}end;local function R(y)if y:type()==m then local A=y:parent()if A~=nil and A:type()==m and d.spans_parent_range(y)then return A end end;return y end;local function S(y)if y:type()==m then local F,G,H,I=y:range()local E=y:named_descendant_for_range(F,G+1,H,I-1)if E~=nil and E~=y and E:type()==m then return 2 end end;return d.child_count(y,v)/2 end;function g.toggle_emphasis_visual(T)g.toggle_emphasis(nil,T)end;function g.toggle_emphasis(U,T)if T==nil then local V,W=f.try_get_char_input()if V then g.toggle_emphasis(U,W)end;return end;local X=r()local y=X[T]if y==nil then return end;local Y=U==nil;local Z=Y and vim.fn.visualmode()=="\22"local _;if Y then _=f.get_visual_range()else _=f.get_motion_range(U)end;local a0=b.get_parser(0,"markdown")local a1=a0:parse(_)[1]local a2=a0:children().markdown_inline;if a2==nil then return end;local a3=a2:parse()local a4=q[y.type]local a5={}local a6={}local function a7(a8,a9)local aa=false;local ab,ac,ad=a9:root(),a8[1],a8[3]+1;for ae,af,ae in a4:iter_captures(ab,0,ac,ad)do local ag,ah=x(af)ag[4]=ag[4]+1;ah[2]=ah[2]-1;if f.range_contains_position(ag,{a8[1],a8[2]})and f.range_contains_position(ah,{a8[3],a8[4]})then table.insert(a5,R(af))aa=true;break end end;if not aa then table.insert(a6,a8)end end;local ai=0;if Z then local F,H=math.min(_[1],_[3]),math.max(_[1],_[3])local G,I=math.min(_[2],_[4]),math.max(_[2],_[4])for aj=F,H,1 do local ak=vim.fn.col({aj+1,"$"})-1;local al=math.min(G,ak)local am=math.min(I,ak)local an=d.find_node(t,{pos={aj,math.max(am-1,0)}})if an~=nil and al~=ak then ai=ai+1;local a8=f.get_overlapping_range({aj,al,aj,am},{an:range()})local ao=d.find_tree_in_node(a3,an)if ao==nil then local ap=b.get_node_text(an,0,nil)e.error("Failed to find inline tree for node '%s'",ap)return end;a7(a8,ao)end end else for ae,an,ae in h:iter_captures(a1:root(),0,_[1],_[3]+1)do ai=ai+1;local a8=f.get_overlapping_range(_,{an:range()})local ao=d.find_tree_in_node(a3,an)if ao==nil then local ap=b.get_node_text(an,0,nil)e.error("Failed to find inline tree for node '%s'",ap)return end;a7(a8,ao)end end;if ai==#a5 then for aq=#a5,1,-1 do local af=a5[aq]local F,G,H,I=af:range()local ar=S(af)f.delete_text(H,I-ar,ar)f.delete_text(F,G,ar)end else for aq=#a6,1,-1 do local as=a6[aq]f.insert_text(as[3],as[4],y.text)f.insert_text(as[1],as[2],y.text)end end;if Y then local at=a.nvim_replace_termcodes("<Esc>",true,false,true)a.nvim_feedkeys(at,"n",false)end end;function g.delete_surrounding_emphasis()local V,T=f.try_get_char_input()local X=r()if not V or X[T]==nil then return end;local aj,au=f.get_cursor()b.get_parser(0,"markdown"):parse({aj,aj+1})local y=X[T]local av=b.get_node({pos={aj,au},ignore_injections=false})while av~=nil and av:type()~=y.type do av=av:parent()end;if av~=nil then av=R(av)local F,G,H,I=av:range()local ar=S(av)f.delete_text(H,I-ar,ar)f.delete_text(F,G,ar)end end;function g.change_surrounding_emphasis()local X=r()local aw,ax=f.try_get_char_input()local ay,az=f.try_get_char_input()if not aw or not ay or X[ax]==nil or X[az]==nil then return end;local aj,au=f.get_cursor()b.get_parser(0,"markdown"):parse({aj,aj+1})local aA=X[ax]local av=b.get_node({pos={aj,au},ignore_injections=false})while av~=nil and av:type()~=aA.type do av=av:parent()end;if av~=nil then av=R(av)local F,G,H,I=av:range()local ar=S(av)local aB=X[az]f.replace_text(H,I-ar,ar,aB.text)f.replace_text(F,G,ar,aB.text)end end;return g
