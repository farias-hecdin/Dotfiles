local a=vim.api;local b=vim.treesitter;local c=require("markdown.treesitter")local d=require("markdown.util")local e={}local f="list"local g="list_item"local h="list_marker_dot"local i="list_marker_parenthesis"local j="task_list_marker_checked"local k="task_list_marker_unchecked"local l="paragraph"local m="inline"local n=b.query.parse("markdown",[[
	(list
		(list_item [
			(list_marker_dot)
			(list_marker_parenthesis)
		])) @l
]])local function o(p)return p:type()==g end;local function q(p)return p:type()==f end;local function r(s,t)local u=s:start()for v in s:iter_children()do local w,x,y,z=v:range()if w~=u and x~=0 then for A=w,y-1,1 do if t<0 then d.delete_text(A,0,math.abs(t))else d.insert_text(A,0,string.rep(" ",t))end end end end end;local function B(s,C)local D=b.get_node_text(s,0,nil)local E=D:match("(%d+)")local A,F=s:start()local G=tostring(C)if E~=G then local H=#E;d.replace_text(A,F,H,G)local I=#G-H;if I~=0 then r(s,I)end end end;local function J(K)local C=1;for s in K:iter_children()do if s:named()then B(s,C)C=C+1 end end end;function e.reset_list_numbering(w,y)if y>=0 then y=y+1 end;local L=b.get_parser(0,"markdown"):parse()[1]for z,M,z in n:iter_matches(L:root(),0,w,y,{all=true})do local K=c.single_node_from_match(M,1)J(K)end end;local function N(s)for O=s:named_child_count()-1,0,-1 do local v=s:named_child(O)if v:type()==l then for P=v:named_child_count()-1,0,-1 do if v:named_child(P):type()==m then return v:named_child(P)end end end end end;local function Q()local R=d.get_cursor()local S=vim.fn.col("$")-1;return R,S end;local T={above=1,below=2}local function U(V)local R,S=Q()b.get_parser(0,"markdown"):parse()local s=c.find_node(o,{pos={R,S}})if s==nil then return false end;local W=s:named_child(0)if W==nil then return false end;local X=W:type()local Y,Z=W:start()local _=W:next_named_sibling()if _~=nil and _:type()~=j and _:type()~=k then _=nil end;local a0;if V==T.above then a0=s:start()else local a1=N(s)if a1~=nil then local a2=a1:end_()a0=a2+1 else a0=Y+1 end end;local a3=a.nvim_buf_get_text(0,Y,0,Y,Z,{})[1]local a4=b.get_node_text(W,0,nil)local a5=_ and"[ ] "or""a.nvim_buf_set_lines(0,a0,a0,true,{a3 ..a4 ..a5})if X==h or X==i then b.get_parser(0,"markdown"):parse()local K=c.find_node(q,{pos={R,S}})if K~=nil then J(K)end end;a0=a0+1;a.nvim_win_set_cursor(0,{a0,vim.fn.col({a0,"$"})})vim.cmd("startinsert!")return true end;function e.insert_list_item_above()return U(T.above)end;function e.insert_list_item_below()return U(T.below)end;local function a6(p)if p:type()~=g then return false end;local _=p:named_child(1)if _==nil then return false end;local a7=_:type()return a7==j or a7==k end;function e.toggle_task(w,y)b.get_parser(0,"markdown"):parse()local a8={}local a9;for A=w,y,1 do local aa=vim.fn.col({A+1,"$"})-1;local p=c.find_node(a6,{pos={A,aa}})if p~=nil and p~=a9 then table.insert(a8,p:named_child(1))a9=p end end;local ab=false;for O=1,#a8,1 do if a8[O]:type()==k then local A,x,z,ac=a8[O]:range()d.replace_text(A,x,ac-x+1,"[x] ")ab=true end end;if not ab then for O=1,#a8,1 do local A,x,z,ac=a8[O]:range()d.replace_text(A,x,ac-x+1,"[ ] ")end end end;return e
