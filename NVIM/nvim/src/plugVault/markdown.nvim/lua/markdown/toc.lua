local a=vim.api;local b=vim.treesitter;local c=require("markdown.section")local d=require("markdown.config")local e=require("markdown.link")local f=require("markdown.list")local g=require("markdown.treesitter")local h={}local i=b.query.parse("markdown",[[
	[
		(atx_heading
			(_) @atx_marker
			heading_content: (inline) @atx_content)
		(setext_heading
			heading_content: (_ (inline) @setext_content)
			(_) @setext_underline)
	] @heading
]])local j=b.query.parse("markdown","(html_block) @html")local k=b.query.parse("markdown_inline","(html_tag) @html")local function l(m)local type=m:type()return type=="list"or type=="block_quote"end;local function n(o)local p;if type(o)=="string"then p=o else p=b.get_node_text(o,0,nil)end;return#p>3 and p:sub(1,4)=="<!--"and p:sub(-3,-1)=="-->"end;local function q(o,r,s)local p=b.get_node_text(o,0,nil)if n(p)then if p:match(r)~=nil then return c.OMIT_LEVEL.section elseif p:match(s)~=nil then return c.OMIT_LEVEL.heading end end;return c.OMIT_LEVEL.none end;local function t(u,r,s)local v=b.get_parser(0,"markdown")v:parse({u:start(),u:end_()+1})local w=v:children().markdown_inline:parse()local x=g.find_tree_in_node(w,u)if x~=nil then for y,z,y in k:iter_captures(x:root(),0,0,-1)do local A=q(z,r,s)if A~=c.OMIT_LEVEL.none then return A end end end;return c.OMIT_LEVEL.none end;local function B()local x=b.get_parser(0,"markdown"):parse()[1]local C=d:get()local r=C.toc.omit_section;local s=C.toc.omit_heading;local D={}local E={}for y,F,y in j:iter_matches(x:root(),0,0,-1,{all=true})do local o=g.single_node_from_match(F,1)local G=g.find_parent(o,l)if not G then local H=q(o,r,s)if H==c.OMIT_LEVEL.section then D[o:end_()]=true elseif H==c.OMIT_LEVEL.heading then E[o:end_()]=true end end end;local I=c:new()for y,F,y in i:iter_matches(x:root(),0,0,-1,{all=true})do local J=g.single_node_from_match(F,5)local G=g.find_parent(J,l)if not G then local K=g.single_node_from_match(F,1)or g.single_node_from_match(F,4)local L=g.single_node_from_match(F,2)or g.single_node_from_match(F,3)local M=b.get_node_text(L,0,nil)local N=tonumber(K:type():match("(%d+)"))local O=J:start()+1;if N>I.level then I=I:add_subsection(M,N,O)else I=I:get_parent(N):add_subsection(M,N,O)end;local P=J:start()if D[P]then I.omit=c.OMIT_LEVEL.section elseif E[P]then I.omit=c.OMIT_LEVEL.heading else local Q=t(L,r,s)if Q==c.OMIT_LEVEL.section then I.omit=c.OMIT_LEVEL.section elseif Q==c.OMIT_LEVEL.heading then I.omit=c.OMIT_LEVEL.heading end end end end;return I:get_root()end;local function R(I,S,T,U,V,W)U=U or{}V=V or 0;W=W or""local K=S[V%#S+1]local X=W..string.rep(" ",#K+1)for y,Y in pairs(I.children)do local Z=Y.omit==c.OMIT_LEVEL.section or Y.level>T;if not Z then local p,_=e.get_heading_link(Y.name)local a0=Y.omit==c.OMIT_LEVEL.heading or p==""if not a0 then local O=W..K.." ["..p.."](#".._..")"table.insert(U,O)R(Y,S,T,U,V+1,X)else R(Y,S,T,U,V,W)end end end;return U end;function h.insert_toc(a1)local I=B()local S={}for a2,a3 in ipairs(a1.markers)do if a3=="."or a3==")"then S[a2]="1"..a3 else S[a2]=a3 end end;local T=a1.max_level or 6;local U=R(I,S,T)local a4;if a1.end_row~=nil then a4=a1.end_row+1 else a4=a1.start_row end;a.nvim_buf_set_lines(0,a1.start_row,a4,true,U)f.reset_list_numbering(a1.start_row,a1.start_row+#U-1)end;local function a5(I,a1,a6,W)a6=a6 or{}W=W or""local X=W.."  "for y,Y in pairs(I.children)do local Z=a1.omit_flagged and Y.omit==c.OMIT_LEVEL.section;if not Z and Y.level<=a1.max_level then local p=e.get_heading_link(Y.name)local a0=a1.omit_flagged and Y.omit==c.OMIT_LEVEL.heading;if not a0 and p~=""then table.insert(a6,{bufnr=a1.bufnr,lnum=Y.line,text=W..p})a5(Y,a1,a6,X)else a5(Y,a1,a6,W)end end end;return a6 end;function h.set_loclist_toc(a1)a1=a1 or{}local I=B()local a7=a.nvim_win_get_buf(0)local a6=a5(I,{bufnr=a7,max_level=a1.max_level or 6,omit_flagged=a1.omit_flagged or false})vim.fn.setloclist(0,a6)vim.cmd.lopen()vim.cmd.setlocal("modifiable")for a2,a8 in ipairs(a6)do a.nvim_buf_set_lines(0,a2-1,a2,true,{a8.text})end;vim.cmd.setlocal("nomodified")vim.cmd.setlocal("nomodifiable")end;return h
