local vim=vim;local a=vim.loop;local b=require"plenary.compat"local c=require"plenary.functional"local d={}d.__index=d;local function e(f,g)local h=f[g]if not h then return end;if not h:is_closing()then h:close()end end;local i=function(j,k,l,m)a.check_start(j._shutdown_check,function()if not j:_pipes_are_closed(k)then return end;a.check_stop(j._shutdown_check)j._shutdown_check=nil;j:_shutdown(l,m)j=nil end)end;local n=function(j,k)return function(l,m)if a.is_closing(j._shutdown_check)then return j:shutdown(l,m)else i(j,k,l,m)end end end;local function o(p)if vim.in_fast_event()then return assert(a.fs_realpath(p),string.format("Path must be valid: %s",p))else return vim.fn.expand(vim.fn.escape(p,"[]$"),true)end end;function d:new(q)if not q then error(debug.traceback"Options are required for Job:new")end;local r=q.command;if not r then if q[1]then r=q[1]else error(debug.traceback"'command' is required for Job:new")end elseif q[1]then error(debug.traceback"Cannot pass both 'command' and array args")end;local s=q.args;if not s then if#q>1 then s={select(2,unpack(q))}end end;local t,u=pcall(vim.fn.executable,r)if not q.skip_validation and t and 1~=u then error(debug.traceback(r..": Executable not found"))end;local v={}v.command=r;v.args=s;v._raw_cwd=q.cwd;if q.env then if type(q.env)~="table"then error"[plenary.job] env has to be a table"end;local w={}for x,y in pairs(q.env)do if type(x)=="number"then table.insert(w,y)elseif type(x)=="string"then table.insert(w,x.."="..tostring(y))end end;v.env=w end;if q.interactive==nil then v.interactive=true else v.interactive=q.interactive end;if q.detached then v.detached=true end;v.enable_handlers=c.if_nil(q.enable_handlers,true,q.enable_handlers)v.enable_recording=c.if_nil(c.if_nil(q.enable_recording,q.enable_handlers,q.enable_recording),true,q.enable_recording)if not v.enable_handlers and v.enable_recording then error"[plenary.job] Cannot record items but disable handlers"end;v._user_on_start=q.on_start;v._user_on_stdout=q.on_stdout;v._user_on_stderr=q.on_stderr;v._user_on_exit=q.on_exit;v._additional_on_exit_callbacks={}v._maximum_results=q.maximum_results;v.user_data={}v.writer=q.writer;self._reset(v)return setmetatable(v,self)end;function d:_reset()self.is_shutdown=nil;if self._shutdown_check and a.is_active(self._shutdown_check)and not a.is_closing(self._shutdown_check)then vim.api.nvim_err_writeln(debug.traceback"We may be memory leaking here. Please report to TJ.")end;self._shutdown_check=a.new_check()self.stdin=nil;self.stdout=nil;self.stderr=nil;self._stdout_reader=nil;self._stderr_reader=nil;if self.enable_recording then self._stdout_results={}self._stderr_results={}else self._stdout_results=nil;self._stderr_results=nil end end;function d:_stop()e(self,"stdin")e(self,"stderr")e(self,"stdout")e(self,"handle")end;function d:_pipes_are_closed(k)for z,A in ipairs{k.stdin,k.stdout,k.stderr}do if A and not a.is_closing(A)then return false end end;return true end;function d:shutdown(l,m)if self._shutdown_check and a.is_active(self._shutdown_check)then return end;self:_shutdown(l,m)end;function d:_shutdown(l,m)if self.is_shutdown then return end;self.code=l;self.signal=m;if self._stdout_reader then pcall(self._stdout_reader,nil,nil,true)end;if self._stderr_reader then pcall(self._stderr_reader,nil,nil,true)end;if self._user_on_exit then self:_user_on_exit(l,m)end;for z,y in ipairs(self._additional_on_exit_callbacks)do y(self,l,m)end;if self.stdout then self.stdout:read_stop()end;if self.stderr then self.stderr:read_stop()end;self:_stop()self.is_shutdown=true;self._stdout_reader=nil;self._stderr_reader=nil end;function d:_create_uv_options()local k={}k.command=self.command;k.args=self.args;k.stdio={self.stdin,self.stdout,self.stderr}if self._raw_cwd then k.cwd=o(self._raw_cwd)end;if self.env then k.env=self.env end;if self.detached then k.detached=true end;return k end;local B=function(self,C,D)return coroutine.wrap(function(E,F,G)local H=1;local I,J,K,L;while true do if F then F=F:gsub("\r","")local M=1;local N=#F+1;repeat J=string.find(F,"\n",M,true)or N;I=string.sub(F,M,J-1)L=J~=N;if K then K=K..I elseif J~=M or L then K=I end;if L then if not K then return vim.api.nvim_err_writeln("Broken data thing due to: "..tostring(K).." "..tostring(F))end;if self.enable_recording then self[C][H]=K end;if D then D(E,K,self)end;if self._maximum_results and H>self._maximum_results then vim.schedule(function()self:shutdown()end)return end;H=H+1;K=nil end;M=J+1 until not L end;if self.enable_recording then self[C][H]=K end;if D and G and not L then D(E,K,self)end;if F==nil or G then return end;E,F,G=coroutine.yield()end end)end;function d:_prepare_pipes()self:_stop()if self.writer then if d.is_job(self.writer)then self.writer:_prepare_pipes()self.stdin=self.writer.stdout elseif self.writer.write then self.stdin=self.writer end end;if not self.stdin then self.stdin=self.interactive and a.new_pipe(false)or nil end;self.stdout=a.new_pipe(false)self.stderr=a.new_pipe(false)end;function d:_execute()local k=self:_create_uv_options()if self._user_on_start then self:_user_on_start()end;self.handle,self.pid=a.spawn(k.command,k,n(self,k))if not self.handle then error(debug.traceback("Failed to spawn process: "..vim.inspect(self)))end;if self.enable_handlers then self._stdout_reader=B(self,"_stdout_results",self._user_on_stdout)self.stdout:read_start(self._stdout_reader)self._stderr_reader=B(self,"_stderr_results",self._user_on_stderr)self.stderr:read_start(self._stderr_reader)end;if self.writer then if d.is_job(self.writer)then self.writer:_execute()elseif type(self.writer)=="table"and b.islist(self.writer)then local O=#self.writer;for P,y in ipairs(self.writer)do self.stdin:write(y)if P~=O then self.stdin:write"\n"else self.stdin:write("\n",function()pcall(self.stdin.close,self.stdin)end)end end elseif type(self.writer)=="string"then self.stdin:write(self.writer,function()self.stdin:close()end)elseif self.writer.write then self.stdin=self.writer else error("Unknown self.writer: "..vim.inspect(self.writer))end end;return self end;function d:start()self:_reset()self:_prepare_pipes()self:_execute()end;function d:sync(Q,R)self:start()self:wait(Q,R)return self.enable_recording and self:result()or nil,self.code end;function d:result()assert(self.enable_recording,"'enabled_recording' is not enabled for this job.")return self._stdout_results end;function d:stderr_result()assert(self.enable_recording,"'enabled_recording' is not enabled for this job.")return self._stderr_results end;function d:pid()return self.pid end;function d:wait(Q,R,S)Q=Q or 5000;R=R or 10;if self.handle==nil then local T=vim.inspect(self)vim.schedule(function()vim.api.nvim_err_writeln(T)end)return end;local U=vim.wait(Q,function()if S then vim.cmd[[redraw!]]end;if self.is_shutdown then assert(not self.handle or self.handle:is_closing(),"Job must be shutdown if it's closing")end;return self.is_shutdown end,R,not S)if not U then error(string.format("'%s %s' was unable to complete in %s ms",self.command,table.concat(self.args or{}," "),Q))end;return self end;function d:co_wait(V)V=V or 5;if self.handle==nil then vim.api.nvim_err_writeln(vim.inspect(self))return end;while not vim.wait(V,function()return self.is_shutdown end)do coroutine.yield()end;return self end;function d.join(...)local W={...}local X=table.getn(W)local Q;if type(W[X])=="number"then Q=table.remove(W,X)X=X-1 end;local Y=0;return vim.wait(Q or 10000,function()for Z,_ in pairs(W)do if _.is_shutdown then W[Z]=nil;Y=Y+1 end end;return X==Y end)end;local a0=0;local a1={}function d:and_then(a2)self:add_on_exit_callback(function()a2:start()end)end;function d:and_then_wrap(a2)self:add_on_exit_callback(vim.schedule_wrap(function()a2:start()end))end;function d:after(a3)self:add_on_exit_callback(a3)return self end;function d:and_then_on_success(a2)self:add_on_exit_callback(function(z,l)if l==0 then a2:start()end end)end;function d:and_then_on_success_wrap(a2)self:add_on_exit_callback(vim.schedule_wrap(function(z,l)if l==0 then a2:start()end end))end;function d:after_success(a3)self:add_on_exit_callback(function(f,l,m)if l==0 then a3(f,l,m)end end)end;function d:and_then_on_failure(a2)self:add_on_exit_callback(function(z,l)if l~=0 then a2:start()end end)end;function d:and_then_on_failure_wrap(a2)self:add_on_exit_callback(vim.schedule_wrap(function(z,l)if l~=0 then a2:start()end end))end;function d:after_failure(a3)self:add_on_exit_callback(function(f,l,m)if l~=0 then a3(f,l,m)end end)end;function d.chain(...)a0=a0+1;a1[a0]=false;local a4={...}for Z=2,#a4 do local a5=a4[Z-1]local a6=a4[Z]a5:add_on_exit_callback(vim.schedule_wrap(function()a6:start()end))end;local a7=a4[#a4]._user_on_exit;a4[#a4]._user_on_exit=function(self,E,F)if a7 then a7(self,E,F)end;a1[a0]=true end;a4[1]:start()return a0 end;function d.chain_status(a8)return a1[a8]end;function d.is_job(a9)if type(a9)~="table"then return false end;return getmetatable(a9)==d end;function d:add_on_exit_callback(D)table.insert(self._additional_on_exit_callbacks,D)end;function d:send(F)if not self.stdin then error"job has no 'stdin'. Have you run `job:start()` yet?"end;self.stdin:write(F)end;return d
