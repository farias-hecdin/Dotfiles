local a=require('cmp')local b={}b.new=function()return setmetatable({},{__index=b})end;b.is_available=function()return vim.g.loaded_vsnip end;b.get_position_encoding_kind=function()return'utf-8'end;b.get_keyword_pattern=function()return'.'end;b.complete=function(self,c,d)local e={}for f,g in ipairs(vim.fn['vsnip#get_complete_items'](vim.api.nvim_get_current_buf()))do local h={}local i=vim.fn.json_decode(g.user_data)local j=self:_get_text_edit(c,g.word,i.vsnip)if j then h.label=g.abbr;h.filterText=g.word;h.insertTextFormat=a.lsp.InsertTextFormat.Snippet;h.textEdit=j;h.kind=a.lsp.CompletionItemKind.Snippet;h.data={filetype=c.context.filetype,snippet=i.vsnip.snippet}table.insert(e,h)end end;d(e)end;b.resolve=function(f,h,d)local k={}table.insert(k,string.format('```%s',h.data.filetype))for f,l in ipairs(vim.split(vim.fn['vsnip#to_string'](h.data.snippet),'\n'))do table.insert(k,l)end;table.insert(k,'```')h.documentation={kind=a.lsp.MarkupKind.Markdown,value=table.concat(k,'\n')}d(h)end;b._get_text_edit=function(f,c,m,n)local o=vim.fn.split(vim.fn.escape(m,[[\/?]]),[[\zs]])local p=[[\%(\V]]..table.concat(o,[[\m\|\V]])..[[\m\)]]local q=o[1]:match('%a')and[[\<]]or''local r=([[%s\V%s\m%s*$]]):format(q,o[1],p)local s=vim.regex(r)local t,u=s:match_str(c.context.cursor_before_line)if not t then return end;return{newText=table.concat(n.snippet,'\n'),range={start={line=c.context.cursor.line,character=t},['end']={line=c.context.cursor.line,character=u}}}end;return b
