local a={}local b={}a.setup=function(c)_G.MiniDiff=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands()for d,e in ipairs(vim.api.nvim_list_bufs())do b.auto_enable({buf=e})end;b.create_default_hl()end;a.config={view={style=vim.go.number and'number'or'sign',signs={add='▒',change='▒',delete='▒'},priority=199},source=nil,delay={text_change=200},mappings={apply='gh',reset='gH',textobject='gh',goto_first='[H',goto_prev='[h',goto_next=']h',goto_last=']H'},options={algorithm='histogram',indent_heuristic=true,linematch=60,wrap_goto=false}}a.enable=function(e)e=b.validate_buf_id(e)if b.is_buf_enabled(e)or b.is_disabled(e)then return end;b.buf_ensure_loaded(e)b.update_buf_cache(e)local f=b.cache[e].source.attach(e)if f==false then return a.disable(e)end;vim.api.nvim_buf_attach(e,false,{on_lines=function(d,d,d,g,d,h)local i=b.cache[e]if i==nil then return true end;b.schedule_diff_update(e,i.config.delay.text_change)end,on_reload=function()b.schedule_diff_update(e,0)end,on_detach=function()a.disable(e)end})b.setup_buf_autocommands(e)end;a.disable=function(e)e=b.validate_buf_id(e)local i=b.cache[e]if i==nil then return end;b.cache[e]=nil;pcall(vim.api.nvim_del_augroup_by_id,i.augroup)vim.b[e].minidiff_summary,vim.b[e].minidiff_summary_string=nil,nil;b.clear_all_diff(e)pcall(i.source.detach,e)end;a.toggle=function(e)e=b.validate_buf_id(e)if b.is_buf_enabled(e)then return a.disable(e)end;return a.enable(e)end;a.toggle_overlay=function(e)e=b.validate_buf_id(e)local i=b.cache[e]if i==nil then b.error(string.format('Buffer %d is not enabled.',e))end;i.overlay=not i.overlay;b.clear_all_diff(e)b.schedule_diff_update(e,0)end;a.export=function(j,k)k=vim.tbl_deep_extend('force',{scope='all'},k or{})if j=='qf'then return b.export_qf(k)end;b.error('`format` should be one of "qf".')end;a.get_buf_data=function(e)e=b.validate_buf_id(e)local i=b.cache[e]if i==nil then return nil end;return vim.deepcopy({config=i.config,hunks=i.hunks,overlay=i.overlay,ref_text=i.ref_text,summary=i.summary})end;a.set_ref_text=function(e,l)e=b.validate_buf_id(e)if not(type(l)=='table'or type(l)=='string')then b.error('`text` should be either string or array.')end;if type(l)=='table'then l=#l>0 and table.concat(l,'\n')or nil end;if not b.is_buf_enabled(e)then a.enable(e)end;if not b.is_buf_enabled(e)then b.error('Can not set reference text for not enabled buffer.')end;if l~=nil and string.sub(l,-1)~='\n'then l=l..'\n'end;if l==nil then b.clear_all_diff(e)vim.cmd('redraw')end;b.cache[e].ref_text=l;b.schedule_diff_update(e,0)end;a.gen_source={}a.gen_source.git=function()local m=function(e)if b.git_cache[e]~=nil then return false end;local n=b.get_buf_realpath(e)if n==''then return false end;b.git_cache[e]={}b.git_start_watching_index(e,n)end;local o=function(e)local p=b.git_cache[e]b.git_cache[e]=nil;b.git_invalidate_cache(p)end;local q=function(e,r)local s=b.git_get_path_data(b.get_buf_realpath(e))if s==nil or s.rel_path==nil then return end;local t=b.git_format_patch(e,r,s)b.git_apply_patch(s,t)end;return{name='git',attach=m,detach=o,apply_hunks=q}end;a.gen_source.none=function()return{name='none',attach=function()end}end;a.gen_source.save=function()local u={}local m=function(e)local v=vim.api.nvim_create_augroup('MiniDiffSourceSaveBuffer'..e,{clear=true})u[e]=v;local w=function()if vim.bo[e].modified then return end;a.set_ref_text(e,vim.api.nvim_buf_get_lines(e,0,-1,false))end;local x={group=v,buffer=e,callback=w,desc='Set reference text after save'}vim.api.nvim_create_autocmd({'BufWritePost','FileChangedShellPost'},x)w()end;local o=function(e)pcall(vim.api.nvim_del_augroup_by_id,u[e])end;return{name='save',attach=m,detach=o}end;a.do_hunks=function(e,y,k)e=b.validate_buf_id(e)local i=b.cache[e]if i==nil then b.error(string.format('Buffer %d is not enabled.',e))end;if type(i.ref_text)~='string'then b.error(string.format('Buffer %d has no reference text.',e))end;if not(y=='apply'or y=='reset'or y=='yank')then b.error('`action` should be one of "apply", "reset", "yank".')end;local z={line_start=1,line_end=vim.api.nvim_buf_line_count(e),register=vim.v.register}k=vim.tbl_deep_extend('force',z,k or{})local A,B=b.validate_target_lines(e,k.line_start,k.line_end)if type(k.register)~='string'then b.error('`opts.register` should be string.')end;local r=b.get_hunks_in_range(i.hunks,A,B)if#r==0 then return b.notify('No hunks to '..y,'INFO')end;if y=='apply'then i.source.apply_hunks(e,r)end;if y=='reset'then b.reset_hunks(e,r)end;if y=='yank'then b.yank_hunks_ref(i.ref_text,r,k.register)end end;a.goto_hunk=function(C,k)local e=vim.api.nvim_get_current_buf()local i=b.cache[e]if i==nil then b.error(string.format('Buffer %d is not enabled.',e))end;if not vim.tbl_contains({'first','prev','next','last'},C)then b.error('`direction` should be one of "first", "prev", "next", "last".')end;local D=i.config.options.wrap_goto;local z={n_times=vim.v.count1,line_start=vim.fn.line('.'),wrap=D}k=vim.tbl_deep_extend('force',z,k or{})if not(type(k.n_times)=='number'and k.n_times>=1)then b.error('`opts.n_times` should be positive number.')end;if type(k.line_start)~='number'then b.error('`opts.line_start` should be number.')end;if type(k.wrap)~='boolean'then b.error('`opts.wrap` should be boolean.')end;local E=b.get_contiguous_hunk_ranges(i.hunks)if#E==0 then return b.notify('No hunks to go to','INFO')end;local F,G=b.iterate_hunk_ranges(E,C,k)if F==nil then return b.notify('No hunk ranges in direction '..vim.inspect(C),'INFO')end;local H=E[F].from;if G then b.notify('Wrapped around edge in direction '..vim.inspect(C),'INFO')end;vim.cmd([[normal! m']])local d,I=vim.fn.getline(H):find('^%s*')vim.api.nvim_win_set_cursor(0,{H,I})vim.cmd('normal! zv')end;a.operator=function(J)local e=vim.api.nvim_get_current_buf()if b.is_disabled(e)then return''end;if J=='apply'or J=='reset'or J=='yank'then b.operator_cache={action=J,win_view=vim.fn.winsaveview(),register=vim.v.register}vim.o.operatorfunc='v:lua.MiniDiff.operator'return'g@'end;local p=b.operator_cache;local k={line_start=vim.fn.line("'["),line_end=vim.fn.line("']"),register=p.register}if k.line_end<k.line_start then return b.notify('Not a proper textobject','INFO')end;a.do_hunks(e,p.action,k)if p.action=='apply'and p.win_view~=nil then vim.fn.winrestview(p.win_view)p.win_view=nil end;return''end;a.textobject=function()local e=vim.api.nvim_get_current_buf()local i=b.cache[e]if i==nil or b.is_disabled(e)then b.error('Current buffer is not enabled.')end;local K=vim.fn.line('.')local L,M=b.get_contiguous_hunk_ranges(i.hunks),nil;for d,N in ipairs(L)do if N.from<=K and K<=N.to then M=N end end;if M==nil then return b.notify('No hunk range under cursor','INFO')end;local O=vim.tbl_contains({'v','V','\22'},vim.fn.mode())if O then vim.cmd('normal! \27')end;vim.cmd(string.format('normal! %dGV%dG',M.from,M.to))end;b.default_config=a.config;b.default_source=a.gen_source.git()b.timer_diff_update=vim.loop.new_timer()b.ns_id={viz=vim.api.nvim_create_namespace('MiniDiffViz'),overlay=vim.api.nvim_create_namespace('MiniDiffOverlay')}b.bufs_to_update={}b.cache={}b.git_cache={}b.operator_cache={}b.style_extmark_data={sign={hl_group_prefix='MiniDiffSign',field='sign_hl_group'},number={hl_group_prefix='MiniDiffSign',field='number_hl_group'}}b.overlay_suffix=string.rep(' ',vim.o.columns)b.extmark_supports_invalidate=vim.fn.has('nvim-0.10')==1;b.vimdiff_opts={result_type='indices',ctxlen=0,interhunkctxlen=0}b.vimdiff_supports_linematch=vim.fn.has('nvim-0.9')==1;b.worddiff_opts={algorithm='minimal',result_type='indices',ctxlen=0,interhunkctxlen=4,indent_heuristic=false}if b.vimdiff_supports_linematch then b.worddiff_opts.linematch=0 end;b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({view={c.view,'table'},source={c.source,'table',true},delay={c.delay,'table'},mappings={c.mappings,'table'},options={c.options,'table'}})vim.validate({['view.style']={c.view.style,'string'},['view.signs']={c.view.signs,'table'},['view.priority']={c.view.priority,'number'},['delay.text_change']={c.delay.text_change,'number'},['mappings.apply']={c.mappings.apply,'string'},['mappings.reset']={c.mappings.reset,'string'},['mappings.textobject']={c.mappings.textobject,'string'},['mappings.goto_first']={c.mappings.goto_first,'string'},['mappings.goto_prev']={c.mappings.goto_prev,'string'},['mappings.goto_next']={c.mappings.goto_next,'string'},['mappings.goto_last']={c.mappings.goto_last,'string'},['options.algorithm']={c.options.algorithm,'string'},['options.indent_heuristic']={c.options.indent_heuristic,'boolean'},['options.linematch']={c.options.linematch,'number'},['options.wrap_goto']={c.options.wrap_goto,'boolean'}})vim.validate({['view.signs.add']={c.view.signs.add,'string'},['view.signs.change']={c.view.signs.change,'string'},['view.signs.delete']={c.view.signs.delete,'string'}})return c end;b.apply_config=function(c)a.config=c;local P=c.mappings;local Q=function()return a.operator('apply')end;b.map({'n','x'},P.apply,Q,{expr=true,desc='Apply hunks'})local R=function()return a.operator('reset')end;b.map({'n','x'},P.reset,R,{expr=true,desc='Reset hunks'})local S=P.textobject==P.apply or P.textobject==P.reset;local T=S and{'o'}or{'x','o'}b.map(T,P.textobject,'<Cmd>lua MiniDiff.textobject()<CR>',{desc='Hunk range textobject'})b.map({'n','x'},P.goto_first,"<Cmd>lua MiniDiff.goto_hunk('first')<CR>",{desc='First hunk'})b.map('o',P.goto_first,"V<Cmd>lua MiniDiff.goto_hunk('first')<CR>",{desc='First hunk'})b.map({'n','x'},P.goto_prev,"<Cmd>lua MiniDiff.goto_hunk('prev')<CR>",{desc='Previous hunk'})b.map('o',P.goto_prev,"V<Cmd>lua MiniDiff.goto_hunk('prev')<CR>",{desc='Previous hunk'})b.map({'n','x'},P.goto_next,"<Cmd>lua MiniDiff.goto_hunk('next')<CR>",{desc='Next hunk'})b.map('o',P.goto_next,"V<Cmd>lua MiniDiff.goto_hunk('next')<CR>",{desc='Next hunk'})b.map({'n','x'},P.goto_last,"<Cmd>lua MiniDiff.goto_hunk('last')<CR>",{desc='Last hunk'})b.map('o',P.goto_last,"V<Cmd>lua MiniDiff.goto_hunk('last')<CR>",{desc='Last hunk'})local U,V=b.ns_id.viz,b.ns_id.overlay;b.set_decoration_provider(U,V)end;b.create_autocommands=function()local v=vim.api.nvim_create_augroup('MiniDiff',{})local W=function(X,Y,Z,_)vim.api.nvim_create_autocmd(X,{group=v,pattern=Y,callback=Z,desc=_})end;W('BufEnter','*',b.auto_enable,'Enable diff')W('VimResized','*',b.on_resize,'Track Neovim resizing')end;b.create_default_hl=function()local a0=function(a1,k)k.default=true;vim.api.nvim_set_hl(0,a1,k)end;local a2=vim.fn.has('nvim-0.10')==1;a0('MiniDiffSignAdd',{link=a2 and'Added'or'diffAdded'})a0('MiniDiffSignChange',{link=a2 and'Changed'or'diffChanged'})a0('MiniDiffSignDelete',{link=a2 and'Removed'or'diffRemoved'})a0('MiniDiffOverAdd',{link='DiffAdd'})a0('MiniDiffOverChange',{link='DiffText'})a0('MiniDiffOverContext',{link='DiffChange'})a0('MiniDiffOverDelete',{link='DiffDelete'})end;b.is_disabled=function(e)local a3=b.get_buf_var(e,'minidiff_disable')return vim.g.minidiff_disable==true or a3==true end;b.get_config=function(c,e)local a4=b.get_buf_var(e,'minidiff_config')or{}return vim.tbl_deep_extend('force',a.config,a4,c or{})end;b.get_buf_var=function(e,a1)if not vim.api.nvim_buf_is_valid(e)then return nil end;return vim.b[e or 0][a1]end;b.auto_enable=vim.schedule_wrap(function(a5)if b.is_buf_enabled(a5.buf)or b.is_disabled(a5.buf)then return end;local a6=a5.buf;if not(vim.api.nvim_buf_is_valid(a6)and vim.bo[a6].buftype==''and vim.bo[a6].buflisted)then return end;if not b.is_buf_text(a6)then return end;a.enable(a6)end)b.on_resize=function()b.overlay_suffix=string.rep(' ',vim.o.columns)for e,d in pairs(b.cache)do if vim.api.nvim_buf_is_valid(e)then b.clear_all_diff(e)b.schedule_diff_update(e,0)end end end;b.validate_buf_id=function(a7)if a7==nil or a7==0 then return vim.api.nvim_get_current_buf()end;if not(type(a7)=='number'and vim.api.nvim_buf_is_valid(a7))then b.error('`buf_id` should be `nil` or valid buffer id.')end;return a7 end;b.validate_target_lines=function(e,A,B)local a8=vim.api.nvim_buf_line_count(e)if type(A)~='number'then b.error('`line_start` should be number.')end;if type(B)~='number'then b.error('`line_end` should be number.')end;A=A<0 and a8+A+1 or A;B=B<0 and a8+B+1 or B;A=math.min(math.max(A,1),a8)B=math.min(math.max(B,1),a8)if not(A<=B)then b.error('`line_start` should be less than or equal to `line_end`.')end;return A,B end;b.validate_callable=function(a7,a1)if vim.is_callable(a7)then return a7 end;b.error('`'..a1 ..'` should be callable.')end;b.is_buf_enabled=function(e)return b.cache[e]~=nil end;b.update_buf_cache=function(e)local a9=b.cache[e]or{}local a4=b.get_config({},e)a9.config=a4;a9.extmark_opts=b.convert_view_to_extmark_opts(a4.view)a9.source=b.normalize_source(a4.source or b.default_source)a9.hunks=a9.hunks or{}a9.summary=a9.summary or{}a9.viz_lines=a9.viz_lines or{}a9.overlay=false;a9.overlay_lines=a9.overlay_lines or{}b.cache[e]=a9 end;b.setup_buf_autocommands=function(e)local v=vim.api.nvim_create_augroup('MiniDiffBuffer'..e,{clear=true})b.cache[e].augroup=v;local aa=vim.schedule_wrap(function()b.update_buf_cache(e)end)local ab={group=v,buffer=e,callback=aa,desc='Update buffer cache'}vim.api.nvim_create_autocmd('BufWinEnter',ab)local ac=vim.schedule_wrap(function(a5)if not b.is_buf_enabled(a5.buf)then return end;a.disable(a5.buf)a.enable(a5.buf)end)local ad={group=v,buffer=e,callback=ac,desc='Reset on rename'}vim.api.nvim_create_autocmd('BufFilePost',ad)local a3=function()a.disable(e)end;local ae={group=v,buffer=e,callback=a3,desc='Disable on delete'}vim.api.nvim_create_autocmd('BufDelete',ae)end;b.normalize_source=function(af)if type(af)~='table'then b.error('`source` should be table.')end;local ag={attach=af.attach}ag.name=af.name or'unknown'ag.detach=af.detach or function(d)end;ag.apply_hunks=af.apply_hunks or function(d)b.error('Current source does not support applying hunks.')end;if type(ag.name)~='string'then b.error('`source.name` should be string.')end;b.validate_callable(ag.attach,'source.attach')b.validate_callable(ag.detach,'source.detach')b.validate_callable(ag.apply_hunks,'source.apply_hunks')return ag end;b.convert_view_to_extmark_opts=function(ah)local ai=b.style_extmark_data[ah.style]if ai==nil then b.error('Style '..vim.inspect(ah.style)..' is not supported.')end;local aj=ah.style=='sign'and ah.signs or{}local ak,al=ai.field,ai.hl_group_prefix;local am;if b.extmark_supports_invalidate then am=true end;return{add={[ak]=al..'Add',sign_text=aj.add,priority=ah.priority,invalidate=am},change={[ak]=al..'Change',sign_text=aj.change,priority=ah.priority,invalidate=am},delete={[ak]=al..'Delete',sign_text=aj.delete,priority=ah.priority,invalidate=am}}end;b.set_decoration_provider=function(U,V)local an=function(d,d,e,ao,ap)local i=b.cache[e]if i==nil then return false end;if i.needs_clear then b.clear_all_diff(e)i.needs_clear=false end;local aq,ar=i.viz_lines,i.overlay_lines;for as=ao+1,ap+1 do if aq[as]~=nil then b.set_extmark(e,U,as-1,0,aq[as])aq[as]=nil end;if ar[as]~=nil then for at=1,#ar[as]do b.draw_overlay_line(e,V,as-1,ar[as][at])end;ar[as]=nil end end end;vim.api.nvim_set_decoration_provider(U,{on_win=an})end;b.schedule_diff_update=vim.schedule_wrap(function(e,au)b.bufs_to_update[e]=true;b.timer_diff_update:stop()b.timer_diff_update:start(au,0,b.process_scheduled_buffers)end)b.process_scheduled_buffers=vim.schedule_wrap(function()for e,d in pairs(b.bufs_to_update)do b.update_buf_diff(e)end;b.bufs_to_update={}end)b.update_buf_diff=vim.schedule_wrap(function(e)local i=b.cache[e]if i==nil then return end;if not vim.api.nvim_buf_is_valid(e)then b.cache[e]=nil;return end;if type(i.ref_text)~='string'or b.is_disabled(e)then local av={source_name=i.source.name}i.hunks,i.viz_lines,i.overlay_lines,i.summary={},{},{},av;vim.b[e].minidiff_summary,vim.b[e].minidiff_summary_string=av,''return end;local aw=i.config.options;b.vimdiff_opts.algorithm=aw.algorithm;b.vimdiff_opts.indent_heuristic=aw.indent_heuristic;if b.vimdiff_supports_linematch then b.vimdiff_opts.linematch=aw.linematch end;local ax=vim.api.nvim_buf_get_lines(e,0,-1,false)local ay=table.concat(ax,'\n')..'\n'local az=vim.diff(i.ref_text,ay,b.vimdiff_opts)b.update_hunk_data(az,i,ax)local av=i.summary;vim.b[e].minidiff_summary=av;local aA={}if av.n_ranges>0 then table.insert(aA,'#'..av.n_ranges)end;if av.add>0 then table.insert(aA,'+'..av.add)end;if av.change>0 then table.insert(aA,'~'..av.change)end;if av.delete>0 then table.insert(aA,'-'..av.delete)end;vim.b[e].minidiff_summary_string=table.concat(aA,' ')i.needs_clear=true;vim.api.nvim_exec_autocmds('User',{pattern='MiniDiffUpdated'})b.redraw_buffer(e)end)b.update_hunk_data=function(az,i,ax)local aB=i.overlay;local aC=aB and vim.split(i.ref_text,'\n')or nil;local aD,aE=i.extmark_opts,i.config.view.priority;local r,aq,ar={},{},{}local aF,aG,aH=0,0,0;local aI,aJ=0,-math.huge;for as,aK in ipairs(az)do local aL,aM=aK[2],aK[4]local aN=aL==0 and'add'or(aM==0 and'delete'or'change')local aO={type=aN,ref_start=aK[1],ref_count=aL,buf_start=aK[3],buf_count=aM}r[as]=aO;local aP=math.min(aL,aM)aF=aF+aM-aP;aG=aG+aP;aH=aH+aL-aP;local aQ=math.max(aK[3],1)local aR=aQ+math.max(aM,1)-1;aI=aI+(aQ<=aJ+1 and 0 or 1)aJ=math.max(aJ,aR)local aS=aD[aN]for aT=aQ,aR do if aq[aT]==nil or aN=='change'then aq[aT]=aS end end;if aB then if aN=='add'then b.append_overlay_add(ar,aO,aE)end;if aN=='change'then b.append_overlay_change(ar,aO,aC,ax,aE)end;if aN=='delete'then b.append_overlay_delete(ar,aO,aC,aE)end end end;i.hunks,i.viz_lines,i.overlay_lines=r,aq,ar;i.summary={add=aF,change=aG,delete=aH,n_ranges=aI}i.summary.source_name=i.source.name end;b.clear_all_diff=function(e)b.clear_namespace(e,b.ns_id.viz,0,-1)b.clear_namespace(e,b.ns_id.overlay,0,-1)end;b.append_overlay=function(ar,aT,a5)local aU=ar[aT]or{}table.insert(aU,a5)ar[aT]=aU end;b.append_overlay_add=function(ar,aO,aE)local a5={type='add',to=aO.buf_start+aO.buf_count-1,priority=aE}b.append_overlay(ar,aO.buf_start,a5)end;b.append_overlay_change=function(ar,aO,aC,ax,aE)if aO.buf_count==aO.ref_count then for as=0,aO.ref_count-1 do local aV,aW=aO.ref_start+as,aO.buf_start+as;local a5={type='change_worddiff',ref_line=aC[aV],buf_line=ax[aW],priority=aE}b.append_overlay(ar,aW,a5)end;return end;local aX={}for as=aO.ref_start,aO.ref_start+aO.ref_count-1 do local aY={{aC[as],'MiniDiffOverChange'},{b.overlay_suffix,'MiniDiffOverChange'}}table.insert(aX,aY)end;b.append_overlay(ar,aO.buf_start,{type='change',lines=aX,priority=aE})end;b.append_overlay_delete=function(ar,aO,aC,aE)local aZ={}for as=aO.ref_start,aO.ref_start+aO.ref_count-1 do table.insert(aZ,{{aC[as],'MiniDiffOverDelete'},{b.overlay_suffix,'MiniDiffOverDelete'}})end;local aT,a_=math.max(aO.buf_start,1),aO.buf_start==0;local a5={type='delete',lines=aZ,show_above=a_,priority=aE}b.append_overlay(ar,aT,a5)end;b.draw_overlay_line=function(e,b0,b1,a5)if a5.type=='add'then local k={end_row=a5.to,end_col=0,hl_group='MiniDiffOverAdd',hl_eol=true,priority=a5.priority}return b.set_extmark(e,b0,b1,0,k)end;if a5.type=='change'then local k={virt_lines=a5.lines,virt_lines_above=true,priority=a5.priority}return b.set_extmark(e,b0,b1,0,k)end;if a5.type=='change_worddiff'then return b.draw_overlay_line_worddiff(e,b0,b1,a5)end;if a5.type=='delete'then local k={virt_lines=a5.lines,virt_lines_above=a5.show_above,priority=a5.priority}return b.set_extmark(e,b0,b1,0,k)end end;b.draw_overlay_line_worddiff=function(e,b0,b1,a5)local b2,b3=a5.ref_line,a5.buf_line;local b4,b5=b.compute_worddiff_changed_parts(b2,b3)local b6,b7={},1;for as=1,#b4 do local b8=b4[as]if b7<b8[1]then table.insert(b6,{b2:sub(b7,b8[1]-1),'MiniDiffOverContext'})end;table.insert(b6,{b2:sub(b8[1],b8[2]),'MiniDiffOverChange'})b7=b8[2]+1 end;if b7<=b2:len()then table.insert(b6,{b2:sub(b7),'MiniDiffOverContext'})end;table.insert(b6,{b.overlay_suffix,'MiniDiffOverContext'})local b9={virt_lines={b6},virt_lines_above=true,priority=a5.priority}b.set_extmark(e,b0,b1,0,b9)for as=1,#b5 do local b8=b5[as]local ba={end_row=b1,end_col=b8[2],hl_group='MiniDiffOverChange',priority=a5.priority}b.set_extmark(e,b0,b1,b8[1]-1,ba)end end;b.compute_worddiff_changed_parts=function(b2,b3)local bb,bc,bd=b.slice_line(b2)local be,bf,bg=b.slice_line(b3)local az=vim.diff(bb,be,b.worddiff_opts)local bh,bi={},{}for as=1,#az do local aK=az[as]if aK[2]>0 then table.insert(bh,{bc[aK[1]],bd[aK[1]+aK[2]-1]})end;if aK[4]>0 then table.insert(bi,{bf[aK[3]],bg[aK[3]+aK[4]-1]})end end;return bh,bi end;b.slice_line=function(bj)local bk=bj:len()local bl,bm,bn;if vim.str_utfindex(bj)==bk then bl,bm,bn=bj:gsub('(.)','%1\n'),{},{}for as=1,string.len(bj)do bm[as],bn[as]=as,as end else bl,bm,bn={},vim.str_utf_pos(bj),{}for as=1,#bm-1 do table.insert(bl,bj:sub(bm[as],bm[as+1]-1))table.insert(bn,bm[as+1]-1)end;table.insert(bl,bj:sub(bm[#bm],bk))table.insert(bn,bk)bl=table.concat(bl,'\n')..'\n'end;return bl,bm,bn end;b.get_hunk_buf_range=function(aO)if aO.buf_count>0 then return aO.buf_start,aO.buf_start+aO.buf_count-1 end;local bo=math.max(aO.buf_start,1)return bo,bo end;b.get_hunks_in_range=function(r,bo,bp)local ag={}for d,bq in ipairs(r)do local br,bs=b.get_hunk_buf_range(bq)local bt,bu=math.max(bo,br),math.min(bp,bs)if bt<=bu then local bv={ref_start=bq.ref_start,ref_count=bq.ref_count}bv.type=bq.ref_count==0 and'add'or(bq.buf_count==0 and'delete'or'change')bv.buf_start=bv.type=='delete'and bq.buf_start or bt;bv.buf_count=bv.type=='delete'and 0 or bu-bt+1;table.insert(ag,bv)end end;table.sort(ag,b.hunk_order)return ag end;b.reset_hunks=function(e,r)local aC=vim.split(b.cache[e].ref_text,'\n')local bw=0;for d,bq in ipairs(r)do local bx=vim.list_slice(aC,bq.ref_start,bq.ref_start+bq.ref_count-1)local by=bw+(bq.buf_count==0 and 1 or 0)-1;local bo,bp=bq.buf_start+by,bq.buf_start+bq.buf_count+by;vim.api.nvim_buf_set_lines(e,bo,bp,false,bx)bw=bw+bq.ref_count-bq.buf_count end end;b.yank_hunks_ref=function(bz,r,bA)local aC,bB=vim.split(bz,'\n'),{}for d,bq in ipairs(r)do for as=bq.ref_start,bq.ref_start+bq.ref_count-1 do bB[as]=aC[as]end end;local bC={}for as=1,#aC do table.insert(bC,bB[as])end;vim.fn.setreg(bA,bC,'l')end;b.get_contiguous_hunk_ranges=function(r)if#r==0 then return{}end;r=vim.deepcopy(r)table.sort(r,b.hunk_order)local bD,bE=b.get_hunk_buf_range(r[1])local ag={{from=bD,to=bE}}for as=2,#r do local bq,M=r[as],ag[#ag]local br,bs=b.get_hunk_buf_range(bq)if br<=M.to+1 then M.to=math.max(M.to,bs)else table.insert(ag,{from=br,to=bs})end end;return ag end;b.iterate_hunk_ranges=function(E,C,k)local bF=#E;local bG;if C=='first'then bG=0 end;if C=='prev'then bG=b.get_range_id_prev(E,k.line_start)end;if C=='next'then bG=b.get_range_id_next(E,k.line_start)end;if C=='last'then bG=bF+1 end;local bH=C=='prev'and bG==1 or C=='next'and bG==bF;if not k.wrap and bH then return nil end;local bI=C=='first'or C=='next'local F=bG+k.n_times*(bI and 1 or-1)local G=k.wrap and(F<1 or bF<F)F=k.wrap and(F-1)%bF+1 or math.min(math.max(F,1),bF)return F,G end;b.get_range_id_next=function(E,A)for as=#E,1,-1 do if E[as].from<=A then return as end end;return 0 end;b.get_range_id_prev=function(E,A)for as=1,#E do if A<=E[as].to then return as end end;return#E+1 end;b.hunk_order=function(bJ,bK)return bJ.buf_start<bK.buf_start or bJ.buf_start==bK.buf_start and bJ.type=='change'end;b.export_qf=function(k)local bL=k.scope=='current'and{vim.api.nvim_get_current_buf()}or vim.tbl_keys(b.cache)bL=vim.tbl_filter(vim.api.nvim_buf_is_valid,bL)table.sort(bL)local ag={}for d,e in ipairs(bL)do local bM=vim.api.nvim_buf_get_name(e)for d,bq in ipairs(b.cache[e].hunks)do local bN={bufnr=e,filename=bM,type=bq.type:sub(1,1):upper()}bN.lnum,bN.end_lnum=b.get_hunk_buf_range(bq)table.insert(ag,bN)end end;return ag end;b.git_start_watching_index=function(e,n)local bO=vim.loop.new_pipe()local bP={'rev-parse','--path-format=absolute','--git-dir'}local bQ={args=bP,cwd=vim.fn.fnamemodify(n,':h'),stdio={nil,bO,nil}}local bR=vim.schedule_wrap(function()a.disable(e)b.git_cache[e]={}end)local bS,bT=nil,{}local bU=function(bV)bS:close()if bV~=0 or bT[1]==nil then return bR()end;local bW=table.concat(bT,''):gsub('\n+$','')b.git_setup_index_watch(e,bW)b.git_set_ref_text(e)end;bS=vim.loop.spawn('git',bQ,bU)b.git_read_stream(bO,bT)end;b.git_setup_index_watch=function(e,bW)local bX,bY=vim.loop.new_fs_event(),vim.loop.new_timer()local bZ=function()b.git_set_ref_text(e)end;local b_=function(d,bM,d)if bM~='index'then return end;bY:stop()bY:start(50,0,bZ)end;bX:start(bW,{recursive=false},b_)b.git_invalidate_cache(b.git_cache[e])b.git_cache[e]={fs_event=bX,timer=bY}end;b.git_set_ref_text=vim.schedule_wrap(function(e)local c0=vim.schedule_wrap(function(l)pcall(a.set_ref_text,e,l)end)local n=b.get_buf_realpath(e)if n==''then return c0({})end;local c1,c2=vim.fn.fnamemodify(n,':h'),vim.fn.fnamemodify(n,':t')local bO=vim.loop.new_pipe()local bQ={args={'show',':0:./'..c2},cwd=c1,stdio={nil,bO,nil}}local bS,bT=nil,{}local bU=function(bV)bS:close()if bV~=0 or bT[1]==nil then return c0({})end;local l=table.concat(bT,''):gsub('\r\n','\n')c0(l)end;bS=vim.loop.spawn('git',bQ,bU)b.git_read_stream(bO,bT)end)b.git_get_path_data=function(n)local c1,c2=vim.fn.fnamemodify(n,':h'),vim.fn.fnamemodify(n,':t')local bO=vim.loop.new_pipe()local bP={'ls-files','--full-name','--format=%(objectmode) %(eolinfo:index) %(path)','--',c2}local bQ={args=bP,cwd=c1,stdio={nil,bO,nil}}local bS,bT,ag,c3=nil,{},{cwd=c1},false;local bU=function(bV)bS:close()c3=true;if bV~=0 then return end;local c4=table.concat(bT,''):gsub('\n+$','')ag.mode_bits,ag.eol,ag.rel_path=string.match(c4,'^(%d+) (%S+) (.*)$')end;bS=vim.loop.spawn('git',bQ,bU)b.git_read_stream(bO,bT)vim.wait(1000,function()return c3 end,1)return ag end;b.git_format_patch=function(e,r,s)local ax=vim.api.nvim_buf_get_lines(e,0,-1,false)local aC=vim.split(b.cache[e].ref_text,'\n')local ag={string.format('diff --git a/%s b/%s',s.rel_path,s.rel_path),'index 000000..000000 '..s.mode_bits,'--- a/'..s.rel_path,'+++ b/'..s.rel_path}local bw=0;local c5=s.eol=='crlf'and'\r'or''for d,bq in ipairs(r)do local c6=bq.ref_start+(bq.ref_count==0 and 1 or 0)table.insert(ag,string.format('@@ -%d,%d +%d,%d @@',c6,bq.ref_count,c6+bw,bq.buf_count))for as=bq.ref_start,bq.ref_start+bq.ref_count-1 do table.insert(ag,'-'..aC[as]..c5)end;for as=bq.buf_start,bq.buf_start+bq.buf_count-1 do table.insert(ag,'+'..ax[as]..c5)end;bw=bw+bq.buf_count-bq.ref_count end;return ag end;b.git_apply_patch=function(s,t)local c7=vim.loop.new_pipe()local bP={'apply','--whitespace=nowarn','--cached','--unidiff-zero','-'}local bQ={args=bP,cwd=s.cwd,stdio={c7,nil,nil}}local bS;bS=vim.loop.spawn('git',bQ,function()bS:close()end)for d,aY in ipairs(t)do c7:write(aY)c7:write('\n')end;c7:shutdown(function()c7:close()end)end;b.git_read_stream=function(c8,c9)local Z=function(ca,a5)if a5~=nil then return table.insert(c9,a5)end;if ca then c9[1]=nil end;c8:close()end;c8:read_start(Z)end;b.git_invalidate_cache=function(p)if p==nil then return end;pcall(vim.loop.fs_event_stop,p.fs_event)pcall(vim.loop.timer_stop,p.timer)end;b.error=function(cb)error(string.format('(mini.diff) %s',cb),0)end;b.notify=function(cb,cc)vim.notify('(mini.diff) '..cb,vim.log.levels[cc])end;b.buf_ensure_loaded=function(e)if type(e)~='number'or vim.api.nvim_buf_is_loaded(e)then return end;local cd=vim.o.eventignore;vim.o.eventignore='BufEnter,BufWinEnter'pcall(vim.fn.bufload,e)vim.o.eventignore=cd end;b.map=function(J,ce,cf,k)if ce==''then return end;k=vim.tbl_deep_extend('force',{silent=true},k or{})vim.keymap.set(J,ce,cf,k)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.get_extmarks=function(...)local cg,ag=pcall(vim.api.nvim_buf_get_extmarks,...)if not cg then return{}end;return ag end;b.clear_namespace=function(...)pcall(vim.api.nvim_buf_clear_namespace,...)end;b.is_buf_text=function(e)local bF=vim.api.nvim_buf_call(e,function()return vim.fn.byte2line(1024)end)local ch=vim.api.nvim_buf_get_lines(e,0,bF,false)return table.concat(ch,''):find('\0')==nil end;b.get_buf_realpath=function(e)return vim.loop.fs_realpath(vim.api.nvim_buf_get_name(e))or''end;b.redraw_buffer=function(e)vim.api.nvim__buf_redraw_range(e,0,-1)vim.cmd('redrawstatus')end;if vim.api.nvim__redraw~=nil then b.redraw_buffer=function(e)vim.api.nvim__redraw({buf=e,valid=true,statusline=true})end end;return a
