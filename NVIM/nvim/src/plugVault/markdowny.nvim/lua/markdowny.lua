local a={}local b=function(c)return vim.api.nvim_buf_get_lines(0,c-1,c,false)[1]end;local d=function(c)vim.api.nvim_buf_set_lines(0,c-1,c,true,{})end;local e=function(f)local g,h=f.first_pos,f.last_pos;h[2]=math.min(h[2],#b(h[1]))return vim.api.nvim_buf_get_text(0,g[1]-1,g[2]-1,h[1]-1,h[2],{})end;local i=function(j,k)j[2]=math.min(j[2],#b(j[1])+1)vim.api.nvim_buf_set_text(0,j[1]-1,j[2]-1,j[1]-1,j[2]-1,k)end;local l=function(f,k)if not f then return end;local g,h=f.first_pos,f.last_pos;vim.api.nvim_buf_set_text(0,g[1]-1,g[2]-1,h[1]-1,h[2],k)end;local m=function(j)if not j then return end;vim.api.nvim_win_set_cursor(0,{j[1],j[2]-1})end;local n=function(o)local p=vim.api.nvim_buf_get_mark(0,o)return{p[1],p[2]+1}end;local q=function(o,p)if p then vim.api.nvim_buf_set_mark(0,o,p[1],p[2]-1,{})end end;local r=function(j)local s=string.byte(b(j[1]):sub(j[2],j[2]))if not s then return j end;while s>=0x80 and s<0xc0 do j[2]=j[2]-1;s=string.byte(b(j[1]):sub(j[2],j[2]))end;return j end;local t=function(j)if not j then return nil end;local s=string.byte(b(j[1]):sub(j[2],j[2]))if not s then return j end;if s>=0xf0 then j[2]=j[2]+3 elseif s>=0xe0 then j[2]=j[2]+2 elseif s>=0xc0 then j[2]=j[2]+1 end;return j end;local u=function(v,w,x)if v and v[w]~=nil then return v[w]else return x end end;local y=function(z,A,v)local B=r(n('<'))local C=t(n('>'))if B==nil or C==nil then return end;if vim.fn.visualmode()=='V'then C[2]=#b(C[1])end;local D=u(v,'remove',true)local f={first_pos=B,last_pos=C}local k=e(f)local E=k[1]:sub(1,#z)==z;local F=k[#k]:sub(-#A)==A;local G=E and F and D;local H=B[1]==C[1]if G then k[1]=k[1]:sub(#z+1,-1)k[#k]=k[#k]:sub(1,-#A-1)l(f,k)if H then C[2]=C[2]-#z-#A else C[2]=C[2]-#A end else i(B,{z})C[2]=C[2]+1;if H then C[2]=C[2]+#z end;i(C,{A})C[2]=C[2]+#A-1 end;q('>',C)end;local I=function(z,A,v)local B=r(n('<'))local C=t(n('>'))if B==nil or C==nil then return end;if vim.fn.visualmode()=='V'then C[2]=#b(C[1])end;local D=u(v,'remove',true)local f={first_pos=B,last_pos=C}local k=e(f)local E=k[1]==z;local F=k[#k]==A;local G=E and F and D;if G then d(B[1])C[1]=C[1]-1;d(C[1])C[1]=C[1]-1;q('>',{C[1],#k[#k-1]-1})m({C[1],1})else i(B,{z,''})B={B[1],1}q('<',B)C={C[1]+1,C[2]+1}i(C,{'',A})C={C[1]+1,#A}q('>',C)m({C[1]-1,1})end end;function a.bold()y('**','**')end;function a.italic()y('_','_')end;function a.code()if vim.fn.visualmode()=='V'then I('```','```')else y('`','`')end end;function a.link()vim.ui.input({prompt='Href:'},function(J)if J==nil then return end;y('[',']('..J..')',{remove=false})end)end;function a.inline_code()vim.notify("[markdowny.nvim] 'inline_code' has been deprecated. Please use 'code' function instead.",vim.log.levels.WARN)end;function a.setup(v)v=v or{}vim.api.nvim_create_autocmd('FileType',{desc='markdowny.nvim keymaps',pattern=v.filetypes or{'markdown','gitcommit','hgcommit'},callback=function()vim.keymap.set('v','<C-b>',":lua require('markdowny').bold()<cr>",{buffer=0,silent=true})vim.keymap.set('v','<C-i>',":lua require('markdowny').italic()<cr>",{buffer=0,silent=true})vim.keymap.set('v','<C-k>',":lua require('markdowny').link()<cr>",{buffer=0,silent=true})vim.keymap.set('v','<C-e>',":lua require('markdowny').code()<cr>",{buffer=0,silent=true})end})end;return a
