local a={}local b={}a.setup=function(c)_G.MiniFiles=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()end;a.config={content={filter=nil,prefix=nil,sort=nil},mappings={close='q',go_in='l',go_in_plus='L',go_out='h',go_out_plus='H',reset='<BS>',reveal_cwd='@',show_help='g?',synchronize='=',trim_left='<',trim_right='>'},options={permanent_delete=true,use_as_default_explorer=true},windows={max_number=math.huge,preview=false,width_focus=50,width_nofocus=15,width_preview=25}}a.open=function(d,e,f)d=b.fs_full_path(d or vim.fn.getcwd())local g=b.fs_get_type(d)if g==nil then b.error('`path` is not a valid path ("'..d..'")')end;local h;if g=='file'then d,h=b.fs_get_parent(d),b.fs_get_basename(d)end;if e==nil then e=true end;local i=a.close()if i==false then return end;local j;if e then j=b.explorer_path_history[d]end;j=j or b.explorer_new(d)j.opts=b.normalize_opts(nil,f)j.target_window=vim.api.nvim_get_current_win()j=b.explorer_focus_on_entry(j,d,h)b.explorer_refresh(j)b.latest_paths[vim.api.nvim_get_current_tabpage()]=d;b.explorer_track_lost_focus()b.trigger_event('MiniFilesExplorerOpen')end;a.refresh=function(f)local j=b.explorer_get()if j==nil then return end;local k=(f or{}).content or{}local l=#vim.tbl_keys(k)>0;if l then l=b.explorer_confirm_modified(j,'buffer updates')end;j.opts=b.normalize_opts(j.opts,f)b.explorer_refresh(j,{force_update=l})end;a.synchronize=function()local j=b.explorer_get()if j==nil then return end;local m=b.explorer_compute_fs_actions(j)if m~=nil and b.fs_actions_confirm(m)then b.fs_actions_apply(m,j.opts)end;b.explorer_refresh(j,{force_update=true})end;a.reset=function()local j=b.explorer_get()if j==nil then return end;j.branch={j.anchor}j.depth_focus=1;for n,o in pairs(j.views)do o.cursor={1,0}end;b.explorer_refresh(j,{skip_update_cursor=true})end;a.close=function()local j=b.explorer_get()if j==nil then return nil end;pcall(vim.loop.timer_stop,b.timers.focus)if not b.explorer_confirm_modified(j,'close')then return false end;b.trigger_event('MiniFilesExplorerClose')j=b.explorer_ensure_target_window(j)pcall(vim.api.nvim_set_current_win,j.target_window)j=b.explorer_update_cursors(j)for p,q in pairs(j.windows)do b.window_close(q)j.windows[p]=nil end;for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do local r=vim.api.nvim_win_get_buf(q)if vim.bo[r].filetype=='minifiles-help'then vim.api.nvim_win_close(q,true)end end;for d,o in pairs(j.views)do j.views[d]=b.view_invalidate_buffer(b.view_encode_cursor(o))end;local s,t=vim.api.nvim_get_current_tabpage(),j.anchor;b.explorer_path_history[t]=j;b.opened_explorers[s]=nil;return true end;a.go_in=function(f)local j=b.explorer_get()if j==nil then return end;f=vim.tbl_deep_extend('force',{close_on_file=false},f or{})local u=f.close_on_file;if u then local v=a.get_fs_entry()u=v~=nil and v.fs_type=='file'end;local w=vim.fn.line('.')j=b.explorer_go_in_range(j,vim.api.nvim_get_current_buf(),w,w)b.explorer_refresh(j)if u then a.close()end end;a.go_out=function()local j=b.explorer_get()if j==nil then return end;if j.depth_focus==1 then j=b.explorer_open_root_parent(j)else j.depth_focus=j.depth_focus-1 end;b.explorer_refresh(j)end;a.trim_left=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_left(j)b.explorer_refresh(j)end;a.trim_right=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_right(j)b.explorer_refresh(j)end;a.reveal_cwd=function()local j=b.explorer_get()if j==nil then return end;local x=b.fs_full_path(vim.fn.getcwd())local y=string.format('^%s/.',vim.pesc(x))while j.branch[1]:find(y)~=nil do local z,A=b.fs_get_parent(j.branch[1]),b.fs_get_basename(j.branch[1])table.insert(j.branch,1,z)j.depth_focus=j.depth_focus+1;local B=j.views[z]or{}B.cursor=A;j.views[z]=B end;b.explorer_refresh(j)end;a.show_help=function()local j=b.explorer_get()if j==nil then return end;local r=vim.api.nvim_get_current_buf()if not b.is_opened_buffer(r)then return end;b.explorer_show_help(r,vim.api.nvim_get_current_win())end;a.get_fs_entry=function(r,C)r=b.validate_opened_buffer(r)C=b.validate_line(r,C)local D=b.match_line_path_id(b.get_bufline(r,C))if D==nil then return nil end;local d=b.path_index[D]return{fs_type=b.fs_get_type(d),name=b.fs_get_basename(d),path=d}end;a.get_target_window=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_ensure_target_window(j)return j.target_window end;a.set_target_window=function(q)if not b.is_valid_win(q)then b.error('`win_id` should be valid window identifier.')end;local j=b.explorer_get()if j==nil then return end;j.target_window=q end;a.get_latest_path=function()return b.latest_paths[vim.api.nvim_get_current_tabpage()]end;a.default_filter=function(v)return true end;a.default_prefix=function(v)if _G.MiniIcons~=nil then local E=v.fs_type=='directory'and'directory'or'file'local F,G=_G.MiniIcons.get(E,v.name)return F..' ',G end;if v.fs_type=='directory'then return' ','MiniFilesDirectory'end;local H,I=pcall(require,'nvim-web-devicons')if not H then return' ','MiniFilesFile'end;local F,G=I.get_icon(v.name,nil,{default=false})return(F or'')..' ',G or'MiniFilesFile'end;a.default_sort=function(J)local K=vim.tbl_map(function(L)return{fs_type=L.fs_type,name=L.name,path=L.path,lower_name=L.name:lower(),is_dir=L.fs_type=='directory'}end,J)table.sort(K,b.compare_fs_entries)return vim.tbl_map(function(L)return{name=L.name,fs_type=L.fs_type,path=L.path}end,K)end;b.default_config=vim.deepcopy(a.config)b.ns_id={highlight=vim.api.nvim_create_namespace('MiniFilesHighlight')}b.timers={focus=vim.loop.new_timer()}b.path_index={}b.explorer_path_history={}b.opened_explorers={}b.latest_paths={}b.opened_buffers={}b.is_windows=vim.loop.os_uname().sysname=='Windows_NT'b.block_event_trigger={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({content={c.content,'table'},mappings={c.mappings,'table'},options={c.options,'table'},windows={c.windows,'table'}})vim.validate({['content.filter']={c.content.filter,'function',true},['content.prefix']={c.content.prefix,'function',true},['content.sort']={c.content.sort,'function',true},['mappings.close']={c.mappings.close,'string'},['mappings.go_in']={c.mappings.go_in,'string'},['mappings.go_in_plus']={c.mappings.go_in_plus,'string'},['mappings.go_out']={c.mappings.go_out,'string'},['mappings.go_out_plus']={c.mappings.go_out_plus,'string'},['mappings.reset']={c.mappings.reset,'string'},['mappings.reveal_cwd']={c.mappings.reveal_cwd,'string'},['mappings.show_help']={c.mappings.show_help,'string'},['mappings.synchronize']={c.mappings.synchronize,'string'},['mappings.trim_left']={c.mappings.trim_left,'string'},['mappings.trim_right']={c.mappings.trim_right,'string'},['options.use_as_default_explorer']={c.options.use_as_default_explorer,'boolean'},['options.permanent_delete']={c.options.permanent_delete,'boolean'},['windows.max_number']={c.windows.max_number,'number'},['windows.preview']={c.windows.preview,'boolean'},['windows.width_focus']={c.windows.width_focus,'number'},['windows.width_nofocus']={c.windows.width_nofocus,'number'},['windows.width_preview']={c.windows.width_preview,'number'}})return c end;b.apply_config=function(c)a.config=c end;b.create_autocommands=function(c)local M=vim.api.nvim_create_augroup('MiniFiles',{})local N=function(O,P,Q,R)vim.api.nvim_create_autocmd(O,{group=M,pattern=P,callback=Q,desc=R})end;N('VimResized','*',a.refresh,'Refresh on resize')if c.options.use_as_default_explorer then vim.cmd('silent! autocmd! FileExplorer *')vim.cmd('autocmd VimEnter * ++once silent! autocmd! FileExplorer *')N('BufEnter','*',b.track_dir_edit,'Track directory edit')end end;b.create_default_hl=function()local S=function(A,f)f.default=true;vim.api.nvim_set_hl(0,A,f)end;S('MiniFilesBorder',{link='FloatBorder'})S('MiniFilesBorderModified',{link='DiagnosticFloatingWarn'})S('MiniFilesCursorLine',{link='CursorLine'})S('MiniFilesDirectory',{link='Directory'})S('MiniFilesFile',{})S('MiniFilesNormal',{link='NormalFloat'})S('MiniFilesTitle',{link='FloatTitle'})S('MiniFilesTitleFocused',{link='FloatTitle'})end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minifiles_config or{},c or{})end;b.normalize_opts=function(T,f)f=vim.tbl_deep_extend('force',b.get_config(),T or{},f or{})f.content.filter=f.content.filter or a.default_filter;f.content.prefix=f.content.prefix or a.default_prefix;f.content.sort=f.content.sort or a.default_sort;return f end;b.track_dir_edit=function(U)if vim.api.nvim_get_current_buf()~=U.buf then return end;if vim.b.minifiles_processed_dir then local V=vim.fn.bufnr('#')if V~=U.buf and vim.fn.buflisted(V)==1 then vim.api.nvim_win_set_buf(0,V)end;return vim.api.nvim_buf_delete(U.buf,{force=true})end;local d=vim.api.nvim_buf_get_name(0)if vim.fn.isdirectory(d)~=1 then return end;vim.bo.bufhidden='wipe'vim.b.minifiles_processed_dir=true;vim.schedule(function()a.open(d,false)end)end;b.explorer_new=function(d)return{branch={d},depth_focus=1,views={},windows={},anchor=d,target_window=vim.api.nvim_get_current_win(),opts={}}end;b.explorer_get=function(s)s=s or vim.api.nvim_get_current_tabpage()local K=b.opened_explorers[s]if b.explorer_is_visible(K)then return K end;b.opened_explorers[s]=nil;return nil end;b.explorer_is_visible=function(j)if j==nil then return nil end;for n,q in ipairs(j.windows)do if b.is_valid_win(q)then return true end end;return false end;b.explorer_refresh=function(j,f)j=b.explorer_normalize(j)if j.is_corrupted then j.is_corrupted=false;a.close()return end;if#j.branch==0 then return end;f=f or{}if not f.skip_update_cursor then j=b.explorer_update_cursors(j)end;if f.force_update then for d,o in pairs(j.views)do o=b.view_encode_cursor(o)o.children_path_ids=b.buffer_update(o.buf_id,d,j.opts)j.views[d]=o end end;for W=1,#j.branch do j=b.explorer_sync_cursor_and_branch(j,W)end;for n,q in ipairs(j.windows)do local r=vim.api.nvim_win_get_buf(q)b.opened_buffers[r].win_id=nil end;local X=b.compute_visible_depth_range(j,j.opts)local Y,Z=0,0;for W=X.from,X.to do Z=Z+1;local _=b.explorer_refresh_depth_window(j,W,Z,Y)Y=Y+_+2 end;for W=Z+1,#j.windows do b.window_close(j.windows[W])j.windows[W]=nil end;local a0=j.depth_focus-X.from+1;local a1=j.windows[a0]b.window_focus(a1)local s=vim.api.nvim_win_get_tabpage(a1)b.opened_explorers[s]=j;return j end;b.explorer_track_lost_focus=function()local a2=vim.schedule_wrap(function()local a3=vim.bo.filetype;if a3=='minifiles'or a3=='minifiles-help'then return end;local a4=vim.api.nvim_get_current_win()a.close()pcall(vim.api.nvim_set_current_win,a4)end)b.timers.focus:start(1000,1000,a2)end;b.explorer_normalize=function(j)local a5={}for n,d in ipairs(j.branch)do if not b.fs_is_present_path(d)then break end;table.insert(a5,d)end;local a6=#a5;j.branch=a5;j.depth_focus=math.min(math.max(j.depth_focus,1),a6)for p=a6+1,#j.windows do b.window_close(j.windows[p])j.windows[p]=nil end;for n,q in pairs(j.windows)do if not b.is_valid_win(q)then j.is_corrupted=true end end;return j end;b.explorer_sync_cursor_and_branch=function(j,W)if#j.branch<W then return j end;local d,a7=j.branch[W],j.branch[W+1]local o=j.views[d]if o==nil then return j end;local r,a8=o.buf_id,o.cursor;if a8==nil then return j end;local a9;if type(a8)=='table'and b.is_valid_buf(r)then local aa=b.get_bufline(r,a8[1])a9=b.path_index[b.match_line_path_id(aa)]elseif type(a8)=='string'then a9=b.fs_child_path(d,a8)else return j end;if a9==a7 then return j end;for p=W+1,#j.branch do j.branch[p]=nil end;j.depth_focus=math.min(j.depth_focus,#j.branch)local ab=j.opts.windows.preview;local ac=type(a9)=='string'and b.fs_is_present_path(a9)local ad=j.depth_focus==W;if ab and ac and ad then table.insert(j.branch,a9)end;return j end;b.explorer_go_in_range=function(j,r,ae,af)local ag,d,C={},nil,nil;for p=ae,af do local v=a.get_fs_entry(r,p)or{}if v.fs_type=='file'then table.insert(ag,v.path)end;if v.fs_type=='directory'then d,C=v.path,p end end;for n,ah in ipairs(ag)do j=b.explorer_open_file(j,ah)end;if d~=nil then j=b.explorer_open_directory(j,d,j.depth_focus+1)local q=b.opened_buffers[r].win_id;if b.is_valid_win(q)then vim.api.nvim_win_set_cursor(q,{C,0})end end;return j end;b.explorer_focus_on_entry=function(j,d,h)if h==nil then return j end;j.depth_focus=b.explorer_get_path_depth(j,d)if j.depth_focus==nil then j.branch,j.depth_focus={d},1 end;local ai=j.views[d]or{}ai.cursor=h;j.views[d]=ai;return j end;b.explorer_compute_fs_actions=function(j)local aj={}for n,o in pairs(j.views)do local ak=b.buffer_compute_fs_diff(o.buf_id,o.children_path_ids)if#ak>0 then vim.list_extend(aj,ak)end end;if#aj==0 then return nil end;local al,am,an,ao,ap={},{},{},{},{}for n,aq in ipairs(aj)do if aq.from==nil then table.insert(al,aq.to)elseif aq.to==nil then am[aq.from]=true else table.insert(ap,aq)end end;local ar={}for n,aq in pairs(ap)do if am[aq.from]then if b.fs_get_parent(aq.from)==b.fs_get_parent(aq.to)then table.insert(an,aq)else table.insert(ao,aq)end;am[aq.from]=nil else table.insert(ar,aq)end end;return{create=al,delete=vim.tbl_keys(am),copy=ar,rename=an,move=ao}end;b.explorer_update_cursors=function(j)for n,q in ipairs(j.windows)do if b.is_valid_win(q)then local r=vim.api.nvim_win_get_buf(q)local d=b.opened_buffers[r].path;j.views[d].cursor=vim.api.nvim_win_get_cursor(q)end end;return j end;b.explorer_refresh_depth_window=function(j,W,as,at)local d=j.branch[W]local au,av,f=j.views,j.windows,j.opts;local o=au[d]or{}o=b.view_ensure_proper(o,d,f)au[d]=o;local aw=W==j.depth_focus;local ax=f.windows.preview and W==j.depth_focus+1;local _=aw and f.windows.width_focus or(ax and f.windows.width_preview or f.windows.width_nofocus)local c={col=at,height=vim.api.nvim_buf_line_count(o.buf_id),width=_,title=as==1 and b.fs_shorten_path(b.fs_full_path(d))or b.fs_get_basename(d)}local q=av[as]if not b.is_valid_win(q)then b.window_close(q)q=b.window_open(o.buf_id,c)av[as]=q end;b.window_update(q,c)b.window_set_view(q,o)b.trigger_event('MiniFilesWindowUpdate',{buf_id=vim.api.nvim_win_get_buf(q),win_id=q})j.views=au;j.windows=av;return _ end;b.explorer_get_path_depth=function(j,d)for W,ay in pairs(j.branch)do if d==ay then return W end end end;b.explorer_confirm_modified=function(j,az)local aA=false;for n,o in pairs(j.views)do if b.is_modified_buffer(o.buf_id)then aA=true end end;if not aA then return true end;local aB=string.format('There is at least one modified buffer\n\nConfirm %s without synchronization?',az)local aC=vim.fn.confirm(aB,'&Yes\n&No',1,'Question')return aC==1 end;b.explorer_open_file=function(j,d)j=b.explorer_ensure_target_window(j)local aD;for n,r in ipairs(vim.api.nvim_list_bufs())do local aE=b.is_valid_buf(r)and vim.bo[r].buflisted and vim.api.nvim_buf_get_name(r)==d;if aE then aD=r end end;if aD~=nil then vim.api.nvim_win_set_buf(j.target_window,aD)else local aF=vim.fn.fnameescape(vim.fn.fnamemodify(d,':.'))pcall(vim.fn.win_execute,j.target_window,'edit '..aF)end;return j end;b.explorer_ensure_target_window=function(j)if not b.is_valid_win(j.target_window)then j.target_window=b.get_first_valid_normal_window()end;return j end;b.explorer_open_directory=function(j,d,aG)j.depth_focus=aG;local aH=d~=j.branch[aG]if aH then j.branch[aG]=d;j=b.explorer_trim_branch_right(j)end;return j end;b.explorer_open_root_parent=function(j)local aI=j.branch[1]local aJ=b.fs_get_parent(aI)if aJ==nil then return j end;table.insert(j.branch,1,aJ)return b.explorer_focus_on_entry(j,aJ,b.fs_get_basename(aI))end;b.explorer_trim_branch_right=function(j)for p=j.depth_focus+1,#j.branch do j.branch[p]=nil end;return j end;b.explorer_trim_branch_left=function(j)local aK={}for p=j.depth_focus,#j.branch do table.insert(aK,j.branch[p])end;j.branch=aK;j.depth_focus=1;return j end;b.explorer_show_help=function(aL,aM)local aN=vim.api.nvim_buf_get_keymap(aL,'n')local aO,aP={},0;for n,U in ipairs(aN)do if U.desc~=nil then aO[U.desc]=U.lhs:lower()=='<lt>'and'<'or U.lhs;aP=math.max(aP,U.desc:len())end end;local aQ=vim.tbl_keys(aO)table.sort(aQ)local aR=string.format('%%-%ds │ %%s',aP)local aS={'Buffer mappings:',''}for n,R in ipairs(aQ)do table.insert(aS,string.format(aR,R,aO[R]))end;table.insert(aS,'')table.insert(aS,'(Press `q` to close)')local r=vim.api.nvim_create_buf(false,true)b.set_buflines(r,aS)vim.keymap.set('n','q','<Cmd>close<CR>',{buffer=r,desc='Close this window'})vim.b[r].minicursorword_disable=true;vim.b[r].miniindentscope_disable=true;vim.bo[r].filetype='minifiles-help'local aT=vim.tbl_map(vim.fn.strdisplaywidth,aS)local aU=math.max(unpack(aT))local c=vim.api.nvim_win_get_config(aM)c.relative='win'c.row=0;c.col=0;c.width=aU;c.height=#aS;c.title=vim.fn.has('nvim-0.9')==1 and[['mini.files' help]]or nil;c.zindex=c.zindex+1;c.style='minimal'local q=vim.api.nvim_open_win(r,false,c)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.window_update_highlight(q,'CursorLine','MiniFilesCursorLine')vim.wo[q].cursorline=true;vim.api.nvim_set_current_win(q)return q end;b.compute_visible_depth_range=function(j,f)local aV,aW=f.windows.width_focus+2,f.windows.width_nofocus+2;local aX=j.opts.windows.preview and j.depth_focus<#j.branch;local aY=aX and f.windows.width_preview+2 or aW;local aZ=1;if aV+aY<=vim.o.columns then aZ=aZ+1 end;if aV+aY+aW<=vim.o.columns then aZ=aZ+math.floor((vim.o.columns-aV-aY)/aW)end;aZ=math.min(math.max(aZ,1),f.windows.max_number)local a_,b0=#j.branch,j.depth_focus;local b1=math.min(a_,aZ)local b2=math.min(a_,math.floor(b0+0.5*b1))local b3=math.max(1,b2-b1+1)b2=b3+math.min(b1,a_)-1;return{from=b3,to=b2}end;b.view_ensure_proper=function(o,d,f)if not b.is_valid_buf(o.buf_id)then b.buffer_delete(o.buf_id)o.buf_id=b.buffer_create(d,f.mappings)local b4=vim.bo[o.buf_id].undolevels;vim.bo[o.buf_id].undolevels=-1;o.children_path_ids=b.buffer_update(o.buf_id,d,f)vim.bo[o.buf_id].undolevels=b4 end;o.cursor=o.cursor or{1,0}if type(o.cursor)=='string'then o=b.view_decode_cursor(o)end;return o end;b.view_encode_cursor=function(o)local r,a8=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a8)~='table'then return o end;local aa=b.get_bufline(r,a8[1])o.cursor=b.match_line_entry_name(aa)return o end;b.view_decode_cursor=function(o)local r,a8=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a8)~='string'then return o end;local aS=vim.api.nvim_buf_get_lines(r,0,-1,false)for p,aa in ipairs(aS)do if a8==b.match_line_entry_name(aa)then o.cursor={p,0}end end;if type(o.cursor)~='table'then o.cursor={1,0}end;return o end;b.view_invalidate_buffer=function(o)b.buffer_delete(o.buf_id)o.buf_id=nil;o.children_path_ids=nil;return o end;b.view_track_cursor=vim.schedule_wrap(function(U)local r=U.buf;local b5=b.opened_buffers[r]if b5==nil then return end;local q=b5.win_id;if not b.is_valid_win(q)then return end;local b6=b.window_tweak_cursor(q,r)local s=vim.api.nvim_win_get_tabpage(q)local j=b.explorer_get(s)if j==nil then return end;local b7=b.explorer_get_path_depth(j,b5.path)if b7==nil then return end;local o=j.views[b5.path]if o~=nil then o.cursor=b6;j.views[b5.path]=o end;j=b.explorer_sync_cursor_and_branch(j,b7)b.block_event_trigger['MiniFilesWindowUpdate']=true;b.explorer_refresh(j)b.block_event_trigger['MiniFilesWindowUpdate']=false end)b.view_track_text_change=function(U)local r=U.buf;local b8=b.opened_buffers[r].n_modified+1;b.opened_buffers[r].n_modified=b8;local q=b.opened_buffers[r].win_id;if b8>0 and b.is_valid_win(q)then b.window_update_border_hl(q)end;if not b.is_valid_win(q)then return end;local b9=vim.api.nvim_buf_line_count(r)local ba=math.min(b9,b.window_get_max_height())vim.api.nvim_win_set_height(q,ba)local bb=vim.fn.line('w0',q)+ba-1;local bc=bb-b9;if bc>0 then vim.cmd('normal! '..bc..'\25')end end;b.buffer_create=function(d,bd)local r=vim.api.nvim_create_buf(false,true)b.opened_buffers[r]={path=d}b.buffer_make_mappings(r,bd)local M=vim.api.nvim_create_augroup('MiniFiles',{clear=false})local N=function(be,R,Q)vim.api.nvim_create_autocmd(be,{group=M,buffer=r,desc=R,callback=Q})end;N({'CursorMoved','CursorMovedI'},'Tweak cursor position',b.view_track_cursor)N({'TextChanged','TextChangedI','TextChangedP'},'Track buffer modification',b.view_track_text_change)vim.b[r].minicursorword_disable=true;vim.bo[r].filetype='minifiles'b.trigger_event('MiniFilesBufferCreate',{buf_id=r})return r end;b.buffer_make_mappings=function(r,bd)local bf=function()for n=1,vim.v.count1 do a.go_in()end end;local bg=function()for n=1,vim.v.count1 do a.go_in({close_on_file=true})end end;local bh=function()for n=1,vim.v.count1 do a.go_out()end end;local bi=function()bh()a.trim_right()end;local bj=function()if vim.fn.mode()~='V'then return bd.go_in end;local bk,bl=vim.fn.line('v'),vim.fn.line('.')local ae,af=math.min(bk,bl),math.max(bk,bl)vim.schedule(function()local j=b.explorer_get()j=b.explorer_go_in_range(j,r,ae,af)b.explorer_refresh(j)end)return[[<C-\><C-n>]]end;local bm=function(bn,bo,bp,R)b.map(bn,bo,bp,{buffer=r,desc=R,nowait=true})end;bm('n',bd.close,a.close,'Close')bm('n',bd.go_in,bf,'Go in entry')bm('n',bd.go_in_plus,bg,'Go in entry plus')bm('n',bd.go_out,bh,'Go out of directory')bm('n',bd.go_out_plus,bi,'Go out of directory plus')bm('n',bd.reset,a.reset,'Reset')bm('n',bd.reveal_cwd,a.reveal_cwd,'Reveal cwd')bm('n',bd.show_help,a.show_help,'Show Help')bm('n',bd.synchronize,a.synchronize,'Synchronize')bm('n',bd.trim_left,a.trim_left,'Trim branch left')bm('n',bd.trim_right,a.trim_right,'Trim branch right')b.map('x',bd.go_in,bj,{buffer=r,desc='Go in selected entries',expr=true})end;b.buffer_update=function(r,d,f)if not(b.is_valid_buf(r)and b.fs_is_present_path(d))then return end;local bq=b.fs_get_type(d)=='directory'and b.buffer_update_directory or b.buffer_update_file;local J=bq(r,d,f)b.trigger_event('MiniFilesBufferUpdate',{buf_id=r,win_id=b.opened_buffers[r].win_id})b.opened_buffers[r].n_modified=-1;return vim.tbl_map(function(L)return L.path_id end,J)end;b.buffer_update_directory=function(r,d,f)local aS,br,bs={},{},{}local J=b.fs_read_dir(d,f.content)local bt=math.floor(math.log10(#b.path_index))+1;local bu='/%0'..bt..'d/%s/%s'local bv=f.content.prefix;for n,bw in ipairs(J)do local bx,G=bv(bw)bx,G=bx or'',G or''table.insert(aS,string.format(bu,b.path_index[bw.path],bx,bw.name))table.insert(br,G)table.insert(bs,bw.fs_type=='directory'and'MiniFilesDirectory'or'MiniFilesFile')end;b.set_buflines(r,aS)local by=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(r,by,0,-1)local bz=function(C,bA,bB)b.set_extmark(r,by,C,bA,bB)end;for p,aa in ipairs(aS)do local bC,bD=aa:match('^/%d+/().-()/')local bE={hl_group=br[p],end_col=bD-1,right_gravity=false}bz(p-1,bC-1,bE)local bF={hl_group=bs[p],end_row=p,end_col=0,right_gravity=false}bz(p-1,bD-1,bF)end;return J end;b.buffer_update_file=function(r,d,f)local bG=vim.loop.fs_open(d,'r',1)local bH=vim.loop.fs_read(bG,1024):find('\0')==nil;vim.loop.fs_close(bG)if not bH then b.set_buflines(r,{'-Non-text-file'..string.rep('-',f.windows.width_preview)})return{}end;local bI,bJ=pcall(vim.fn.readfile,d,'',vim.o.lines)local aS=bI and vim.split(table.concat(bJ,'\n'),'\n')or{}b.set_buflines(r,aS)if b.buffer_should_highlight(r)then local a3=vim.filetype.match({buf=r,filename=d})local bK,bL=pcall(vim.treesitter.language.get_lang,a3)local bM,n=pcall(vim.treesitter.start,r,bK and bL or a3)if not bM then vim.bo[r].syntax=a3 end end;return{}end;b.buffer_delete=function(r)if r==nil then return end;pcall(vim.api.nvim_buf_delete,r,{force=true})b.opened_buffers[r]=nil end;b.buffer_compute_fs_diff=function(r,bN)if not b.is_modified_buffer(r)then return{}end;local d=b.opened_buffers[r].path;local aS=vim.api.nvim_buf_get_lines(r,0,-1,false)local K,bO={},{}for n,aa in ipairs(aS)do local D=b.match_line_path_id(aa)local bP=b.path_index[D]local bQ=D~=nil and aa:sub(b.match_line_offset(aa))or aa;local bR=b.fs_child_path(d,bQ)..(vim.endswith(bQ,'/')and'/'or'')if aa:find('^%s*$')==nil and bP~=bR then table.insert(K,{from=bP,to=bR})elseif D~=nil then bO[D]=true end end;for n,bS in ipairs(bN)do if not bO[bS]then table.insert(K,{from=b.path_index[bS],to=nil})end end;return K end;b.buffer_should_highlight=function(r)local bT=vim.api.nvim_buf_call(r,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return bT<=1000000 and bT<=1000*vim.api.nvim_buf_line_count(r)end;b.is_opened_buffer=function(r)return b.opened_buffers[r]~=nil end;b.is_modified_buffer=function(r)local U=b.opened_buffers[r]return U~=nil and U.n_modified>0 end;b.match_line_entry_name=function(aa)if aa==nil then return nil end;local bU=b.match_line_offset(aa)local K=aa:sub(bU):gsub('/.*$','')return K end;b.match_line_offset=function(aa)if aa==nil then return nil end;return aa:match('^/.-/.-/()')or 1 end;b.match_line_path_id=function(aa)if aa==nil then return nil end;local bV=aa:match('^/(%d+)')local bW,K=pcall(tonumber,bV)if not bW then return nil end;return K end;b.window_open=function(r,c)c.anchor='NW'c.border='single'c.focusable=true;c.relative='editor'c.style='minimal'c.zindex=99;c.row=1;if vim.fn.has('nvim-0.9')==0 then c.title=nil end;local q=vim.api.nvim_open_win(r,false,c)vim.wo[q].concealcursor='nvic'vim.wo[q].foldenable=false;vim.wo[q].wrap=false;vim.api.nvim_win_call(q,function()vim.fn.matchadd('Conceal',[[^/\d\+/]])vim.fn.matchadd('Conceal',[[^/\d\+/[^/]*\zs/\ze]])end)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.window_update_highlight(q,'CursorLine','MiniFilesCursorLine')b.trigger_event('MiniFilesWindowOpen',{buf_id=r,win_id=q})return q end;b.window_update=function(q,c)local bX=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bY=b.window_get_max_height()c.row=bX and 1 or 0;c.height=c.height~=nil and math.min(c.height,bY)or nil;c.width=c.width~=nil and math.min(c.width,vim.o.columns)or nil;if vim.fn.has('nvim-0.9')==1 and c.title~=nil then local bZ,b_=c.title,c.width;local c0=vim.fn.strcharlen(bZ)if b_<c0 then bZ='…'..vim.fn.strcharpart(bZ,c0-b_+1,b_-1)end;c.title=bZ;local c1=vim.api.nvim_win_get_config(q)c.border,c.title_pos=c1.border,c1.title_pos else c.title=nil end;c.relative='editor'vim.api.nvim_win_set_config(q,c)b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')vim.wo[q].cursorline=true;vim.wo[q].conceallevel=3 end;b.window_update_highlight=function(q,c2,c3)local c4=c2 ..':'..c3;local c5=string.format('(%s:[^,]*)',vim.pesc(c2))local c6,c7=vim.wo[q].winhighlight:gsub(c5,c4)if c7==0 then c6=c6 ..','..c4 end;vim.wo[q].winhighlight=c6 end;b.window_focus=function(q)vim.api.nvim_set_current_win(q)b.window_update_highlight(q,'FloatTitle','MiniFilesTitleFocused')end;b.window_close=function(q)if q==nil then return end;local c8,r=pcall(vim.api.nvim_win_get_buf,q)if c8 then b.opened_buffers[r].win_id=nil end;pcall(vim.api.nvim_win_close,q,true)end;b.window_set_view=function(q,o)local r=o.buf_id;vim.api.nvim_win_set_buf(q,r)b.opened_buffers[r].win_id=q;pcall(b.window_set_cursor,q,o.cursor)vim.wo[q].cursorline=true;b.window_update_border_hl(q)end;b.window_set_cursor=function(q,a8)if type(a8)~='table'then return end;vim.api.nvim_win_set_cursor(q,a8)b.window_tweak_cursor(q,vim.api.nvim_win_get_buf(q))end;b.window_tweak_cursor=function(q,r)local a8=vim.api.nvim_win_get_cursor(q)local aa=b.get_bufline(r,a8[1])local c9=b.match_line_offset(aa)if a8[2]<c9-1 then a8[2]=c9-1;vim.api.nvim_win_set_cursor(q,a8)vim.cmd('normal! 1000zh')end;return a8 end;b.window_update_border_hl=function(q)if not b.is_valid_win(q)then return end;local r=vim.api.nvim_win_get_buf(q)local ca=b.is_modified_buffer(r)and'MiniFilesBorderModified'or'MiniFilesBorder'b.window_update_highlight(q,'FloatBorder',ca)end;b.window_get_max_height=function()local bX=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local cb=vim.o.laststatus>0;return vim.o.lines-vim.o.cmdheight-(bX and 1 or 0)-(cb and 1 or 0)-2 end;b.fs_read_dir=function(d,k)local cc=vim.loop.fs_scandir(d)local K={}if not cc then return K end;local A,g=vim.loop.fs_scandir_next(cc)while A do if not(g=='file'or g=='directory')then g=b.fs_get_type(b.fs_child_path(d,A))end;table.insert(K,{fs_type=g,name=A,path=b.fs_child_path(d,A)})A,g=vim.loop.fs_scandir_next(cc)end;K=k.sort(vim.tbl_filter(k.filter,K))for n,bw in ipairs(K)do bw.path_id=b.add_path_to_index(bw.path)end;return K end;b.add_path_to_index=function(d)local cd=b.path_index[d]if cd~=nil then return cd end;local ce=#b.path_index+1;b.path_index[ce]=d;b.path_index[d]=ce;return ce end;b.replace_path_in_index=function(b3,b2)local cf,cg=b.path_index[b3],b.path_index[b2]b.path_index[cf],b.path_index[b2]=b2,cf;if cg then b.path_index[cg]=nil end;b.path_index[b3]=nil end;b.compare_fs_entries=function(ch,ci)if ch.is_dir and not ci.is_dir then return true end;if not ch.is_dir and ci.is_dir then return false end;return ch.lower_name<ci.lower_name end;b.fs_normalize_path=function(d)return d:gsub('/+','/'):gsub('(.)/$','%1')end;if b.is_windows then b.fs_normalize_path=function(d)return d:gsub('\\','/'):gsub('/+','/'):gsub('(.)/$','%1')end end;b.fs_is_present_path=function(d)return vim.loop.fs_stat(d)~=nil end;b.fs_child_path=function(cj,A)return b.fs_normalize_path(string.format('%s/%s',cj,A))end;b.fs_full_path=function(d)return b.fs_normalize_path(vim.fn.fnamemodify(d,':p'))end;b.fs_shorten_path=function(d)d=b.fs_normalize_path(d)local ck=b.fs_normalize_path(vim.loop.os_homedir()or'~')local K=d:gsub('^'..vim.pesc(ck),'~')return K end;b.fs_get_basename=function(d)return b.fs_normalize_path(d):match('[^/]+$')end;b.fs_get_parent=function(d)d=b.fs_full_path(d)local cl=b.fs_is_windows_top(d)or d=='/'if cl then return nil end;local K=b.fs_normalize_path(d:match('^.*/'))local cm=b.fs_is_windows_top(K)and'/'or''return K..cm end;b.fs_is_windows_top=function(d)return b.is_windows and d:find('^%w:[\\/]?$')~=nil end;b.fs_get_type=function(d)if not b.fs_is_present_path(d)then return nil end;return vim.fn.isdirectory(d)==1 and'directory'or'file'end;b.fs_actions_confirm=function(m)local aB=table.concat(b.fs_actions_to_lines(m),'\n')local aC=vim.fn.confirm(aB,'&Yes\n&No',1,'Question')return aC==1 end;b.fs_actions_to_lines=function(m)local cn={}local co=function(d)local cp=b.fs_shorten_path(b.fs_get_parent(d))local cq=cn[cp]or{}cn[cp]=cq;return cq end;local cr=function(d)return string.format("'%s'",b.fs_get_basename(d))end;for n,aq in ipairs(m.copy)do local cq=co(aq.from)local aa=string.format("    COPY: %s to '%s'",cr(aq.from),b.fs_shorten_path(aq.to))table.insert(cq,aa)end;for n,d in ipairs(m.create)do local cq=co(d)local g=d:find('/$')==nil and'file'or'directory'local aa=string.format('  CREATE: %s (%s)',cr(d),g)table.insert(cq,aa)end;for n,d in ipairs(m.delete)do local cq=co(d)local aa=string.format('  DELETE: %s',cr(d))table.insert(cq,aa)end;for n,aq in ipairs(m.move)do local cq=co(aq.from)local aa=string.format("    MOVE: %s to '%s'",cr(aq.from),b.fs_shorten_path(aq.to))table.insert(cq,aa)end;for n,aq in ipairs(m.rename)do local cq=co(aq.from)local aa=string.format('  RENAME: %s to %s',cr(aq.from),cr(aq.to))table.insert(cq,aa)end;local K={'CONFIRM FILE SYSTEM ACTIONS',''}for d,cq in pairs(cn)do table.insert(K,d..':')vim.list_extend(K,cq)table.insert(K,'')end;return K end;b.fs_actions_apply=function(m,f)for n,aq in ipairs(m.copy)do local bW,cs=pcall(b.fs_copy,aq.from,aq.to)local U={action='copy',from=aq.from,to=aq.to}if bW and cs then b.trigger_event('MiniFilesActionCopy',U)end end;for n,d in ipairs(m.create)do local bW,cs=pcall(b.fs_create,d)local U={action='create',to=b.fs_normalize_path(d)}if bW and cs then b.trigger_event('MiniFilesActionCreate',U)end end;for n,aq in ipairs(m.move)do local bW,cs=pcall(b.fs_move,aq.from,aq.to)local U={action='move',from=aq.from,to=aq.to}if bW and cs then b.trigger_event('MiniFilesActionMove',U)end end;for n,aq in ipairs(m.rename)do local bW,cs=pcall(b.fs_rename,aq.from,aq.to)local U={action='rename',from=aq.from,to=aq.to}if bW and cs then b.trigger_event('MiniFilesActionRename',U)end end;for n,d in ipairs(m.delete)do local bW,cs=pcall(b.fs_delete,d,f.options.permanent_delete)local U={action='delete',from=d}if bW and cs then b.trigger_event('MiniFilesActionDelete',U)end end end;b.fs_create=function(d)if b.fs_is_present_path(d)then return b.warn_existing_path(d,'create')end;vim.fn.mkdir(b.fs_get_parent(d),'p')local g=d:find('/$')==nil and'file'or'directory'if g=='directory'then return vim.fn.mkdir(d)==1 else return vim.fn.writefile({},d)==0 end end;b.fs_copy=function(b3,b2)if b.fs_is_present_path(b2)then return b.warn_existing_path(b3,'copy')end;local ct=b.fs_get_type(b3)if ct==nil then return false end;vim.fn.mkdir(b.fs_get_parent(b2),'p')if ct=='file'then return vim.loop.fs_copyfile(b3,b2)end;local J=b.fs_read_dir(b3,{filter=function()return true end,sort=function(L)return L end})vim.fn.mkdir(b2)local cs=true;for n,bw in ipairs(J)do cs=cs and b.fs_copy(bw.path,b.fs_child_path(b2,bw.name))end;return cs end;b.fs_delete=function(d,cu)if cu then return vim.fn.delete(d,'rf')==0 end;local cv=b.fs_child_path(vim.fn.stdpath('data'),'mini.files/trash')vim.fn.mkdir(cv,'p')local cw=b.fs_child_path(cv,b.fs_get_basename(d))pcall(vim.fn.delete,cw,'rf')return vim.loop.fs_rename(d,cw)end;b.fs_move=function(b3,b2)if b.fs_is_present_path(b2)then return b.warn_existing_path(b3,'move or rename')end;vim.fn.mkdir(b.fs_get_parent(b2),'p')local cs=vim.loop.fs_rename(b3,b2)if not cs then return cs end;b.replace_path_in_index(b3,b2)for n,r in ipairs(vim.api.nvim_list_bufs())do b.rename_loaded_buffer(r,b3,b2)end;return cs end;b.fs_rename=b.fs_move;b.rename_loaded_buffer=function(r,b3,b2)if not(vim.api.nvim_buf_is_loaded(r)and vim.bo[r].buftype=='')then return end;local cx=b.fs_normalize_path(vim.api.nvim_buf_get_name(r))local cy=cx:gsub('^'..vim.pesc(b3),b2)if cx==cy then return end;vim.api.nvim_buf_set_name(r,cy)vim.api.nvim_buf_call(r,function()vim.cmd('silent! write! | edit')end)end;b.warn_existing_path=function(d,cz)b.notify(string.format('Can not %s %s. Target path already exists.',cz,d),'WARN')return false end;b.validate_opened_buffer=function(L)if L==nil or L==0 then L=vim.api.nvim_get_current_buf()end;if not b.is_opened_buffer(L)then b.error('`buf_id` should be an identifier of an opened directory buffer.')end;return L end;b.validate_line=function(r,L)L=L or vim.fn.line('.')if not(type(L)=='number'and 1<=L and L<=vim.api.nvim_buf_line_count(r))then b.error('`line` should be a valid line number in buffer '..r..'.')end;return L end;b.error=function(aB)error(string.format('(mini.files) %s',aB),0)end;b.notify=function(aB,cA)vim.notify('(mini.files) '..aB,vim.log.levels[cA])end;b.map=function(bn,bo,bp,f)if bo==''then return end;f=vim.tbl_deep_extend('force',{silent=true},f or{})vim.keymap.set(bn,bo,bp,f)end;b.trigger_event=function(cB,U)if b.block_event_trigger[cB]then return end;vim.api.nvim_exec_autocmds('User',{pattern=cB,data=U})end;b.is_valid_buf=function(r)return type(r)=='number'and vim.api.nvim_buf_is_valid(r)end;b.is_valid_win=function(q)return type(q)=='number'and vim.api.nvim_win_is_valid(q)end;b.get_bufline=function(r,C)return vim.api.nvim_buf_get_lines(r,C-1,C,false)[1]end;b.set_buflines=function(r,aS)local cC=string.format('lockmarks lua vim.api.nvim_buf_set_lines(%d, 0, -1, false, %s)',r,vim.inspect(aS))vim.cmd(cC)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.get_first_valid_normal_window=function()for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(q).relative==''then return q end end end;return a
