local a=require("which-key.config")local b=require("which-key.util")local c={}c.VERSION=2;c.notifs={}c.notify=true;c.fields={rhs={},lhs={},buffer={inherit=true},callback={transform="rhs"},desc={},expr={inherit=true},mode={inherit=true},noremap={transform=function(d)return not d,"remap"end},nowait={inherit=true},remap={inherit=true},replace_keycodes={inherit=true},script={},silent={inherit=true},unique={inherit=true},plugin={},group={},hidden={inherit=true},cond={inherit=true},preset={inherit=true},icon={inherit=true},name={transform="group",deprecated=true},prefix={inherit=true,deprecated=true},cmd={transform="rhs",deprecated=true}}function c.error(e,f)c.log(e,vim.log.levels.ERROR,f)end;function c.warn(e,f)c.log(e,vim.log.levels.WARN,f)end;function c.log(e,g,f)if not c.notify then return end;c.notifs[#c.notifs+1]={msg=e,level=g,spec=f}if a.notify then b.warn({"There were issues reported with your **which-key** mappings.","Use `:checkhealth which-key` to find out more."},{once=true})end end;function c.expect(f,h,i)i=type(i)=="string"and{i}or i;local j=false;for k,l in ipairs(i)do if type(f[h])==l then j=true;break end end;if not j then c.error("Expected `"..h.."` to be "..table.concat(i,", "),f)end;return j end;function c._parse(f,m,n)n=n or{}n.version=n.version or c.VERSION;if f.version then n.version=f.version;f.version=nil end;if m==nil and n.version~=c.VERSION then c.warn("You're using an old version of the which-key spec.\n".."Your mappings will work, but it's recommended to update them to the new version.\n".."Please check the docs and suggested spec below for more info.\nMappings",vim.deepcopy(f))end;m=m or{}f=type(f)=="string"and{desc=f}or f;local o={}local p={}local q=vim.tbl_keys(f)table.sort(q,function(r,s)local t,u=type(r),type(s)if type(r)==type(s)then return r<s end;return t<u end)for k,v in ipairs(q)do local w=f[v]local h=c.fields[v]if h then if type(h.transform)=="string"then v=h.transform elseif type(h.transform)=="function"then local x,y=h.transform(w,f)w,v=x,y or v end;o[v]=w elseif type(v)=="string"then if n.version==1 then if c.expect(f,v,{"string","table"})then if type(w)=="string"then table.insert(p,{prefix=(f.prefix or"")..v,desc=w})elseif type(w)=="table"then w.prefix=(f.prefix or"")..v;table.insert(p,w)end end else c.error("Invalid field `"..v.."`",f)end elseif type(v)=="number"and type(w)=="table"then if n.version==1 then w.prefix=f.prefix or""end;table.insert(p,w)f[v]=nil end end;local z=#f;if n.version==c.VERSION then if z==1 then if c.expect(f,1,"string")then o.lhs=f[1]end elseif z==2 then if c.expect(f,1,"string")and c.expect(f,2,{"string","function"})then o.lhs=f[1]o.rhs=f[2]end elseif z>2 then c.error("expected 1 or 2 elements, got "..z,f)end elseif n.version==1 then if o.expr and o.replace_keycodes==nil then o.replace_keycodes=false end;if z==1 then if c.expect(f,1,"string")then if o.desc then c.warn("overwriting desc",f)end;o.desc=f[1]end elseif z==2 then if c.expect(f,1,{"string","function"})and c.expect(f,2,"string")then if o.desc then c.warn("overwriting desc",f)end;o.rhs=f[1]o.desc=f[2]end elseif z>2 then c.error("expected 1 or 2 elements, got "..z,f)end end;c.add(o,m)for k,A in ipairs(p)do for v,w in pairs(o)do if c.fields[v]and c.fields[v].inherit and A[v]==nil then A[v]=w end end;c._parse(A,m,n)end;return m end;function c.add(o,m)if o.cond==false or type(o.cond)=="function"and not o.cond()then return end;o.cond=nil;if o.desc=="which_key_ignore"then o.hidden=true;o.desc=nil end;if type(o.group)=="string"or type(o.group)=="function"then o.desc=o.group;o.group=true end;if o.plugin then o.group=true end;if o.group and o.desc then o.desc=o.desc;if type(o.desc)=="string"then o.desc=o.desc:gsub("^%+","")end end;if o.buffer==0 or o.buffer==true then o.buffer=vim.api.nvim_get_current_buf()end;if o.rhs then o.silent=o.silent~=false end;o.lhs=o.lhs or o.prefix or""o.prefix=nil;local B=o.desc~=nil;b.getters(o,{"desc","icon"})if B or o.group or o.hidden or o.rhs then local C=o.mode or{"n"}C=type(C)=="string"and vim.split(C,"")or C;for k,D in ipairs(C)do local E=vim.deepcopy(o)E.mode=D;table.insert(m,E)end end end;function c.create(o)assert(o.lhs,"Missing lhs")assert(o.mode,"Missing mode")assert(o.rhs,"Missing rhs")local F={"remap","noremap","buffer","silent","nowait","expr","unique","script","desc","replace_keycodes"}local n={}for k,v in ipairs(F)do if o[v]~=nil then n[v]=o[v]end end;vim.keymap.set(o.mode,o.lhs,o.rhs,n)end;function c.parse(f,n)n=n or{}c.notify=n.notify~=false;local m=c._parse(f,nil,n)c.notify=true;for k,E in ipairs(m)do if E.rhs and n.create then c.create(E)end end;return m end;return c
