local a={}local b=require'plenary.path'local c=require'mind.notify'.notify;local d=require'mind.node'a.expand_opts_paths=function(e)e.persistence.state_path=vim.fn.expand(e.persistence.state_path)e.persistence.data_dir=vim.fn.expand(e.persistence.data_dir)end;a.get_main_tree=function()return a.state.tree end;a.get_project_tree=function(f)if f~=nil then return a.state.projects[f]else return a.local_tree end end;a.new_global_project_tree=function(f,e)c('creating a new global project tree')local g={uid=vim.fn.strftime('%Y%m%d%H%M%S'),contents={{text=f:match('^.*/(.+)$')}},type=d.TreeType.ROOT,icon=e.ui.root_marker}a.state.projects[f]=g;return g end;a.new_local_tree=function(f,e)c('creating a new local tree')a.local_tree={uid=vim.fn.strftime('%Y%m%d%H%M%S'),contents={{text=f:match('^.*/(.+)$')}},type=d.TreeType.LOCAL_ROOT,icon=e.ui.root_marker}return a.local_tree end;a.load_main_state=function(e)a.state={tree={uid=vim.fn.strftime('%Y%m%d%H%M%S'),contents={{text='Main'}},type=d.TreeType.ROOT,icon=e.ui.root_marker},projects={}}if e.persistence.state_path==nil then c('cannot load shit',vim.log.levels.ERROR)return end;local h=io.open(e.persistence.state_path,'r')if h~=nil then local i=h:read('*a')h:close()if i~=nil then a.state=vim.json.decode(i)end end;a.state.tree.uid=a.state.tree.uid or vim.fn.strftime('%Y%m%d%H%M%S')for j,g in ipairs(a.state.projects)do g.uid=g.uid or vim.fn.strftime('%Y%m%d%H%M%S')end end;a.save_main_state=function(e)if e.persistence.state_path==nil then return end;local k=b:new(e.persistence.state_path)if not k:exists()then k:touch({parents=true})end;local h=io.open(e.persistence.state_path,'w')if h==nil then c(string.format('cannot save main state at %s',e.persistence.state_path),vim.log.levels.ERROR)else local i=vim.json.encode(a.state)h:write(i)h:close()end end;a.load_local_state=function()a.local_tree=nil;local f=vim.fn.getcwd()local l=b:new(f,'.mind')if l:is_dir()then local h=io.open(b:new(f,'.mind','state.json'):expand(),'r')if h==nil then c('cannot open local Mind tree')else local i=h:read('*a')h:close()if i~=nil then a.local_tree=vim.json.decode(i)a.local_tree.uid=a.local_tree.uid or vim.fn.strftime('%Y%m%d%H%M%S')a.local_cwd=f end end end end;a.save_local_state=function()if a.local_tree~=nil then local f=vim.fn.getcwd()if a.local_cwd and f~=a.local_cwd then c('refusing to save local state: differs from when it was loaded',vim.log.levels.ERROR)c(string.format('hint: loaded as %s, try saving as %s',a.local_cwd,f),vim.log.levels.INFO)c(string.format('hint: cd to %s in order to save the tree',a.local_cwd),vim.log.levels.INFO)return end;local l=b:new(f,'.mind')if not l:exists()then l:mkdir({parents=true})end;if l:is_dir()then local h=io.open(b:new(f,'.mind','state.json'):expand(),'w')if h==nil then c(string.format('cannot save local project at %s',f),4)else local i=vim.json.encode(a.local_tree)h:write(i)h:close()end end end end;a.load_state=function(e)a.load_main_state(e)a.load_local_state()end;a.save_state=function(e)a.save_main_state(e)a.save_local_state()end;a.get_project_data_dir=function(m,e)if m then return e.persistence.data_dir end;return'.mind/data'end;return a
