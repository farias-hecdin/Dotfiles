local a=require('cmp_nvim_lsp.source')local b={}b.client_source_map={}b.setup=function()vim.api.nvim_create_autocmd('InsertEnter',{group=vim.api.nvim_create_augroup('cmp_nvim_lsp',{clear=true}),pattern='*',callback=b._on_insert_enter})end;local c=function(d,e)if d==nil then return e end;return d end;local function f(g,h,i,j,k)local l=g..' is deprecated'j=j or'Nvim'l=h and l..', use '..h..' instead.'or l;l=l..' See :h deprecated\nThis function will be removed in '..j..' version '..i;if vim.notify_once(l,vim.log.levels.WARN)and k~=false then vim.notify(debug.traceback('',2):sub(2),vim.log.levels.WARN)end end;b.default_capabilities=function(m)m=m or{}return{textDocument={completion={dynamicRegistration=c(m.dynamicRegistration,false),completionItem={snippetSupport=c(m.snippetSupport,true),commitCharactersSupport=c(m.commitCharactersSupport,true),deprecatedSupport=c(m.deprecatedSupport,true),preselectSupport=c(m.preselectSupport,true),tagSupport=c(m.tagSupport,{valueSet={1}}),insertReplaceSupport=c(m.insertReplaceSupport,true),resolveSupport=c(m.resolveSupport,{properties={"documentation","detail","additionalTextEdits"}}),insertTextModeSupport=c(m.insertTextModeSupport,{valueSet={1,2}}),labelDetailsSupport=c(m.labelDetailsSupport,true)},contextSupport=c(m.snippetSupport,true),insertTextMode=c(m.insertTextMode,1),completionList=c(m.completionList,{itemDefaults={'commitCharacters','editRange','insertTextFormat','insertTextMode','data'}})}}}end;b.update_capabilities=function(n,m)local o=vim.deprecate or f;o('cmp_nvim_lsp.update_capabilities','cmp_nvim_lsp.default_capabilities','1.0.0','cmp-nvim-lsp')return b.default_capabilities(m)end;b._on_insert_enter=function()local p=require('cmp')local q={}for n,r in ipairs(vim.lsp.get_active_clients())do q[r.id]=r;if not b.client_source_map[r.id]then local s=a.new(r)if s:is_available()then b.client_source_map[r.id]=p.register_source('nvim_lsp',s)end end end;for n,r in ipairs(vim.lsp.buf_get_clients(0))do q[r.id]=r;if not b.client_source_map[r.id]then local s=a.new(r)if s:is_available()then b.client_source_map[r.id]=p.register_source('nvim_lsp',s)end end end;for t,u in pairs(b.client_source_map)do if not q[t]or q[t]:is_stopped()then p.unregister_source(u)b.client_source_map[t]=nil end end end;return b
