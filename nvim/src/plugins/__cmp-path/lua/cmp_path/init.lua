local a=require'cmp'local b='\\%([^/\\\\:\\*?<>\'"`\\|]\\)'local c=vim.regex(([[\%(\%(/PAT*[^/\\\\:\\*?<>\'"`\\| .~]\)\|\%(/\.\.\)\)*/\zePAT*$]]):gsub('PAT',b))local d={}local e={max_lines=20}local f={trailing_slash=false,label_trailing_slash=true,get_cwd=function(g)return vim.fn.expand(('#%d:p:h'):format(g.context.bufnr))end}d.new=function()return setmetatable({},{__index=d})end;d.get_trigger_characters=function()return{'/','.'}end;d.get_keyword_pattern=function(self,g)return b..'*'end;d.complete=function(self,g,h)local i=self:_validate_option(g)local j=self:_dirname(g,i)if not j then return h()end;local k=string.sub(g.context.cursor_before_line,g.offset,g.offset)=='.'self:_candidates(j,k,i,function(l,m)if l then return h()end;h(m)end)end;d.resolve=function(self,n,h)local o=n.data;if o.stat and o.stat.type=='file'then local p,q=pcall(function()return self:_get_documentation(o.path,e.max_lines)end)if p then n.documentation=q end end;h(n)end;d._dirname=function(self,g,i)local r=c:match_str(g.context.cursor_before_line)if not r then return nil end;local j=string.gsub(string.sub(g.context.cursor_before_line,r+2),'%a*$','')local s=string.sub(g.context.cursor_before_line,1,r+1)local t=i.get_cwd(g)if vim.api.nvim_get_mode().mode=='c'then t=vim.fn.getcwd()end;if s:match('%.%./$')then return vim.fn.resolve(t..'/../'..j)end;if s:match('%./$')or s:match('"$')or s:match('\'$')then return vim.fn.resolve(t..'/'..j)end;if s:match('~/$')then return vim.fn.resolve(vim.fn.expand('~')..'/'..j)end;local u=s:match('%$([%a_]+)/$')if u then local v=vim.fn.getenv(u)if v~=vim.NIL then return vim.fn.resolve(v..'/'..j)end end;if s:match('/$')then local w=true;w=w and not s:match('%a/$')w=w and not s:match('%a+:/$')and not s:match('%a+://$')w=w and not s:match('</$')w=w and not s:match('[%d%)]%s*/$')w=w and(not s:match('^[%s/]*$')or not self:_is_slash_comment())if w then return vim.fn.resolve('/'..j)end end;return nil end;d._candidates=function(x,j,k,i,h)local y,l=vim.loop.fs_scandir(j)if l then return h(l,nil)end;local z={}local function A(B,C)if not(k or string.sub(B,1,1)~='.')then return end;local D=j..'/'..B;local E=vim.loop.fs_stat(D)local F=nil;if E then C=E.type elseif C=='link'then F=vim.loop.fs_lstat(j)if not F then return end else return end;local G={label=B,filterText=B,insertText=B,kind=a.lsp.CompletionItemKind.File,data={path=D,type=C,stat=E,lstat=F}}if C=='directory'then G.kind=a.lsp.CompletionItemKind.Folder;if i.label_trailing_slash then G.label=B..'/'else G.label=B end;G.insertText=B..'/'if not i.trailing_slash then G.word=B end end;table.insert(z,G)end;while true do local B,C,H=vim.loop.fs_scandir_next(y)if H then return h(C,nil)end;if not B then break end;A(B,C)end;h(nil,z)end;d._is_slash_comment=function(x)local I=vim.bo.commentstring or''local J=vim.bo.filetype==''local K=false;K=K or I:match('/%*')K=K or I:match('//')return K and not J end;d._validate_option=function(x,g)local i=vim.tbl_deep_extend('keep',g.option,f)vim.validate({trailing_slash={i.trailing_slash,'boolean'},label_trailing_slash={i.label_trailing_slash,'boolean'},get_cwd={i.get_cwd,'function'}})return i end;d._get_documentation=function(x,L,M)local N=assert(io.open(L,'rb'))local O=N:read(1024)if O:find('\0')then return{kind=a.lsp.MarkupKind.PlainText,value='binary file'}end;local P={}for Q in O:gmatch("[^\r\n]+")do table.insert(P,Q)if M~=nil and#P>=M then break end end;local R=vim.filetype.match({filename=L})if not R then return{kind=a.lsp.MarkupKind.PlainText,value=table.concat(P,'\n')}end;table.insert(P,1,'```'..R)table.insert(P,'```')return{kind=a.lsp.MarkupKind.Markdown,value=table.concat(P,'\n')}end;return d
