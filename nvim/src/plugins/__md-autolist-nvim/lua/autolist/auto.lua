local a=require("autolist.utils")local b=require("autolist.config")local c=vim.fn;local d="^%s*%S+%s%[.%]"local e=":%s*$"local f=b.checkbox.left..b.checkbox.fill..b.checkbox.right;local g=b.checkbox.left.." "..b.checkbox.right;local h=a.get_percent_filtered(f)local i=a.get_percent_filtered(g)local j=false;local k=""local l="n"local m={}local function n(o,p)if not o or o==""then return end;local q=vim.api.nvim_replace_termcodes(o,true,true,true)if p=="i"then vim.cmd.normal({"a"..q,bang=true})else vim.cmd.normal({q,bang=true})end end;local function r()return b.lists[vim.bo.filetype]end;local function s(t)if t:match(f)then return true elseif t:match(g)then return false end;return nil end;local function u(v,w)local x=r()local y;if v then y=v else y=a.get_list_start(c.line("."),x)w=0 end;if not y then return end;if w then local z=y+w;local A=c.getline(z)if a.is_ordered(A)then c.setline(z,a.set_ordered_value(A,1))end end;local B=c.getline(y)local C=a.get_indent_lvl(B)local D=a.get_value_ordered(B)+1;local E=y+1;local t=c.getline(E)local F=a.get_indent_lvl(t)local G=-1;while F>=C and E<y+b.list_cap do if a.is_list(t,x)then if F==C then local H=a.set_ordered_value(B,D)a.set_line_marker(E,a.get_marker(H,x),x,t:match(d))D=D+1;G=-1 elseif F~=G and F==C+b.tabstop then u(E)G=F end else return end;E=E+1;t=c.getline(E)F=a.get_indent_lvl(t)end end;local function I(J)if b.recal_full then u()else u(a.get_list_start(c.line("."),r()))end end;local function K(L,M)local N,O=L:gsub("^(%s*"..M.."%s).*$","%1",1)if O==0 then N,O=L:gsub("^(%s*"..M..")$","%1",1)end;if a.get_whitespace_trimmed(N)==a.get_whitespace_trimmed(L)then if O==1 then return{replaced=true}else return{replaced=false}end end;return a.get_ordered_add(N,1)end;function m.new_before(P,Q)j=true;return m.new(P,Q)end;function m.new(P,Q)local R=r()if P==nil then k=Q;vim.o.operatorfunc="v:lua.require'autolist'.new"l=vim.api.nvim_get_mode().mode;if a.is_list(c.getline("."),R)then return"<esc>g@la"end;return Q end;n(k,l)if not R then return end;if c.line(".")<=0 then return end;local S=c.getline(c.line(".")-1)if j and c.line(".")+1==a.get_list_start(c.line("."),R)then S=a.set_ordered_value(c.getline(c.line(".")+1),0)end;if not a.is_list(S,R)then return end;local N=false;for T,U in ipairs(R)do local V=K(S,U)if V.replaced then N=true elseif V.replaced~=false then if S:match(d)then V=V..i.." "if S:match(d.."%s?$")then N=true;break end elseif not j and b.colon.indent and S:match(e)then if b.colon.preferred~=""then V=V:gsub("^(%s*).*","%1",1)..b.colon.preferred.." "end;V=b.tab..V;j=true end;local W=c.getline(".")a.set_current_line(V..W:gsub("^%s*","",1))I(j)j=false;return end end;if N then c.setline(c.line(".")-1,"")a.reset_cursor_column()j=false;return end;if b.colon.indent_raw and S:match(e)then a.set_current_line(b.colon.preferred.." "..c.getline("."):gsub("^%s*","",1))end;j=false end;function m.indent(P,Q)local R=r()local X=a.is_list(c.getline("."),R)if P==nil then if string.lower(Q)=="<tab>"then local W=c.getline(".")if X and c.getpos(".")[3]-1==string.len(W)then Q="<c-t>"end end;k=Q;vim.o.operatorfunc="v:lua.require'autolist'.indent"l=vim.api.nvim_get_mode().mode;if not X then return Q end;if l=="i"then return"<esc>g@la"end;return"g@l"end;n(k,l)if X then u()end end;function m.force_recalculate(P,Q)local R=r()if P==nil then k=Q;vim.o.operatorfunc="v:lua.require'autolist'.force_recalculate"l=vim.api.nvim_get_mode().mode;if l=="i"then return"<esc>g@la"end;return"g@l"end;n(k,l)if not R then return end;u()end;local function Y()local W=c.getline(".")local Z=c.line(".")local x=r()if b.invert.toggles_checkbox then local _=s(W)if _==true then c.setline(".",W:gsub(f,i,1))return elseif _==false then c.setline(".",W:gsub(g,h,1))return end end;if a.is_list(W,x)then if a.get_indent_lvl(W)==0 and b.invert.indent==true then c.setline(".",b.tab..W)end;if a.is_ordered(W)then a.set_line_marker(a.get_list_start(Z,x),b.invert.ul_marker,x)else local a0=b.invert.ol_incrementable..b.invert.ol_delim;a.set_line_marker(a.get_list_start(Z,x),a0,x)end;a.reset_cursor_column(c.col("$"))end;I()end;function m.invert_entry(P,Q)if P==nil then k=Q;vim.o.operatorfunc="v:lua.require'autolist'.invert_entry"l=vim.api.nvim_get_mode().mode;if l=="i"then return"<esc>g@la"end;return"g@l"end;n(k,l)local R=r()if not R then return end;Y()end;return m
