local a=require"colorizer.buffer"local b=a.clear_hl_cache;local c=a.rehighlight;local d=require"colorizer.utils"local e=d.merge;local f=vim.api;local g=f.nvim_create_augroup;local h=f.nvim_create_autocmd;local i=f.nvim_buf_get_option;local j=f.nvim_buf_clear_namespace;local k=f.nvim_get_current_buf;local l={}l.DEFAULT_NAMESPACE=a.default_namespace;l.highlight_buffer=a.highlight;local m;local n="ColorizerSetup"local o={}local p={}local q={RGB=true,RRGGBB=true,names=true,RRGGBBAA=false,AARRGGBB=false,rgb_fn=false,hsl_fn=false,css=false,css_fn=false,mode="background",tailwind=false,sass={enable=false,parsers={css=true}},virtualtext="â– "}local r={buf={},file={}}local s={exclusions={buf={},file={}},all={file=false,buf=false},default_options=q}local function t(u,v)local w;if v=="buf"then w=i(u,"buftype")else w=i(u,"filetype")end;return r.file[w]or s.default_options end;function l.is_buffer_attached(u)if u==0 or u==nil then u=k()else if not f.nvim_buf_is_valid(u)then p[u],o[u]=nil,nil;return end end;local x=f.nvim_get_autocmds{group=m,event={"WinScrolled","TextChanged","TextChangedI","TextChangedP"},buffer=u}if not o[u]or vim.tbl_isempty(x)then return end;return u end;function l.detach_from_buffer(u,y)u=l.is_buffer_attached(u)if not u then return end;j(u,y or l.DEFAULT_NAMESPACE,0,-1)if p[u]then for z,A in pairs(p[u].__detach.ns)do j(u,A,0,-1)end;for z,B in pairs(p[u].__detach.functions)do if type(B)=="function"then B(u)end end;for z,C in ipairs(p[u].__autocmds or{})do pcall(f.nvim_del_autocmd,C)end;p[u].__autocmds=nil;p[u].__detach=nil end;o[u]=nil end;function l.attach_to_buffer(u,D,v)if u==0 or u==nil then u=k()else if not f.nvim_buf_is_valid(u)then p[u],o[u]=nil,nil;return end end;if not D then D=l.get_buffer_options(u)end;if not D then D=t(u,v)end;if not a.highlight_mode_names[D.mode]then if D.mode~=nil then local E=D.mode;vim.defer_fn(function()vim.notify_once(string.format("Warning: Invalid mode given to colorizer setup [ %s ]",E))end,0)end;D.mode="background"end;o[u]=D;p[u]=p[u]or{}local F,G=c(u,D)if not F then return end;p[u].__detach=p[u].__detach or G.detach;p[u].__init=true;if p[u].__autocmds then return end;local H={}local I=m;local J={"TextChanged","TextChangedI","TextChangedP"}if D.sass and D.sass.enable then table.insert(J,"InsertLeave")end;H[#H+1]=h(J,{group=I,buffer=u,callback=function(K)if o[u]then p[u].__event=K.event;if K.event=="TextChanged"or K.event=="InsertLeave"then c(u,D,p[u])else local L=vim.fn.getpos"."p[u].__startline=L[2]-1;p[u].__endline=L[2]c(u,D,p[u],true)end end end})H[#H+1]=h({"WinScrolled"},{group=I,buffer=u,callback=function(K)if o[u]then p[u].__event=K.event;c(u,D,p[u])end end})h({"BufUnload","BufDelete"},{group=I,buffer=u,callback=function()if o[u]then l.detach_from_buffer(u)end;p[u].__init=nil end})p[u].__autocmds=H;p[u].__augroup_id=I end;function l.setup(M)if not vim.opt.termguicolors then vim.schedule(function()vim.notify("Colorizer: Error: &termguicolors must be set","Error")end)return end;local N=vim.deepcopy(M)or{}local O=N.filetypes or N[1]or{"*"}local P=N.user_default_options or N[2]or{}local Q=N.buftypes or N[3]or nil;r={buf={},file={}}s={exclusions={buf={},file={}},all={file=false,buf=false},default_options=e(q,P)}o,p={},{}local function R(v)local S=vim.bo.filetype;local T=vim.bo.buftype;local u=k()p[u]=p[u]or{}if s.exclusions.file[S]or s.exclusions.buf[T]then if o[u]then l.detach_from_buffer(u)end;p[u].__init=nil;return end;local U,V,D=r[v][S],r[v][T],nil;if v=="file"then D=U elseif U and V then D=U else D=V end;if not D and not s.all[v]then return end;D=D or s.default_options;if not p[u].__init then l.attach_to_buffer(u,D,v)end end;m=g(n,{})local W={buf="BufWinEnter",file="FileType"}local function X(v,Y)if type(Y)=="table"then local Z={}for _,a0 in pairs(Y)do local w;local D=s.default_options;if type(_)=="string"then w=_;if type(a0)~="table"then vim.notify("colorizer: Invalid option type for "..v.."type"..w,"ErrorMsg")else D=e(s.default_options,a0)end else w=a0 end;if w:sub(1,1)=="!"then s.exclusions[v][w:sub(2)]=true else r[v][w]=D;if w=="*"then s.all[v]=true else table.insert(Z,w)end end end;h({W[v]},{group=m,pattern=v=="file"and(s.all[v]and"*"or Z)or nil,callback=function()R(v)end})elseif Y then vim.notify_once(string.format("colorizer: Invalid type for %stypes %s",v,vim.inspect(Y)),"ErrorMsg")end end;X("file",O)X("buf",Q)h("ColorScheme",{group=m,callback=function()require("colorizer").clear_highlight_cache()end})end;function l.get_buffer_options(u)local a1=l.is_buffer_attached(u)if a1 then return o[a1]end end;function l.reload_all_buffers()for u,z in pairs(o)do l.attach_to_buffer(u,l.get_buffer_options(u))end end;function l.clear_highlight_cache()b()vim.schedule(l.reload_all_buffers)end;return l
