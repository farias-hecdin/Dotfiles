local a=vim.api;local b=vim.loop;local c=require"colorizer.utils"local d=c.get_last_modified;local e=c.watch_file;local f={}local g=("$"):byte()local h=("@"):byte()local i=(";"):byte()local j={}local function k(l,m)if type(j[l].IMPORTS[m])=="table"then for n,o in pairs(j[l].IMPORTS[m])do k(l,n)end end;j[l].DEFINITIONS[m]=nil;j[l].DEFINITIONS_LINEWISE[m]=nil;j[l].IMPORTS[m]=nil;pcall(b.fs_event_stop,j[l].WATCH_IMPORTS[m])j[l].WATCH_IMPORTS[m]=nil end;function f.cleanup(l)k(l,a.nvim_buf_get_name(l))j[l]=nil end;function f.name_parser(p,q,l)local r=p:match("^%$([%w_-]+)",q)if r then local s=j[l].DEFINITIONS_ALL[r]if s then return#r+1,s end end end;local function t(l,u,v,w)j[l].DEFINITIONS_ALL=j[l].DEFINITIONS_ALL or{}j[l].DEFINITIONS_RECURSIVE_CURRENT=j[l].DEFINITIONS_RECURSIVE_CURRENT or{}j[l].DEFINITIONS_RECURSIVE_CURRENT_ABSOLUTE=j[l].DEFINITIONS_RECURSIVE_CURRENT_ABSOLUTE or{}j[l].DEFINITIONS_LINEWISE[w]=j[l].DEFINITIONS_LINEWISE[w]or{}j[l].DEFINITIONS[w]=j[l].DEFINITIONS[w]or{}j[l].IMPORTS[w]=j[l].IMPORTS[w]or{}j[l].WATCH_IMPORTS[w]=j[l].WATCH_IMPORTS[w]or{}j[l].CURRENT_IMPORTS[w]={}local x=false;for q,p in ipairs(v)do local y=q-1+u;if not vim.tbl_isempty(j[l].DEFINITIONS_LINEWISE[w][y]or{})then for z,o in pairs(j[l].DEFINITIONS_LINEWISE[w][y])do j[l].DEFINITIONS[w][z]=nil end;j[l].DEFINITIONS_LINEWISE[w][y]={}else j[l].DEFINITIONS_LINEWISE[w][y]={}end;local A=1;while A<#p do if p:sub(A,A+1)=="//"then A=#p elseif not x and p:byte(A)==g then local r,B=p:match("^%$([%w_-]+)%s*:%s*(.+)%s*",A)if r and B then if B:byte()==g then local C,D=B:match"^%$([%w_-]+)()"if C then j[l].DEFINITIONS_RECURSIVE_CURRENT[r]=C;j[l].DEFINITIONS_LINEWISE[w][y][r]=true;A=A+D end;A=A+1 else if j[l].COLOR_PARSER then local E,s=j[l].COLOR_PARSER(B,1)if E and s then j[l].DEFINITIONS[w][r]=s;j[l].DEFINITIONS_RECURSIVE_CURRENT[r]=s;j[l].DEFINITIONS_RECURSIVE_CURRENT_ABSOLUTE[r]=s;j[l].DEFINITIONS_LINEWISE[w][y][r]=true;A=A+E+3 end end end;A=A+#r end elseif x and p:byte(A)==i then x,A=false,A+1 elseif p:byte(A)==h or x then local B,F,G;if x then B,F=p:match("%s*(.*[^;])%s*([;]?)",A)else G,B,F=p:match("@(%a+)%s+(.+[^;])%s*([;]?)",A)G=G=="import"or G=="use"end;if not F or F==""then x=true else x=false end;if G and B then local H={}for I,J in B:gmatch"['\"](.-)()['\"]"do local K,L=vim.fn.fnamemodify(I,":h"),vim.fn.fnamemodify(I,":t")if L~=""then local M=vim.fn.fnamemodify(w,":h")M=M~=""and M.."/"or""K=vim.fn.fnamemodify(M..K,":p")L=L;table.insert(H,K..L..".scss")table.insert(H,K.."_"..L..".scss")table.insert(H,K..L..".sass")table.insert(H,K.."_"..L..".sass")end;A=A+2*J end;for o,z in ipairs(H)do local N=d(z)if N then z=b.fs_realpath(z)j[l].CURRENT_IMPORTS[w][z]=true;if not j[l].WATCH_IMPORTS[w][z]then j[l].IMPORTS[w][z]=N;local O,P={},0;for Q in io.lines(z)do P=P+1;O[P]=Q end;t(l,0,O,z)O=nil;local function R()local S=vim.api.nvim_buf_call(l,function()return{vim.fn.line"w0",vim.fn.line"w$",vim.fn.line"$",vim.api.nvim_win_get_height(0)}end)if j[l].LOCAL_OPTIONS and S[1]~=S[2]and(S[3]>S[4]and S[2]>S[4]or S[2]>=S[3])then j[l].LOCAL_OPTIONS.__startline=S[1]j[l].LOCAL_OPTIONS.__endline=S[2]end;j[l].LOCAL_OPTIONS.__event=""local T=d(z)if T then j[l].IMPORTS[w]=j[l].IMPORTS[w]or{}j[l].IMPORTS[w][z]=T;local U,V={},0;for Q in io.lines(z)do V=V+1;U[V]=Q end;t(l,0,U,z)U=nil end;require("colorizer.buffer").rehighlight(l,j[l].OPTIONS,j[l].LOCAL_OPTIONS,true)end;j[l].WATCH_IMPORTS[w][z]=e(z,R)end else j[l].IMPORTS[w][z]=nil;pcall(b.fs_event_stop,j[l].WATCH_IMPORTS[w][z])j[l].WATCH_IMPORTS[w][z]=nil end end end end;A=A+1 end end;for n,o in pairs(j[l].IMPORTS[w])do if not j[l].CURRENT_IMPORTS[w][n]then k(l,w)end end end;function f.update_variables(l,u,W,X,Y,Z,_)X=X or vim.api.nvim_buf_get_lines(l,u,W,false)if not j[l]then j[l]={DEFINITIONS_ALL={},DEFINITIONS={},IMPORTS={},WATCH_IMPORTS={},CURRENT_IMPORTS={},DEFINITIONS_LINEWISE={},OPTIONS=Z,LOCAL_OPTIONS=_}end;j[l].COLOR_PARSER=Y;j[l].DEFINITIONS_ALL={}j[l].DEFINITIONS_RECURSIVE_CURRENT={}j[l].DEFINITIONS_RECURSIVE_CURRENT_ABSOLUTE={}t(l,u,X,a.nvim_buf_get_name(l))for o,a0 in pairs(j[l].DEFINITIONS)do for a1,a2 in pairs(a0)do j[l].DEFINITIONS_ALL[a1]=a2 end end;for w,a2 in pairs(j[l].DEFINITIONS_RECURSIVE_CURRENT_ABSOLUTE)do j[l].DEFINITIONS_ALL[w]=a2 end;local function a3(w,a1)return j[l].DEFINITIONS_ALL[a1]or j[l].DEFINITIONS_RECURSIVE_CURRENT[a1]and a3(w,j[l].DEFINITIONS_RECURSIVE_CURRENT[a1])end;local function a4(w,a1)local a5=a3(w,a1)if a5 then j[l].DEFINITIONS_ALL[w]=a5 end;j[l].DEFINITIONS_RECURSIVE_CURRENT[w]=nil end;for w,a1 in pairs(j[l].DEFINITIONS_RECURSIVE_CURRENT)do a4(w,a1)end;j[l].DEFINITIONS_RECURSIVE_CURRENT=nil;j[l].DEFINITIONS_RECURSIVE_CURRENT_ABSOLUTE=nil end;return f
