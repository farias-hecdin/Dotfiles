local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.6')==0 then vim.notify('(mini.jump2d) Official support for Neovim<0.6 will soon be dropped. Update to a newer version of Neovim.')end;_G.MiniJump2d=a;c=b.setup_config(c)b.apply_config(c)if c.mappings.start_jumping=='<CR>'then vim.api.nvim_exec([[augroup MiniJump2d
          au!
          autocmd BufWinEnter quickfix nnoremap <buffer> <CR> <CR>
          autocmd CmdwinEnter * nnoremap <buffer> <CR> <CR>
        augroup END]],false)end;local d='hi default MiniJump2dSpot guifg=white guibg=black gui=bold,nocombine'if vim.o.background=='light'then d='hi default MiniJump2dSpot guifg=black guibg=white gui=bold,nocombine'end;vim.cmd(d)end;a.config={spotter=nil,labels='abcdefghijklmnopqrstuvwxyz',allowed_lines={blank=true,cursor_before=true,cursor_at=true,cursor_after=true,fold=true},allowed_windows={current=true,not_current=true},hooks={before_start=nil,after_jump=nil},mappings={start_jumping='<CR>'}}a.start=function(e)if b.is_disabled()then return end;e=e or{}local f=(e.hooks or{}).before_start or((vim.b.minijump2d_config or{}).hooks or{}).before_start or a.config.hooks.before_start;if f~=nil then f()end;e=b.get_config(e)e.spotter=e.spotter or a.default_spotter;e.hl_group=e.hl_group or'MiniJump2dSpot'local g=b.spots_compute(e)g=b.spots_add_label(g,e)b.spots_show(g,e)b.cache.spots=g;if b.is_operator_pending()then b.advance_jump(e)else vim.defer_fn(function()b.advance_jump(e)end,0)end end;a.stop=function()b.spots_unshow()b.cache.spots=nil;b.cache.msg_shown=false;vim.cmd('redraw')if b.cache.is_in_getchar then vim.api.nvim_input('<C-c>')end end;a.gen_pattern_spotter=function(h,i)h=h or'[^%s%p]+'i=i or'start'local j=h:sub(1,1)=='^'or h:sub(-1,-1)=='$'if j then return function(k,l)local m=vim.fn.getline(k)local n,o,p=m:find(h)return{({['start']=n,['end']=o,['none']=p})[i]}end end;local q=i=='none'and'(%s)'or'(()%s)'h=q:format(h)return function(k,l)local m=vim.fn.getline(k)local r={}for s,t in string.gmatch(m,h)do if i=='end'then t=t+math.max(s:len()-1,0)end;t=math.min(math.max(t,0),m:len())local u=vim.str_utfindex(m,t)t=vim.str_byteindex(m,u)if t~=r[#r]then table.insert(r,t)end end;return r end end;a.default_spotter=(function()local v=a.gen_pattern_spotter('%S+','start')local w=a.gen_pattern_spotter('%S+','end')local x=a.gen_pattern_spotter('[^%s%p]%p','start')local y=a.gen_pattern_spotter('%p[^%s%p]','end')local z=a.gen_pattern_spotter('%u+','start')return function(k,l)local A=b.merge_unique(v(k,l),w(k,l))local B=b.merge_unique(x(k,l),y(k,l))local r=b.merge_unique(A,B)return b.merge_unique(r,z(k,l))end end)()a.builtin_opts={}a.builtin_opts.default={spotter=a.default_spotter}a.builtin_opts.line_start={spotter=function(k,l)return{1}end,hooks={after_jump=function()vim.cmd('normal! ^')end}}a.builtin_opts.word_start={spotter=a.gen_pattern_spotter('[^%s%p]+')}local function C(D)local r={spotter=function()return{}end,allowed_lines={blank=false,fold=false}}r.hooks={before_start=function()local E=D()if E==nil then r.spotter=function()return{}end else local h=vim.pesc(E)r.spotter=a.gen_pattern_spotter(h)end end}return r end;a.builtin_opts.single_character=C(function()return b.getcharstr('Enter single character to search')end)a.builtin_opts.query=C(function()return b.input('Enter query to search')end)b.default_config=a.config;b.ns_id={spots=vim.api.nvim_create_namespace('MiniJump2dSpots'),input=vim.api.nvim_create_namespace('MiniJump2dInput')}b.cache={spots=nil,is_in_getchar=false,msg_shown=false}b.keys={esc=vim.api.nvim_replace_termcodes('<Esc>',true,true,true),cr=vim.api.nvim_replace_termcodes('<CR>',true,true,true),block_operator_pending=vim.api.nvim_replace_termcodes('no<C-V>',true,true,true)}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({spotter={c.spotter,'function',true},labels={c.labels,'string'},allowed_lines={c.allowed_lines,'table'},allowed_windows={c.allowed_windows,'table'},hooks={c.hooks,'table'},mappings={c.mappings,'table'}})vim.validate({['allowed_lines.blank']={c.allowed_lines.blank,'boolean'},['allowed_lines.cursor_before']={c.allowed_lines.cursor_before,'boolean'},['allowed_lines.cursor_at']={c.allowed_lines.cursor_at,'boolean'},['allowed_lines.cursor_after']={c.allowed_lines.cursor_after,'boolean'},['allowed_lines.fold']={c.allowed_lines.fold,'boolean'},['allowed_windows.current']={c.allowed_windows.current,'boolean'},['allowed_windows.not_current']={c.allowed_windows.not_current,'boolean'},['hooks.before_start']={c.hooks.before_start,'function',true},['hooks.after_jump']={c.hooks.after_jump,'function',true},['mappings.start_jumping']={c.mappings.start_jumping,'string'}})return c end;b.apply_config=function(c)a.config=c;local F=c.mappings.start_jumping;b.map('n',F,'<Cmd>lua MiniJump2d.start()<CR>',{desc='Start 2d jumping'})b.map('x',F,'<Cmd>lua MiniJump2d.start()<CR>',{desc='Start 2d jumping'})b.map('o',F,'<Cmd>lua MiniJump2d.start()<CR>',{desc='Start 2d jumping'})end;b.is_disabled=function()return vim.g.minijump2d_disable==true or vim.b.minijump2d_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minijump2d_config or{},c or{})end;b.spots_compute=function(e)local G=vim.api.nvim_get_current_win()local H=vim.tbl_filter(function(I)if I==G then return e.allowed_windows.current end;return e.allowed_windows.not_current end,b.tabpage_list_wins(0))local r={}for J,I in ipairs(H)do vim.api.nvim_win_call(I,function()local K=vim.api.nvim_win_get_cursor(I)local L={win_id=I,win_id_init=G}local M=vim.api.nvim_win_get_buf(I)for N=vim.fn.line('w0'),vim.fn.line('w$')do local O=b.spot_find_in_line(N,L,e,K)for J,P in ipairs(O)do table.insert(r,{line=N,column=P,buf_id=M,win_id=I})end end end)end;return r end;b.spots_add_label=function(g,e)local Q=vim.split(e.labels,'')local R,S=#g,#Q;local T,U=math.floor(R/S),R%S;local V,W=1,0;local X=T+(V<=U and 1 or 0)for J,n in ipairs(g)do n.label=Q[V]W=W+1;if W>=X then V,W=V+1,0;X=T+(V<=U and 1 or 0)end end;return g end;b.spots_show=function(g,e)g=g or b.cache.spots or{}if#g==0 then b.message('No spots to show.')return end;for J,Y in ipairs(b.spots_to_extmarks(g))do local Z={hl_mode='combine',priority=1000,virt_text={{Y.text,e.hl_group}},virt_text_pos='overlay'}pcall(vim.api.nvim_buf_set_extmark,Y.buf_id,b.ns_id.spots,Y.line,Y.col,Z)end;if b.is_operator_pending()then vim.cmd('redraw')end end;b.spots_unshow=function(g)g=g or b.cache.spots or{}local _={}for J,n in ipairs(g)do _[n.buf_id]=true end;for J,M in ipairs(vim.tbl_keys(_))do pcall(vim.api.nvim_buf_clear_namespace,M,b.ns_id.spots,0,-1)end end;b.spots_to_extmarks=function(g)if#g==0 then return{}end;local r={}local M,m,P=g[1].buf_id,g[1].line-1,g[1].column-1;local a0={}local a1=P;for J,n in ipairs(g)do local a2=n.buf_id==M and n.line==m+1 and n.column==a1+1;if not a2 then table.insert(r,{buf_id=M,col=P,line=m,text=table.concat(a0)})M,m,P=n.buf_id,n.line-1,n.column-1;a0={}end;table.insert(a0,n.label)a1=n.column end;table.insert(r,{buf_id=M,col=P,line=m,text=table.concat(a0)})return r end;b.spot_find_in_line=function(k,L,e,K)local a3=e.allowed_lines;local a4=K[1]if not a3.cursor_before and k<a4 or not a3.cursor_at and k==a4 or not a3.cursor_after and k>a4 then return{}end;local a5=vim.fn.foldclosed(k)if a5~=-1 then return a3.fold and a5==k and{1}or{}end;if vim.fn.prevnonblank(k)~=k then return a3.blank and{1}or{}end;return e.spotter(k,L)end;b.advance_jump=function(e)local Q=vim.split(e.labels,'')local g=b.cache.spots;if type(g)~='table'or#g<1 then b.spots_unshow(g)b.cache.spots=nil;return end;local a6=b.getcharstr('Enter encoding symbol to advance jump')if vim.tbl_contains(Q,a6)then b.spots_unshow(g)g=vim.tbl_filter(function(a7)return a7.label==a6 end,g)if#g>1 then g=b.spots_add_label(g,e)b.spots_show(g,e)b.cache.spots=g;if b.is_operator_pending()then b.advance_jump(e)else vim.defer_fn(function()b.advance_jump(e)end,0)return end end end;if#g==1 or a6==b.keys.cr then vim.cmd('normal! m`')local a8=g[1]vim.api.nvim_set_current_win(a8.win_id)vim.api.nvim_win_set_cursor(a8.win_id,{a8.line,a8.column-1})vim.cmd('normal! zv')if e.hooks.after_jump~=nil then e.hooks.after_jump()end end;a.stop()end;b.echo=function(a9,aa)a9=type(a9)=='string'and{{a9}}or a9;table.insert(a9,1,{'(mini.jump2d) ','WarningMsg'})local ab=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local ac,ad={},0;for J,ae in ipairs(a9)do local af={vim.fn.strcharpart(ae[1],0,ab-ad),ae[2]}table.insert(ac,af)ad=ad+vim.fn.strdisplaywidth(af[1])if ad>=ab then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(ac,aa,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(a9)b.echo(a9,true)end;b.is_operator_pending=function()return vim.tbl_contains({'no','noV',b.keys.block_operator_pending},vim.fn.mode(1))end;b.getcharstr=function(a9)local ag=true;if a9~=nil then vim.defer_fn(function()if not ag then return end;b.echo(a9)b.cache.msg_shown=true end,1000)end;b.cache.is_in_getchar=true;local ah,ai=pcall(vim.fn.getchar)b.cache.is_in_getchar=false;ag=false;b.unecho()if not ah then return end;if type(ai)=='number'then ai=vim.fn.nr2char(ai)end;return ai end;b.input=function(aj,ak)local al=vim.on_key or vim.register_keystroke_callback;local am=false;al(function(a6)if a6==b.keys.esc then am=true end end,b.ns_id.input)local e={prompt='(mini.jump2d) '..aj..': ',default=ak or''}local ah,r=pcall(vim.fn.input,e)al(nil,b.ns_id.input)if not ah or am then return end;return r end;b.tabpage_list_wins=function(an)local ao=vim.api.nvim_tabpage_list_wins(an)local ap={}for J,I in ipairs(ao)do local aq=vim.api.nvim_win_get_position(I)local c=vim.api.nvim_win_get_config(I)ap[I]={row=aq[1],col=aq[2],zindex=c.zindex or 0}end;table.sort(ao,function(ar,as)if ap[ar].zindex<ap[as].zindex then return true end;if ap[ar].zindex>ap[as].zindex then return false end;if ap[ar].col<ap[as].col then return true end;if ap[ar].col>ap[as].col then return false end;return ap[ar].row<ap[as].row end)return ao end;b.map=function(at,a6,au,e)if a6==''then return end;e=vim.tbl_deep_extend('force',{noremap=true,silent=true},e or{})if vim.fn.has('nvim-0.7')==0 then e.desc=nil end;vim.api.nvim_set_keymap(at,a6,au,e)end;b.merge_unique=function(av,aw)if not(type(av)=='table'and type(aw)=='table')then return end;local ax,ay=#av,#aw;local r,N,az={},1,1;local aA;while N<=ax and az<=ay do if av[N]<aw[az]then aA=av[N]N=N+1 else aA=aw[az]az=az+1 end;if r[#r]~=aA then table.insert(r,aA)end end;while N<=ax do aA=av[N]if r[#r]~=aA then table.insert(r,aA)end;N=N+1 end;while az<=ay do aA=aw[az]if r[#r]~=aA then table.insert(r,aA)end;az=az+1 end;return r end;return a
