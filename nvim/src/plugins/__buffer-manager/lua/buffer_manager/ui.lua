local a=require("buffer_manager")local b=require("plenary.popup")local c=require("buffer_manager.utils")local d=require("buffer_manager.dev").log;local e=require("buffer_manager").marks;local f={}Buffer_manager_win_id=nil;Buffer_manager_bufh=nil;local g={}local function h(i)i=i or false;vim.api.nvim_win_close(Buffer_manager_win_id,true)Buffer_manager_win_id=nil;Buffer_manager_bufh=nil end;local function j()d.trace("_create_window()")local k=a.get_config()local l=60;local m=10;if k then if k.width~=nil then if k.width<=1 then local n=vim.api.nvim_list_uis()[1].width;l=math.floor(n*k.width)else l=k.width end end;if k.height~=nil then if k.height<=1 then local o=vim.api.nvim_list_uis()[1].height;m=math.floor(o*k.height)else m=k.height end end end;local p=k.borderchars or{"─","│","─","│","╭","╮","╯","╰"}local q=vim.api.nvim_create_buf(false,false)local Buffer_manager_win_id,r=b.create(q,{title="Buffers",highlight="Normal",line=math.floor((vim.o.lines-m)/2-1),col=math.floor((vim.o.columns-l)/2),minwidth=l,minheight=m,borderchars=p})vim.api.nvim_win_set_option(r.border.win_id,"winhl","Normal:Normal")return{bufnr=q,win_id=Buffer_manager_win_id}end;local function s(string,t)return string.sub(string,1,string.len(t))==t end;local function u(v,q)return vim.api.nvim_buf_is_valid(q)and not s(v,"term://")and not vim.bo[q].modified and q~=-1 end;local function w(q)for x,y in pairs(e)do if y.buf_id==q then return true end end;return false end;local function z()for x,y in pairs(g)do if not w(y.buf_id)then if u(y.filename,y.buf_id)then vim.api.nvim_buf_clear_namespace(y.buf_id,-1,1,-1)vim.api.nvim_buf_delete(y.buf_id,{})end end end;for A,y in pairs(e)do local q=vim.fn.bufnr(y.filename)if q==-1 then vim.cmd("badd "..y.filename)e[A].buf_id=vim.fn.bufnr(y.filename)end end end;local function B()vim.api.nvim_buf_set_keymap(Buffer_manager_bufh,"n","q","<Cmd>lua require('buffer_manager.ui').toggle_quick_menu()<CR>",{silent=true})vim.api.nvim_buf_set_keymap(Buffer_manager_bufh,"n","<ESC>","<Cmd>lua require('buffer_manager.ui').toggle_quick_menu()<CR>",{silent=true})local k=a.get_config()for x,C in pairs(k.select_menu_item_commands)do vim.api.nvim_buf_set_keymap(Buffer_manager_bufh,"n",C.key,"<Cmd>lua require('buffer_manager.ui').select_menu_item('"..C.command.."')<CR>",{})end;vim.cmd(string.format("autocmd BufModifiedSet <buffer=%s> set nomodified",Buffer_manager_bufh))vim.cmd("autocmd BufLeave <buffer> ++nested ++once silent".." lua require('buffer_manager.ui').toggle_quick_menu()")vim.cmd(string.format("autocmd BufWriteCmd <buffer=%s>".." lua require('buffer_manager.ui').on_menu_save()",Buffer_manager_bufh))local D=k.line_keys;for E=1,#D do local F=D:sub(E,E)vim.api.nvim_buf_set_keymap(Buffer_manager_bufh,"n",F,string.format("<Cmd>%s <bar> lua require('buffer_manager.ui')"..".select_menu_item()<CR>",E),{})end end;local function G(H,I)vim.api.nvim_win_set_option(Buffer_manager_win_id,"number",true)vim.api.nvim_buf_set_name(Buffer_manager_bufh,"buffer_manager-menu")vim.api.nvim_buf_set_lines(Buffer_manager_bufh,0,#H,false,H)vim.api.nvim_buf_set_option(Buffer_manager_bufh,"filetype","buffer_manager")vim.api.nvim_buf_set_option(Buffer_manager_bufh,"buftype","acwrite")vim.api.nvim_buf_set_option(Buffer_manager_bufh,"bufhidden","delete")vim.cmd(string.format(":call cursor(%d, %d)",I,1))end;local function J()local K=vim.api.nvim_list_bufs()for A=1,#K do local L=K[A]local M=vim.api.nvim_buf_get_name(L)local N=M;if 1==vim.fn.buflisted(L)and M~=""and not w(L)then table.insert(e,{filename=N,buf_id=L})end end end;function f.toggle_quick_menu()d.trace("toggle_quick_menu()")if Buffer_manager_win_id~=nil and vim.api.nvim_win_is_valid(Buffer_manager_win_id)then if vim.api.nvim_buf_get_changedtick(vim.fn.bufnr())>0 then f.on_menu_save()end;h(true)z()return end;local k=a.get_config()local O=-1;if k.focus_alternate_buffer then O=vim.fn.bufnr("#")end;if O==-1 then O=vim.fn.bufnr()end;local P=j()local H={}g={}Buffer_manager_win_id=P.win_id;Buffer_manager_bufh=P.bufnr;J()local I=1;local Q=1;for A,y in pairs(e)do if vim.fn.buflisted(y.buf_id)~=1 then e[A]=nil else local R=e[A]g[A]={filename=R.filename,buf_id=R.buf_id}if R.buf_id==O then I=Q end;local S=R.filename;if not s(S,"term://")then S=c.normalize_path(S)end;H[Q]=string.format("%s",S)Q=Q+1 end end;G(H,I)B()end;function f.select_menu_item(T)local A=vim.fn.line(".")if vim.api.nvim_buf_get_changedtick(vim.fn.bufnr())>0 then f.on_menu_save()end;h(true)f.nav_file(A,T)z()end;local function U()d.trace("_get_menu_items()")local V=vim.api.nvim_buf_get_lines(Buffer_manager_bufh,0,-1,true)local W={}for x,Q in pairs(V)do if not c.is_white_space(Q)then table.insert(W,Q)end end;return W end;local function X(Y)d.trace("set_mark_list(): New list:",Y)e={}for x,Z in pairs(Y)do if type(Z)=="string"then table.insert(e,{filename=Z,buf_id=vim.fn.bufnr(Z)})end end end;function f.on_menu_save()d.trace("on_menu_save()")X(U())end;function f.nav_file(_,T)if next(e)==nil then J()end;d.trace("nav_file(): Navigating to",_)if T==nil then T="edit"end;local y=e[_]if not y then return else vim.cmd(T.." "..y.filename)end end;local function a0()if next(e)==nil then J()end;local O=vim.fn.bufnr()for A,y in pairs(e)do if y.buf_id==O then return A end end;d.error("get_current_buf_line(): Could not find current buffer in marks")return-1 end;function f.nav_next()d.trace("nav_next()")local I=a0()if I==-1 then return end;local a1=I+1;if a1>#e then a1=1 end;f.nav_file(a1)end;function f.nav_prev()d.trace("nav_prev()")local I=a0()if I==-1 then return end;local a2=I-1;if a2<1 then a2=#e end;f.nav_file(a2)end;function f.location_window(a3)local a4={relative="editor",style="minimal",width=30,height=15,row=2,col=2}a3=vim.tbl_extend("keep",a3,a4)local q=a3.bufnr or vim.api.nvim_create_buf(false,true)local a5=vim.api.nvim_open_win(q,true,a3)return{bufnr=q,win_id=a5}end;return f
