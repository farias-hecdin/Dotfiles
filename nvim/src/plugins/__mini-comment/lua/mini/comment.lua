local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.6')==0 then vim.notify('(mini.comment) Official support for Neovim<0.6 will soon be dropped. Update to a newer version of Neovim.')end;_G.MiniComment=a;c=b.setup_config(c)b.apply_config(c)end;a.config={mappings={comment='gc',comment_line='gcc',textobject='gc'},hooks={pre=function()end,post=function()end}}a.operator=function(d)if b.is_disabled()then return''end;if d==nil then vim.cmd('set operatorfunc=v:lua.MiniComment.operator')return'g@'end;local e,f='[',']'if d=='visual'then e,f='<','>'end;local g,h=unpack(vim.api.nvim_buf_get_mark(0,e))local i,j=unpack(vim.api.nvim_buf_get_mark(0,f))if g>i or g==i and h>j then return end;vim.cmd(string.format('lockmarks lua MiniComment.toggle_lines(%d, %d)',g,i))return''end;a.toggle_lines=function(k,l)if b.is_disabled()then return end;local m=vim.api.nvim_buf_line_count(0)if not(1<=k and k<=m and 1<=l and l<=m)then error(('(mini.comment) `line_start` and `line_end` should be within range [1; %s].'):format(m))end;if not(k<=l)then error('(mini.comment) `line_start` should be less than or equal to `line_end`.')end;local c=b.get_config()if c.hooks.pre()==false then return end;local n=b.make_comment_parts()local o=vim.api.nvim_buf_get_lines(0,k-1,l,false)local p,q=b.get_lines_info(o,n)local r;if q then r=b.make_uncomment_function(n)else r=b.make_comment_function(n,p)end;for s,t in pairs(o)do o[s]=r(t)end;vim.api.nvim_buf_set_lines(0,k-1,l,false,o)if c.hooks.post()==false then return end end;a.textobject=function()if b.is_disabled()then return end;local c=b.get_config()if c.hooks.pre()==false then return end;local n=b.make_comment_parts()local u=b.make_comment_check(n)local v=vim.api.nvim_win_get_cursor(0)[1]if u(vim.fn.getline(v))then local k=v;while k>=2 and u(vim.fn.getline(k-1))do k=k-1 end;local l=v;local m=vim.api.nvim_buf_line_count(0)while l<=m-1 and u(vim.fn.getline(l+1))do l=l+1 end;vim.cmd(string.format('normal! %dGV%dG',k,l))end;if c.hooks.post()==false then return end end;b.default_config=a.config;b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({mappings={c.mappings,'table'},hooks={c.hooks,'table'}})vim.validate({['mappings.comment']={c.mappings.comment,'string'},['mappings.comment_line']={c.mappings.comment_line,'string'},['mappings.textobject']={c.mappings.textobject,'string'},['hooks.pre']={c.hooks.pre,'function'},['hooks.post']={c.hooks.post,'function'}})return c end;b.apply_config=function(c)a.config=c;b.map('n',c.mappings.comment,'v:lua.MiniComment.operator()',{expr=true,desc='Comment'})b.map('x',c.mappings.comment,[[:<c-u>lua MiniComment.operator('visual')<cr>]],{desc='Comment selection'})b.map('n',c.mappings.comment_line,'v:lua.MiniComment.operator() . "_"',{expr=true,desc='Comment line'})b.map('o',c.mappings.textobject,'<cmd>lua MiniComment.textobject()<cr>',{desc='Comment textobject'})end;b.is_disabled=function()return vim.g.minicomment_disable==true or vim.b.minicomment_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minicomment_config or{},c or{})end;b.make_comment_parts=function()local w=vim.api.nvim_buf_get_option(0,'commentstring')if w==''then vim.api.nvim_echo({{'(mini.comment) ','WarningMsg'},{[[Option 'commentstring' is empty.]]}},true,{})return{left='',right=''}end;local x,y=w:match('^%s*(.-)%s*%%s%s*(.-)%s*$')return{left=x,right=y}end;b.make_comment_check=function(n)local t,z=n.left,n.right;local A=string.format('^%%s-%s.*%s%%s-$',vim.pesc(t),vim.pesc(z))return function(B)return B:find(A)~=nil end end;b.get_lines_info=function(o,n)local C,D=math.huge,math.huge;local p,E;local q=true;local u=b.make_comment_check(n)for F,t in pairs(o)do if C>0 then F,D,E=t:find('^(%s*)')if D<C and D<t:len()then C=D;p=E end end;if q then q=u(t)end end;return p or'',q end;b.make_comment_function=function(n,p)local G=p:len()+1;local t,z=n.left,n.right;local H=t==''and''or' 'local I=z==''and''or' 'local J=p..t..z;local K=p..t:gsub('%%','%%%%')..H..'%s'..I..z:gsub('%%','%%%%')return function(B)if B:find('^%s*$')~=nil then return J else return string.format(K,B:sub(G))end end end;b.make_uncomment_function=function(n)local t,z=n.left,n.right;local H=t==''and''or'[ ]?'local I=z==''and''or'[ ]?'local L=string.format('^(%%s*)%s%s(.-)%s%s%%s-$',vim.pesc(t),H,I,vim.pesc(z))return function(B)local p,M=string.match(B,L)if M==nil then return B end;if M==''then p=''end;return('%s%s'):format(p,M)end end;b.map=function(d,N,O,P)if N==''then return end;P=vim.tbl_deep_extend('force',{noremap=true,silent=true},P or{})if vim.fn.has('nvim-0.7')==0 then P.desc=nil end;vim.api.nvim_set_keymap(d,N,O,P)end;return a
