local a=require('gitsigns.async').wrap;local b=require('gitsigns.async').scheduler;local c=require("gitsigns.debug")local d=require('gitsigns.util')local e=require('gitsigns.subprocess')local f=require("gitsigns.hunks")local g=f.Hunk;local h=vim.loop;local i=vim.startswith;local j=require("gitsigns.debug").dprint;local k=require("gitsigns.debug").eprint;local l=require('gitsigns.message').error;local m={BlameInfo={},Version={},RepoInfo={},Repo={},FileProps={},Obj={}}local n=function(o)for p,q in ipairs(vim.split(o,d.path_sep))do if q=='.git'then return true end end;return false end;local r=m.Obj;local s=m.Repo;local function t(u)assert(u:match('%d+%.%d+%.%w+'),'Invalid git version: '..u)local v={}local w=vim.split(u,'%.')v.major=tonumber(w[1])v.minor=tonumber(w[2])if w[3]=='GIT'then v.patch=0 else v.patch=tonumber(w[3])end;return v end;local function x(u)if not m.version then return false end;if m.version.major<u[1]then return false end;if u[2]and m.version.minor<u[2]then return false end;if u[3]and m.version.patch<u[3]then return false end;return true end;m.command=a(function(y,z,A)z=z or{}z.command=z.command or'git'z.args=z.command=='git'and{'--no-pager','--literal-pathspecs',unpack(y)}or y;e.run_job(z,function(p,p,B,C)if not z.suppress_stderr then if C then c.eprint(C)end end;local D=vim.split(B or'','\n',true)if D[#D]==''then D[#D]=nil end;if c.verbose then c.vprintf('%d lines:',#D)for E=1,math.min(10,#D)do c.vprintf('\t%s',D[E])end end;A(D,C)end)end,3)m.diff=function(F,G,H,I)return m.command({'-c','core.safecrlf=false','diff','--color=never','--'..(H and''or'no-')..'indent-heuristic','--diff-algorithm='..I,'--patch-with-raw','--unified=0',F,G})end;local function J(K,L,M,N)if not K then return L end;if L=='HEAD'then local O=m.command({'rev-parse','--short','HEAD'},{command=N or'git',suppress_stderr=true,cwd=M})[1]or''if c.debug_mode and O~=''then O='HEAD'end;if d.path_exists(K..'/rebase-merge')or d.path_exists(K..'/rebase-apply')then return O..'(rebasing)'end;return O end;return L end;local P=jit and jit.os=='Windows'and vim.fn.executable('cygpath')==1;local Q;if P then Q=function(M)return m.command({'-aw',M},{command='cygpath'})[1]end end;local function R(M)if M and P and not h.fs_stat(M)then M=Q(M)end;return M end;m.get_repo_info=function(M,N,K,S)local T=x({2,13})local U=T and'--absolute-git-dir'or'--git-dir'b()local y={}if K then vim.list_extend(y,{'--git-dir',K})end;if S then vim.list_extend(y,{'--work-tree',S})end;vim.list_extend(y,{'rev-parse','--show-toplevel',U,'--abbrev-ref','HEAD'})local V=m.command(y,{command=N or'git',suppress_stderr=true,cwd=M})local v={toplevel=R(V[1]),gitdir=R(V[2])}v.abbrev_head=J(v.gitdir,V[3],M,N)if v.gitdir and not T then v.gitdir=h.fs_realpath(v.gitdir)end;v.detached=v.toplevel and v.gitdir~=v.toplevel..'/.git'return v end;m.set_version=function(u)if u~='auto'then m.version=t(u)return end;local V,C=m.command({'--version'})local W=V[1]if not W then l("Unable to detect git version as 'git --version' failed to return anything")k(C)return end;assert(type(W)=='string','Unexpected output: '..W)assert(i(W,'git version'),'Unexpected output: '..W)local w=vim.split(W,'%s+')m.version=t(w[3])end;s.command=function(self,y,z)z=z or{}z.cwd=self.toplevel;local X={'--git-dir',self.gitdir}if self.detached then vim.list_extend(X,{'--work-tree',self.toplevel})end;vim.list_extend(X,y)return m.command(X,z)end;s.files_changed=function(self)local V=self:command({'status','--porcelain','--ignore-submodules'})local v={}for p,W in ipairs(V)do if W:sub(1,2):match('^.M')then v[#v+1]=W:sub(4,-1)end end;return v end;s.get_show_text=function(self,Y,Z)local B,C=self:command({'show',Y},{suppress_stderr=true})if Z~='utf-8'then b()for E,_ in ipairs(B)do if vim.fn.type(_)==vim.v.t_string then B[E]=vim.fn.iconv(_,Z,'utf-8')end end end;return B,C end;s.update_abbrev_head=function(self)self.abbrev_head=m.get_repo_info(self.toplevel).abbrev_head end;s.new=function(a0,K,S)local self=setmetatable({},{__index=s})self.username=m.command({'config','user.name'})[1]local a1=m.get_repo_info(a0,nil,K,S)for a2,a3 in pairs(a1)do self[a2]=a3 end;if m.enable_yadm and not self.gitdir then if vim.startswith(a0,os.getenv('HOME'))and#m.command({'ls-files',a0},{command='yadm'})~=0 then m.get_repo_info(a0,'yadm',K,S)local a4=m.get_repo_info(a0,'yadm',K,S)for a2,a3 in pairs(a4)do self[a2]=a3 end end end;return self end;r.command=function(self,y,z)return self.repo:command(y,z)end;r.update_file_info=function(self,a5,a6)local a7=self.object_name;local a8=self:file_info(self.file,a6)if a5 then self.relpath=a8.relpath end;self.object_name=a8.object_name;self.mode_bits=a8.mode_bits;self.has_conflicts=a8.has_conflicts;self.i_crlf=a8.i_crlf;self.w_crlf=a8.w_crlf;return a7~=self.object_name end;r.file_info=function(self,o,a6)local V,C=self:command({'-c','core.quotepath=off','ls-files','--stage','--others','--exclude-standard','--eol',o or self.file},{suppress_stderr=true})if C and not a6 then if not C:match('^warning: could not open directory .*: No such file or directory')then c.eprint(C)end end;local a9={}for p,W in ipairs(V)do local w=vim.split(W,'\t')if#w>2 then local aa=vim.split(w[2],'%s+')a9.i_crlf=aa[1]=='i/crlf'a9.w_crlf=aa[2]=='w/crlf'a9.relpath=w[3]local ab=vim.split(w[1],'%s+')local ac=tonumber(ab[3])if ac<=1 then a9.mode_bits=ab[1]a9.object_name=ab[2]else a9.has_conflicts=true end else a9.relpath=w[2]end end;return a9 end;r.get_show_text=function(self,ad)if not self.relpath then return{}end;local B,C=self.repo:get_show_text(ad..':'..self.relpath,self.encoding)if not self.i_crlf and self.w_crlf then for E=1,#B do B[E]=B[E]..'\r'end end;return B,C end;r.unstage_file=function(self)self:command({'reset',self.file})end;r.run_blame=function(self,ae,af,ag)if not self.object_name or self.repo.abbrev_head==''then return{author='Not Committed Yet',['author_mail']='<not.committed.yet>',committer='Not Committed Yet',['committer_mail']='<not.committed.yet>'}end;local y={'blame','--contents','-','-L',af..',+1','--line-porcelain',self.file}if ag then y[#y+1]='-w'end;local ah=self.repo.toplevel..'/.git-blame-ignore-revs'if h.fs_stat(ah)then vim.list_extend(y,{'--ignore-revs-file',ah})end;local V=self:command(y,{writer=ae})if#V==0 then return end;local ai=vim.split(table.remove(V,1),' ')local v={}v.sha=ai[1]v.orig_lnum=tonumber(ai[2])v.final_lnum=tonumber(ai[3])v.abbrev_sha=string.sub(v.sha,1,8)for p,_ in ipairs(V)do if not i(_,'\t')then local aj=vim.split(_,' ')local ak=table.remove(aj,1):gsub('-','_')v[ak]=table.concat(aj,' ')if ak=='previous'then v.previous_sha=aj[1]v.previous_filename=aj[2]end end end;return v end;r.ensure_file_in_index=function(self)if not self.object_name or self.has_conflicts then if not self.object_name then self:command({'add','--intent-to-add',self.file})else local a1=string.format('%s,%s,%s',self.mode_bits,self.object_name,self.relpath)self:command({'update-index','--add','--cacheinfo',a1})end;self:update_file_info()end end;r.stage_lines=function(self,ae)local B=self:command({'hash-object','-w','--path',self.relpath,'--stdin'},{writer=ae})local al=B[1]self:command({'update-index','--cacheinfo',string.format('%s,%s,%s',self.mode_bits,al,self.relpath)})end;r.stage_hunks=function(self,am,an)self:ensure_file_in_index()self:command({'apply','--whitespace=nowarn','--cached','--unidiff-zero','-'},{writer=f.create_patch(self.relpath,am,self.mode_bits,an)})end;r.has_moved=function(self)local ao=self:command({'diff','--name-status','-C','--cached'})local ap=self.orig_relpath or self.relpath;for p,_ in ipairs(ao)do local w=vim.split(_,'%s+')if#w==3 then local aq,ar=w[2],w[3]if ap==aq then self.orig_relpath=ap;self.relpath=ar;self.file=self.repo.toplevel..'/'..ar;return ar end end end end;r.new=function(o,Z,K,S)if n(o)then j('In git dir')return nil end;local self=setmetatable({},{__index=r})self.file=o;self.encoding=Z;self.repo=s.new(d.dirname(o),K,S)if not self.repo.gitdir then j('Not in git repo')return nil end;local a6=K~=nil and S~=nil;self:update_file_info(true,a6)return self end;return m
