local a=require('gitsigns.async').void;local b=require('gitsigns.async').wrap;local c=require('gitsigns.async').scheduler;local d=require('gitsigns.cache')local e=d.CacheEntry;local f=d.cache;local g=require('gitsigns.signs')local h=require("gitsigns.status")local i=require('gitsigns.debounce').debounce_trailing;local j=require('gitsigns.debounce').throttle_by_id;local k=require("gitsigns.debug")local l=k.dprint;local m=k.dprintf;local n=k.eprint;local o=require('gitsigns.subprocess')local p=require('gitsigns.util')local q=require('gitsigns.diff')local r=require('gitsigns.git')local s=require('gitsigns.uv')local t=require("gitsigns.hunks")local u=t.Hunk;local v=require('gitsigns.config').config;local w=vim.api;local x;local y={}local z=function(A,B)vim.schedule(function()if vim.api.nvim_buf_is_valid(A)then B()end end)end;local C=b(z,2)local function D(E,F,G,H,I,J)if I then x:remove(E)end;F=F or{}if I and F[1]then x:add(E,t.calc_signs(F[1],F[1].added.start,F[1].added.start,J))end;for K,L in ipairs(F)do if G<=L.vend and H>=L.added.start then x:add(E,t.calc_signs(L,G,H,J))end;if L.added.start>H then break end end end;y.on_lines=function(A,M,N,O)local P=f[A]if not P then l('Cache for buffer was nil. Detaching')return true end;x:on_lines(A,M,N,O)if x:contains(A,M,O)then P.force_next_update=true end;y.update_debounced(A,f[A])end;local Q=w.nvim_create_namespace('gitsigns')local function R(E,S)if vim.fn.foldclosed(S+1)~=-1 then return end;if not f[E]or not f[E].hunks then return end;local T=w.nvim_buf_get_lines(E,S,S+1,false)[1]if not T then return end;local U=S+1;local L=t.find_hunk(U,f[E].hunks)if not L then return end;if L.added.count~=L.removed.count then return end;local V=U-L.added.start+1;local W=L.added.lines[V]local X=L.removed.lines[V]local K,Y=require('gitsigns.diff_int').run_word_diff({X},{W})local Z=#T;for K,_ in ipairs(Y)do local a0,a1,a2=_[2],_[3]-1,_[4]-1;if a2==a1 then a2=a1+1 end;local a3=a0=='add'and'GitSignsAddLnInline'or a0=='change'and'GitSignsChangeLnInline'or'GitSignsDeleteLnInline'local a4={ephemeral=true,priority=1000}if a2>Z and a2==a1+1 then a4.virt_text={{' ',a3}}a4.virt_text_pos='overlay'else a4.end_col=a2;a4.hl_group=a3 end;w.nvim_buf_set_extmark(E,Q,S,a1,a4)w.nvim__buf_redraw_range(E,S,S+1)end end;local a5=w.nvim_create_namespace('gitsigns_removed')local a6=300;local function a7(E)local a8=w.nvim_buf_get_extmarks(E,a5,0,-1,{})for K,a9 in ipairs(a8)do w.nvim_buf_del_extmark(E,a5,a9[1])end end;function y.show_deleted(E,aa,L)local ab={}for ac,T in ipairs(L.removed.lines)do local ad={}local ae=1;if v.word_diff then local af=require('gitsigns.diff_int').run_word_diff({L.removed.lines[ac]},{L.added.lines[ac]})for K,_ in ipairs(af)do local ag,a1,a2=_[1],_[3],_[4]if ag>1 then break end;ad[#ad+1]={T:sub(ae,a1-1),'GitSignsDeleteVirtLn'}ad[#ad+1]={T:sub(a1,a2-1),'GitSignsDeleteVirtLnInline'}ae=a2 end end;if#T>0 then ad[#ad+1]={T:sub(ae,-1),'GitSignsDeleteVirtLn'}end;local ah=string.rep(' ',a6-#T)ad[#ad+1]={ah,'GitSignsDeleteVirtLn'}ab[ac]=ad end;local ai=L.added.start==0 and L.type=='delete'local S=ai and 0 or L.added.start-1;w.nvim_buf_set_extmark(E,aa,S,-1,{virt_lines=ab,virt_lines_above=L.type~='delete'or ai})end;function y.show_added(E,aj,L)local ak=L.added.start-1;for al=0,L.added.count-1 do local S=ak+al;w.nvim_buf_set_extmark(E,aj,S,0,{end_row=S+1,hl_group='GitSignsAddPreview',hl_eol=true,priority=1000})end;local K,Y=require('gitsigns.diff_int').run_word_diff(L.removed.lines,L.added.lines)for K,_ in ipairs(Y)do local al,a0,a1,a2=_[1]-1,_[2],_[3]-1,_[4]-1;w.nvim_buf_set_extmark(E,aj,ak+al,a1,{end_col=a2,hl_group=a0=='add'and'GitSignsAddInline'or a0=='change'and'GitSignsChangeInline'or'GitSignsDeleteInline',priority=1001})end end;local function am(E)local P=f[E]a7(E)if v.show_deleted then for K,L in ipairs(P.hunks)do y.show_deleted(E,a5,L)end end end;local an=0;y.update=j(function(E,P)local ao='update'P=P or f[E]if not P then n('Cache for buffer '..E..' was nil')return end;C(E)local ap=p.buf_lines(E)local aq=P.git_obj;if not P.compare_text or v._refresh_staged_on_update then P.compare_text=aq:get_show_text(P:get_compare_rev())end;local ar=P.hunks;P.hunks=q(P.compare_text,ap)C(E)if P.force_next_update or t.compare_heads(P.hunks,ar)then D(E,P.hunks,vim.fn.line('w0'),vim.fn.line('w$'),true,aq.object_name==nil)am(E)P.force_next_update=false;w.nvim_exec_autocmds('User',{pattern='GitSignsUpdate',modeline=false})end;local as=t.get_summary(P.hunks)as.head=aq.repo.abbrev_head;h:update(E,as)an=an+1;m('updates: %s, jobs: %s',an,o.job_cnt)end,true)y.detach=function(E,at)if not at then x:remove(E)end end;local function au(E,P,av)local aq=P.git_obj;local aw=false;local ax=aq:has_moved()if ax then m('File moved to %s',ax)aq.relpath=ax;if not aq.orig_relpath then aq.orig_relpath=av end;aw=true elseif aq.orig_relpath then local ay=aq.repo.toplevel..p.path_sep..aq.orig_relpath;if aq:file_info(ay).relpath then m('Moved file reset')aq.relpath=aq.orig_relpath;aq.orig_relpath=nil;aw=true end else end;if aw then aq.file=aq.repo.toplevel..p.path_sep..aq.relpath;P.file=aq.file;aq:update_file_info()c()local az=vim.fn.bufexists(P.file)==1;local aA=w.nvim_buf_get_name(E)if not az then p.buf_rename(E,P.file)end;local aB=az and'Cannot rename'or'Renamed'm('%s buffer %d from %s to %s',aB,E,aA,P.file)end end;y.watch_gitdir=function(E,aC)if not v.watch_gitdir.enable then return end;m('Watching git dir')local aD=s.new_fs_poll(true)aD:start(aC,v.watch_gitdir.interval,a(function(aE)local ao='watcher_cb'if aE then m('Git dir update error: %s',aE)return end;l('Git dir update')local P=f[E]if not P then l('Has detached, aborting')return end;local aq=P.git_obj;aq.repo:update_abbrev_head()c()h:update(E,{head=aq.repo.abbrev_head})local aF=aq.object_name~=nil;local av=aq.relpath;if not aq:update_file_info()then l('File not changed')return end;if v.watch_gitdir.follow_files and aF and not aq.object_name then au(E,P,av)end;P.compare_text=nil;y.update(E,P)end))return aD end;local aG;y.update_cwd_head=a(function()if aG then aG:stop()else aG=s.new_fs_poll(true)end;local aH=vim.loop.cwd()local aC,aI;for K,P in pairs(f)do local aJ=P.git_obj.repo;if aJ.toplevel==aH then aI=aJ.abbrev_head;aC=aJ.gitdir;break end end;if not aI or not aC then local aK=r.get_repo_info(aH)aC=aK.gitdir;aI=aK.abbrev_head end;c()vim.g.gitsigns_head=aI;if not aC then return end;local aL=aC..'/HEAD'if aG:getpath()==aL then return end;aG:start(aL,v.watch_gitdir.interval,a(function(aE)local ao='cwd_watcher_cb'if aE then m('Git dir update error: %s',aE)return end;l('Git cwd dir update')local aM=r.get_repo_info(aH).abbrev_head;c()vim.g.gitsigns_head=aM end))end)y.reset_signs=function()x:reset()end;y.setup=function()w.nvim_set_decoration_provider(Q,{on_win=function(K,K,E,aN,aO)local P=f[E]if not P or not P.hunks then return false end;local aP=math.min(aO,w.nvim_buf_line_count(E))local J=P.git_obj.object_name==nil;D(E,P.hunks,aN+1,aP+1,false,J)if not(v.word_diff and v.diff_opts.internal)then return false end end,on_line=function(K,aQ,E,S)R(E,S)end})x=g.new(v.signs)y.update_debounced=i(v.update_debounce,a(y.update))end;return y
