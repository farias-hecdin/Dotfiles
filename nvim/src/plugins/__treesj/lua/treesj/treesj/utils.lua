local a=require('treesj.utils')local b='join'local c='split'local d={}function d.get_observed_range(e)local f=a.readable_range({e:range()})local g=e:prev_sibling()if g then local h=a.readable_range({g:range()})f.col.start=h.row.start==f.row.start and h.col.end_ or 0 end;return{f.row.start,f.col.start,f.row.end_,f.col.end_}end;local function i(j,k)local l={}l.__index=l;local m,n,o,p=j:range()function l:range()if k=='first'then return o,p,o,p else return m,n,m,n end end;function l:type()return'imitator'end;return l end;function d.add_first_last_imitator(q,r)local s=a.get_preset(q)if s and a.get_nested_key_value(s,'non_bracket_node')then local t,u=a.get_non_bracket_first_last(q)if t then table.insert(r,1,i(t,'first'))end;if u then table.insert(r,i(u,'last'))end end end;local function v(w,x)if type(w)=='table'then w=vim.list_extend({},w,1,#w)w[1]=x..w[1]else w=x..w end;return w end;local function y(z)local A=a.get_whitespace(z)local x=v(z:text(),A)z:_update_text(x)end;local function B(z,s)if not s then return false end;local C=z:next()local D=C and C:text()==s.force_insert or false;if z:is_framing()or a.is_empty(s.force_insert)or D then return false end;local E=vim.endswith(z:text(),s.force_insert)local F=not a.check_match(s.no_insert_if,z)return F and not E end;local function G(x,s)return vim.endswith(x,s.separator),s.last_separator end;local function H(z,s)if not s then return end;if not z:is_first()and z:next()and z:next():is_last()then local I=z:text()local x=type(I)=='table'and I[#I]or I;local E,F=G(x,s)if E and not F then x=x:sub(1,#x-#s.separator)elseif F and not E then x=x..s.separator end;if type(I)=='table'then I[#I]=x else I=x end;z:_update_text(I)end end;local function J(z)local K=a.calc_indent(z)local L=' 'if not vim.bo.expandtab then K=K/vim.fn.shiftwidth()L='\t'end;local x=v(z:text(),L:rep(K))z:_update_text(x)end;local function M(N,...)local g=N[#N]local x=table.concat({...})if vim.trim(x)==''or not g then return end;local O=type(g)=='table'and g[#g]or N[#N]if vim.endswith(O,' ')then x=vim.trim(x)end;if type(g)=='table'then g[#g]=O..x else N[#N]=O..x end end;function d._join(P)local N={}for z in P:iter_children()do if P:has_preset()then local s=P:preset(b)if B(z,s)then z:_update_text(z:text()..s.force_insert)end;H(z,s)y(z)table.insert(N,z:text())else y(z)table.insert(N,z:text())end end;return table.concat(N)end;local function Q(P,z,N)local s=P:preset(c)H(z,s)if z:is_omit()then y(z)M(N,z:text())else J(z)table.insert(N,z:text())end end;local function R(z,N)local S=type(z:text())=='string'local T=type(z:text())=='table'if z:is_first()then table.insert(N,z:text())elseif S then y(z)M(N,z:text())elseif T and not a.is_empty(N)then y(z)M(N,z:text()[1])table.remove(z:text(),1)if not a.is_empty(z:text())then table.insert(N,z:text())end end end;function d._split(P)local N={}for z in P:iter_children()do if P:has_preset()then Q(P,z,N)elseif P:has_to_format()then R(z,N)else y(z:text())table.insert(N,z:text())end end;return N end;return d
