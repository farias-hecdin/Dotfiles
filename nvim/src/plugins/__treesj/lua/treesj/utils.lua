local a=require('vim.treesitter.query')local b=require('treesj.settings').settings.langs;local c=require('treesj.notify')local d=c.msg;local e,f=pcall(require,'nvim-treesitter.parsers')if not e then c.error(d.ts_not_found)return end;local g={}function g.tobool(h)return h and true or false end;function g.is_empty(h)if type(h)=='table'then return vim.tbl_isempty(h)elseif type(h)=='string'then return h==''else return false end end;function g.every(i,j)if not vim.tbl_islist(i)or g.is_empty(i)then return false end;for _,k in ipairs(i)do if not j(k)then return false end end;return true end;function g.some(i,j)if not vim.tbl_islist(i)or g.is_empty(i)then return false end;for _,k in ipairs(i)do if j(k)then return true end end;return false end;function g.get_node_lang(l)local m={l:range()}local n=f.get_parser()local o=n:language_for_range(m)return o:lang()end;function g.is_lang_support(p)return g.tobool(b[p])end;function g.get_preset(l,q)local p=g.get_node_lang(l)if not g.is_lang_support(p)then return nil end;local r=b[p]local type=l:type()if r[type]then return q and r[type][q]or r[type]else return nil end end;function g.get_self_preset(l)local s=g.get_preset(l)if s and not s.target_nodes then return s end;return nil end;function g.has_preset(l)return g.tobool(g.get_preset(l))end;function g.has_targets(l)local t=g.get_preset(l).target_nodes;return t and not g.is_empty(t)end;function g.get_targets(l)return vim.tbl_keys(g.get_preset(l).target_nodes)end;function g.get_nodes_for_lang(p)return vim.tbl_keys(b[p])end;function g.get_nested_key_value(i,u)if not i or vim.tbl_islist(i)then return nil end;local v;for w,h in pairs(i)do if w==u then return h end;if type(h)=='table'and not vim.tbl_islist(h)then v=g.get_nested_key_value(h,u)end;if v then return v end end;return nil end;function g.skip_empty_nodes(x)local y=vim.trim(a.get_node_text(x,0))return not g.is_empty(y)end;function g.collect_children(l,z)local A={}for B in l:iter_children()do if not z or z(B)then table.insert(A,B)end end;return A end;function g.get_node_text(l)local C=a.get_node_text(l,0,{concat=false})local D={}local E=' 'for _,F in ipairs(C)do F=vim.trim(F)if not g.is_empty(F)then table.insert(D,F)end end;return table.concat(D,E)end;function g.is_empty_node(x,r)local G=2;local function H(B)return vim.tbl_contains(r.omit,B:type())end;local function I(B)return B:named()end;local J=x:child_count()local A=g.collect_children(x,I)local K=J==G;return g.every(A,H)or K end;function g.check_descendants(L,j)j=j or function()end;local function M(l,N)local O=false;for B in l:iter_children()do if N(B)then return true end;if B:child_count()>=1 then O=M(B,N)else O=N(B)end;if O then return true end end;return O end;return M(L,j)end;function g.has_node_to_format(L,P)local function Q(x)local s=g.get_preset(x)local R=g.get_nested_key_value(P,'recursive_ignore')local S=R and vim.tbl_contains(R,x:type())or false;return g.tobool(s and not(s.target_nodes or S))end;return g.check_descendants(L,Q)end;function g.has_disabled_descendants(L,q)local s=g.get_preset(L,q)if not s then return false end;local function T(x)return vim.tbl_contains(s.no_format_with,x:type())end;return g.check_descendants(L,T)end;function g.readable_range(m)return{row={start=m[1],end_=m[3]or m[1]},col={start=m[2],end_=m[4]or m[2]}}end;local function U(V,W)return V and V:range()[3]==W:range()[1]or false end;local function X(V,Y)return Y:range()[2]-V:range()[4]end;function g.get_whitespace(Z)local s=Z:parent():preset('join')local a0=s and s.space_separator or 1;if Z:is_first()then a0=0 elseif(not s or Z:is_omit())and U(Z:prev(),Z)then a0=X(Z:prev(),Z)elseif s and(Z:prev():is_first()or Z:is_last())then a0=s.space_in_brackets and 1 or 0 end;return(' '):rep(a0)end;local function a1(Z)local a2=Z:parent()if a2 and a2:has_preset()then local a3=a2:child(1)for B in a2:iter_children()do a3=not B:is_omit()and B or a3 end;return Z==a3 end;return false end;function g.calc_indent(Z)local a2=Z:parent()if Z:is_first()or Z:is_omit()or not a2 then return 0 end;local a4=a2:preset('split')local a5=a2._root_indent;local a6=vim.fn.shiftwidth()local a7=a5+a6;local a8=a1(Z)and a4.last_indent=='normal'return a8 and a5 or a7 end;function g.get_non_bracket_first_last(x)local a9=x:prev_sibling()or x:parent():prev_sibling()local aa=x:next_sibling()or x:parent():next_sibling()return a9,aa end;function g.range(x)local s=g.get_preset(x)local ab=g.get_nested_key_value(s,'non_bracket_node')local ac,ad,ae,af=x:range()if s and ab then local a9,aa=g.get_non_bracket_first_last(x)if a9 then local ag={a9:range()}ac,ad,_,_=ag[3],ag[4]end;if aa then local ag={aa:range()}_,_,ae,af=_,_,ag[1],ag[2]end end;return ac,ad,ae,af end;local function ah(k)return type(k)=='function'end;function g.check_match(i,ai)local aj=vim.tbl_contains(i,ai:type())local ak=vim.tbl_filter(ah,i)if not aj and#ak>0 then return g.some(ak,function(j)return j(ai)end)else return aj end end;return g
