local a=require"fzf-lua.utils"local b=require"fzf-lua.path"local c={}local d="default"c.expect=function(e)if not e then return nil end;local f={}for g,h in pairs(e)do if g~=d and h~=false then table.insert(f,g)end end;if#f>0 then return string.format("--expect=%s",table.concat(f,","))end;return nil end;c.normalize_selected=function(e,i)if not e or not i then return end;local j=d;if a.tbl_length(e)>1 or not e[d]then if#i[1]>0 then j=i[1]end;local k={}for l=2,#i do table.insert(k,i[l])end;return j,k else return j,i end end;c.act=function(e,i,m)if not e or not i then return end;local n,k=c.normalize_selected(e,i)local j=e[n]if type(j)=="table"then for o,p in ipairs(j)do p(k,m)end elseif type(j)=="function"then j(k,m)elseif type(j)=="string"then vim.cmd(j)elseif n~=d then a.warn(("unsupported action: '%s', type:%s"):format(n,type(j)))end end;c.resume=function(o,o)vim.cmd("lua require'fzf-lua'.resume()")end;c.vimcmd=function(q,i,r)for l=1,#i do vim.cmd(("%s %s"):format(q,r and i[l]or vim.fn.fnameescape(i[l])))end end;c.vimcmd_file=function(q,i,m)local s=vim.api.nvim_buf_get_name(0)local t=a.is_term_buffer(0)for l=1,#i do local u=b.entry_to_file(i[l],m,m.force_uri)u.ctag=m._ctag and b.entry_to_ctag(i[l])local v=u.path or u.uri and u.uri:match("^%a+://(.*)")if not b.starts_with_separator(v)then v=b.join({m.cwd or vim.loop.cwd(),v})end;if q=="e"and s~=v and not vim.o.hidden and a.buffer_is_dirty(nil,false,true)then if a.save_dialog(nil)then q=q.."!"else return end end;if not t then vim.cmd("normal! m`")end;if q~="e"or s~=v then if u.path then vim.cmd(q.." "..vim.fn.fnameescape(u.path))elseif q~="e"then vim.cmd(q)end end;if u.uri then vim.lsp.util.jump_to_location(u,"utf-16")elseif u.ctag then vim.api.nvim_win_set_cursor(0,{1,0})vim.fn.search(u.ctag,"W")elseif u.line>1 or u.col>1 then u.col=u.col and u.col>0 and u.col or 1;vim.api.nvim_win_set_cursor(0,{tonumber(u.line),tonumber(u.col)-1})end;if not t and not m.no_action_zz then vim.cmd("norm! zvzz")end end end;c.file_edit=function(i,m)local q="e"c.vimcmd_file(q,i,m)end;c.file_split=function(i,m)local q="new"c.vimcmd_file(q,i,m)end;c.file_vsplit=function(i,m)local q="vnew"c.vimcmd_file(q,i,m)end;c.file_tabedit=function(i,m)local q="tabnew"c.vimcmd_file(q,i,m)end;c.file_open_in_background=function(i,m)local q="badd"c.vimcmd_file(q,i,m)end;local w=function(i,m,x)local y={}for l=1,#i do local z=b.entry_to_file(i[l],m)local A=i[l]:match(":%d+:%d?%d?%d?%d?:?(.*)$")table.insert(y,{filename=z.bufname or z.path,lnum=z.line,col=z.col,text=A})end;if x then vim.fn.setloclist(0,y)vim.cmd"lopen"else vim.fn.setqflist(y)vim.cmd"copen"end end;c.file_sel_to_qf=function(i,m)w(i,m)end;c.file_sel_to_ll=function(i,m)w(i,m,true)end;c.file_edit_or_qf=function(i,m)if#i>1 then return c.file_sel_to_qf(i,m)else return c.file_edit(i,m)end end;c.file_switch=function(i,m)local B=nil;local u=b.entry_to_file(i[1])local v=u.path;if not b.starts_with_separator(v)then v=b.join({m.cwd or vim.loop.cwd(),v})end;for o,C in ipairs(vim.api.nvim_list_bufs())do local D=vim.api.nvim_buf_get_name(C)if D and D==v then B=C;break end end;if not B then return false end;local t=a.is_term_buffer(0)if not t then vim.cmd("normal! m`")end;local E=a.winid_from_tabh(0,B)if E then vim.api.nvim_set_current_win(E)end;if u.line>1 or u.col>1 then vim.api.nvim_win_set_cursor(0,{tonumber(u.line),tonumber(u.col)-1})end;if not t and not m.no_action_zz then vim.cmd("norm! zvzz")end;return true end;c.file_switch_or_edit=function(...)c.file_switch(...)c.file_edit(...)end;c.vimcmd_buf=function(q,i,m)local s=vim.api.nvim_get_current_buf()local F=vim.api.nvim_win_get_cursor(0)[1]local t=a.is_term_buffer(0)for l=1,#i do local u=b.entry_to_file(i[l],m)if not u.bufnr then return end;assert(type(u.bufnr)=="number")if q=="b"and s~=u.bufnr and not vim.o.hidden and a.buffer_is_dirty(nil,false,true)then if a.save_dialog(nil)then q=q.."!"else return end end;if not t then vim.cmd("normal! m`")end;if q~="b"or s~=u.bufnr then local G=q.." "..u.bufnr;local H,I=pcall(vim.cmd,G)if not H then a.warn(("':%s' failed: %s"):format(G,I))end end;if q~="bd"then if s~=u.bufnr or F~=u.line then u.col=u.col and u.col>0 and u.col or 1;vim.api.nvim_win_set_cursor(0,{tonumber(u.line),tonumber(u.col)-1})end;if not t and not m.no_action_zz then vim.cmd("norm! zvzz")end end end end;c.buf_edit=function(i,m)local q="b"c.vimcmd_buf(q,i,m)end;c.buf_split=function(i,m)local q="split | b"c.vimcmd_buf(q,i,m)end;c.buf_vsplit=function(i,m)local q="vertical split | b"c.vimcmd_buf(q,i,m)end;c.buf_tabedit=function(i,m)local q="tab split | b"c.vimcmd_buf(q,i,m)end;c.buf_del=function(i,m)local q="bd"local J=vim.tbl_filter(function(K)local C=tonumber(K:match("%[(%d+)"))return not a.buffer_is_dirty(C,true,false)end,i)c.vimcmd_buf(q,J,m)end;c.buf_switch=function(i,o)local L=tonumber(i[1]:match("(%d+)%)"))local M=L and vim.api.nvim_list_tabpages()[L]if M then vim.api.nvim_set_current_tabpage(M)else M=vim.api.nvim_win_get_tabpage(0)end;local B=tonumber(string.match(i[1],"%[(%d+)"))if B then local E=a.winid_from_tabh(M,B)if E then vim.api.nvim_set_current_win(E)end end end;c.buf_switch_or_edit=function(...)c.buf_switch(...)c.buf_edit(...)end;c.buf_sel_to_qf=function(i,m)return w(i,m)end;c.buf_sel_to_ll=function(i,m)return w(i,m,true)end;c.buf_edit_or_qf=function(i,m)if#i>1 then return c.buf_sel_to_qf(i,m)else return c.buf_edit(i,m)end end;c.colorscheme=function(i)local N=i[1]vim.cmd("colorscheme "..N)end;c.ensure_insert_mode=function()a.warn("calling 'ensure_insert_mode' is no longer required and can be safely omitted.")end;c.run_builtin=function(i)local O=i[1]vim.cmd(string.format("lua require'fzf-lua'.%s()",O))end;c.ex_run=function(i)local G=i[1]vim.cmd("stopinsert")vim.fn.feedkeys(string.format(":%s",G),"n")return G end;c.ex_run_cr=function(i)local G=c.ex_run(i)a.feed_keys_termcodes("<CR>")vim.fn.histadd("cmd",G)end;c.exec_menu=function(i)local G=i[1]vim.cmd("emenu "..G)end;c.search=function(i)local P=i[1]vim.cmd("stopinsert")vim.fn.feedkeys(string.format("/%s",P),"n")return P end;c.search_cr=function(i)local P=c.search(i)a.feed_keys_termcodes("<CR>")vim.fn.histadd("search",P)end;c.goto_mark=function(i)local Q=i[1]Q=Q:match("[^ ]+")vim.cmd("stopinsert")vim.cmd("normal! '"..Q)end;c.goto_jump=function(i,m)if m.jump_using_norm then local R,o,o,o=i[1]:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")if tonumber(R)then vim.cmd(("normal! %d"):format(R))end else local o,F,S,T=i[1]:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")local H,I=pcall(vim.fn.expand,T)if not H then T=""else T=I end;if not T or not vim.loop.fs_stat(T)then T=vim.api.nvim_buf_get_name(0)end;local u=("%s:%d:%d:"):format(T,tonumber(F),tonumber(S)+1)c.file_edit({u},m)end end;c.spell_apply=function(i)local U=i[1]vim.cmd("normal! ciw"..U)vim.cmd("stopinsert")end;c.set_filetype=function(i)vim.api.nvim_buf_set_option(0,"filetype",i[1])end;c.packadd=function(i)for l=1,#i do vim.cmd("packadd "..i[l])end end;local function V(W)return vim.tbl_map(function(X)return X:match("[^%s]+")end,W)end;c.help=function(i)local q="help"c.vimcmd(q,V(i),true)end;c.help_vert=function(i)local q="vert help"c.vimcmd(q,V(i),true)end;c.help_tab=function(i)local q="tab help"c.vimcmd(q,V(i),true)end;local function Y(W)return vim.tbl_map(function(X)return X:match("[^[,( ]+")end,W)end;c.man=function(i)local q="Man"c.vimcmd(q,Y(i))end;c.man_vert=function(i)local q="vert Man"c.vimcmd(q,Y(i))end;c.man_tab=function(i)local q="tab Man"c.vimcmd(q,Y(i))end;c.git_switch=function(i,m)local G=b.git_cwd({"git","checkout"},m)local Z=a.git_version()if Z and Z>=2.23 then G=b.git_cwd({"git","switch"},m)end;local _=i[1]:match("[^ ]+")if _:find("%*")~=nil then return end;if _:find("^remotes/")then table.insert(G,"--detach")end;table.insert(G,_)local a0=a.io_systemlist(G)if a.shell_error()then a.err(unpack(a0))else a.info(unpack(a0))vim.cmd("edit!")end end;c.git_checkout=function(i,m)local a1=b.git_cwd({"git","checkout"},m)local a2=b.git_cwd({"git","rev-parse","--short HEAD"},m)local a3=i[1]:match("[^ ]+")if a.input("Checkout commit "..a3 .."? [y/n] ")=="y"then local a4=a.io_systemlist(a2)if a3==a4 then return end;table.insert(a1,a3)local a0=a.io_systemlist(a1)if a.shell_error()then a.err(unpack(a0))else a.info(unpack(a0))vim.cmd("edit!")end end end;local a5=function(i,m,G)for o,a6 in ipairs(i)do local z=b.relative(b.entry_to_file(a6,m).path,m.cwd)local a7=vim.deepcopy(G)table.insert(a7,z)local a0=a.io_systemlist(a7)if a.shell_error()then a.err(unpack(a0))end end end;c.git_stage=function(i,m)local G=b.git_cwd({"git","add","--"},m)a5(i,m,G)end;c.git_unstage=function(i,m)local G=b.git_cwd({"git","reset","--"},m)a5(i,m,G)end;c.git_reset=function(i,m)local G=b.git_cwd({"git","checkout","HEAD","--"},m)a5(i,m,G)end;c.git_stash_drop=function(i,m)local G=b.git_cwd({"git","stash","drop"},m)a5(i,m,G)end;c.git_stash_pop=function(i,m)if a.input("Pop "..#i.." stash(es)? [y/n] ")=="y"then local G=b.git_cwd({"git","stash","pop"},m)a5(i,m,G)vim.cmd("e!")end end;c.git_stash_apply=function(i,m)if a.input("Apply "..#i.." stash(es)? [y/n] ")=="y"then local G=b.git_cwd({"git","stash","apply"},m)a5(i,m,G)vim.cmd("e!")end end;c.git_buf_edit=function(i,m)local G=b.git_cwd({"git","show"},m)local a8=b.git_root(m,true)local a9=vim.api.nvim_get_current_win()local aa=vim.bo.filetype;local z=b.relative(vim.fn.expand("%:p"),a8)local a3=i[1]:match("[^ ]+")table.insert(G,a3 ..":"..z)local ab=a.io_systemlist(G)local ac=vim.api.nvim_create_buf(true,true)local ad=string.gsub(z,"$","["..a3 .."]")vim.api.nvim_buf_set_lines(ac,0,0,true,ab)vim.api.nvim_buf_set_name(ac,ad)vim.api.nvim_buf_set_option(ac,"buftype","nofile")vim.api.nvim_buf_set_option(ac,"bufhidden","wipe")vim.api.nvim_buf_set_option(ac,"filetype",aa)vim.api.nvim_buf_set_option(ac,"modifiable",false)vim.api.nvim_win_set_buf(a9,ac)end;c.git_buf_tabedit=function(i,m)vim.cmd("tab split")c.git_buf_edit(i,m)end;c.git_buf_split=function(i,m)vim.cmd("split")c.git_buf_edit(i,m)end;c.git_buf_vsplit=function(i,m)vim.cmd("vsplit")c.git_buf_edit(i,m)end;c.arg_add=function(i,m)local q="argadd"c.vimcmd_file(q,i,m)end;c.arg_del=function(i,m)local q="argdel"c.vimcmd_file(q,i,m)end;c.grep_lgrep=function(o,m)assert(m.__MODULE__ and type(m.__MODULE__.grep)=="function"or type(m.__MODULE__.live_grep)=="function")local ae=vim.tbl_extend("keep",{search=false,resume=true,resume_search_default="",rg_glob=m.rg_glob or m.__call_opts.rg_glob,requires_processing=m.rg_glob or m.__call_opts.rg_glob,__prev_query=not m.fn_reload and m.__resume_data.last_query,query=m.fn_reload and m.__call_opts.__prev_query},m.__call_opts or{})if m.fn_reload then m.__MODULE__.grep(ae)else m.__MODULE__.live_grep(ae)end end;c.sym_lsym=function(o,m)assert(m.__MODULE__ and type(m.__MODULE__.workspace_symbols)=="function"or type(m.__MODULE__.live_workspace_symbols)=="function")local ae=vim.tbl_extend("keep",{resume=true,lsp_query=false,__prev_query=not m.fn_reload and m.__resume_data.last_query,query=m.fn_reload and m.__call_opts.__prev_query},m.__call_opts or{})if m.fn_reload then m.__MODULE__.workspace_symbols(ae)else m.__MODULE__.live_workspace_symbols(ae)end end;c.tmux_buf_set_reg=function(i,m)local ac=i[1]:match("^%[(.-)%]")local af=vim.fn.system({"tmux","show-buffer","-b",ac})if not a.shell_error()and af and#af>0 then m.register=m.register or[["]]local H,ag=pcall(vim.fn.setreg,m.register,af)if H then a.info(string.format("%d characters copied into register %s",#af,m.register))else a.err(string.format("setreg(%s) failed: %s",m.register,ag))end end end;c.paste_register=function(i)local ah=i[1]:match("%[(.-)%]")local H,af=pcall(vim.fn.getreg,ah)if H and#af>0 then vim.api.nvim_paste(af,false,-1)end end;return c
