local a=require"fzf-lua.utils"local b=string.sub;local c=string.byte;local d={}d.separator=function()return"/"end;d.dot_byte=c(".")d.separator_byte=c(d.separator())d.starts_with_separator=function(e)return c(e,1)==d.separator_byte end;d.ends_with_separator=function(e)return c(e,#e)==d.separator_byte end;d.starts_with_cwd=function(e)return#e>1 and c(e,1)==d.dot_byte and c(e,2)==d.separator_byte end;d.strip_cwd_prefix=function(e)return#e>2 and e:sub(3)end;function d.tail(e)local f=c(d.separator())for g=#e,1,-1 do if c(e,g)==f then return e:sub(g+1)end end;return e end;function d.extension(e)for g=#e,1,-1 do if c(e,g)==46 then return e:sub(g+1)end end;return e end;function d.to_matching_str(e)return a.lua_regex_escape(e)end;function d.join(h)return table.concat(h,d.separator()):gsub(d.separator()..d.separator(),d.separator())end;function d.split(e)return e:gmatch("[^"..d.separator().."]+"..d.separator().."?")end;function d.basename(e)e=d.remove_trailing(e)local g=e:match("^.*()"..d.separator())if not g then return e end;return e:sub(g+1,#e)end;function d.parent(e,i)e=" "..d.remove_trailing(e)local g=e:match("^.+()"..d.separator())if not g then return nil end;e=e:sub(2,g)if i then e=d.remove_trailing(e)end;return e end;function d.relative(e,j)local k,l=e:gsub("^"..d.to_matching_str(d.add_trailing(j)),"")return k end;function d.is_relative(e,j)local k=e:match("^"..d.to_matching_str(d.add_trailing(j)))return k~=nil end;function d.add_trailing(e)if e:sub(-1)==d.separator()then return e end;return e..d.separator()end;function d.remove_trailing(e)local k,l=e:gsub(d.separator().."$","")return k end;local function m(n,o,p)local q=c(o,1)for g=p or 1,#n do if c(n,g)==q then return g end end end;d.HOME=function()if not d.__HOME then d.__HOME=os.getenv("HOME")end;return d.__HOME end;function d.tilde_to_HOME(e)return e and e:gsub("^~",d.HOME())or nil end;function d.HOME_to_tilde(e)return e and e:gsub("^"..d.HOME(),"~")or nil end;function d.shorten(e,r)local s=d.separator()local t={}local p=1;r=r and tonumber(r)>0 and r or 1;repeat local g=m(e,s,p)local u=g and p+math.min(g-p,r)-1 or nil;table.insert(t,b(e,p,u))if g then p=g+1 end until not g;return table.concat(t,s)end;function d.lengthen(e)e=a.glob_escape(e)return vim.fn.glob(e:gsub(d.separator(),"%*"..d.separator()):gsub("^%*"..d.separator(),d.separator())):match("[^\n]+")or string.format("<glob expand failed for '%s'>",e)end;local function v(w,x)local g=w:match(".*"..x.."()")if g==nil then return nil else return g-1 end end;local function y(n,s)local z=v(n,s)or 0;return n:sub(z+1),z end;function d.entry_to_ctag(A,B)local C=A:match("%:.-/^?\t?(.*)/")C=C and C:match("/^(.*)")or C;if C and not B then C=C:gsub("[\\%]~*]",function(D)return"\\"..D end)end;return C end;function d.entry_to_location(A,E)local F,G,H=A:match("^(.*://.*):(%d+):(%d+):")G=G and tonumber(G)or 1;H=H and tonumber(H)or 1;if E and E.path_shorten then F=F:match("^.*://")..d.lengthen(F:match("^.*://(.*)"))end;return{stripped=A,line=G,col=H,uri=F,range={start={line=G-1,character=H-1}}}end;function d.entry_to_file(A,E,I)E=E or{}local J=E.cwd;A=a.strip_ansi_coloring(A)local K,z=y(A,a.nbsp)K=d.tilde_to_HOME(K)local L=K:match("^%a+://")if J and#J>0 and not L and not d.starts_with_separator(K)then K=d.join({J,K})end;if not L and I then L=true;K="file://"..K end;local M=z>1 and A:sub(1,z):match("%[(%d+)")or nil;if L and not M then return d.entry_to_location(K,E)end;local N=a.strsplit(K,":")if not N[1]then return{}end;local O=N[1]local G=tonumber(N[2])local H=tonumber(N[3])if#N>1 then local P=O;for g=2,#N do P=("%s:%s"):format(P,N[g])if vim.loop.fs_stat(P)then O=P;G=N[g+1]H=N[g+2]end end end;local Q;if M then Q=a.is_term_buffer(M)if Q then O,G=K:match("([^:]+):(%d+)")end end;if E.path_shorten then O=d.lengthen(O)end;return{stripped=K,bufnr=tonumber(M),bufname=M and vim.api.nvim_buf_is_valid(tonumber(M))and vim.api.nvim_buf_get_name(tonumber(M)),terminal=Q,path=O,line=tonumber(G)or 1,col=tonumber(H)or 1}end;function d.git_cwd(R,E)local S=E or{}if type(S)=="string"then S={cwd=S}end;local T={{"cwd","-C"},{"git_dir","--git-dir"},{"git_worktree","--work-tree"}}if type(R)=="string"then local U=""for l,V in ipairs(T)do if S[V[1]]then S[V[1]]=vim.fn.expand(S[V[1]])U=U..("%s %s "):format(V[2],vim.fn.shellescape(S[V[1]]))end end;R=R:gsub("^git ","git "..U)else local z=2;R=a.tbl_deep_clone(R)for l,V in ipairs(T)do if S[V[1]]then S[V[1]]=vim.fn.expand(S[V[1]])table.insert(R,z,V[2])table.insert(R,z+1,S[V[1]])z=z+2 end end end;return R end;function d.is_git_repo(E,W)return not not d.git_root(E,W)end;function d.git_root(E,W)local R=d.git_cwd({"git","rev-parse","--show-toplevel"},E)local X,Y=a.io_systemlist(R)if Y~=0 then if not W then a.info(unpack(X))end;return nil end;return X[1]end;return d
