local a=require"fzf-lua.core"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.shell"local e=require"fzf-lua.config"local f=require"fzf-lua.make_entry"local g={}g.commands=function(h)h=e.normalize_opts(h,e.globals.commands)if not h then return end;local i=vim.api.nvim_get_commands{}local j=vim.api.nvim_buf_get_commands(0,{})local k=vim.tbl_extend("force",{},i,j)local l=d.action(function(m)local n=m[1]if k[n]then n=vim.inspect(k[n])end;return n end,nil,h.debug)local o={}for p,q in pairs(i)do table.insert(o,c.ansi_codes.magenta(p))end;for p,r in pairs(j)do if type(r)=="table"then table.insert(o,c.ansi_codes.green(p))end end;table.sort(o,function(s,t)return s<t end)h.fzf_opts["--no-multi"]=""h.fzf_opts["--preview"]=l;a.fzf_exec(o,h)end;local u=function(h,v)local u=vim.fn.execute("history "..v)u=vim.split(u,"\n")local o={}for w=#u,3,-1 do local x=u[w]local q,y=string.find(x,"%d+ +")table.insert(o,string.sub(x,y+1))end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;local z=function(A,B,C)A=c.ansi_codes.yellow(A)B=c.ansi_codes.yellow(B)return vim.fn.shellescape((":: %s to %s, %s to edit"):format(A,C,B))end;g.command_history=function(h)h=e.normalize_opts(h,e.globals.command_history)if not h then return end;h.fzf_opts["--header"]=z("<CR>","<Ctrl-e>","execute")u(h,"cmd")end;g.search_history=function(h)h=e.normalize_opts(h,e.globals.search_history)if not h then return end;h.fzf_opts["--header"]=z("<CR>","<Ctrl-e>","search")u(h,"search")end;g.changes=function(h)h=h or{}h.cmd="changes"h.prompt=h.prompt or"Changes> "return g.jumps(h)end;g.jumps=function(h)h=e.normalize_opts(h,e.globals.jumps)if not h then return end;local D=vim.fn.execute(h.cmd)D=vim.split(D,"\n")local o={}for w=#D-1,3,-1 do local E,F,G,C=D[w]:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")table.insert(o,string.format("%-15s %-15s %-15s %s",c.ansi_codes.yellow(E),c.ansi_codes.blue(F),c.ansi_codes.green(G),C))end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.tagstack=function(h)h=e.normalize_opts(h,e.globals.tagstack)if not h then return end;local H=vim.fn.gettagstack().items;local I={}for w=#H,1,-1 do local J=H[w]J.bufnr=J.from[1]if vim.api.nvim_buf_is_valid(J.bufnr)then I[#I+1]=J;J.filename=vim.fn.bufname(J.bufnr)J.lnum=J.from[2]J.col=J.from[3]J.text=vim.api.nvim_buf_get_lines(J.bufnr,J.lnum-1,J.lnum,false)[1]or""end end;if vim.tbl_isempty(I)then c.info("No tagstack available")return end;local o={}for w,J in ipairs(I)do local K=b.HOME_to_tilde(b.relative(J.filename,vim.loop.cwd()))local L,M;if h.file_icons then local N=b.tail(K)local O=b.extension(N)L,M=f.get_devicon(N,O)if h.color_icons then L=c.ansi_codes[M](L)end end;table.insert(o,("%s)%s%s%s%s:%s:%s: %s %s"):format(c.ansi_codes.yellow(tostring(w)),c.nbsp,L or"",L and c.nbsp or"",c.ansi_codes.magenta(#K>0 and K or"[No Name]"),c.ansi_codes.green(tostring(J.lnum)),J.col,c.ansi_codes.red("["..J.tagname.."]"),J.text))end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.marks=function(h)h=e.normalize_opts(h,e.globals.marks)if not h then return end;local P=vim.fn.execute("marks")P=vim.split(P,"\n")local o={}for w=#P,3,-1 do local Q,F,G,C=P[w]:match("(.)%s+(%d+)%s+(%d+)%s+(.*)")table.insert(o,string.format("%-15s %-15s %-15s %s",c.ansi_codes.yellow(Q),c.ansi_codes.blue(F),c.ansi_codes.green(G),C))end;table.sort(o,function(s,t)return s<t end)h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.registers=function(h)h=e.normalize_opts(h,e.globals.registers)if not h then return end;local R={'"',"_","#","=","_","/","*","+",":",".","%"}for w=0,9 do table.insert(R,tostring(w))end;for w=65,90 do table.insert(R,string.char(w))end;local function S(T,U)if not T then return end;local V={["\3"]="^C",["\27"]="^[",["\18"]="^R"}for p,r in pairs(V)do T=T:gsub(p,c.ansi_codes.magenta(r))end;return not U and T or T:gsub("\n",c.ansi_codes.magenta("\\n"))end;local l=d.action(function(m)local W=m[1]:match("%[(.*)%] ")local q,X=pcall(vim.fn.getreg,W)return X and S(X)or m[1]end,nil,h.debug)local o={}for q,W in ipairs(R)do local q,X=pcall(vim.fn.getreg,W)X=S(X,true)if X and#X>0 or not h.ignore_empty then table.insert(o,string.format("[%s] %s",c.ansi_codes.yellow(W),X))end end;h.fzf_opts["--no-multi"]=""h.fzf_opts["--preview"]=l;a.fzf_exec(o,h)end;g.keymaps=function(h)h=e.normalize_opts(h,e.globals.keymaps)if not h then return end;local Y={n="blue",i="red",c="yellow"}local Z={}local _=function(a0)local a1=a0.desc or a0.rhs or string.format("%s",a0.callback)if type(a0.rhs)=="string"and#a0.rhs==0 then return end;a0.str=string.format("%s │ %-40s │ %s",c.ansi_codes[Y[a0.mode]or"blue"](a0.mode),a0.lhs:gsub("%s","<Space>"),a1 or"")local p=string.format("[%s:%s:%s]",a0.buffer,a0.mode,a0.lhs)Z[p]=a0 end;for a2,q in pairs(Y)do local a3=vim.api.nvim_get_keymap(a2)for q,a0 in pairs(a3)do _(a0)end;local a4=vim.api.nvim_buf_get_keymap(0,a2)for q,a0 in pairs(a4)do _(a0)end end;local o={}for q,r in pairs(Z)do table.insert(o,r.str)end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.spell_suggest=function(h)h=e.normalize_opts(h,e.globals.spell_suggest)if not h then return end;local a5=vim.fn.expand"<cword>"local o=vim.fn.spellsuggest(a5)if vim.tbl_isempty(o)then return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.filetypes=function(h)h=e.normalize_opts(h,e.globals.filetypes)if not h then return end;local o=vim.fn.getcompletion("","filetype")if vim.tbl_isempty(o)then return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.packadd=function(h)h=e.normalize_opts(h,e.globals.packadd)if not h then return end;local o=vim.fn.getcompletion("","packadd")if vim.tbl_isempty(o)then return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.menus=function(h)h=e.normalize_opts(h,e.globals.menus)if not h then return end;local function a6(a7,a8)local a9=a7 and("%s.%s"):format(a7,a8.name)or a8.name;if a8.submenus then return vim.tbl_map(function(aa)return a6(a9,aa)end,a8.submenus)else return a9 end end;local o=vim.tbl_flatten(vim.tbl_map(function(aa)return a6(nil,aa)end,vim.fn.menu_get("")))if vim.tbl_isempty(o)then c.info("No menus available")return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;return g
