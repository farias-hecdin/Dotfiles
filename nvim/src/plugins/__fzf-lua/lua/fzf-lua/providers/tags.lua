local a=require"fzf-lua.path"local b=require"fzf-lua.utils"local c=require"fzf-lua.libuv"local d=require"fzf-lua.config"local e=require"fzf-lua.make_entry"local f={}function f.get_last_search(g)local h=d.globals.tags._last_search or{}return h.query,h.no_esc end;function f.set_last_search(g,i,j)d.globals.tags._last_search={query=i,no_esc=j}if d.__resume_data then d.__resume_data.last_query=i end end;local function k(l)local i,m=nil,nil;local n,o=nil,nil;if vim.fn.executable("rg")==1 then n,o="rg",l.rg_opts else n,o="grep",l.grep_opts end;if l.filename and#l.filename>0 then i=c.shellescape(l.filename)elseif l.search and#l.search>0 then m=('%s -v "^!"'):format(n)i=c.shellescape(l.no_esc and l.search or b.rg_escape(l.search))else i='-v "^!_TAG_"'end;return("%s %s %s %s"):format(n,o,i,l._ctags_file and vim.fn.shellescape(l._ctags_file)or""),m end;local function p(l)l.__MODULE__=l.__MODULE__ or f;l.__module__=l.__module__ or"tags"l._ctag=true;l.ctags_bin=l.ctags_bin or"ctags"l.ctags_file=l.ctags_file and vim.fn.expand(l.ctags_file)or"tags"l._ctags_file=l.ctags_file;if not a.starts_with_separator(l._ctags_file)and l.cwd then l._ctags_file=a.join({l.cwd,l.ctags_file})end;if not l.ctags_autogen and not vim.loop.fs_stat(l._ctags_file)then if l.filename then if vim.fn.executable(l.ctags_bin)==1 then l.cmd=l.cmd or l._btags_cmd else b.info("Unable to locate `ctags` executable, ".."install `ctags` or supply its path using 'ctags_bin'")return end else b.info(("Tags file ('%s') does not exist. Create one with ctags -R"):format(l._ctags_file))return end end;if l.line_field_index==nil then local q=k({rg_opts="-m 1",grep_opts="-m 1",_ctags_file=l._ctags_file})local r,s,t=pcall(b.io_systemlist,q)if r and t==0 and s and not vim.tbl_isempty(s)then local u,v=e.tag(s[1],l)if u and not v then l.line_field_index=0 end end end;l.requires_processing=true;if l.multiprocess then l.__mt_transform=[[return require("make_entry").tag]]else l.__mt_transform=e.tag end;if l.lgrep then local g,m=k({search="dummy"})l.filter=l.filter==nil and m or l.filter;l.rg_glob=false;l.filename=l._ctags_file;if l.multiprocess then return require"fzf-lua.providers.grep".live_grep_mt(l)else l.fn_transform=function(w)return e.tag(w,l)end;return require"fzf-lua.providers.grep".live_grep_st(l)end else local q,m=k(l)l.raw_cmd=l.cmd or q;l.filter=l.filter==nil and m or l.filter;if l.filter and#l.filter>0 then l.raw_cmd=("%s | %s"):format(l.raw_cmd,l.filter)end;return require"fzf-lua.providers.grep".grep(l)end end;f.tags=function(l)l=d.normalize_opts(l,d.globals.tags)if not l then return end;return p(l)end;f.btags=function(l)l=d.normalize_opts(l,d.globals.btags)if not l then return end;l.filename=vim.api.nvim_buf_get_name(0)if not l.filename or#l.filename==0 then b.info("'btags' is not available for unnamed buffers.")return end;l._btags_cmd=string.format("%s %s %s",l.ctags_bin or"ctags",l.ctags_args or"-f -",l.filename)if l.ctags_autogen then l.cmd=l.cmd or l._btags_cmd end;l.filename=a.relative(l.filename,l.cwd or vim.loop.cwd())return p(l)end;f.grep=function(l)l=l or{}if not l.search and l.resume then l.search,l.no_esc=f.get_last_search(l)l.search=l.search or l.resume_search_default end;if not l.search then l.search=b.input(l.input_prompt or"Grep For> ")end;return f.tags(l)end;f.live_grep=function(l)l=d.normalize_opts(l,d.globals.tags)if not l then return end;l.lgrep=true;return p(l)end;f.grep_cword=function(l)if not l then l={}end;l.search=vim.fn.expand("<cword>")return f.grep(l)end;f.grep_cWORD=function(l)if not l then l={}end;l.search=vim.fn.expand("<cWORD>")return f.grep(l)end;f.grep_visual=function(l)if not l then l={}end;l.search=b.get_visual_selection()return f.grep(l)end;return f
