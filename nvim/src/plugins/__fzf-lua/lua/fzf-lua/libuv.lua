local a=vim.loop;local b={}local c=debug.getinfo(1,"S").source:gsub("^@","")if not vim.g.fzf_lua_directory and#vim.api.nvim_list_uis()==0 then package.path=(";%s/?.lua;"):format(vim.fn.fnamemodify(c,":h"))..package.path;local d=require;require=function(e)return d(e:gsub("^fzf%-lua%.",""))end;local f=vim.fn.fnamemodify(vim.fn.tempname(),":h")if f and#f>0 then vim.fn.delete(f,"rf")end end;local g=string.byte;local h=string.sub;local function i(j)for k=#j,1,-1 do if g(j,k)==10 then return k end end end;local function l(j,m)for k=m or 1,#j do if g(j,k)==10 then return k end end end;local function n(o,p)if not o or not tonumber(o)then return false end;if type(a.os_getpriority(o))=="number"then a.kill(o,p or 9)return true end;return false end;b.process_kill=n;local function q(r)local s=coroutine.running()local t=function(...)if coroutine.status(s)=="suspended"then coroutine.resume(s,...)else local o=unpack({...})n(o)end end;r(t)return coroutine.yield()end;local function u(r)return function(...)local v={...}return coroutine.wrap(function()return q(function(w)table.insert(v,w)r(unpack(v))end)end)()end end;b.spawn=function(x,y,z)local A=a.new_pipe(false)local B=a.new_pipe(false)local C=0;local D=nil;if x.fn_transform then y=x.fn_transform end;local E=function(F,G,H,o)A:shutdown()B:shutdown()if x.cb_finish then x.cb_finish(F,G,H,o)end;if z then z(o)end end;local I,o=a.spawn("sh",{args={"-c",x.cmd},stdio={nil,A,B},cwd=x.cwd},function(F,p)A:read_stop()B:read_stop()A:close()B:close()if C==0 then E(F,p,1)end end)if x.cb_pid then x.cb_pid(o)end;if x.pid_cb then x.pid_cb(o)end;if x._pid_cb then x._pid_cb(o)end;local function J(K)C=C+1;x.cb_write(K,function(L)C=C-1;if L then E(130,0,2,o)elseif C==0 and a.is_closing(A)then E(0,0,3,o)end end)end;local function M(K)local N={}local m=1;repeat local O=l(K,m)local P=K:sub(m,O-1)P=y(P)if P then table.insert(N,P)end;m=O+1 until m>=#K;if#N>0 then J(table.concat(N,"\n").."\n")end end;local Q=function(L,K)if L then assert(not L)E(130,0,4,o)end;if not K then return end;if D then if#D>4096 then D=D:sub(1,4096)end;K=D..K;D=nil end;if not y then J(K)elseif g(K,#K)==10 then M(K)else local R=i(K)if not R then D=K else D=h(K,R+1)local S=h(K,1,R)M(S)end end end;local T=function(L,K)if L then E(130,0,9,o)end;if not K then return end;if x.cb_err then x.cb_err(K)else J(K)end end;if not I then T(nil,o.."\n")T(o,nil)else A:read_start(Q)B:read_start(T)end end;b.async_spawn=u(b.spawn)b.spawn_nvim_fzf_cmd=function(x,y,U)assert(not y or type(y)=="function")if U and type(U)=="function"then U(x)end;return function(V,W,V)local function X(V,V)W(nil)end;local function Y(K,w)W(K,w)end;return b.spawn({cwd=x.cwd,cmd=x.cmd,cb_finish=X,cb_write=Y,cb_pid=x.pid_cb},y)end end;b.spawn_stdio=function(x,y,U)local function Z(_)if type(_)~="string"then return end;local a0=nil;local r=loadstring(_)or load(_)if r then a0=r()end;if type(a0)~="function"then a0=nil end;return a0 end;io.stderr:setvbuf"line"if x.stderr_to_stdout==nil and vim.loop.os_uname().sysname=="Darwin"then x.stderr_to_stdout=true end;y=Z(y)U=Z(U)if U then U(x)end;if x.debug then io.stdout:write("[DEBUG]: "..x.cmd.."\n")end;local a1,a2=nil,nil;local function a3(a4)if a1 then a1:write(a4)else io.stderr:write(a4)end end;local function a5(a6,a4)if a4 then a3(a4)end;os.exit(a6)end;local function a7(a8)if not a8 then return end;local a9=a.fs_open(a8,"w",-1)if type(a9)~="number"then a5(1,("error opening '%s': %s\n"):format(a8,a9))end;local aa=a.new_pipe(false)aa:open(a9)return aa end;local function ab(aa)if aa and not aa:is_closing()then aa:close()end end;local function ac(aa,K,w)if not aa or aa:is_closing()then return end;aa:write(K,function(L)if L then a3(("pipe:write error: %s\n"):format(L))end;if w then w(L)end end)end;if type(x.stderr)=="string"then a1=a7(x.stderr)end;if type(x.stdout)=="string"then a2=a7(x.stdout)end;local X=x.on_finish or function(F)ab(a2)ab(a1)a5(F)end;local Y=x.on_write or function(K,w)if a2 then ac(a2,K,w)else local ad,L=io.stdout:write(K)if not ad then a3(("io.stdout:write error: %s\n"):format(L))w(L or true)else w(nil)end end end;local ae=x.on_err or function(K)if a1 then ac(a1,K)elseif x.stderr~=false then if x.stderr_to_stdout then io.stdout:write(K)else io.stderr:write(K)end end end;return b.spawn({cwd=x.cwd,cmd=x.cmd,cb_finish=X,cb_write=Y,cb_err=ae},y and function(af)return y(af,x)end)end;b.shellescape=function(e)local ag=vim.o.shell;if not ag or not ag:match("fish$")then return vim.fn.shellescape(e)else local ah=nil;vim.o.shell="sh"if not e:match([["]])and not e:match([[\]])then ah=vim.fn.shellescape(({e:gsub([[']],[["]])})[1])ah=[["]]..ah:gsub([["]],[[']]):sub(2,#ah-1)..[["]]else ah=vim.fn.shellescape(e)end;vim.o.shell=ag;return ah end end;b.wrap_spawn_stdio=function(x,y,U)assert(x and type(x)=="string")assert(not y or type(y)=="string")local ai=vim.v.progpath;local aj=x;for V,r in ipairs({y,U})do if type(r)=="string"then aj=("%s,[[%s]]"):format(aj,r)end end;local ak=("%s -n --headless --clean --cmd %s"):format(vim.fn.shellescape(ai),b.shellescape(("lua loadfile([[%s]])().spawn_stdio(%s)"):format(c,aj)))return ak end;return b
