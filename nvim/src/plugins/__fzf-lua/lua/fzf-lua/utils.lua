function _G.dump(...)local a=vim.tbl_map(vim.inspect,{...})print(unpack(a))end;local b={}function b.__FILE__()return debug.getinfo(2,"S").source end;function b.__LINE__()return debug.getinfo(2,"l").currentline end;function b.__FNC__()return debug.getinfo(2,"n").name end;function b.__FNCREF__()return debug.getinfo(2,"f").func end;b.nbsp="\xe2\x80\x82"if _VERSION and type(_VERSION)=="string"then local c=tonumber(_VERSION:match("%d+.%d+"))if c<5.2 then b.nbsp=b.nbsp:gsub("\\x(%x%x)",function(d)return string.char(tonumber(d,16))end)end end;b._if=function(e,f,g)if e then return f else return g end end;b.strsplit=function(h,i)local j={}for k in string.gmatch(h,"([^"..i.."]+)")do table.insert(j,k)end;return j end;local l=string.byte;b.find_last_char=function(k,m)for n=#k,1,-1 do if l(k,n)==m then return n end end end;b.find_next_char=function(k,m,o)for n=o or 1,#k do if l(k,n)==m then return n end end end;function b.round(p,q)if not p then return nil end;if not q then q=0.5 end;local r=p-math.floor(p)if r>q then return math.ceil(p)end;return math.floor(p)end;function b.nvim_has_option(s)return vim.fn.exists("&"..s)==1 end;function b._echo_multiline(t)for u,v in ipairs(vim.fn.split(t,"\n"))do vim.cmd("echom '"..v:gsub("'","''").."'")end end;function b.info(t)vim.cmd("echohl Directory")b._echo_multiline("[Fzf-lua] "..t)vim.cmd("echohl None")end;function b.warn(t)vim.cmd("echohl WarningMsg")b._echo_multiline("[Fzf-lua] "..t)vim.cmd("echohl None")end;function b.err(t)vim.cmd("echohl ErrorMsg")b._echo_multiline("[Fzf-lua] "..t)vim.cmd("echohl None")end;function b.shell_error()return vim.v.shell_error~=0 end;function b.rg_escape(k)if not k then return k end;return k:gsub("[\\~$?*|{\\[()^%-%.%+]",function(d)return"\\"..d end)end;function b.sk_escape(k)if not k then return k end;return k:gsub('["`]',function(d)return"\\"..d end):gsub([[\\]],[[\\\\]]):gsub([[\%$]],[[\\\$]])end;function b.lua_escape(k)if not k then return k end;return k:gsub("[%%]",function(d)return"%"..d end)end;function b.lua_regex_escape(k)if not k then return nil end;return k:gsub("[%(%)%.%+%-%*%[%?%^%$%%]",function(d)return"%"..d end)end;function b.glob_escape(k)if not k then return k end;return k:gsub("[\\%{}]",function(d)return[[\]]..d end)end;function b.pcall_expand(w)local x,y=pcall(vim.fn.expand,w:gsub("%-","\\-"))if x and y and#y>0 then return y else return w end end;b.file_is_binary=function(w)w=b.pcall_expand(w)if vim.fn.executable("file")~=1 or not vim.loop.fs_stat(w)then return false end;local z=b.io_system({"file","--dereference","--mime",w})return z:match("charset=binary")~=nil end;b.perl_file_is_binary=function(w)w=b.pcall_expand(w)if vim.fn.executable("perl")~=1 or not vim.loop.fs_stat(w)then return false end;b.io_system({"perl","-E","exit((-B $ARGV[0])?0:1);",w})return not b.shell_error()end;b.read_file=function(w)local A=vim.loop.fs_open(w,"r",438)if A==nil then return""end;local B=assert(vim.loop.fs_fstat(A))if B.type~="file"then return""end;local C=assert(vim.loop.fs_read(A,B.size,0))assert(vim.loop.fs_close(A))return C end;b.read_file_async=function(w,D)vim.loop.fs_open(w,"r",438,function(E,A)if E then vim.schedule(function()b.warn(("Unable to open file '%s', error: %s"):format(w,E))end)return end;vim.loop.fs_fstat(A,function(F,B)assert(not F,F)if B.type~="file"then return D("")end;vim.loop.fs_read(A,B.size,0,function(G,C)assert(not G,G)vim.loop.fs_close(A,function(H)assert(not H,H)return D(C)end)end)end)end)end;function b.deepcopy(j)local x,I=pcall(vim.deepcopy,j)if x then return I else return b.tbl_deep_clone(j)end end;function b.tbl_deep_clone(j)if not j then return end;local J={}for K,L in pairs(j)do if type(L)=="table"then J[K]=b.tbl_deep_clone(L)else J[K]=L end end;return J end;function b.tbl_length(M)local N=0;for u in pairs(M)do N=N+1 end;return N end;function b.tbl_isempty(M)if not M or not next(M)then return true end;return false end;function b.tbl_concat(...)local O={}local P=0;for u,j in ipairs({...})do for n,L in ipairs(j)do O[P+n]=L end;P=P+#j end;return O end;function b.tbl_pack(...)return{n=select("#",...),...}end;function b.tbl_unpack(j,n,Q)return unpack(j,n or 1,Q or j.n or#j)end;b.ansi_codes={}b.ansi_colors={clear="[0m",bold="[1m",italic="[3m",underline="[4m",black="[0;30m",red="[0;31m",green="[0;32m",yellow="[0;33m",blue="[0;34m",magenta="[0;35m",cyan="[0;36m",white="[0;37m",grey="[0;90m",dark_grey="[0;97m"}b.add_ansi_code=function(R,S)b.ansi_codes[R]=function(string)if string==nil or#string==0 then return""end;return S..string..b.ansi_colors.clear end end;for T,S in pairs(b.ansi_colors)do b.add_ansi_code(T,S)end;local function U(V)local W,X,g=V:match("#(..)(..)(..)")if not W or not X or not g then return end;W,X,g=tonumber(W,16),tonumber(X,16),tonumber(g,16)return W,X,g end;local function Y(Z,_)return vim.fn.synIDattr(vim.fn.synIDtrans(vim.fn.hlID(Z)),_)end;function b.ansi_from_hl(Z,v,a0)if vim.fn.hlexists(Z)==1 then local a1={["fg"]={rgb=true,code=38},["bg"]={rgb=true,code=48},["bold"]={code=1},["italic"]={code=3},["underline"]={code=4},["inverse"]={code=7},["reverse"]={code=7},["strikethrough"]={code=9}}for _,a2 in pairs(a1)do local S=nil;if a2.rgb then local V=Y(Z,_)if V and not V:match("^#")and a0 then local a3=a0[V:sub(1,1):upper()..V:sub(2)]if a3 then V=("#%06x"):format(a3)end end;local W,X,g=U(V)if W and X and g then S=("[%d;2;%d;%d;%dm"):format(a2.code,W,X,g)end else local a4=Y(Z,_)if a4 and tonumber(a4)==1 then S=("[%dm"):format(a2.code)end end;if S then v=("%s%s%s"):format(S,v,b.ansi_colors.clear)end end end;return v end;function b.strip_ansi_coloring(k)if not k then return k end;return k:gsub("%[[%d;]+m","")end;function b.get_visual_selection()local u,a5,a6,a7,a8;local a9=vim.fn.mode()if a9=="v"or a9=="V"or a9==""then u,a5,a6,u=unpack(vim.fn.getpos("."))u,a7,a8,u=unpack(vim.fn.getpos("v"))if a9=="V"then a6,a8=0,999 end;vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>",true,false,true),"n",true)else u,a5,a6,u=unpack(vim.fn.getpos("'<"))u,a7,a8,u=unpack(vim.fn.getpos("'>"))end;if a7<a5 then a5,a7=a7,a5 end;if a8<a6 then a6,a8=a8,a6 end;local aa=vim.fn.getline(a5,a7)local P=b.tbl_length(aa)if P<=0 then return""end;aa[P]=string.sub(aa[P],1,a8)aa[1]=string.sub(aa[1],a6)return table.concat(aa,"\n")end;function b.fzf_exit()vim.cmd([[lua require('fzf-lua.win').win_leave()]])end;function b.fzf_winobj()return loadstring("return require'fzf-lua'.win.__SELF()")()end;function b.reset_info()pcall(loadstring("require'fzf-lua'.set_info(nil)"))end;function b.send_ctrl_c()vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<C-c>",true,false,true),"n",true)end;function b.feed_keys_termcodes(ab)vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(ab,true,false,true),"n",true)end;function b.is_term_bufname(ac)if ac and ac:match("term://")then return true end;return false end;function b.is_term_buffer(ad)ad=tonumber(ad)or 0;ad=ad==0 and vim.api.nvim_get_current_buf()or ad;local ae=vim.fn.bufwinid(ad)if tonumber(ae)>0 and vim.api.nvim_win_is_valid(ae)then return vim.fn.getwininfo(ae)[1].terminal==1 end;local ac=vim.api.nvim_buf_is_valid(ad)and vim.api.nvim_buf_get_name(ad)return b.is_term_bufname(ac)end;function b.buffer_is_dirty(ad,af,ag)ad=tonumber(ad)or vim.api.nvim_get_current_buf()local ah=ad and vim.fn.getbufinfo(ad)[1]if ah and ah.changed~=0 then if ag and 1<b.tbl_length(vim.fn.win_findbuf(ad))then return false end;if af then b.warn(("buffer %d:%s has unsaved changes"):format(ad,ah.name and#ah.name>0 and ah.name or"<unnamed>"))end;return true end;return false end;function b.save_dialog(ad)ad=tonumber(ad)or vim.api.nvim_get_current_buf()local ah=ad and vim.fn.getbufinfo(ad)[1]if not ah.name or#ah.name==0 then b.warn(string.format("buffer %d has unsaved changes",ad))return false end;local I=vim.fn.confirm(string.format([[Save changes to "%s"?]],ah.name),"&Yes\n&No\n&Cancel")if I==3 then return false end;if I==1 then local z=vim.api.nvim_cmd({cmd="update"},{output=true})b.info(z)end;return true end;function b.win_is_qf(ae,ai)ai=ai or vim.api.nvim_win_is_valid(ae)and vim.fn.getwininfo(ae)[1]if ai and ai.quickfix==1 then return ai.loclist==1 and 2 or 1 end;return false end;function b.buf_is_qf(ad,aj)aj=aj or vim.api.nvim_buf_is_valid(ad)and vim.fn.getbufinfo(ad)[1]if aj and aj.variables and aj.variables.current_syntax=="qf"and not vim.tbl_isempty(aj.windows)then return b.win_is_qf(aj.windows[1])end;return false end;function b.winid_from_tabh(ak,ad)for u,_ in ipairs(vim.api.nvim_tabpage_list_wins(ak))do if ad==vim.api.nvim_win_get_buf(_)then return _ end end;return nil end;function b.winid_from_tabi(al,ad)local ak=vim.api.nvim_list_tabpages()[al]return b.winid_from_tabh(ak,ad)end;function b.nvim_buf_get_name(ad,aj)if not vim.api.nvim_buf_is_valid(ad)then return end;if aj and aj.name and#aj.name>0 then return aj.name end;local ac=vim.api.nvim_buf_get_name(ad)if not ac or#ac==0 then local am=b.buf_is_qf(ad,aj)if am then ac=am==1 and"[Quickfix List]"or"[Location List]"else ac="[No Name]"end end;assert(#ac>0)return ac end;function b.zz()if b.is_term_buffer()then return end;local an=vim.api.nvim_win_get_cursor(0)[1]local ao=vim.api.nvim_buf_line_count(0)local ap="keepj norm! %dzb"if an==ao then vim.fn.execute(ap:format(an))return end;vim.cmd("norm! zvzz")an=vim.api.nvim_win_get_cursor(0)[1]vim.cmd("norm! L")local aq=vim.api.nvim_win_get_cursor(0)[1]if aq+vim.fn.getwinvar(0,"&scrolloff")>=ao then vim.fn.execute(ap:format(aq))end;if an~=aq then vim.cmd("keepj norm! ``")end end;function b.nvim_win_call(ae,ar)vim.validate({winid={ae,function(_)return _ and vim.api.nvim_win_is_valid(_)end,"a valid window"},func={ar,"function"}})local as=vim.api.nvim_get_current_win()local at="noa call nvim_set_current_win(%d)"if as~=ae then vim.cmd(at:format(ae))end;local au=ar()if as~=ae then vim.cmd(at:format(as))end;return au end;function b.ft_detect(av)local aw=""if not av then return aw end;local ax=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_option(ax,"bufhidden","wipe")pcall(vim.api.nvim_buf_call,ax,function()local ay=vim.fn.tempname().."."..av;vim.cmd("file "..ay)vim.cmd("doautocmd BufEnter")vim.cmd("filetype detect")aw=vim.api.nvim_buf_get_option(ax,"filetype")end)if vim.api.nvim_buf_is_valid(ax)then vim.api.nvim_buf_delete(ax,{force=true})end;return aw end;local az=false;function b.set_lua_io(g)az=g;if az then b.warn("using experimental feature 'lua_io'")end end;function b.io_systemlist(aA,aB)if not aB then aB=az end;if aB and aA=="string"then local aC=0;local aD=""local aE=io.popen(aA.." 2>&1; echo $?","r")if aE then aD={}for aF in aE:lines()do aD[#aD+1]=aF end;aC=tonumber(aD[#aD])aD[#aD]=nil;aE:close()end;return aD,aC else return vim.fn.systemlist(aA),vim.v.shell_error end end;function b.io_system(aA,aB)if not aB then aB=az end;if aB then local aD,aC=b.io_systemlist(aA,true)if type(aD)=="table"then aD=table.concat(aD,"\n")end;return aD,aC else return vim.fn.system(aA),vim.v.shell_error end end;function b.input(aG,aH)local x,I=pcall(vim.fn.input,aG,aH or"")return x and I or nil end;function b.fzf_bind_to_neovim(ab)local aI={["alt"]="A",["ctrl"]="C",["shift"]="S"}ab=ab:lower()for K,L in pairs(aI)do ab=ab:gsub(K,L)end;return("<%s>"):format(ab)end;function b.neovim_bind_to_fzf(ab)local aI={["a"]="alt",["c"]="ctrl",["s"]="shift"}ab=ab:lower():gsub("[<>]","")for K,L in pairs(aI)do ab=ab:gsub(K.."%-",L.."-")end;return ab end;function b.git_version()local z=b.io_system({"git","--version"})return tonumber(z:match("(%d+.%d+)."))end;function b.find_version()local z,aC=b.io_systemlist({"find","--version"})return aC==0 and tonumber(z[1]:match("(%d+.%d+)"))or nil end;return b
