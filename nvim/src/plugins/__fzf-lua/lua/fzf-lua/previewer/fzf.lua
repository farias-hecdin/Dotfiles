local a=require"fzf-lua.path"local b=require"fzf-lua.shell"local c=require"fzf-lua.utils"local d=require"fzf-lua.class"local e={}e.base=d:extend()function e.base:new(f,g)f=f or{}self.type="cmd"self.cmd=f.cmd;self.args=f.args or""self.opts=g;return self end;function e.base:preview_window(h)return nil end;function e.base:preview_offset()if self.opts.line_field_index then return("+{%d}-/2"):format(self.opts.line_field_index)end end;function e.base:fzf_delimiter()if not self.opts.line_field_index then return end;local i=self.opts.fzf_opts and self.opts.fzf_opts["--delimiter"]if not i then i="[:]"elseif not i:match(":")then if i:match("%[.*%]")then i=i:match("(%[.*)%]")..":]"else i=i:match("^'?(.*)'$?")or i;i="["..c.rg_escape(i):gsub("%]","\\]")..":]"end end;return i end;e.cmd=e.base:extend()function e.cmd:new(f,g)e.cmd.super.new(self,f,g)return self end;function e.cmd:format_cmd(j,k,l,m)return string.format([[%s %s %s $(%s)]],j,k or"",m or"",l)end;function e.cmd:cmdline(f)f=f or{}f.action=f.action or self:action(f)return self:format_cmd(self.cmd,self.args,f.action)end;function e.cmd:action(f)f=f or{}local n=b.raw_action(function(o,h,h)local p=a.entry_to_file(o[1],self.opts)return p.bufname or p.path end,self.opts.field_index_expr or"{}",self.opts.debug)return n end;e.bat=e.cmd:extend()function e.bat:new(f,g)e.bat.super.new(self,f,g)self.theme=f.theme;return self end;function e.bat:cmdline(f)f=f or{}f.action=f.action or self:action(f)local q=""if self.opts.line_field_index then q=string.format("--highlight-line={%d}",self.opts.line_field_index)end;return self:format_cmd(self.cmd,self.args,f.action,q)end;e.head=e.cmd:extend()function e.head:new(f,g)e.head.super.new(self,f,g)return self end;function e.head:cmdline(f)f=f or{}f.action=f.action or self:action(f)local r="--lines=-0"return self:format_cmd(self.cmd,self.args,f.action,r)end;e.cmd_async=e.base:extend()function e.cmd_async:new(f,g)e.cmd_async.super.new(self,f,g)return self end;local s=function(t,u)local v=1;local w=t;local x=c.rg_escape(u)if not x or not w then return v end;local y=vim.fn.executable("rg")==1 and{"rg","--line-number"}or{"grep","-n","-P"}x=x:gsub("\\%$$","\\r??%$")local j=c.tbl_deep_clone(y)table.insert(j,x)table.insert(j,w)local z=c.io_system(j)if not c.shell_error()then v=tonumber(z:match("[^:]+"))or 1 else c.warn(("previewer: unable to find pattern '%s' in file '%s'"):format(x,t))end;return v end;function e.cmd_async:parse_entry_and_verify(A)local p=a.entry_to_file(A,self.opts)local w=p.bufname or p.path or""if self.opts._ctag and p.line<=1 then local v=p.stripped:match("[^:]+(%d+):")local B=a.entry_to_ctag(p.stripped,true)if not v and B then p.ctag=B;p.line=s(w,p.ctag)end end;local C=nil;if#w==0 or not vim.loop.fs_stat(w)then C=('echo "%s: NO SUCH FILE OR ACCESS DENIED"'):format(w and#w>0 and vim.fn.shellescape(w)or"<null>")end;return w,p,C end;function e.cmd_async:cmdline(f)f=f or{}local n=b.raw_preview_action_cmd(function(o)local w,h,C=self:parse_entry_and_verify(o[1])local j=C or("%s %s %s"):format(self.cmd,self.args,vim.fn.shellescape(w))return j end,"{}",self.opts.debug)return n end;e.bat_async=e.cmd_async:extend()function e.bat_async:new(f,g)e.bat_async.super.new(self,f,g)self.theme=f.theme;return self end;function e.bat_async:cmdline(f)f=f or{}local n=b.raw_preview_action_cmd(function(o,D)local w,p,C=self:parse_entry_and_verify(o[1])local E=""if p.ctag then local F=math.max(1,p.line-D/2)local G=F+D-1;E=("--line-range=%d:%d"):format(F,G)end;local j=C or("%s %s %s %s %s"):format(self.cmd,self.args,self.opts.line_field_index and("--highlight-line=%d"):format(p.line)or"",E,vim.fn.shellescape(w))return j end,"{}",self.opts.debug)return n end;e.git_diff=e.base:extend()function e.git_diff:new(f,g)e.git_diff.super.new(self,f,g)self.cmd_deleted=a.git_cwd(f.cmd_deleted,g)self.cmd_modified=a.git_cwd(f.cmd_modified,g)self.cmd_untracked=a.git_cwd(f.cmd_untracked,g)self.pager=f.pager or g.preview_pager;do local H=f._fn_git_icons and f._fn_git_icons()self.git_icons={}for h,I in ipairs({"D","M","R","A","C","T","?"})do self.git_icons[I]=H and H[I]and c.lua_regex_escape(H[I].icon)or I end end;return self end;function e.git_diff:cmdline(f)f=f or{}local n=b.raw_preview_action_cmd(function(o,D,J)if not o or vim.tbl_isempty(o)then c.warn("shell error while running preview action.")return end;local K=o[1]:match(self.git_icons["D"]..c.nbsp)~=nil;local L=o[1]:match("["..self.git_icons["M"]..self.git_icons["R"]..self.git_icons["A"]..self.git_icons["T"].."]"..c.nbsp)~=nil;local M=o[1]:match("["..self.git_icons["?"]..self.git_icons["C"].."]"..c.nbsp)~=nil;local t=a.entry_to_file(o[1],self.opts)local j=nil;if L then j=self.cmd_modified elseif K then j=self.cmd_deleted elseif M then j=self.cmd_untracked end;if not j then return""end;local N=""if self.pager and#self.pager>0 and vim.fn.executable(self.pager:match("[^%s]+"))==1 then N="| "..self.pager end;if not j:match("%%s")then j=j.." %s"end;j=j:format(vim.fn.shellescape(t.path))j=("LINES=%d;COLUMNS=%d;FZF_PREVIEW_LINES=%d;FZF_PREVIEW_COLUMNS=%d;%s %s"):format(D,J,D,J,j,N)j="sh -c "..vim.fn.shellescape(j)return j end,nil,self.opts.debug)return n end;e.man_pages=e.base:extend()function e.man_pages:new(f,g)e.man_pages.super.new(self,f,g)self.cmd=self.cmd or"man"return self end;function e.man_pages:cmdline(f)f=f or{}local n=b.raw_preview_action_cmd(function(o)local O=o[1]:match("[^[,( ]+")local j=("%s %s %s"):format(self.cmd,self.args,vim.fn.shellescape(O))return j end,"{}",self.opts.debug)return n end;return e
