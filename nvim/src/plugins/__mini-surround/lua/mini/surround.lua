local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.6')==0 then vim.notify('(mini.surround) Official support for Neovim<0.6 will soon be dropped. Update to a newer version of Neovim.')end;_G.MiniSurround=a;c=b.setup_config(c)b.apply_config(c)vim.api.nvim_exec('hi default link MiniSurround IncSearch',false)end;a.config={custom_surroundings=nil,highlight_duration=500,mappings={add='sa',delete='sd',find='sf',find_left='sF',highlight='sh',replace='sr',update_n_lines='sn',suffix_last='l',suffix_next='n'},n_lines=20,search_method='cover'}a.operator=function(d,e)if b.is_disabled()then return[[\<Esc>]]end;b.cache=e or{}vim.cmd(string.format('set operatorfunc=v:lua.MiniSurround.%s',d))return'g@'end;a.add=function(f)if b.is_disabled()then return'<Esc>'end;local g=b.get_marks_pos(f)local h;if f=='visual'then h=b.get_surround_spec('output',false)else h=b.get_surround_spec('output',true)end;if h==nil then return'<Esc>'end;b.region_replace({from={line=g.second.line,col=g.second.col+1}},h.right)b.region_replace({from=g.first},h.left)b.set_cursor(g.first.line,g.first.col+h.left:len())end;a.delete=function()local i=b.find_surrounding(b.get_surround_spec('input',true))if i==nil then return'<Esc>'end;b.region_replace(i.right,{})b.region_replace(i.left,{})local j=i.left.from;b.set_cursor(j.line,j.col)end;a.replace=function()local i=b.find_surrounding(b.get_surround_spec('input',true))if i==nil then return'<Esc>'end;local k=b.get_surround_spec('output',true)if k==nil then return'<Esc>'end;b.region_replace(i.right,k.right)b.region_replace(i.left,k.left)local j=i.left.from;b.set_cursor(j.line,j.col+k.left:len())end;a.find=function()local i=b.find_surrounding(b.get_surround_spec('input',true))if i==nil then return'<Esc>'end;local l=b.surr_to_pos_array(i)local m=b.cache.direction or'right'b.cursor_cycle(l,m)vim.cmd('normal! zv')end;a.highlight=function()local i=b.find_surrounding(b.get_surround_spec('input',true))if i==nil then return'<Esc>'end;local c=b.get_config()local n=vim.api.nvim_get_current_buf()b.region_highlight(n,i.left)b.region_highlight(n,i.right)vim.defer_fn(function()b.region_unhighlight(n,i.left)b.region_unhighlight(n,i.right)end,c.highlight_duration)end;a.update_n_lines=function()if b.is_disabled()then return'<Esc>'end;local o=a.user_input('New number of neighbor lines',a.config.n_lines)o=math.floor(tonumber(o)or a.config.n_lines)a.config.n_lines=o end;a.user_input=function(p,q)local r=vim.on_key or vim.register_keystroke_callback;local s=false;r(function(t)if t==vim.api.nvim_replace_termcodes('<Esc>',true,true,true)then s=true end end,b.ns_id.input)local u={prompt='(mini.surround) '..p..': ',default=q or''}vim.cmd('echohl Question')local v,w=pcall(vim.fn.input,u)vim.cmd([[echohl None | echo '' | redraw]])r(nil,b.ns_id.input)if not v or s then return end;return w end;a.gen_spec={input={},output={}}a.gen_spec.input.treesitter=function(x,u)u=vim.tbl_deep_extend('force',{use_nvim_treesitter=true},u or{})x=b.prepare_captures(x)return function()local y,z=pcall(require,'nvim-treesitter')local A=y and u.use_nvim_treesitter and b.get_matched_node_pairs_plugin or b.get_matched_node_pairs_builtin;local B=A(x)return vim.tbl_map(function(C)local D,E,F,G=C.outer:range()local H={line=D+1,col=E+1}local I={line=F+1,col=G}local J,K;if C.inner==nil then J=I;K=b.pos_to_right(I)I=nil else local L,M,N,O=C.inner:range()J={line=L+1,col=M+1}K={line=N+1,col=O}J,K=b.pos_to_left(J),b.pos_to_right(K)end;return{left={from=H,to=J},right={from=K,to=I}}end,B)end end;b.default_config=a.config;b.ns_id={highlight=vim.api.nvim_create_namespace('MiniSurroundHighlight'),input=vim.api.nvim_create_namespace('MiniSurroundInput')}b.builtin_surroundings={['(']={input={'%b()','^.%s*().-()%s*.$'},output={left='( ',right=' )'}},[')']={input={'%b()','^.().*().$'},output={left='(',right=')'}},['[']={input={'%b[]','^.%s*().-()%s*.$'},output={left='[ ',right=' ]'}},[']']={input={'%b[]','^.().*().$'},output={left='[',right=']'}},['{']={input={'%b{}','^.%s*().-()%s*.$'},output={left='{ ',right=' }'}},['}']={input={'%b{}','^.().*().$'},output={left='{',right='}'}},['<']={input={'%b<>','^.%s*().-()%s*.$'},output={left='< ',right=' >'}},['>']={input={'%b<>','^.().*().$'},output={left='<',right='>'}},['?']={input=function()local P=a.user_input('Left surrounding')if P==nil or P==''then return end;local Q=a.user_input('Right surrounding')if Q==nil or Q==''then return end;return{vim.pesc(P)..'().-()'..vim.pesc(Q)}end,output=function()local P=a.user_input('Left surrounding')if P==nil then return end;local Q=a.user_input('Right surrounding')if Q==nil then return end;return{left=P,right=Q}end},['b']={input={{'%b()','%b[]','%b{}'},'^.().*().$'},output={left='(',right=')'}},['f']={input={'%f[%w_%.][%w_%.]+%b()','^.-%(().*()%)$'},output=function()local R=a.user_input('Function name')if R==nil then return nil end;return{left=('%s('):format(R),right=')'}end},['t']={input={'<(%w-)%f[^<%w][^<>]->.-</%1>','^<.->().*()</[^/]->$'},output=function()local S=a.user_input('Tag name')if S==nil then return nil end;local T=S:match('^%S*')return{left='<'..S..'>',right='</'..T..'>'}end},['q']={input={{"'.-'",'".-"','`.-`'},'^.().*().$'},output={left='"',right='"'}}}b.builtin_surroundings.i={input=function()b.message('Using `i` for interactive surrounding is deprecated and will be removed soon. Use `?`.')vim.loop.sleep(2000)return b.builtin_surroundings['?'].input()end,output=function()b.message('Using `i` for interactive surrounding is deprecated and will be removed soon. Use `?`.')vim.loop.sleep(2000)return b.builtin_surroundings['?'].output()end}b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({custom_surroundings={c.custom_surroundings,'table',true},highlight_duration={c.highlight_duration,'number'},mappings={c.mappings,'table'},n_lines={c.n_lines,'number'},search_method={c.search_method,b.is_search_method}})vim.validate({['mappings.add']={c.mappings.add,'string'},['mappings.delete']={c.mappings.delete,'string'},['mappings.find']={c.mappings.find,'string'},['mappings.find_left']={c.mappings.find_left,'string'},['mappings.highlight']={c.mappings.highlight,'string'},['mappings.replace']={c.mappings.replace,'string'},['mappings.update_n_lines']={c.mappings.update_n_lines,'string'},['mappings.suffix_last']={c.mappings.suffix_last,'string'},['mappings.suffix_next']={c.mappings.suffix_next,'string'}})return c end;b.apply_config=function(c)a.config=c;local U=function(V,W,X)b.map('n',V,W,{expr=true,desc=X})end;local Y=c.mappings;U(Y.add,[[v:lua.MiniSurround.operator('add')]],'Add surrounding')U(Y.delete,[[v:lua.MiniSurround.operator('delete') . ' ']],'Delete surrounding')U(Y.replace,[[v:lua.MiniSurround.operator('replace') . ' ']],'Replace surrounding')U(Y.find,[[v:lua.MiniSurround.operator('find', {'direction': 'right'}) . ' ']],'Find right surrounding')U(Y.find_left,[[v:lua.MiniSurround.operator('find', {'direction': 'left'}) . ' ']],'Find left surrounding')U(Y.highlight,[[v:lua.MiniSurround.operator('highlight') . ' ']],'Highlight surrounding')b.map('n',Y.update_n_lines,'<Cmd>lua MiniSurround.update_n_lines()<CR>',{desc='Update `MiniSurround.config.n_lines`'})b.map('x',Y.add,[[:<C-u>lua MiniSurround.add('visual')<CR>]],{desc='Add surrounding to selection'})local Z=function(V,_,W,X)if V==''then return end;U(V.._,W,X)end;if Y.suffix_last~=''then local a0=Y.suffix_last;Z(Y.delete,a0,[[v:lua.MiniSurround.operator('delete', {'search_method': 'prev'}) . ' ']],'Delete previous surrounding')Z(Y.replace,a0,[[v:lua.MiniSurround.operator('replace', {'search_method': 'prev'}) . ' ']],'Replace previous surrounding')Z(Y.find,a0,[[v:lua.MiniSurround.operator('find', {'direction': 'right', 'search_method': 'prev'}) . ' ']],'Find previous right surrounding')Z(Y.find_left,a0,[[v:lua.MiniSurround.operator('find', {'direction': 'left', 'search_method': 'prev'}) . ' ']],'Find previous left surrounding')Z(Y.highlight,a0,[[v:lua.MiniSurround.operator('highlight', {'search_method': 'prev'}) . ' ']],'Highlight previous surrounding')end;if Y.suffix_next~=''then local a0=Y.suffix_next;Z(Y.delete,a0,[[v:lua.MiniSurround.operator('delete', {'search_method': 'next'}) . ' ']],'Delete next surrounding')Z(Y.replace,a0,[[v:lua.MiniSurround.operator('replace', {'search_method': 'next'}) . ' ']],'Replace next surrounding')Z(Y.find,a0,[[v:lua.MiniSurround.operator('find', {'direction': 'right', 'search_method': 'next'}) . ' ']],'Find next right surrounding')Z(Y.find_left,a0,[[v:lua.MiniSurround.operator('find', {'direction': 'left', 'search_method': 'next'}) . ' ']],'Find next left surrounding')Z(Y.highlight,a0,[[v:lua.MiniSurround.operator('highlight', {'search_method': 'next'}) . ' ']],'Highlight next surrounding')end end;b.is_disabled=function()return vim.g.minisurround_disable==true or vim.b.minisurround_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minisurround_config or{},c or{})end;b.is_search_method=function(a1,a2)a1=a1 or b.get_config().search_method;a2=a2 or'`config.search_method`'local a3=vim.tbl_keys(b.span_compare_methods)if vim.tbl_contains(a3,a1)then return true end;table.sort(a3)local a4=table.concat(vim.tbl_map(vim.inspect,a3),', ')local a5=([[%s should be one of %s.]]):format(a2,a4)return false,a5 end;b.validate_search_method=function(a1,a2)local a6,a5=b.is_search_method(a1,a2)if not a6 then b.error(a5)end end;b.get_surround_spec=function(a7,a8)local w;if a8 then w=b.cache[a7]if w~=nil then return w end end;local a9=b.user_surround_id(a7)if a9==nil then return nil end;w=b.make_surrounding_table()[a9][a7]if vim.is_callable(w)then w=w()end;if a7=='input'and(type(w)=='table'and w.find~=nil and w.extract~=nil)then b.message('Specification format of input surrounding has changed.'..' Previous will work until next release (0.6.0). See `:h MiniSurround-surround-specification` '..'(section "Transition from previous specification") for more details.')local z,aa=w.extract:gsub('(%(.-%))','%1')local ab=0;local ac=w.extract:gsub('%(.-%)',function(a1)ab=ab+1;if ab==1 or ab==aa then return'()'..a1:sub(2,-2)..'()'end end)w={w.find,ac}end;if not b.is_surrounding_info(w,a7)then return nil end;if b.is_composed_pattern(w)then w=vim.tbl_map(b.wrap_callable_table,w)end;w=setmetatable(w,{__index={id=a9}})if a8 then b.cache[a7]=w end;return w end;b.make_surrounding_table=function()local ad=vim.tbl_deep_extend('force',b.builtin_surroundings,b.get_config().custom_surroundings or{})for a9,ae in pairs(ad)do local af=b.get_default_surrounding_info(a9)ad[a9]=vim.tbl_deep_extend('force',af,ae)end;return setmetatable(ad,{__index=function(z,t)return b.get_default_surrounding_info(t)end})end;b.get_default_surrounding_info=function(a9)local ag=vim.pesc(a9)return{input={ag..'().-()'..ag},output={left=a9,right=a9}}end;b.is_surrounding_info=function(a1,a7)if a7=='input'then return b.is_composed_pattern(a1)or b.is_region_pair(a1)or b.is_region_pair_array(a1)elseif a7=='output'then return type(a1)=='table'and type(a1.left)=='string'and type(a1.right)=='string'end end;b.is_region=function(a1)if type(a1)~='table'then return false end;local ah=type(a1.from)=='table'and type(a1.from.line)=='number'and type(a1.from.col)=='number'local ai=true;if a1.to~=nil then ai=type(a1.to)=='table'and type(a1.to.line)=='number'and type(a1.to.col)=='number'end;return ah and ai end;b.is_region_pair=function(a1)if type(a1)~='table'then return false end;return b.is_region(a1.left)and b.is_region(a1.right)end;b.is_region_pair_array=function(a1)if not vim.tbl_islist(a1)then return false end;for z,aj in ipairs(a1)do if not b.is_region_pair(aj)then return false end end;return true end;b.is_composed_pattern=function(a1)if not(vim.tbl_islist(a1)and#a1>0)then return false end;for z,ak in ipairs(a1)do local al=type(ak)if not(al=='table'or al=='string'or vim.is_callable(ak))then return false end end;return true end;b.find_surrounding=function(am,u)if am==nil then return end;if b.is_region_pair(am)then return am end;u=vim.tbl_deep_extend('force',b.get_default_opts(),u or{})b.validate_search_method(u.search_method,'search_method')local an=b.find_surrounding_region_pair(am,u)if an==nil then local a5=([[No surrounding '%s%s' found within %d line%s and `config.search_method = '%s'`.]]):format(u.n_times>1 and u.n_times or'',am.id,u.n_lines,u.n_lines>1 and's'or'',u.search_method)b.message(a5)end;return an end;b.find_surrounding_region_pair=function(am,u)local ao,ap,o=u.reference_region,u.n_times,u.n_lines;if ap==0 then return end;local aq=b.get_neighborhood(ao,0)local ar=aq.region_to_span(ao)local as=function(at)local w=b.find_best_match(aq,am,at,u)if w.span==nil then if o==0 or aq.n_neighbors>0 then return{}end;local au=aq.span_to_region(at)aq=b.get_neighborhood(ao,o)ar=aq.region_to_span(ao)at=aq.region_to_span(au)w=b.find_best_match(aq,am,at,u)end;return w end;local av={span=ar}for z=1,ap do av=as(av.span)if av.span==nil then return end end;local ac=function(aw,ax)if type(ax)=='table'then return ax end;local ay=aq['1d']:sub(aw.from,aw.to-1)local az=b.extract_surr_spans(ay,ax)local aA=aw.from-1;local P,Q=az.left,az.right;return{left={from=P.from+aA,to=P.to+aA},right={from=Q.from+aA,to=Q.to+aA}}end;local aB=ac(av.span,av.extract_pattern)local aC={from=aB.left.from,to=aB.right.to}if b.is_span_covering(ar,aC)then av=as(av.span)if av.span==nil then return end;aB=ac(av.span,av.extract_pattern)aC={from=aB.left.from,to=aB.right.to}if b.is_span_covering(ar,aC)then return end end;return{left=aq.span_to_region(aB.left),right=aq.span_to_region(aB.right)}end;b.get_default_opts=function()local c=b.get_config()local aD=vim.api.nvim_win_get_cursor(0)return{n_lines=c.n_lines,n_times=vim.v.count1,reference_region={from={line=aD[1],col=aD[2]+1}},search_method=b.cache.search_method or c.search_method}end;b.prepare_captures=function(x)local aE=function(a1)return type(a1)=='string'and a1:sub(1,1)=='@'end;if not(type(x)=='table'and aE(x.outer)and aE(x.inner))then b.error('Wrong format for `captures`. See `MiniSurround.gen_spec.input.treesitter()` for details.')end;return{outer=x.outer,inner=x.inner}end;b.get_matched_node_pairs_plugin=function(x)local aF=require('nvim-treesitter.query')local aG=require('nvim-treesitter.parsers')local aH={}local aI=aG.get_parser(0)if aI then aI:for_each_tree(function(aJ,aK)local aL=aK:lang()local aM=aF.get_capture_matches(0,x.outer,'textobjects',aJ:root(),aL)for z,Y in pairs(aM)do Y.lang=aL end;vim.list_extend(aH,aM)end)end;return vim.tbl_map(function(aN)local aO=aN.node;local aP=aF.get_capture_matches(0,x.inner,'textobjects',aO,aN.lang)local aQ=vim.tbl_map(function(a1)return a1.node end,aP)return{outer=aO,inner=b.get_biggest_node(aQ)}end,aH)end;b.get_matched_node_pairs_builtin=function(x)local aL=vim.bo.filetype;local v,aI=pcall(vim.treesitter.get_parser,0,aL)if not v then b.error_treesitter('parser',aL)end;local aR=vim.treesitter.get_query(aL,'textobjects')if aR==nil then b.error_treesitter('query',aL)end;local aS,aT=x.outer:sub(2),x.inner:sub(2)local aU={}for z,aJ in ipairs(aI:trees())do vim.list_extend(aU,b.get_builtin_matched_nodes(aS,aJ:root(),aR))end;return vim.tbl_map(function(aO)local aQ=b.get_builtin_matched_nodes(aT,aO,aR)return{outer=aO,inner=b.get_biggest_node(aQ)}end,aU)end;b.get_builtin_matched_nodes=function(aV,aW,aR)local w={}for aX,aY,z in aR:iter_captures(aW,0)do if aR.captures[aX]==aV then table.insert(w,aY)end end;return w end;b.get_biggest_node=function(aZ)local a_,b0=nil,-math.huge;for z,aY in ipairs(aZ)do local z,z,b1=aY:start()local z,z,b2=aY:end_()local b3=b2-b1+1;if b0<b3 then a_,b0=aY,b3 end end;return a_ end;b.error_treesitter=function(b4,aL)local b5=vim.api.nvim_get_current_buf()local a5=string.format([[Can not get %s for buffer %d and language '%s'.]],b4,b5,aL)b.error(a5)end;b.find_best_match=function(b6,am,ar,u)local b7,b8,b9;local ba=function(aw)if b.is_better_span(aw,b7,ar,u)then b7=aw;b8=b9 end end;if b.is_region_pair_array(am)then for z,an in ipairs(am)do local bb={from=an.left.from,to=an.right.to or an.right.from}if b6.is_region_inside(bb)then b9={{left=b6.region_to_span(an.left),right=b6.region_to_span(an.right)}}ba(b6.region_to_span(bb))end end else for z,bc in ipairs(b.cartesian_product(am))do b9=bc;b.iterate_matched_spans(b6['1d'],bc,ba)end end;local ax;if b8~=nil then ax=b8[#b8]end;return{span=b7,extract_pattern=ax}end;b.iterate_matched_spans=function(bd,bc,ba)local be=#bc;local bf={}local bg;bg=function(bh,bi,bj)local bk=bc[bh]local bl=function(ay,bm)return b.string_find(ay,bk,bm)end;if vim.is_callable(bk)then bl=bk end;local bn=type(bk)=='string'and bk:match('^%%b(.)%1$')~=nil;local bm=1;while bm<=bi:len()do local j,bo=bl(bi,bm)if j==nil then break end;if bh==be then local bp=b.new_span(j+bj,bo+bj)local bq=string.format('%s_%s',bp.from,bp.to)if not bf[bq]then ba(bp)bf[bq]=true end else local br=bi:sub(j,bo)local bs=bj+j-1;bg(bh+1,br,bs)end;bm=(bn and bo or j)+1 end end;bg(1,bd,0)end;b.new_span=function(j,bo)return{from=j,to=bo==nil and j or bo+1}end;b.is_better_span=function(bt,bu,bv,u)if b.is_span_covering(bv,bt)or b.is_span_equal(bt,bv)then return false end;return b.span_compare_methods[u.search_method](bt,bu,bv)end;b.span_compare_methods={cover=function(bt,bu,bv)local w=b.is_better_covering_span(bt,bu,bv)if w~=nil then return w end;return false end,cover_or_next=function(bt,bu,bv)local w=b.is_better_covering_span(bt,bu,bv)if w~=nil then return w end;if not b.is_span_on_left(bv,bt)then return false end;if bu==nil then return true end;local bw=b.span_distance.next;return bw(bt,bv)<bw(bu,bv)end,cover_or_prev=function(bt,bu,bv)local w=b.is_better_covering_span(bt,bu,bv)if w~=nil then return w end;if not b.is_span_on_left(bt,bv)then return false end;if bu==nil then return true end;local bw=b.span_distance.prev;return bw(bt,bv)<bw(bu,bv)end,cover_or_nearest=function(bt,bu,bv)local w=b.is_better_covering_span(bt,bu,bv)if w~=nil then return w end;if bu==nil then return true end;local bw=b.span_distance.near;return bw(bt,bv)<bw(bu,bv)end,next=function(bt,bu,bv)if b.is_span_covering(bt,bv)then return false end;if not b.is_span_on_left(bv,bt)then return false end;if bu==nil then return true end;local bw=b.span_distance.next;return bw(bt,bv)<bw(bu,bv)end,prev=function(bt,bu,bv)if b.is_span_covering(bt,bv)then return false end;if not b.is_span_on_left(bt,bv)then return false end;if bu==nil then return true end;local bw=b.span_distance.prev;return bw(bt,bv)<bw(bu,bv)end,nearest=function(bt,bu,bv)if b.is_span_covering(bt,bv)then return false end;if bu==nil then return true end;local bw=b.span_distance.near;return bw(bt,bv)<bw(bu,bv)end}b.span_distance={next=function(bx,by)return math.abs(bx.from-by.from)end,prev=function(bx,by)return math.abs(bx.to-by.to)end,near=function(bx,by)return math.min(math.abs(bx.from-by.from),math.abs(bx.to-by.to))end}b.is_better_covering_span=function(bt,bu,bv)local bz=b.is_span_covering(bt,bv)local bA=b.is_span_covering(bu,bv)if bz and bA then return bt.to-bt.from<bu.to-bu.from end;if bz and not bA then return true end;if not bz and bA then return false end;return nil end;b.is_span_covering=function(aw,bB)if aw==nil or bB==nil then return false end;if aw.from==aw.to then return aw.from==bB.from and bB.to==aw.to end;if bB.from==bB.to then return aw.from<=bB.from and bB.to<aw.to end;return aw.from<=bB.from and bB.to<=aw.to end;b.is_span_equal=function(bx,by)if bx==nil or by==nil then return false end;return bx.from==by.from and bx.to==by.to end;b.is_span_on_left=function(bx,by)if bx==nil or by==nil then return false end;return bx.from<=by.from and bx.to<=by.to end;b.is_point_inside_spans=function(bC,bD)for z,aw in ipairs(bD)do if aw[1]<=bC and bC<=aw[2]then return true end end;return false end;b.get_marks_pos=function(f)local bE,bF;if f=='visual'then bE,bF='<','>'else bE,bF='[',']'end;local bG=vim.api.nvim_buf_get_mark(0,bE)local bH=vim.api.nvim_buf_get_mark(0,bF)local bI=f=='line'or f=='visual'and vim.fn.visualmode()=='V'if bI then bG[2]=vim.fn.indent(bG[1])bH[2]=vim.fn.col({bH[1],'$'})-2 end;bG[2],bH[2]=bG[2]+1,bH[2]+1;local bJ=vim.fn.getline(bH[1])if f=='visual'and vim.o.selection=='exclusive'then bH[2]=bH[2]-1 else local bK=vim.str_utfindex(bJ,math.min(#bJ,bH[2]))bH[2]=vim.str_byteindex(bJ,bK)end;return{first={line=bG[1],col=bG[2]},second={line=bH[1],col=bH[2]}}end;b.set_cursor=function(bd,bL)vim.api.nvim_win_set_cursor(0,{bd,bL-1})end;b.compare_pos=function(bG,bH)if bG.line<bH.line then return'<'end;if bG.line>bH.line then return'>'end;if bG.col<bH.col then return'<'end;if bG.col>bH.col then return'>'end;return'='end;b.cursor_cycle=function(l,m)local aD=vim.api.nvim_win_get_cursor(0)aD={line=aD[1],col=aD[2]+1}local bM,bN,bO,bP;for z,bQ in pairs(l)do bM=b.compare_pos(aD,bQ)bN=bM=='>'and m=='left'bO=bP==nil and bM=='<'and m=='right'if bN or bO then bP=bQ end end;bP=bP or(m=='right'and l[1]or l[#l])b.set_cursor(bP.line,bP.col)end;b.user_surround_id=function(a7)local bR=true;vim.defer_fn(function()if not bR then return end;local a5=string.format('Enter %s surrounding identifier (single character) ',a7)b.echo(a5)b.cache.msg_shown=true end,1000)local v,a9=pcall(vim.fn.getchar)bR=false;b.unecho()if not v or a9==27 then return nil end;if type(a9)=='number'then a9=vim.fn.nr2char(a9)end;if a9:find('^[%w%p%s]$')==nil then b.message('Input must be single character: alphanumeric, punctuation, or space.')return nil end;return a9 end;b.pos_to_left=function(bQ)if bQ.line==1 and bQ.col==1 then return{line=bQ.line,col=bQ.col}end;if bQ.col==1 then return{line=bQ.line-1,col=b.get_line_cols(bQ.line-1)}end;return{line=bQ.line,col=bQ.col-1}end;b.pos_to_right=function(bQ)local bS=b.get_line_cols(bQ.line)if bQ.line==vim.api.nvim_buf_line_count(0)and bQ.col>bS then return{line=bQ.line,col=bS}end;if bQ.col>bS then return{line=bQ.line+1,col=1}end;return{line=bQ.line,col=bQ.col+1}end;b.region_replace=function(bT,q)local bU,bV=bT.from.line-1,bT.from.col-1;local bW,bX;if b.region_is_empty(bT)then bW,bX=bU,bV else bW,bX=bT.to.line-1,bT.to.col;if bW<vim.api.nvim_buf_line_count(0)and b.get_line_cols(bW+1)<bX then bW,bX=bW+1,0 end end;if type(q)=='string'then q={q}end;if#q>0 then q=vim.split(table.concat(q,'\n'),'\n')end;pcall(vim.api.nvim_buf_set_text,0,bU,bV,bW,bX,q)end;b.surr_to_pos_array=function(i)local w={}local bY=function(bQ,bZ)if bQ==nil then return end;if b.get_line_cols(bQ.line)<bQ.col and bQ.col>1 then bQ=bZ=='left'and b.pos_to_left(bQ)or b.pos_to_right(bQ)end;local bd,bL=bQ.line,bQ.col;local b_=w[#w]if not(b_~=nil and b_.line==bd and b_.col==bL)then table.insert(w,{line=bd,col=bL})end end;if not b.region_is_empty(i.left)then bY(i.left.from,'right')bY(i.left.to,'right')end;if not b.region_is_empty(i.right)then bY(i.right.from,'left')bY(i.right.to,'left')end;return w end;b.region_highlight=function(n,bT)if b.region_is_empty(bT)then return end;local c0=b.ns_id.highlight;local c1,c2,c3,c4=bT.from.line-1,bT.from.col-1,bT.to.line-1,bT.to.col;vim.highlight.range(n,c0,'MiniSurround',{c1,c2},{c3,c4})end;b.region_unhighlight=function(n,bT)local c0=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(n,c0,bT.from.line-1,(bT.to or bT.from).line)end;b.region_is_empty=function(bT)return bT.to==nil end;b.extract_surr_spans=function(ay,ax)local c5={ay:match(ax)}local c6=true;for z,bQ in ipairs(c5)do if type(bQ)~='number'then c6=false end end;local c7=c6 and(#c5==2 or#c5==4)if not c7 then local a5='Could not extract proper positions (two or four empty captures) from '..string.format([[string '%s' with extraction pattern '%s'.]],ay,ax)b.error(a5)end;if#c5==2 then return{left=b.new_span(1,c5[1]-1),right=b.new_span(c5[2],ay:len())}end;return{left=b.new_span(c5[1],c5[2]-1),right=b.new_span(c5[3],c5[4]-1)}end;b.get_neighborhood=function(ao,c8)local c1,c3=ao.from.line,(ao.to or ao.from).line;local c9=math.max(1,c1-c8)local ca=math.min(vim.api.nvim_buf_line_count(0),c3+c8)local cb=vim.api.nvim_buf_get_lines(0,c9-1,ca,false)for cc,aj in pairs(cb)do cb[cc]=aj..'\n'end;local cd=table.concat(cb,'')local ce=function(bQ)if bQ==nil then return nil end;local cf=c9;local cg=0;while cf<bQ.line do cg=cg+cb[cf-c9+1]:len()cf=cf+1 end;return cg+bQ.col end;local ch=function(cg)if cg==nil then return nil end;local cf=1;local ci=0;while cf<=#cb and ci+cb[cf]:len()<cg do ci=ci+cb[cf]:len()cf=cf+1 end;return{line=c9+cf-1,col=cg-ci}end;local cj=function(bT)if bT==nil then return nil end;local ck=bT.to==nil;local bo=bT.to or bT.from;return{from=ce(bT.from),to=ce(bo)+(ck and 0 or 1)}end;local cl=function(aw)if aw==nil then return nil end;local w={from=ch(aw.from)}if aw.from<aw.to then w.to=ch(aw.to-1)end;return w end;local cm=function(bT)local w=c9<=bT.from.line;if bT.to~=nil then w=w and bT.to.line<=ca end;return w end;return{n_neighbors=c8,region=ao,['1d']=cd,['2d']=cb,pos_to_offset=ce,offset_to_pos=ch,region_to_span=cj,span_to_region=cl,is_region_inside=cm}end;b.echo=function(a5,cn)a5=type(a5)=='string'and{{a5}}or a5;table.insert(a5,1,{'(mini.surround) ','WarningMsg'})local co=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local cp,cq={},0;for z,cr in ipairs(a5)do local cs={vim.fn.strcharpart(cr[1],0,co-cq),cr[2]}table.insert(cp,cs)cq=cq+vim.fn.strdisplaywidth(cs[1])if cq>=co then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(cp,cn,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(a5)b.echo(a5,true)end;b.error=function(a5)error(string.format('(mini.surround) %s',a5))end;b.map=function(f,t,W,u)if t==''then return end;u=vim.tbl_deep_extend('force',{noremap=true,silent=true},u or{})if vim.fn.has('nvim-0.7')==0 then u.desc=nil end;vim.api.nvim_set_keymap(f,t,W,u)end;b.get_line_cols=function(cf)return vim.fn.getline(cf):len()end;b.string_find=function(ay,bk,bm)bm=bm or 1;if bk:sub(1,1)=='^'then if bm>1 then return nil end;return string.find(ay,bk)end;local ct,z,cu=string.find(bk,'(.)%.%-')local cv=ct~=nil and cu~='%'if not cv then return string.find(ay,bk,bm)end;local j,bo=string.find(ay,bk,bm)if j==nil then return end;local cw,cx=j,bo;while cx==bo do j,bo=cw,cx;cw,cx=string.find(ay,bk,cw+1)end;return j,bo end;b.cartesian_product=function(cy)if not(type(cy)=='table'and#cy>0)then return{}end;cy=vim.tbl_map(function(a1)return vim.tbl_islist(a1)and a1 or{a1}end,cy)local w,cz={},{}local bg;bg=function(bh)for cA=1,#cy[bh]do table.insert(cz,cy[bh][cA])if bh==#cy then table.insert(w,vim.tbl_flatten(cz))else bg(bh+1)end;table.remove(cz,#cz)end end;bg(1)return w end;b.wrap_callable_table=function(a1)if vim.is_callable(a1)and type(a1)=='table'then return function(...)return a1(...)end end;return a1 end;return a
