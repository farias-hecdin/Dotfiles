local a={}local b;local c=require("staline.config")local d=require("staline.utils")local e=d.colorize;local f=c.defaults;local g=vim.fn.has('win32')==1 and"nul"or"/dev/null"local h=require("staline.widgets")local i=function()for j,k in pairs(vim.api.nvim_list_wins())do if vim.api.nvim_get_current_win()==k then vim.wo[k].statusline='%!v:lua.require\'staline\'.get_statusline("active")'elseif vim.api.nvim_buf_get_name(0)~=""then vim.wo[k].statusline='%!v:lua.require\'staline\'.get_statusline()'end end end;local l=function()local m=io.popen('git branch --show-current 2>'..g)local n=''if m~=nil then n=m:read("*l")or m:read("*a")m:close()end;a.Branch_name=n~=""and f.branch_symbol..n or""end;a.setup=function(o)if b then return else b=true end;for p,j in pairs(o or{})do for q,r in pairs(o[p])do c[p][q]=r end end;vim.api.nvim_create_autocmd('BufEnter',{callback=l})vim.api.nvim_create_autocmd({'BufEnter','BufReadPost','ColorScheme','TabEnter','TabClosed'},{callback=i})end;local s=function(t,u)e('Staline',t,u,f.font_active)e('StalineFill',f.fg,t,f.font_active)e('StalineNone',nil,u)e('DoubleSep',t,f.inactive_color)e('MidSep',f.inactive_color,u)end;local v=function()local w=""for type,x in pairs(c.lsp_symbols)do local y=#vim.diagnostic.get(0,{severity=type})local z=f.true_colors and"%#DiagnosticSign"..type.."#"or" "local A=y>0 and z..x..y.." "or""w=w..A end;return w end;local B=function()local C=require('null-ls').get_sources()local D={}for j,E in pairs(C)do if E.filetypes[vim.bo.ft]then if not vim.tbl_contains(D,E.name)then table.insert(D,E.name)end end end;return D end;local F=function()local G={}for j,H in pairs(vim.lsp.get_active_clients())do if f.expand_null_ls then if H.name=='null-ls'then for j,E in pairs(B())do G[#G+1]=E..f.null_ls_symbol end else G[#G+1]=H.name end else G[#G+1]=f.lsp_client_symbol..H.name end end;return table.concat(G,', ')end;local I=function(J)local K=type(J)if K=='string'then if string.match(J,"^-")then J=J:match("^-(.+)")return"%#StalineFill#"..(a.sections[J]or J)else return"%#Staline#"..(a.sections[J]or J)end elseif K=='function'then local L=J()if type(L)=="string"then return L elseif type(L)=="table"then return"%#"..L[1].."#"..L[2]end elseif K=='table'then if#J==1 then return J[1]elseif#J==2 then if type(J[2])=='string'then return"%#"..J[1].."#"..(a.sections[J[2]]or J[2])elseif type(J[2])=='function'then return"%#"..J[1].."#"..J[2]()end end else vim.api.nvim_err_writeln("[staline.nvim]: Section format error!")end end;a.get_statusline=function(M)if c.special_table[vim.bo.ft]~=nil then local N=c.special_table[vim.bo.ft]return"%#Staline#%="..N[2]..N[1].."%="end;a.sections={}local O=vim.api.nvim_get_mode()['mode']local P=M and c.mode_colors[O]or f.inactive_color;local Q=M and f.bg or f.inactive_bgcolor;local R=c.mode_icons[O]or"ïŸ› "local S=f.full_path and'%F'or'%t'local T=d.get_file_icon(vim.fn.expand('%:t'),vim.fn.expand('%:e'))local U=vim.bo.mod and f.mod_symbol or""local V=("%.1f"):format(vim.fn.getfsize(vim.api.nvim_buf_get_name(0))/1024)s(P,Q)a.sections['clock']=" "..h.app_clock().." "a.sections['counter']=" "..h.app_counter().." "a.sections['lazy']=" "..h.app_lazy().." "a.sections['mode']=" "..R.." "a.sections['branch']=" "..(a.Branch_name or"").." "a.sections['file_name']=" "..T.." "..S..U.." "a.sections['file_size']=" "..V.."k "a.sections['cool_symbol']=" "..f.cool_symbol.." "a.sections['line_column']=" "..f.line_column.." "a.sections['left_sep']=f.left_separator;a.sections['right_sep']=f.right_separator;a.sections['left_sep_double']="%#DoubleSep#"..f.left_separator.."%#MidSep#"..f.left_separator;a.sections['right_sep_double']="%#MidSep#"..f.right_separator.."%#DoubleSep#"..f.right_separator;a.sections['lsp']=v()a.sections['diagnostics']=v()a.sections['lsp_name']=F()a.sections['cwd']=" "..vim.fn.fnamemodify(vim.fn.getcwd(),':t').." "local W=""for j,X in ipairs({'left','mid','right'})do for j,J in pairs(c.sections[X])do W=W..I(J).."%#StalineNone#"end;if X~='right'then W=W.."%="end end;return W end;return a
