local a=require("todo-comments.config")local b={}b.enabled=false;b.bufs={}b.wins={}b.state={}function b.match(c,d)local e=a.options.highlight.max_line_len;if e and#c>e then return end;d=d or a.hl_regex;if not type(d)=="table"then d={d}end;for f,g in pairs(d)do local h=vim.fn.matchlist(c,[[\v\C]]..g)if#h>1 and h[2]then local i=h[2]local j=c:find(i)return j,j+#i,i end end end;function b.is_comment(k,l,m)if vim.treesitter.highlighter.active[k]then local n=vim.treesitter.get_captures_at_pos(k,l,m)for f,o in ipairs(n)do if o.capture=="comment"then return true end end else local p=vim.fn.bufwinid(k)return p~=-1 and vim.api.nvim_win_call(p,function()for f,q in ipairs(vim.fn.synstack(l+1,m))do local r=vim.fn.synIDtrans(q)local s=vim.fn.synIDattr(q,"name")local t=vim.fn.synIDattr(r,"name")if s=="Comment"or t=="Comment"then return true end end end)end end;local function u(v,w,x,y,z,A)vim.api.nvim_buf_add_highlight(v,w,x,y,z,A)end;function b.get_state(k)if not b.state[k]then b.state[k]={dirty={},comments={}}end;return b.state[k]end;function b.redraw(k,B,C)B=math.max(B-a.options.highlight.multiline_context,0)C=math.min(C+a.options.highlight.multiline_context,vim.api.nvim_buf_line_count(k))local D=b.get_state(k)for E=B,C do D.dirty[E]=true end;if not b.timer then b.timer=vim.defer_fn(b.update,a.options.highlight.throttle)end end;b.timer=nil;function b.update()b.timer=nil;for k,D in pairs(b.state)do if vim.api.nvim_buf_is_valid(k)then if not vim.tbl_isempty(D.dirty)then local F=vim.tbl_keys(D.dirty)table.sort(F)local E=1;while E<=#F do local B=F[E]local C=F[E]while F[E+1]==F[E]+1 do E=E+1;C=F[E]end;b.highlight(k,B,C)E=E+1 end;D.dirty={}end else b.state[k]=nil end end end;function b.highlight(k,B,C,G)if not vim.api.nvim_buf_is_valid(k)then return end;vim.api.nvim_buf_clear_namespace(k,a.ns,B,C+1)for f,H in pairs(vim.fn.sign_getplaced(k,{group="todo-signs"})[1].signs)do if H.lnum-1>=B and H.lnum-1<=C then vim.fn.sign_unplace("todo-signs",{buffer=k,id=H.id})end end;local I=vim.api.nvim_buf_get_lines(k,B,C+1,false)local J;for K,y in ipairs(I)do local L,j,M,i=pcall(b.match,y)local N=B+K-1;if L and j then if a.options.highlight.comments_only and not b.is_quickfix(k)and not b.is_comment(k,N,j-1)then i=nil else J={kw=i,start=j}end end;local O=false;if not i and J and a.options.highlight.multiline then if b.is_comment(k,N,J.start)and y:find(a.options.highlight.multiline_pattern,J.start)then i=J.kw;j=J.start;M=j;O=true else J=nil end end;if i then i=a.keywords[i]or i end;local P=a.options.keywords[i]if P then j=j-1;M=M-1;local Q="TodoFg"..i;local R="TodoBg"..i;local x=a.options.highlight;if not O then if x.before=="fg"then u(k,a.ns,Q,N,0,j)elseif x.before=="bg"then u(k,a.ns,R,N,0,j)end;if x.keyword=="wide"or x.keyword=="wide_bg"then u(k,a.ns,R,N,math.max(j-1,0),M+1)elseif x.keyword=="wide_fg"then u(k,a.ns,Q,N,math.max(j-1,0),M+1)elseif x.keyword=="bg"then u(k,a.ns,R,N,j,M)elseif x.keyword=="fg"then u(k,a.ns,Q,N,j,M)end end;if x.after=="fg"then u(k,a.ns,Q,N,M,#y)elseif x.after=="bg"then u(k,a.ns,R,N,M,#y)end;if not O then local S=a.options.signs;if P.signs~=nil then S=P.signs end;if S then vim.fn.sign_place(0,"todo-signs","todo-sign-"..i,k,{lnum=N+1,priority=a.options.sign_priority})end end end end end;function b.highlight_win(p,T)p=p or vim.api.nvim_get_current_win()if T~=true and not b.is_valid_win(p)then return end;vim.api.nvim_win_call(p,function()local k=vim.api.nvim_win_get_buf(p)local B=vim.fn.line("w0")-1;local C=vim.fn.line("w$")b.redraw(k,B,C)end)end;function b.is_float(p)local P=vim.api.nvim_win_get_config(p)return P and P.relative and P.relative~=""end;function b.is_valid_win(p)if not vim.api.nvim_win_is_valid(p)then return false end;if vim.fn.getcmdwintype()~=""then return false end;if b.is_float(p)then return false end;local k=vim.api.nvim_win_get_buf(p)return b.is_valid_buf(k)end;function b.is_quickfix(k)return vim.api.nvim_buf_get_option(k,"buftype")=="quickfix"end;function b.is_valid_buf(k)local U=vim.api.nvim_buf_get_option(k,"buftype")if U~=""and U~="quickfix"then return false end;local V=vim.api.nvim_buf_get_option(k,"filetype")if vim.tbl_contains(a.options.highlight.exclude,V)then return false end;return true end;function b.attach(p)p=p or vim.api.nvim_get_current_win()if not b.is_valid_win(p)then return end;local k=vim.api.nvim_win_get_buf(p)if not b.bufs[k]then vim.api.nvim_buf_attach(k,false,{on_lines=function(G,W,X,B,Y,Z)if not b.enabled then return true end;if not b.is_valid_buf(k)then return true end;b.redraw(k,B,Z)end,on_detach=function()b.state[k]=nil;b.bufs[k]=nil end})local _=require("vim.treesitter.highlighter")local x=_.active[k]if x then x.tree:register_cbs({on_bytes=function(f,f,l)b.redraw(k,l,l+1)end,on_changedtree=function(a0)for f,a1 in ipairs(a0 or{})do b.redraw(k,a1[1],a1[3]+1)end end})end;b.bufs[k]=true;b.highlight_win(p)b.wins[p]=true elseif not b.wins[p]then b.highlight_win(p)b.wins[p]=true end end;function b.stop()b.enabled=false;pcall(vim.cmd,"autocmd! Todo")pcall(vim.cmd,"augroup! Todo")b.wins={}vim.fn.sign_unplace("todo-signs")for k,f in pairs(b.bufs)do if vim.api.nvim_buf_is_valid(k)then pcall(vim.api.nvim_buf_clear_namespace,k,a.ns,0,-1)end end;b.bufs={}end;function b.start()if b.enabled then b.stop()end;b.enabled=true;vim.api.nvim_exec([[augroup Todo
        autocmd!
        autocmd BufWinEnter,WinNew * lua require("todo-comments.highlight").attach()
        autocmd BufWritePost * silent! lua require'trouble'.refresh({auto = true, provider = "todo"})
        autocmd WinScrolled * lua require("todo-comments.highlight").highlight_win()
        autocmd ColorScheme * lua vim.defer_fn(require("todo-comments.config").colors, 10)
      augroup end]],false)for f,p in pairs(vim.api.nvim_list_wins())do b.attach(p)end end;return b
