local a=require('Comment.ft')local b=vim.api;local c={}c.cmode={toggle=0,comment=1,uncomment=2}c.ctype={linewise=1,blockwise=2}c.cmotion={line=1,char=2,block=3,v=4,V=5}function c.is_empty(d)return#d==0 end;function c.get_pad(e)return e and' 'or''end;function c.get_padpat(e)return e and'%s?'or''end;function c.is_fn(f,...)if type(f)=='function'then return f(...)end;return f end;function c.ignore(g,h)return h and string.find(g,h)~=nil end;function c.get_region(i)if not i then local j=unpack(b.nvim_win_get_cursor(0))return{srow=j,scol=0,erow=j,ecol=0}end;local k=string.match(i,'[vV]')and{'<','>'}or{'[',']'}local l,m=b.nvim_buf_get_mark(0,k[1]),b.nvim_buf_get_mark(0,k[2])return{srow=l[1],scol=l[2],erow=m[1],ecol=m[2]}end;function c.get_count_lines(n)local o=unpack(b.nvim_win_get_cursor(0))local p=o+n-1;local q=b.nvim_buf_get_lines(0,o-1,p,false)return q,{srow=o,scol=0,erow=p,ecol=0}end;function c.get_lines(r)if r.srow==r.erow then return{b.nvim_get_current_line()}end;return b.nvim_buf_get_lines(0,r.srow-1,r.erow,false)end;function c.unwrap_cstr(s)local t,u=string.match(s,'(.*)%%s(.*)')assert(t or u,{msg=string.format('Invalid commentstring for %s! Read `:h commentstring` for help.',vim.bo.filetype)})return vim.trim(t),vim.trim(u)end;function c.parse_cstr(v,w)local x=c.is_fn(v.pre_hook,w)or a.calculate(w)assert(x or w.ctype~=c.ctype.blockwise,{msg=vim.bo.filetype.." doesn't support block comments!"})return c.unwrap_cstr(x or vim.bo.commentstring)end;function c.commenter(t,u,y,z,A,B)local C=c.get_pad(y)local D=c.is_empty(t)and t or t..C;local E=c.is_empty(u)and u or C..u;local F=string.rep(B and'\t'or' ',z or 0)..t..u;local G=z and not A;return function(H)if G then if c.is_empty(H)then return F end;if z==0 then return D..H..E end;local I=string.sub(H,0,z)local J=string.sub(H,z+1,-1)return I..D..J..E end;if type(H)=='table'then local I,J=H[1],H[#H]if z and A then local K=string.sub(I,0,z)local L=string.sub(I,z+1,-1)local M=string.sub(J,0,A+1)local N=string.sub(J,A+2,-1)H[1]=K..D..L;H[#H]=M..E..N else H[1]=c.is_empty(I)and t or string.gsub(I,'^(%s*)','%1'..vim.pesc(D))H[#H]=c.is_empty(J)and u or J..E end;return H end;if A>#H then return D..H..E end;local I=string.sub(H,0,z)local O=string.sub(H,z+1,A+1)local J=string.sub(H,A+2,-1)return I..D..O..E..J end end;function c.uncommenter(t,u,y,z,A)local P,Q=c.get_padpat(y),y and 1 or 0;local R,S=#t+Q,#u+Q;local D=c.is_empty(t)and t or vim.pesc(t)..P;local E=c.is_empty(u)and u or P..vim.pesc(u)local G=not(z and z)local T=G and'^(%s*)'..D..'(.-)'..E..'$'or''return function(H)if type(H)=='table'then local I,J=H[1],H[#H]if z and A then local K=string.sub(I,0,z)local L=string.sub(I,z+R+1,-1)local M=string.sub(J,0,A-S+1)local N=string.sub(J,A+2,-1)H[1]=K..L;H[#H]=M..N else H[1]=string.gsub(I,'^(%s*)'..D,'%1')H[#H]=string.gsub(J,E..'$','')end;return H end;if G then local U,V,W=string.match(H,T)assert(U and V,{msg='Nothing to uncomment!'})return c.is_empty(V)and V or U..V..(W or'')end;if A>#H then return string.sub(H,z+R+1,#H-S)end;local I=string.sub(H,0,z)local O=string.sub(H,z+R+1,A-S+1)local J=string.sub(H,A+2,-1)return I..O..J end end;function c.is_commented(t,u,y,z,A)local P=c.get_padpat(y)local D=c.is_empty(t)and t or'^%s*'..vim.pesc(t)..P;local E=c.is_empty(u)and u or P..vim.pesc(u)..'$'local T=D..'.-'..E;local X=z==nil or A==nil;return function(H)if type(H)=='table'then local I,J=H[1],H[#H]if X then return(string.find(I,D)and string.find(J,E))~=nil end;return(string.find(string.sub(I,z+1,-1),D)and string.find(string.sub(J,0,A+1),E))~=nil end;if X then return string.find(H,T)~=nil end;return string.find(string.sub(H,z+1,A>#H and#H or A+1),T)~=nil end end;function c.catch(f,...)xpcall(f,function(Y)vim.notify(string.format('[Comment.nvim] %s',Y.msg),vim.log.levels.WARN)end,...)end;return c
