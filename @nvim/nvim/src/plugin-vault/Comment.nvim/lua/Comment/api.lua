local a=require('Comment.config')local b=require('Comment.utils')local c=require('Comment.opfunc')local d=require('Comment.extra')local e=vim.api;local f,g={},{}function g.__index(h,i)local j={}local k,l=h.cmode,b.ctype[i]function j.current(m,n)b.catch(c.opfunc,nil,n or a:get(),k,l)end;function j.count(o,n)b.catch(c.count,o or e.nvim_get_vvar('count'),n or a:get(),k,l)end;function j.count_repeat(m,o,n)j.count(o,n)end;return setmetatable({},{__index=j,__call=function(m,p,n)b.catch(c.opfunc,p,n or a:get(),k,l)end})end;f.toggle=setmetatable({cmode=b.cmode.toggle},g)f.comment=setmetatable({cmode=b.cmode.comment},g)f.uncomment=setmetatable({cmode=b.cmode.uncomment},g)f.insert=setmetatable({},{__index=function(m,i)return{above=function(n)b.catch(d.insert_above,b.ctype[i],n or a:get())end,below=function(n)b.catch(d.insert_below,b.ctype[i],n or a:get())end,eol=function(n)b.catch(d.insert_eol,b.ctype[i],n or a:get())end}end})function f.locked(q)return function(p)return e.nvim_command(('lockmarks lua require("Comment.api").%s(%s)'):format(q,p and('%q'):format(p)))end end;function f.call(q,r)return function()e.nvim_set_option('operatorfunc',("v:lua.require'Comment.api'.locked'%s'"):format(q))a.position=a:get().sticky and e.nvim_win_get_cursor(0)or nil;return r end end;return f
