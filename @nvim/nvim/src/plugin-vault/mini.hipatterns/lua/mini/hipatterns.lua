local a={}local b={}a.setup=function(c)_G.MiniHipatterns=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands()for d,e in ipairs(vim.api.nvim_list_wins())do b.auto_enable({buf=vim.api.nvim_win_get_buf(e)})end;b.create_default_hl()end;a.config={highlighters={},delay={text_change=200,scroll=50}}a.enable=function(f,c)f=b.validate_buf_id(f)c=b.validate_config_arg(c)if b.is_buf_enabled(f)then return end;b.update_cache(f,c)vim.api.nvim_buf_attach(f,false,{on_lines=function(d,d,d,g,d,h)local i=b.cache[f]if i==nil then return true end;b.process_lines(f,g+1,h,i.delay.text_change)end,on_reload=function()pcall(a.update,f)end,on_detach=function()a.disable(f)end})local j=vim.api.nvim_create_augroup('MiniHipatternsBuffer'..f,{clear=true})b.cache[f].augroup=j;local k=vim.schedule_wrap(function()if not b.is_buf_enabled(f)then return end;b.update_cache(f,c)local l=b.cache[f].delay.text_change;b.process_lines(f,1,vim.api.nvim_buf_line_count(f),l)end)vim.api.nvim_create_autocmd({'BufWinEnter','FileType'},{group=j,buffer=f,callback=k,desc='Update highlighting for whole buffer'})vim.api.nvim_create_autocmd('WinScrolled',{group=j,buffer=f,callback=b.update_view,desc='Update highlighting in view'})b.process_lines(f,1,vim.api.nvim_buf_line_count(f),0)end;a.disable=function(f)f=b.validate_buf_id(f)local i=b.cache[f]if i==nil then return end;b.cache[f]=nil;vim.api.nvim_del_augroup_by_id(i.augroup)vim.api.nvim_buf_clear_namespace(f,b.ns_id.highlight,0,-1)end;a.toggle=function(f,c)f=b.validate_buf_id(f)c=b.validate_config_arg(c)if b.is_buf_enabled(f)then a.disable(f)else a.enable(f,c)end end;a.update=function(f,g,h)f=b.validate_buf_id(f)if not b.is_buf_enabled(f)then b.error(string.format('Buffer %d is not enabled.',f))end;g=g or 1;if type(g)~='number'then b.error('`from_line` should be a number.')end;h=h or vim.api.nvim_buf_line_count(f)if type(h)~='number'then b.error('`to_line` should be a number.')end;b.process_lines(f,g,h,0)end;a.get_enabled_buffers=function()local m={}for f,d in pairs(b.cache)do if vim.api.nvim_buf_is_valid(f)then table.insert(m,f)else b.cache[f]=nil end end;table.sort(m)return m end;a.gen_highlighter={}a.gen_highlighter.hex_color=function(n)n=vim.tbl_deep_extend('force',{style='full',priority=200,filter=b.always_true},n or{})local o=n.style=='#'and'()#()%x%x%x%x%x%x%f[%X]'or'#%x%x%x%x%x%x%f[%X]'local p=n.style=='line'and'line'or'bg'return{pattern=b.wrap_pattern_with_filter(o,n.filter),group=function(d,d,q)return a.compute_hex_color_group(q.full_match,p)end,priority=n.priority}end;a.compute_hex_color_group=function(r,p)local s=r:lower():sub(2)local t='MiniHipatterns'..s;if b.hex_color_groups[t]then return t end;if p=='bg'then local u=b.compute_opposite_color(s)vim.api.nvim_set_hl(0,t,{fg=u,bg=r})end;if p=='line'then vim.api.nvim_set_hl(0,t,{sp=r,underline=true})end;b.hex_color_groups[t]=true;return t end;b.default_config=a.config;b.timer_debounce=vim.loop.new_timer()b.timer_view=vim.loop.new_timer()b.ns_id={highlight=vim.api.nvim_create_namespace('MiniHipatternsHighlight')}b.change_queue={}b.cache={}b.hex_color_groups={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({highlighters={c.highlighters,'table'},delay={c.delay,'table'}})vim.validate({['delay.text_change']={c.delay.text_change,'number'},['delay.scroll']={c.delay.scroll,'number'}})return c end;b.apply_config=function(c)a.config=c end;b.create_autocommands=function()local j=vim.api.nvim_create_augroup('MiniHipatterns',{})local v=function(w,o,x,y)vim.api.nvim_create_autocmd(w,{group=j,pattern=o,callback=x,desc=y})end;v('BufEnter','*',b.auto_enable,'Enable highlighting')v('ColorScheme','*',b.on_colorscheme,'Reload all enabled pattern highlighters')end;b.create_default_hl=function()vim.api.nvim_set_hl(0,'MiniHipatternsFixme',{default=true,link='DiagnosticError'})vim.api.nvim_set_hl(0,'MiniHipatternsHack',{default=true,link='DiagnosticWarn'})vim.api.nvim_set_hl(0,'MiniHipatternsTodo',{default=true,link='DiagnosticInfo'})vim.api.nvim_set_hl(0,'MiniHipatternsNote',{default=true,link='DiagnosticHint'})end;b.is_disabled=function(f)local z=b.get_buf_var(f,'minihipatterns_disable')return vim.g.minihipatterns_disable==true or z==true end;b.get_config=function(c,f)local A=b.get_buf_var(f,'minihipatterns_config')or{}return vim.tbl_deep_extend('force',a.config,A,c or{})end;b.get_buf_var=function(f,B)if not vim.api.nvim_buf_is_valid(f)then return nil end;return vim.b[f or 0][B]end;b.auto_enable=vim.schedule_wrap(function(q)if b.is_buf_enabled(q.buf)then return end;if vim.api.nvim_buf_is_valid(q.buf)and vim.bo[q.buf].buftype==''then a.enable(q.buf)end end)b.update_view=vim.schedule_wrap(function(q)local i=b.cache[q.buf]if i==nil then return end;b.timer_view:stop()b.timer_view:start(i.delay.scroll,0,b.process_view)end)b.on_colorscheme=function()b.hex_color_groups={}for f,d in pairs(b.cache)do a.disable(f)a.enable(f)end end;b.validate_buf_id=function(C)if C==nil or C==0 then return vim.api.nvim_get_current_buf()end;if not(type(C)=='number'and vim.api.nvim_buf_is_valid(C))then b.error('`buf_id` should be `nil` or valid buffer id.')end;return C end;b.validate_config_arg=function(C)if C==nil or type(C)=='table'then return C or{}end;b.error('`config` should be `nil` or table.')end;b.validate_string=function(C,B)if type(C)=='string'then return C end;b.error(string.format('`%s` should be string.'))end;b.is_buf_enabled=function(f)return b.cache[f]~=nil end;b.update_cache=function(f,c)local i=b.cache[f]or{}local A=b.get_config(c,f)i.highlighters=b.normalize_highlighters(A.highlighters)i.delay=A.delay;b.cache[f]=i end;b.normalize_highlighters=function(D)local m={}for d,E in pairs(D)do local o=type(E.pattern)=='string'and function(...)return E.pattern end or E.pattern;local F=type(E.group)=='string'and function(...)return E.group end or E.group;local G=E.priority or 200;if vim.is_callable(o)and vim.is_callable(F)and type(G)=='number'then table.insert(m,{pattern=o,group=F,priority=G})end end;return m end;b.process_lines=vim.schedule_wrap(function(f,g,h,l)table.insert(b.change_queue,{f,g,h})b.timer_debounce:stop()b.timer_debounce:start(l,0,b.process_change_queue)end)b.process_view=vim.schedule_wrap(function()table.insert(b.change_queue,{vim.api.nvim_get_current_buf(),vim.fn.line('w0'),vim.fn.line('w$')})b.process_change_queue()end)b.process_change_queue=vim.schedule_wrap(function()local H=b.normalize_change_queue()for f,I in pairs(H)do b.process_buffer_changes(f,I)end;b.change_queue={}end)b.normalize_change_queue=function()local m={}for d,J in ipairs(b.change_queue)do local f=J[1]local K=m[f]or{}for L=J[2],J[3]do K[L]=true end;m[f]=K end;return m end;b.process_buffer_changes=vim.schedule_wrap(function(f,I)local i=b.cache[f]if not vim.api.nvim_buf_is_valid(f)or b.is_disabled(f)or i==nil then return end;local M=b.ns_id.highlight;for N,d in pairs(I)do vim.api.nvim_buf_clear_namespace(f,M,N-1,N)end;local D=i.highlighters;for d,E in ipairs(D)do b.apply_highlighter(E,f,I)end end)b.apply_highlighter=vim.schedule_wrap(function(E,f,I)local o,F=E.pattern(f),E.group;if type(o)~='string'then return end;local O=o:sub(1,1)=='^'local M=b.ns_id.highlight;local P={priority=E.priority}for N,d in pairs(I)do local Q=b.get_line(f,N)local R,S,T,U=Q:find(o)while R and R<=S do local V=Q:sub(R,S)T,U=T or R,U or S+1;U=U-1;local W=Q:sub(T,U)P.hl_group=F(f,W,{full_match=V,line=N,from_col=T,to_col=U})P.end_col=U;if P.hl_group~=nil then b.set_extmark(f,M,N-1,T-1,P)end;if O then break end;R,S,T,U=Q:find(o,S+1)end end end)b.wrap_pattern_with_filter=function(o,X)return function(...)if not X(...)then return nil end;return o end end;b.compute_opposite_color=function(s)local Y=tonumber(s,16)local Z=b.correct_channel(math.fmod(Y,256)/255)local _=b.correct_channel(math.fmod((Y-Z)/256,256)/255)local a0=b.correct_channel(math.floor(Y/65536)/255)local a1=0.4122214708*a0+0.5363325363*_+0.0514459929*Z;local a2=0.2119034982*a0+0.6806995451*_+0.1073969566*Z;local a3=0.0883024619*a0+0.2817188376*_+0.6299787005*Z;local a4,a5,a6=b.cuberoot(a1),b.cuberoot(a2),b.cuberoot(a3)local a7=b.correct_lightness(0.2104542553*a4+0.7936177850*a5-0.0040720468*a6)return a7<0.5 and'#ffffff'or'#000000'end;b.correct_channel=function(C)return 0.04045<C and math.pow((C+0.055)/1.055,2.4)or C/12.92 end;b.correct_lightness=function(C)local a8,a9=0.206,0.03;local aa=(1+a8)/(1+a9)return 0.5*(aa*C-a8+math.sqrt((aa*C-a8)^2+4*a9*aa*C))end;b.error=function(ab)error(string.format('(mini.hipatterns) %s',ab),0)end;b.get_line=function(f,ac)return vim.api.nvim_buf_get_lines(f,ac-1,ac,false)[1]or''end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.always_true=function()return true end;b.cuberoot=function(C)return math.pow(C,0.333333)end;return a
