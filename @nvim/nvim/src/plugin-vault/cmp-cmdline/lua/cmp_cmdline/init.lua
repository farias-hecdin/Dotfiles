local a=require('cmp')local function b(c,d)local e=[[\%(]]..table.concat(c,[[\|]])..[[\)]]if d then e='^'..e end;return vim.regex(e)end;local f={ignore_cmds={'Man','!'}}local g=b({[=[\s*abo\%[veleft]\s*]=],[=[\s*bel\%[owright]\s*]=],[=[\s*bo\%[tright]\s*]=],[=[\s*bro\%[wse]\s*]=],[=[\s*conf\%[irm]\s*]=],[=[\s*hid\%[e]\s*]=],[=[\s*keepal\s*t]=],[=[\s*keeppa\%[tterns]\s*]=],[=[\s*lefta\%[bove]\s*]=],[=[\s*loc\%[kmarks]\s*]=],[=[\s*nos\%[wapfile]\s*]=],[=[\s*rightb\%[elow]\s*]=],[=[\s*sil\%[ent]\s*]=],[=[\s*tab\s*]=],[=[\s*to\%[pleft]\s*]=],[=[\s*verb\%[ose]\s*]=],[=[\s*vert\%[ical]\s*]=]},true)local h=b({[=[\s*\%(\d\+\|\$\)\%[,\%(\d\+\|\$\)]\s*]=],[=[\s*'\%[<,'>]\s*]=],[=[\s*\%(\d\+\|\$\)\s*]=]},true)local i=b({[=[^\s*\%(\d\+\|\$\)\%[,\%(\d\+\|\$\)]\s*$]=],[=[^\s*'\%[<,'>]\s*$]=],[=[^\s*\%(\d\+\|\$\)\s*$]=]},true)local j=b({[=[se\%[tlocal][^=]*$]=]},true)local function k(l)local m,n=pcall(function()return vim.opt[l]:get()end)if m then return type(n)=='boolean'end end;local o={{ctype='cmdline',regex=[=[[^[:blank:]]*$]=],kind=a.lsp.CompletionItemKind.Variable,isIncomplete=true,exec=function(p,q,r,s)if not s and i:match_str(r)then return{}end;local t,u=pcall(function()local v=r;local w,x=h:match_str(v)if w and x then v=v:sub(x+1)end;return vim.api.nvim_parse_cmd(v,{})or{}end)u=u or{}if vim.tbl_contains(p.ignore_cmds,u.cmd)then return{}end;if q~=r then while true do local w,x=g:match_str(r)if w==nil then break end;r=string.sub(r,x+1)end end;local y;do local z=vim.regex([[\h\w*$]]):match_str(q)y=string.sub(q,1,z or#q)end;local A=j:match_str(r)~=nil;local B={}local C=r:gsub([[\\]],[[\\\\]])for t,D in ipairs(vim.fn.getcompletion(C,'cmdline'))do local l=type(D)=='string'and D or D.word;local E={label=l}table.insert(B,E)if A and k(l)then table.insert(B,vim.tbl_deep_extend('force',{},E,{label='no'..l,filterText=l}))end end;for t,E in ipairs(B)do if not string.find(E.label,y,1,true)then E.label=y..E.label end end;return B end}}local F={}F.new=function()return setmetatable({before_line='',offset=-1,ctype='',items={}},{__index=F})end;F.get_keyword_pattern=function()return[=[[^[:blank:]]*]=]end;F.get_trigger_characters=function()return{' ','.','#','-'}end;F.complete=function(self,G,H)local I=0;local J=''local B={}local K;local L=false;for t,M in ipairs(o)do local w,x=vim.regex(M.regex):match_str(G.context.cursor_before_line)if w and x then I=w;J=M.ctype;B=M.exec(vim.tbl_deep_extend('keep',G.option or{},f),string.sub(G.context.cursor_before_line,w+1),G.context.cursor_before_line,G.context:get_reason()==a.ContextReason.Manual)K=M.kind;L=M.isIncomplete;if not(#B==0 and M.fallback)then break end end end;local N={}for t,E in ipairs(B)do E.kind=K;N[E.label]=true end;local O=false;if#G.context.cursor_before_line>#self.before_line then O=string.find(G.context.cursor_before_line,self.before_line,1,true)==1 elseif#G.context.cursor_before_line<#self.before_line then O=string.find(self.before_line,G.context.cursor_before_line,1,true)==1 end;if O and self.offset==I and self.ctype==J then for t,E in ipairs(self.items)do if not N[E.label]then table.insert(B,E)end end end;self.before_line=G.context.cursor_before_line;self.offset=I;self.ctype=J;self.items=B;H({isIncomplete=L,items=B})end;return F
