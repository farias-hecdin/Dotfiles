local a=require("which-key.config")local b=require("which-key.text")local c=require("which-key.keys")local d=require("which-key.util")local e={}e.__index=e;function e:new(f,g)g=g or a.options;local h={results=f,mapping=f.mapping,items=f.mappings,options=g,text=b:new()}setmetatable(h,self)return h end;function e:max_width(i)local j=0;for k,l in pairs(self.items)do if l[i]and b.len(l[i])>j then j=b.len(l[i])end end;return j end;function e:trail()local m=self.results.prefix_i;local n=c.get_tree(self.results.mode,self.results.buf).tree:path(m)local o=c.get_tree(self.results.mode).tree:path(m)local p=#self.results.mapping.keys.notation;local q={{" "}}for r=1,p,1 do local s=n[r]if not(s and s.mapping and s.mapping.label)then s=o[r]end;local t=self.mapping.keys.notation[r]if s and s.mapping and s.mapping.label then t=self.options.icons.group..s.mapping.label end;if a.options.key_labels[t]then t=a.options.key_labels[t]end;if a.options.show_keys then table.insert(q,{t,"WhichKeyGroup"})if r~=#self.mapping.keys.notation then table.insert(q,{" "..self.options.icons.breadcrumb.." ","WhichKeySeparator"})end end end;local u=0;if a.options.show_keys then for k,v in pairs(q)do u=u+b.len(v[1])end end;local w={["<bs>"]="go up one level",["<esc>"]="close"}if#self.text.lines>self.options.layout.height.max then w[a.options.popup_mappings.scroll_down]="scroll down"w[a.options.popup_mappings.scroll_up]="scroll up"end;local x={}local y=0;for i,z in pairs(w)do y=y+b.len(i)+b.len(z)+2;table.insert(x,{i.." ","WhichKey"})table.insert(x,{z.." ","WhichKeySeparator"})end;if a.options.show_keys then table.insert(q,{string.rep(" ",math.floor(vim.o.columns/2-y/2)-u)})end;if self.options.show_help then for k,A in pairs(x)do table.insert(q,A)end end;if vim.o.cmdheight>0 then vim.api.nvim_echo(q,false,{})vim.cmd([[redraw]])else local B=1;self.text:nl()local C=#self.text.lines;for k,D in ipairs(q)do self.text:set(C,B,D[1],D[2]and D[2]:gsub("WhichKey","")or nil)B=B+vim.fn.strwidth(D[1])end end end;function e:layout(E)local F,G,H,I=unpack(self.options.window.padding)local J=vim.api.nvim_win_get_width(E)local u=J;u=u-G-I;local K=self:max_width("key")local L=self:max_width("label")local M=self:max_width("value")local N=K+2+b.len(self.options.icons.separator)+self.options.layout.spacing;local O=L+N+M;if O>u then O=u end;local P=O;if M==0 then if P>self.options.layout.width.max then P=self.options.layout.width.max end;if P<self.options.layout.width.min then P=self.options.layout.width.min end else M=math.min(M,math.floor((P-N)/2))end;L=P-(N+M)local Q=math.floor(u/P)local R=math.ceil(#self.items/Q)if R<self.options.layout.height.min then R=self.options.layout.height.min end;local B=1;local C=1;local S=math.min(Q,math.ceil(#self.items/R))local T=0;if S<Q then if self.options.layout.align=="right"then T=(Q-S)*P elseif self.options.layout.align=="center"then T=math.floor((Q-S)*P/2)end end;for k,l in pairs(self.items)do local U=(B-1)*P+self.options.layout.spacing+T+I;local i=l.key or""if i=="<lt>"then i="<"end;if i==d.t("<esc>")then i="<esc>"end;if b.len(i)<K then i=string.rep(" ",K-b.len(i))..i end;self.text:set(C+F,U,i,"")U=U+b.len(i)+1;self.text:set(C+F,U,self.options.icons.separator,"Separator")U=U+b.len(self.options.icons.separator)+1;if l.value then local V=l.value;U=U+1;if b.len(V)>M then V=vim.fn.strcharpart(V,0,M-2).." …"end;self.text:set(C+F,U,V,"Value")if l.highlights then for k,W in pairs(l.highlights)do self.text:highlight(C+F,U+W[1]-1,U+W[2]-1,W[3])end end;U=U+M+2 end;local z=l.label;if b.len(z)>L then z=vim.fn.strcharpart(z,0,L-2).." …"end;self.text:set(C+F,U,z,l.group and"Group"or"Desc")if C%R==0 then B=B+1;C=1 else C=C+1 end end;for k=1,H,1 do self.text:nl()end;self:trail()return self.text end;return e
