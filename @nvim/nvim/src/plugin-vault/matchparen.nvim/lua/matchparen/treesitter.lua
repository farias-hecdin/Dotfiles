local a=require('matchparen.utils')local b=vim.treesitter.is_in_node_range;local c={highlighter=nil}local d={trees={},skip_nodes={}}local e={'string','comment'}local function f(g)d.skip_nodes[g]={}for h,i in ipairs(d.trees)do local j=i.query:iter_captures(i.root,c.highlighter.bufnr,g,g+1)for k,l in j do if vim.tbl_contains(e,i.query.captures[k])then table.insert(d.skip_nodes[g],l)end end end end;local function m(g,n)if not d.skip_nodes[g]then pcall(f,g)end;for h,l in ipairs(d.skip_nodes[g])do if b(l,g,n)then return l end end end;local function o()local p={}c.highlighter.tree:for_each_tree(function(q,i)if not q then return end;local r=q:root()local s=c.highlighter:get_query(i:lang()):query()if s then table.insert(p,{root=r,query=s})end end,true)return p end;local function t(l)return a.str_contains(l:type(),'string')end;local function u(l)return a.str_contains(l:type(),'comment')end;local function v(g,n)if a.is_inside_fold(g)then return false end;return m(g,n)~=nil end;local function w(l,x)local y=x and'prev_sibling'or'next_sibling'return function(z,A)while l do if b(l,z,A)then return{skip=false}end;if not u(l)then return{stop=true}end;l=l[y](l)if not(l and u(l))then return{stop=true}end end;return{skip=false}end end;function c.get_highlighter()local B=vim.api.nvim_get_current_buf()return vim.treesitter.highlighter.active[B]end;function c.skip_by_region(g,n,x)d.trees=o()d.skip_nodes={}local C=m(g,n)if C and t(C)and a.is_in_insert_mode()then if not b(C,g,n+1)then C=nil end end;if C then return w(C,x)else return function(z,A)if v(z,A)then return{skip=true}else return{skip=false}end end end end;return c
