local a=nil;local function b()if not a then return end;local c,d,e=unpack(a)a=nil;if c<2 then return end;vim.api.nvim_buf_set_lines(0,c-1,d,true,e)end;local function f(g,h,i)return g:sub(1,h-1)..i..g:sub(h)end;local function j(k,l)if not l then k=vim.fn.escape(k,'^$()%.[]*+-?')end;if#k>1 then local m={}for n in k:gmatch('(\\\\)')do table.insert(m,k:find(n,(m[#m]or 0)+1))end;k=k:gsub('\\','%%')for _,n in ipairs(m)do k=k:sub(1,n-2)..[[\]]..k:sub(n+1)end end;return k end;local function o(k,p,q,r)local s,t,u,v;if r then s,t,u,v=unpack(r)else _,s,t,_=unpack(vim.fn.getpos('v'))_,u,v,_=unpack(vim.fn.getcurpos())end;if not q then vim.api.nvim_buf_clear_namespace(0,-1,0,-1)else if r then for w=s,u do vim.api.nvim_buf_add_highlight(0,-1,'Visual',w-1,0,-1)end end end;if s==v then return end;if not k or k==''then return end;p=not not p;q=not not q;b()if u<s then u,s=s,u end;local x=0;local y={}local z=vim.fn.mode()=='v'local A;if q then A=vim.api.nvim_buf_get_lines(0,s-1,u,true)if not a then a={s,u,A}end else A=a and a[3]or vim.api.nvim_buf_get_lines(0,s-1,u,true)a=nil end;if not A then return end;for w=s,u do local B=A[w-s+1]if not B then break end;if q and(w==s and z and not pcall(string.find,B,k,t)or not pcall(string.find,B,k))then return end;local C=w==s and z and B:find(k,t)or B:find(k)if C then if w==u and v<C and z then break end;table.insert(y,{w,C})if p then for D=C-1,1,-1 do if B:sub(D,D)==" "then C=D else break end end end;x=math.max(x,C)end end;if x==0 or#y==0 then return end;for _,h in ipairs(y)do local E,F=unpack(h)local G=A[E-s+1]if F<=x then vim.api.nvim_buf_set_lines(0,E-1,E,true,{f(G,F,(' '):rep(x-F+(p and 1 or 0)))})else vim.api.nvim_buf_set_lines(0,E-1,E,true,{string.sub(G,1,x)..string.sub(G,F)})end end;if not q then vim.api.nvim_input('<Esc>')else if r then for w=s,u do vim.api.nvim_buf_add_highlight(0,-1,'Visual',w-1,0,-1)end end end;print(' ')return 1 end;local function H(k)local I=vim.fn.getcharstr()if I==vim.api.nvim_replace_termcodes('<Esc>',true,false,true)then print(' ')return 0,nil end;if I==vim.api.nvim_replace_termcodes('<CR>',true,false,true)then return 1,nil end;if I==vim.api.nvim_replace_termcodes('<BS>',true,false,true)then return 2,k:sub(1,#k-1)else return nil,k..I end end;local function J(k,p,r)if r and r.sr then local s,u=r.sr,r.er;if s==u then return end;for w=s,u do vim.api.nvim_buf_add_highlight(0,-1,'Visual',w-1,0,-1)end end;o(k,p,false,r)end;local function K(L,p,q,r)if r and r.sr then local s,u=r.sr,r.er;if s==u then return end;for w=s,u do vim.api.nvim_buf_add_highlight(0,-1,'Visual',w-1,0,-1)end end;L=math.max(L,1)q=not not q and L>1;local M='Enter '..(L>1 and L..' characters: 'or'a character: ')print(M)local k=''while#k<L do vim.cmd[[redraw]]print(M..k)local N,O=H(k)if q then b()end;if N==0 then return end;if N==1 then break end;k=O;o(j(k),not not p,true,r)end;J(j(k),not not p,r)end;local function P(l,p,q,r)if r and r.sr then local s,u=r.sr,r.er;if s==u then return end;for w=s,u do vim.api.nvim_buf_add_highlight(0,-1,'Visual',w-1,0,-1)end end;q=not not q;l=not not l;local M=l and'Enter pattern: 'or'Enter string: 'print(M)local k=''while true do vim.cmd[[redraw]]print(M..k)local N,O=H(k)if q then b()end;if N==0 then print(' ')vim.cmd[[redraw]]return end;if N==1 then break end;k=O;local Q=j(k,l)o(Q,not not p,true,r)end;J(j(k,l),not not p,r)end;local function R(S,T)T=T or{}local U=vim.go.operatorfunc;_G.op_align=function()local s,t=unpack(vim.api.nvim_buf_get_mark(0,'['))local u,v=unpack(vim.api.nvim_buf_get_mark(0,']'))if not s or s==u then vim.go.operatorfunc=U;_G.op_align=nil;return end;for w=s,u do vim.api.nvim_buf_add_highlight(0,-1,'Visual',w-1,0,-1)end;local r={s,t,u,v}if S==K then K(T.length,T.reverse,T.preview,r)elseif S==P then P(T.is_pattern,T.reverse,T.preview,r)elseif S==J then J(T.str,T.reverse,r)else error('Unknown function: '..S)end;vim.api.nvim_buf_clear_namespace(0,-1,0,-1)vim.go.operatorfunc=U;_G.op_align=nil end;vim.go.operatorfunc='v:lua.op_align'vim.api.nvim_feedkeys('g@','n',false)end;return{align=J,align_to_char=K,align_to_string=P,operator=R}
