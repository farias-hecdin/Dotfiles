local a=require('cmp.utils.cache')local b=require('cmp.utils.char')local c=require('cmp.utils.misc')local d=require('cmp.utils.str')local e=require('cmp.config')local f=require('cmp.types')local g=require('cmp.matcher')local h={}h.new=function(i,j,k,l)local self=setmetatable({},{__index=h})self.id=c.id('entry.new')self.cache=a.new()self.match_cache=a.new()self.score=0;self.exact=false;self.matches={}self.context=i;self.source=j;self.source_offset=j.request_offset;self.source_insert_range=j:get_default_insert_range()self.source_replace_range=j:get_default_replace_range()self.completion_item=self:fill_defaults(k,l)self.resolved_completion_item=nil;self.resolved_callbacks={}self.resolving=false;self.confirmed=false;return self end;h.get_offset=function(self)return self.cache:ensure('get_offset',function()local m=self.source_offset;if self:get_completion_item().textEdit then local n=self:get_insert_range()if n then m=self.context.cache:ensure('entry:'..'get_offset:'..tostring(n.start.character),function()local o=math.min(n.start.character+1,m)for p=o,self.source_offset do local q=string.byte(self.context.cursor_line,p)if q==nil or not b.is_white(q)then return p end end;return m end)end else local r=self:get_word()for p=self.source_offset-1,self.source_offset-#r,-1 do if b.is_semantic_index(self.context.cursor_line,p)then local s=string.byte(self.context.cursor_line,p)if b.is_white(s)then break end;local t=true;for u=1,self.source_offset-p do local v=string.byte(r,u)local w=string.byte(self.context.cursor_line,p+u-1)if not v or not w or v~=w then t=false;break end end;if t then m=math.min(m,p)end end end end;return m end)end;h.get_word=function(self)return self.cache:ensure('get_word',function()if self:get_completion_item().word then return self:get_completion_item().word end;local r;if self:get_completion_item().textEdit and not c.empty(self:get_completion_item().textEdit.newText)then r=d.trim(self:get_completion_item().textEdit.newText)if self:get_completion_item().insertTextFormat==f.lsp.InsertTextFormat.Snippet then r=vim.lsp.util.parse_snippet(r)end;local x=self:get_overwrite()if 0<x[2]or self:get_completion_item().insertTextFormat==f.lsp.InsertTextFormat.Snippet then r=d.get_word(r,string.byte(self.context.cursor_after_line,1),x[1]or 0)end elseif not c.empty(self:get_completion_item().insertText)then r=d.trim(self:get_completion_item().insertText)if self:get_completion_item().insertTextFormat==f.lsp.InsertTextFormat.Snippet then r=d.get_word(vim.lsp.util.parse_snippet(r))end else r=d.trim(self:get_completion_item().label)end;return d.oneline(r)end)end;h.get_overwrite=function(self)return self.cache:ensure('get_overwrite',function()if self:get_completion_item().textEdit then local n=self:get_insert_range()if n then return self.context.cache:ensure('entry:'..'get_overwrite:'..tostring(n.start.character)..':'..tostring(n['end'].character),function()local y=n.start.character+1;local z=n['end'].character+1;local A=self.context.cursor.col-y;local B=z-self.context.cursor.col;return{A,B}end)end end;return{0,0}end)end;h.get_filter_text=function(self)return self.cache:ensure('get_filter_text',function()local r;if self:get_completion_item().filterText then r=self:get_completion_item().filterText else r=d.trim(self:get_completion_item().label)end;return r end)end;h.get_insert_text=function(self)return self.cache:ensure('get_insert_text',function()local r;if self:get_completion_item().textEdit then r=d.trim(self:get_completion_item().textEdit.newText)if self:get_completion_item().insertTextFormat==f.lsp.InsertTextFormat.Snippet then r=d.remove_suffix(d.remove_suffix(r,'$0'),'${0}')end elseif self:get_completion_item().insertText then r=d.trim(self:get_completion_item().insertText)if self:get_completion_item().insertTextFormat==f.lsp.InsertTextFormat.Snippet then r=d.remove_suffix(d.remove_suffix(r,'$0'),'${0}')end else r=d.trim(self:get_completion_item().label)end;return r end)end;h.is_deprecated=function(self)return self:get_completion_item().deprecated or vim.tbl_contains(self:get_completion_item().tags or{},f.lsp.CompletionItemTag.Deprecated)end;h.get_view=function(self,C,D)local E=self:get_vim_item(C)return self.cache:ensure('get_view:'..tostring(D),function()local F={}vim.api.nvim_buf_call(D,function()F.abbr={}F.abbr.text=E.abbr or''F.abbr.bytes=#F.abbr.text;F.abbr.width=vim.fn.strdisplaywidth(F.abbr.text)F.abbr.hl_group=E.abbr_hl_group or(self:is_deprecated()and'CmpItemAbbrDeprecated'or'CmpItemAbbr')F.kind={}F.kind.text=E.kind or''F.kind.bytes=#F.kind.text;F.kind.width=vim.fn.strdisplaywidth(F.kind.text)F.kind.hl_group=E.kind_hl_group or'CmpItemKind'..(f.lsp.CompletionItemKind[self:get_kind()]or'')F.menu={}F.menu.text=E.menu or''F.menu.bytes=#F.menu.text;F.menu.width=vim.fn.strdisplaywidth(F.menu.text)F.menu.hl_group=E.menu_hl_group or'CmpItemMenu'F.dup=E.dup end)return F end)end;h.get_vim_item=function(self,C)return self.cache:ensure('get_vim_item:'..tostring(C),function()local k=self:get_completion_item()local r=self:get_word()local G=d.oneline(k.label)local H=false;local I=e.get().formatting.expandable_indicator;if#(k.additionalTextEdits or{})>0 then H=true elseif k.insertTextFormat==f.lsp.InsertTextFormat.Snippet then H=self:get_insert_text()~=r elseif k.kind==f.lsp.CompletionItemKind.Snippet then H=true end;if I and H then G=G..'~'end;if C<self:get_offset()then r=string.sub(self.context.cursor_before_line,C,self:get_offset()-1)..r end;local J=nil;if k.labelDetails then J=''if k.labelDetails.detail then J=J..k.labelDetails.detail end;if k.labelDetails.description then J=J..k.labelDetails.description end end;if self:get_offset()~=self.context.cursor.col then for u=1,#r do if d.has_prefix(self.context.cursor_after_line,string.sub(r,u,#r))then r=string.sub(r,1,u-1)break end end end;local K=self:get_completion_item().cmp or{}local L={word=r,abbr=G,kind=K.kind_text or f.lsp.CompletionItemKind[self:get_kind()]or f.lsp.CompletionItemKind[1],kind_hl_group=K.kind_hl_group,menu=J,dup=self:get_completion_item().dup or 1}if e.get().formatting.format then L=e.get().formatting.format(self,L)end;L.word=d.oneline(L.word or'')L.abbr=d.oneline(L.abbr or'')L.kind=d.oneline(L.kind or'')L.menu=d.oneline(L.menu or'')L.equal=1;L.empty=1;return L end)end;h.get_commit_characters=function(self)return self:get_completion_item().commitCharacters or{}end;h.get_insert_range=function(self)local M;if self:get_completion_item().textEdit then if self:get_completion_item().textEdit.insert then M=self:get_completion_item().textEdit.insert else M=self:get_completion_item().textEdit.range end;M=self:convert_range_encoding(M)else M={start={line=self.context.cursor.row-1,character=self:get_offset()-1},['end']=self.source_insert_range['end']}end;return M end;h.get_replace_range=function(self)return self.cache:ensure('get_replace_range',function()local N;if self:get_completion_item().textEdit then if self:get_completion_item().textEdit.replace then N=self:get_completion_item().textEdit.replace else N=self:get_completion_item().textEdit.range end;N=self:convert_range_encoding(N)end;if not N or self.context.cursor.col-1==N['end'].character then N={start={line=self.source_replace_range.start.line,character=self:get_offset()-1},['end']=self.source_replace_range['end']}end;return N end)end;h.match=function(self,O,P)return self.match_cache:ensure(O..':'..(self.resolved_completion_item and'1'or'0'..':')..(P.disallow_fuzzy_matching and'1'or'0')..':'..(P.disallow_partial_fuzzy_matching and'1'or'0')..':'..(P.disallow_partial_matching and'1'or'0')..':'..(P.disallow_prefix_unmatching and'1'or'0'),function()local Q={disallow_fuzzy_matching=P.disallow_fuzzy_matching,disallow_partial_fuzzy_matching=P.disallow_partial_fuzzy_matching,disallow_partial_matching=P.disallow_partial_matching,disallow_prefix_unmatching=P.disallow_prefix_unmatching,synonyms={self:get_word(),self:get_completion_item().label}}local R,S,T,U;local V={}T=self:get_filter_text()V[T]=true;R,S=g.match(O,T,Q)if R==0 then if self:get_completion_item().textEdit and not c.empty(self:get_completion_item().textEdit.newText)then local W=self.source_offset-self:get_offset()if W>0 then local X=string.sub(self.context.cursor_line,self:get_offset(),self:get_offset()+W)local Y=nil;Y=Y or string.match(X,'^[^%a]+$')Y=Y or string.find(self:get_completion_item().textEdit.newText,X,1,true)if Y then T=X..self:get_filter_text()if not V[T]then V[T]=true;R,S=g.match(O,T,Q)end end end end end;if R>0 then local L=self:get_vim_item(self.source_offset)T=L.abbr or L.word;if not V[T]then local W=self.source_offset-self:get_offset()U,S=g.match(O:sub(1+W),T,Q)end end;return{score=R,matches=S}end)end;h.get_completion_item=function(self)return self.cache:ensure('get_completion_item',function()if self.resolved_completion_item then local k=c.copy(self.completion_item)for Z,_ in pairs(self.resolved_completion_item)do k[Z]=_ or k[Z]end;return k end;return self.completion_item end)end;h.get_documentation=function(self)local E=self:get_completion_item()local a0={}if E.detail and E.detail~=''then local a1=self.context.filetype;local a2=string.find(a1,'%.')if a2~=nil then a1=string.sub(a1,0,a2-1)end;table.insert(a0,{kind=f.lsp.MarkupKind.Markdown,value=('```%s\n%s\n```'):format(a1,d.trim(E.detail))})end;local a3=E.documentation;if type(a3)=='string'and a3~=''then local a4=d.trim(a3)if a4~=''then table.insert(a0,{kind=f.lsp.MarkupKind.PlainText,value=a4})end elseif type(a3)=='table'and not c.empty(a3.value)then local a4=d.trim(a3.value)if a4~=''then table.insert(a0,{kind=a3.kind,value=a4})end end;return vim.lsp.util.convert_input_to_markdown_lines(a0)end;h.get_kind=function(self)return self:get_completion_item().kind or f.lsp.CompletionItemKind.Text end;h.execute=function(self,a5)self.source:execute(self:get_completion_item(),a5)end;h.resolve=function(self,a5)if self.resolved_completion_item then return a5()end;table.insert(self.resolved_callbacks,a5)if not self.resolving then self.resolving=true;self.source:resolve(self.completion_item,function(k)self.resolving=false;if not k then return end;self.resolved_completion_item=k or self.completion_item;self.cache:clear()for U,s in ipairs(self.resolved_callbacks)do s()end end)end end;h.fill_defaults=function(U,k,a6)a6=a6 or{}if a6.data then k.data=k.data or a6.data end;if a6.commitCharacters then k.commitCharacters=k.commitCharacters or a6.commitCharacters end;if a6.insertTextFormat then k.insertTextFormat=k.insertTextFormat or a6.insertTextFormat end;if a6.insertTextMode then k.insertTextMode=k.insertTextMode or a6.insertTextMode end;if a6.editRange then if not k.textEdit then if a6.editRange.insert then k.textEdit={insert=a6.editRange.insert,replace=a6.editRange.replace,newText=k.textEditText or k.label}else k.textEdit={range=a6.editRange,newText=k.textEditText or k.label}end end end;return k end;h.convert_range_encoding=function(self,n)local a7=self.source:get_position_encoding_kind()return self.context.cache:ensure('entry.convert_range_encoding:'..n.start.character..':'..n['end'].character..':'..a7,function()return{start=f.lsp.Position.to_utf8(self.context.cursor_line,n.start,a7),['end']=f.lsp.Position.to_utf8(self.context.cursor_line,n['end'],a7)}end)end;return h
