local a=require('cmp.context')local b=require('cmp.config')local c=require('cmp.entry')local d=require('cmp.utils.debug')local e=require('cmp.utils.misc')local f=require('cmp.utils.cache')local g=require('cmp.types')local h=require('cmp.utils.async')local i=require('cmp.utils.pattern')local j=require('cmp.utils.char')local k={}k.SourceStatus={}k.SourceStatus.WAITING=1;k.SourceStatus.FETCHING=2;k.SourceStatus.COMPLETED=3;k.new=function(l,m)local self=setmetatable({},{__index=k})self.id=e.id('cmp.source.new')self.name=l;self.source=m;self.cache=f.new()self.complete_dedup=h.dedup()self.revision=0;self:reset()return self end;k.reset=function(self)self.cache:clear()self.revision=self.revision+1;self.context=a.empty()self.is_triggered_by_symbol=false;self.incomplete=false;self.entries={}self.offset=-1;self.request_offset=-1;self.completion_context=nil;self.status=k.SourceStatus.WAITING;self.complete_dedup(function()end)end;k.get_source_config=function(self)return b.get_source_config(self.name)or{}end;k.get_matching_config=function()return b.get().matching end;k.get_fetching_time=function(self)if self.status==k.SourceStatus.FETCHING then return vim.loop.now()-self.context.time end;return 100*1000 end;k.get_entries=function(self,n)if self.offset==-1 then return{}end;local o=self.entries;if not self.incomplete then local p=self.cache:get({'get_entries',tostring(self.revision)})if p and n.cursor.row==p.ctx.cursor.row and self.offset==p.offset then if p.ctx.cursor.col<=n.cursor.col then o=p.entries end end end;local q=self:get_entry_filter()local r={}local s={}local t=self:get_matching_config()for u,v in ipairs(o)do local w=v:get_offset()if not r[w]then r[w]=string.sub(n.cursor_before_line,w)end;local x=v:match(r[w],t)v.score=x.score;v.exact=false;if v.score>=1 then v.matches=x.matches;v.exact=v:get_filter_text()==r[w]or v:get_word()==r[w]if q(v,n)then s[#s+1]=v end end;h.yield()if n.aborted then h.abort()end end;if not self.incomplete then self.cache:set({'get_entries',tostring(self.revision)},{entries=s,ctx=n,offset=self.offset})end;if self:get_source_config().max_item_count then local y={}for z=1,math.min(#s,self:get_source_config().max_item_count)do y[z]=s[z]end;s=y end;return s end;k.get_default_insert_range=function(self)if not self.context then error('context is not initialized yet.')end;return self.cache:ensure({'get_default_insert_range',tostring(self.revision)},function()return{start={line=self.context.cursor.row-1,character=self.offset-1},['end']={line=self.context.cursor.row-1,character=self.context.cursor.col-1}}end)end;k.get_default_replace_range=function(self)if not self.context then error('context is not initialized yet.')end;return self.cache:ensure({'get_default_replace_range',tostring(self.revision)},function()local u,v=i.offset('^'..'\\%('..self:get_keyword_pattern()..'\\)',string.sub(self.context.cursor_line,self.offset))return{start={line=self.context.cursor.row-1,character=self.offset},['end']={line=self.context.cursor.row-1,character=v and self.offset+v-2 or self.context.cursor.col-1}}end)end;k.get_debug_name=function(self)local l=self.name;if self.source.get_debug_name then l=self.source:get_debug_name()end;return l end;k.is_available=function(self)if self.source.is_available then return self.source:is_available()end;return true end;k.get_trigger_characters=function(self)local A=self:get_source_config()if A.trigger_characters then return A.trigger_characters end;local B={}if self.source.get_trigger_characters then B=self.source:get_trigger_characters(e.copy(A))or{}end;if b.get().completion.get_trigger_characters then return b.get().completion.get_trigger_characters(B)end;return B end;k.get_keyword_pattern=function(self)local A=self:get_source_config()if A.keyword_pattern then return A.keyword_pattern end;if self.source.get_keyword_pattern then local C=self.source:get_keyword_pattern(e.copy(A))if C then return C end end;return b.get().completion.keyword_pattern end;k.get_keyword_length=function(self)local A=self:get_source_config()if A.keyword_length then return A.keyword_length end;return b.get().completion.keyword_length or 1 end;k.get_entry_filter=function(self)local A=self:get_source_config()if A.entry_filter then return A.entry_filter end;return function(u,u)return true end end;k.get_position_encoding_kind=function(self)if self.source.get_position_encoding_kind then return self.source:get_position_encoding_kind()end;return g.lsp.PositionEncodingKind.UTF16 end;k.complete=function(self,n,D)local E=n:get_offset(self:get_keyword_pattern())local F=string.sub(n.cursor_before_line,-1)if n:get_reason()==g.cmp.ContextReason.TriggerOnly then F=string.match(n.cursor_before_line,'(.)%s*$')if not F or not j.is_symbol(string.byte(F))then F=''end end;local G;if n:get_reason()==g.cmp.ContextReason.Manual then G={triggerKind=g.lsp.CompletionTriggerKind.Invoked}elseif vim.tbl_contains(self:get_trigger_characters(),F)then G={triggerKind=g.lsp.CompletionTriggerKind.TriggerCharacter,triggerCharacter=F}elseif n:get_reason()~=g.cmp.ContextReason.TriggerOnly then if E<n.cursor.col and self:get_keyword_length()<=n.cursor.col-E then if self.incomplete and self.context.cursor.col~=n.cursor.col and self.status~=k.SourceStatus.FETCHING then G={triggerKind=g.lsp.CompletionTriggerKind.TriggerForIncompleteCompletions}elseif not vim.tbl_contains({self.request_offset,self.offset},E)then G={triggerKind=g.lsp.CompletionTriggerKind.Invoked}end else self:reset()end else self:reset()end;if not G then return end;if G.triggerKind==g.lsp.CompletionTriggerKind.TriggerCharacter then self.is_triggered_by_symbol=j.is_symbol(string.byte(G.triggerCharacter))end;d.log(self:get_debug_name(),'request',E,vim.inspect(G))local H=self.status;self.status=k.SourceStatus.FETCHING;self.offset=E;self.request_offset=E;self.context=n;self.completion_context=G;self.source:complete(vim.tbl_extend('keep',e.copy(self:get_source_config()),{offset=self.offset,context=n,completion_context=G}),self.complete_dedup(vim.schedule_wrap(function(I)if self.context~=n then return end;I=I or{}self.incomplete=I.isIncomplete or false;if#(I.items or I)>0 then d.log(self:get_debug_name(),'retrieve',#(I.items or I))local J=self.offset;local K=self.entries;self.status=k.SourceStatus.COMPLETED;self.entries={}for z,L in ipairs(I.items or I)do if(L or{}).label then local v=c.new(n,self,L,I.itemDefaults)self.entries[z]=v;self.offset=math.min(self.offset,v:get_offset())end end;self.revision=self.revision+1;if#self.entries==0 then self.offset=J;self.entries=K;self.revision=self.revision+1 end else if E==n.cursor.col then self:reset()end;self.status=H end;D()end)))return true end;k.resolve=function(self,L,D)if not self.source.resolve then return D(L)end;self.source:resolve(L,function(M)D(M or L)end)end;k.execute=function(self,L,D)if not self.source.execute then return D()end;self.source:execute(L,function()D()end)end;return k
