local a=require('cmp.utils.debug')local b=require('cmp.utils.str')local c=require('cmp.utils.char')local d=require('cmp.utils.feedkeys')local e=require('cmp.utils.async')local f=require('cmp.utils.keymap')local g=require('cmp.context')local h=require('cmp.source')local i=require('cmp.view')local j=require('cmp.utils.misc')local k=require('cmp.config')local l=require('cmp.types')local m=require('cmp.utils.api')local n=require('cmp.utils.event')local o={}o.new=function()local self=setmetatable({},{__index=o})self.suspending=false;self.sources={}self.context=g.new()self.event=n.new()self.view=i.new()self.view.event:on('keymap',function(...)self:on_keymap(...)end)for p,q in ipairs({'complete_done','menu_opened','menu_closed'})do self.view.event:on(q,function(r)self.event:emit(q,r)end)end;return self end;o.register_source=function(self,s)self.sources[s.id]=s end;o.unregister_source=function(self,t)self.sources[t]=nil end;o.get_context=function(self,u)self.context:abort()local v=self.context:clone()v.prev_context=nil;v.cache=nil;local w=g.new(v,u)self:set_context(w)return self.context end;o.set_context=function(self,w)self.context=w end;o.suspend=function(self)self.suspending=true;return vim.schedule_wrap(function()self.suspending=false end)end;o.get_sources=function(self,x)local y=function(s)if type(x)=='table'then return vim.tbl_contains(x,s.status)elseif type(x)=='function'then return x(s)end;return true end;local z={}for p,A in pairs(k.get().sources)do for p,s in pairs(self.sources)do if A.name==s.name then if s:is_available()and y(s)then table.insert(z,s)end end end end;return z end;o.on_keymap=function(self,B,C)local D=m.get_mode()for E,F in pairs(k.get().mapping)do if f.equals(E,B)and F[D]then return F[D](C)end end;local G=f.t(B)local H=self.view:get_active_entry()if H and vim.tbl_contains(k.get().confirmation.get_commit_characters(H:get_commit_characters()),G)then local I=c.is_printable(string.byte(G,1))self:confirm(H,{behavior=I and'insert'or'replace',commit_character=G},function()local w=self:get_context()local J=H:get_word()if string.sub(w.cursor_before_line,-#J,w.cursor.col-1)==J and I then C()else self:reset()end end)return end;C()end;o.prepare=function(self)for B,F in pairs(k.get().mapping)do for D in pairs(F)do f.listen(D,B,function(...)self:on_keymap(...)end)end end end;o.on_change=function(self,K)local L=false;L=L or self.suspending;L=L or vim.fn.pumvisible()==1 and vim.v.completed_item.word;L=L or not self.view:ready()if L then self:get_context({reason=l.cmp.ContextReason.Auto})return end;self:autoindent(K,function()local w=self:get_context({reason=l.cmp.ContextReason.Auto})a.log(('ctx: `%s`'):format(w.cursor_before_line))if w:changed(w.prev_context)then self.view:on_change()a.log('changed')if vim.tbl_contains(k.get().completion.autocomplete or{},K)then self:complete(w)else self.filter.timeout=self.view:visible()and k.get().performance.throttle or 0;self:filter()end else a.log('unchanged')end end)end;o.on_moved=function(self)local L=false;L=L or self.suspending;L=L or vim.fn.pumvisible()==1 and vim.v.completed_item.word;L=L or not self.view:visible()if L then return end;self:filter()end;local function M(N)local O=#N;while O>0 do if N:sub(O,O):find('%s')then return N:sub(O+1)end;O=O-1 end;return N end;o.autoindent=function(self,K,P)if K~=l.cmp.TriggerEvent.TextChanged then return P()end;if not m.is_insert_mode()then return P()end;local Q=m.get_cursor_before_line()local R=M(Q)or''if#R==0 then return P()end;for p,E in ipairs(vim.split(vim.bo.indentkeys,','))do if vim.tbl_contains({'='..R,'0='..R},E)then self:reset()self:set_context(g.empty())break end end;P()end;o.complete_common_string=function(self)if not self.view:visible()or self.view:get_selected_entry()then return false end;k.set_onetime({sources=k.get().sources,matching={disallow_prefix_unmatching=true,disallow_partial_matching=true,disallow_fuzzy_matching=true}})self:filter()self.filter:sync(1000)k.set_onetime({})local S=m.get_cursor()local T=self.view:get_offset()or S[2]local U;for p,H in ipairs(self.view:get_entries())do local V=H:get_vim_item(T)if not U then U=V.word else U=b.get_common_string(U,V.word)end end;local Q=m.get_cursor_before_line()local W=Q:sub(T)if U and#U>#W then d.call(f.backspace(W)..U,'n')return true end;return false end;o.complete=function(self,w)if not m.is_suitable_mode()then return end;self:set_context(w)local z=self:get_sources()for p,s in ipairs(z)do local P;P=(function(X)return function()local Y=g.new(w)if X.incomplete and Y:changed(X.context)then X:complete(Y,P)else if not self.view:get_active_entry()then self.filter.stop()self.filter.timeout=k.get().performance.debounce;self:filter()end end end end)(s)s:complete(w,P)end;if not self.view:get_active_entry()then self.filter.timeout=self.view:visible()and k.get().performance.throttle or 1;self:filter()end end;local Z=e.wrap(function(self)self.filter.timeout=k.get().performance.throttle;local L=false;L=L or not m.is_suitable_mode()if L then return end;local z={}for p,s in ipairs(self:get_sources({h.SourceStatus.FETCHING,h.SourceStatus.COMPLETED}))do if not s.incomplete and k.get().performance.fetching_timeout>s:get_fetching_time()then self.filter.timeout=k.get().performance.fetching_timeout-s:get_fetching_time()self:filter()if#z==0 then return end end;table.insert(z,s)end;local w=self:get_context()local _=self.view:open(w,z)local a0=#self:get_sources(function(s)return s.status==h.SourceStatus.FETCHING end)if not _ and a0==0 then k.set_onetime({})end end)o.filter=e.throttle(Z,k.get().performance.throttle)o.confirm=function(self,H,u,P)if not(H and not H.confirmed)then if P then P()end;return end;H.confirmed=true;a.log('entry.confirm',H:get_completion_item())e.sync(function(a1)H:resolve(a1)end,k.get().performance.confirm_resolve_timeout)local a2=self:suspend()self.view:close()d.call(f.indentkeys(),'n')d.call('','n',function()local w=g.new()local B={}table.insert(B,f.backspace(w.cursor_before_line:sub(H:get_offset())))table.insert(B,H:get_word())table.insert(B,f.undobreak())d.call(table.concat(B,''),'in')end)d.call('','n',function()local w=g.new()if m.is_cmdline_mode()then local B={}table.insert(B,f.backspace(w.cursor_before_line:sub(H:get_offset())))table.insert(B,string.sub(H.context.cursor_before_line,H:get_offset()))d.call(table.concat(B,''),'in')else vim.cmd([[silent! undojoin]])vim.api.nvim_buf_set_text(0,H.context.cursor.row-1,H:get_offset()-1,w.cursor.row-1,w.cursor.col-1,{H.context.cursor_before_line:sub(H:get_offset())})vim.api.nvim_win_set_cursor(0,{H.context.cursor.row,H.context.cursor.col-1})end end)d.call('','n',function()local w=g.new()if#(H:get_completion_item().additionalTextEdits or{})==0 then H:resolve(function()local Y=g.new()local a3=H:get_completion_item().additionalTextEdits or{}if#a3==0 then return end;local a4=(function()local a5=math.min(w.cursor.row,Y.cursor.row)local a6=math.max(w.cursor.row,Y.cursor.row)for p,a7 in ipairs(a3)do local a8=a7.range.start.line+1;local a9=a7.range['end'].line+1;if a8<=a5 and a6<=a9 then return true end end;return false end)()if a4 then return end;vim.cmd([[silent! undojoin]])vim.lsp.util.apply_text_edits(a3,w.bufnr,H.source:get_position_encoding_kind())end)else vim.cmd([[silent! undojoin]])vim.lsp.util.apply_text_edits(H:get_completion_item().additionalTextEdits,w.bufnr,H.source:get_position_encoding_kind())end end)d.call('','n',function()local w=g.new()local aa=j.copy(H:get_completion_item())if not aa.textEdit then aa.textEdit={}local ab=aa.insertText;if j.empty(ab)then ab=nil end;aa.textEdit.newText=ab or aa.word or aa.label end;local ac=u.behavior or k.get().confirmation.default_behavior;if ac==l.cmp.ConfirmBehavior.Replace then aa.textEdit.range=H:get_replace_range()else aa.textEdit.range=H:get_insert_range()end;local ad=math.max(0,H.context.cursor.col-(aa.textEdit.range.start.character+1))local ae=math.max(0,aa.textEdit.range['end'].character+1-H.context.cursor.col)local af=aa.textEdit.newText;aa.textEdit.range.start.line=w.cursor.line;aa.textEdit.range.start.character=w.cursor.col-1-ad;aa.textEdit.range['end'].line=w.cursor.line;aa.textEdit.range['end'].character=w.cursor.col-1+ae;if m.is_insert_mode()then if false then vim.print({item=H:get_completion_item(),diff_before=ad,diff_after=ae,new_text=af,text_edit_new_text=aa.textEdit.newText,range_start=aa.textEdit.range.start.character,range_end=aa.textEdit.range['end'].character,original_range_start=H:get_completion_item().textEdit.range.start.character,original_range_end=H:get_completion_item().textEdit.range['end'].character,cursor_line=w.cursor_line,cursor_col0=w.cursor.col-1})end;local ag=aa.insertTextFormat==l.lsp.InsertTextFormat.Snippet;if ag then aa.textEdit.newText=''end;vim.lsp.util.apply_text_edits({aa.textEdit},w.bufnr,'utf-8')local ah=vim.split(aa.textEdit.newText,'\n')vim.api.nvim_win_set_cursor(0,{aa.textEdit.range.start.line+#ah,#ah==1 and aa.textEdit.range.start.character+#ah[1]or#ah[#ah]})if ag then k.get().snippet.expand({body=af,insert_text_mode=aa.insertTextMode})end else local B={}table.insert(B,f.backspace(w.cursor_line:sub(aa.textEdit.range.start.character+1,w.cursor.col-1)))table.insert(B,f.delete(w.cursor_line:sub(w.cursor.col,aa.textEdit.range['end'].character)))table.insert(B,af)d.call(table.concat(B,''),'in')end end)d.call(f.indentkeys(vim.bo.indentkeys),'n')d.call('','n',function()H:execute(vim.schedule_wrap(function()a2()self.event:emit('confirm_done',{entry=H,commit_character=u.commit_character})if P then P()end end))end)end;o.reset=function(self)for p,s in pairs(self.sources)do s:reset()end;self.context=g.empty()end;return o
