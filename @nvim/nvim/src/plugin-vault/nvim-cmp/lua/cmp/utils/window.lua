local a=require('cmp.utils.misc')local b=require('cmp.utils.options')local c=require('cmp.utils.buffer')local d=require('cmp.utils.api')local e=require('cmp.config')local f={}f.new=function()local self=setmetatable({},{__index=f})self.name=a.id('cmp.utils.window.new')self.win=nil;self.sbar_win=nil;self.thumb_win=nil;self.style={}self.opt={}self.buffer_opt={}return self end;f.option=function(self,g,h)if vim.fn.exists('+'..g)==0 then return end;if h==nil then return self.opt[g]end;self.opt[g]=h;if self:visible()then b.win_set_option(self.win,g,h)end end;f.buffer_option=function(self,g,h)if vim.fn.exists('+'..g)==0 then return end;if h==nil then return self.buffer_opt[g]end;self.buffer_opt[g]=h;local i=c.get(self.name)if i then b.buf_set_option(i,g,h)end end;f.set_style=function(self,j)self.style=j;local k=self:info()if vim.o.lines and vim.o.lines<=k.row+k.height+1 then self.style.height=vim.o.lines-k.row-k.border_info.vert-1 end;self.style.zindex=self.style.zindex or 1;self.style.width=math.ceil(self.style.width)self.style.height=math.ceil(self.style.height)end;f.get_buffer=function(self)local l,m=c.ensure(self.name)if m then for n,o in pairs(self.buffer_opt)do b.buf_set_option(l,n,o)end end;return l end;f.open=function(self,j)if j then self:set_style(j)end;if self.style.width<1 or self.style.height<1 then return end;if self.win and vim.api.nvim_win_is_valid(self.win)then vim.api.nvim_win_set_config(self.win,self.style)else local p=a.copy(self.style)p.noautocmd=true;self.win=vim.api.nvim_open_win(self:get_buffer(),false,p)for n,o in pairs(self.opt)do b.win_set_option(self.win,n,o)end end;self:update()end;f.update=function(self)local k=self:info()if k.scrollable then if not k.border_info.visible then local j={relative='editor',style='minimal',width=1,height=self.style.height,row=k.row,col=k.col+k.width-k.scrollbar_offset,zindex=self.style.zindex and self.style.zindex+1 or 1}if self.sbar_win and vim.api.nvim_win_is_valid(self.sbar_win)then vim.api.nvim_win_set_config(self.sbar_win,j)else j.noautocmd=true;self.sbar_win=vim.api.nvim_open_win(c.ensure(self.name..'sbar_buf'),false,j)b.win_set_option(self.sbar_win,'winhighlight','EndOfBuffer:PmenuSbar,NormalFloat:PmenuSbar')end end;local q=math.floor(k.inner_height*k.inner_height/self:get_content_height()+0.5)local r=math.floor(k.inner_height*vim.fn.getwininfo(self.win)[1].topline/self:get_content_height())local j={relative='editor',style='minimal',width=1,height=math.max(1,q),row=k.row+r+(k.border_info.visible and k.border_info.top or 0),col=k.col+k.width-1,zindex=self.style.zindex and self.style.zindex+2 or 2}if self.thumb_win and vim.api.nvim_win_is_valid(self.thumb_win)then vim.api.nvim_win_set_config(self.thumb_win,j)else j.noautocmd=true;self.thumb_win=vim.api.nvim_open_win(c.ensure(self.name..'thumb_buf'),false,j)b.win_set_option(self.thumb_win,'winhighlight','EndOfBuffer:PmenuThumb,NormalFloat:PmenuThumb')end else if self.sbar_win and vim.api.nvim_win_is_valid(self.sbar_win)then vim.api.nvim_win_hide(self.sbar_win)self.sbar_win=nil end;if self.thumb_win and vim.api.nvim_win_is_valid(self.thumb_win)then vim.api.nvim_win_hide(self.thumb_win)self.thumb_win=nil end end;if d.is_cmdline_mode()then vim.api.nvim_win_call(self.win,function()a.redraw()end)end end;f.close=function(self)if self.win and vim.api.nvim_win_is_valid(self.win)then if self.win and vim.api.nvim_win_is_valid(self.win)then vim.api.nvim_win_hide(self.win)self.win=nil end;if self.sbar_win and vim.api.nvim_win_is_valid(self.sbar_win)then vim.api.nvim_win_hide(self.sbar_win)self.sbar_win=nil end;if self.thumb_win and vim.api.nvim_win_is_valid(self.thumb_win)then vim.api.nvim_win_hide(self.thumb_win)self.thumb_win=nil end end end;f.visible=function(self)return self.win and vim.api.nvim_win_is_valid(self.win)end;f.info=function(self)local s=self:get_border_info()local t=e.get().window.completion.scrollbar;local k={row=self.style.row,col=self.style.col,width=self.style.width+s.left+s.right,height=self.style.height+s.top+s.bottom,inner_width=self.style.width,inner_height=self.style.height,border_info=s,scrollable=false,scrollbar_offset=0}if self:get_content_height()>k.inner_height and t then k.scrollable=true;if not s.visible then k.scrollbar_offset=1;k.width=k.width+1 end end;return k end;f.get_border_info=function(self)local u=self.style.border;if not u or u=='none'then return{top=0,left=0,right=0,bottom=0,vert=0,horiz=0,visible=false}end;if type(u)=='string'then if u=='shadow'then return{top=0,left=0,right=1,bottom=1,vert=1,horiz=1,visible=false}end;return{top=1,left=1,right=1,bottom=1,vert=2,horiz=2,visible=true}end;local v={}while#v<=8 do for w,x in ipairs(u)do table.insert(v,type(x)=='string'and x or x[1])end end;local k={}k.top=v[2]==''and 0 or 1;k.right=v[4]==''and 0 or 1;k.bottom=v[6]==''and 0 or 1;k.left=v[8]==''and 0 or 1;k.vert=k.top+k.bottom;k.horiz=k.left+k.right;k.visible=not(vim.tbl_contains({'',' '},v[2])and vim.tbl_contains({'',' '},v[4])and vim.tbl_contains({'',' '},v[6])and vim.tbl_contains({'',' '},v[8]))return k end;f.get_content_height=function(self)if not self:option('wrap')then return vim.api.nvim_buf_line_count(self:get_buffer())end;local y=0;vim.api.nvim_buf_call(self:get_buffer(),function()for w,z in ipairs(vim.api.nvim_buf_get_lines(self:get_buffer(),0,-1,false))do y=y+math.max(1,math.ceil(vim.fn.strdisplaywidth(z)/self.style.width))end end)return y end;return f
