local a=require('cmp.utils.misc')local b=require('cmp.utils.buffer')local c=require('cmp.utils.api')local d={}d.t=function(e)return string.gsub(e,'(<[A-Za-z0-9\\%-%[%]%^@]->)',function(f)return vim.api.nvim_eval(string.format([["\%s"]],f))end)end;d.normalize=function(e)local g=b.ensure('cmp.util.keymap.normalize')vim.api.nvim_buf_set_keymap(g,'t',e,'<Plug>(cmp.utils.keymap.normalize)',{})for h,i in ipairs(vim.api.nvim_buf_get_keymap(g,'t'))do if d.t(i.rhs)==d.t('<Plug>(cmp.utils.keymap.normalize)')then vim.api.nvim_buf_del_keymap(g,'t',e)return i.lhs end end;vim.api.nvim_buf_del_keymap(g,'t',e)vim.api.nvim_buf_delete(g,{})return e end;d.to_keymap=setmetatable({['<CR>']={'\n','\r','\r\n'},['<Tab>']={'\t'},['<BSlash>']={'\\'},['<Bar>']={'|'},['<Space>']={' '}},{__call=function(self,j)return string.gsub(j,'.',function(k)for l,m in pairs(self)do if vim.tbl_contains(m,k)then return l end end;return k end)end})d.undobreak=function()if not c.is_insert_mode()then return''end;return d.t('<C-g>u')end;d.undojoin=function()if not c.is_insert_mode()then return''end;return d.t('<C-g>U')end;d.backspace=function(n)if type(n)=='string'then n=vim.fn.strchars(n,true)end;if n<=0 then return''end;local e={}table.insert(e,d.t(string.rep('<BS>',n)))return table.concat(e,'')end;d.delete=function(n)if type(n)=='string'then n=vim.fn.strchars(n,true)end;if n<=0 then return''end;local e={}table.insert(e,d.t(string.rep('<Del>',n)))return table.concat(e,'')end;d.indentkeys=function(o)return string.format(d.t('<Cmd>set indentkeys=%s<CR>'),o and vim.fn.escape(o,'| \t\\')or'')end;d.equals=function(p,q)return d.normalize(p)==d.normalize(q)end;d.listen=function(r,s,t)s=d.normalize(d.to_keymap(s))local u=d.get_map(r,s)if u.desc=='cmp.utils.keymap.set_map'then return end;local v=u.buffer and vim.api.nvim_get_current_buf()or-1;local w=d.fallback(v,r,u)d.set_map(v,r,s,function()local x=false;x=x or r=='c'and vim.fn.getcmdtype()=='='if x then w()else t(s,a.once(w))end end,{expr=false,noremap=true,silent=true})end;d.fallback=function(v,r,i)return function()if i.expr then local y=string.format('<Plug>(cmp.u.k.fallback_expr:%s)',i.lhs)d.set_map(v,r,y,function()return d.solve(v,r,i).keys end,{expr=true,noremap=i.noremap,script=i.script,nowait=i.nowait,silent=i.silent and r~='c',replace_keycodes=i.replace_keycodes})vim.api.nvim_feedkeys(d.t(y),'im',true)elseif i.callback then i.callback()else local z=d.solve(v,r,i)vim.api.nvim_feedkeys(z.keys,z.mode,true)end end end;d.solve=function(v,r,i)local s=d.t(i.lhs)local A=d.t(i.rhs)if i.expr then if i.callback then A=i.callback()else A=vim.api.nvim_eval(d.t(i.rhs))end end;if i.noremap then return{keys=A,mode='in'}end;if string.find(A,s,1,true)==1 then local B=string.format('<SNR>0_(cmp.u.k.recursive:%s)',s)d.set_map(v,r,B,s,{noremap=true,script=true,nowait=i.nowait,silent=i.silent and r~='c',replace_keycodes=i.replace_keycodes})return{keys=d.t(B)..string.gsub(A,'^'..vim.pesc(s),''),mode='im'}end;return{keys=A,mode='im'}end;d.get_map=function(r,s)s=d.normalize(s)for h,i in ipairs(vim.api.nvim_buf_get_keymap(0,r))do if d.equals(i.lhs,s)then return{lhs=i.lhs,rhs=i.rhs or'',expr=i.expr==1,callback=i.callback,desc=i.desc,noremap=i.noremap==1,script=i.script==1,silent=i.silent==1,nowait=i.nowait==1,buffer=true,replace_keycodes=i.replace_keycodes==1}end end;for h,i in ipairs(vim.api.nvim_get_keymap(r))do if d.equals(i.lhs,s)then return{lhs=i.lhs,rhs=i.rhs or'',expr=i.expr==1,callback=i.callback,desc=i.desc,noremap=i.noremap==1,script=i.script==1,silent=i.silent==1,nowait=i.nowait==1,buffer=false,replace_keycodes=i.replace_keycodes==1}end end;return{lhs=s,rhs=s,expr=false,callback=nil,noremap=true,script=false,silent=true,nowait=false,buffer=false,replace_keycodes=true}end;d.set_map=function(v,r,s,A,C)if type(A)=='function'then C.callback=A;A=''end;C.desc='cmp.utils.keymap.set_map'if vim.fn.has('nvim-0.8')==0 then C.replace_keycodes=nil end;if v==-1 then vim.api.nvim_set_keymap(r,s,A,C)else vim.api.nvim_buf_set_keymap(v,r,s,A,C)end end;return d
