local a=require('cmp.utils.feedkeys')local b=require('cmp.config')local c={}local d={}vim.api.nvim_create_autocmd('VimLeavePre',{callback=function()for e,f in pairs(d)do if f and not f:is_closing()then f:stop()f:close()end end end})c.throttle=function(g,h)local i=nil;local f=assert(vim.loop.new_timer())local j=nil;d[#d+1]=f;local k;k=setmetatable({running=false,timeout=h,sync=function(self,l)if not self.running then return end;vim.wait(l or 1000,function()return not self.running end,10)end,stop=function(m)if m~=false then i=nil end;k.running=false;f:stop()if j then j:cancel()j=nil end end},{__call=function(self,...)local n={...}if i==nil then i=vim.loop.now()end;self.stop(false)self.running=true;f:start(math.max(1,self.timeout-(vim.loop.now()-i)),0,function()vim.schedule(function()i=nil;local o=g(unpack(n))if c.is_async(o)then j=o;j:await(function(e,error)j=nil;self.running=false;if error and error~='abort'then vim.notify(error,vim.log.levels.ERROR)end end)else self.running=false end end)end)end})return k end;c.step=function(...)local p={...}local q;q=function(...)if#p>0 then table.remove(p,1)(q,...)end end;table.remove(p,1)(q)end;c.timeout=function(g,h)local f;local r=false;local s=function(...)if not r then r=true;f:stop()f:close()g(...)end end;f=vim.loop.new_timer()f:start(h,0,function()s()end)return s end;c.dedup=function()local t=0;return function(s)t=t+1;local u=t;return function(...)if u==t then s(...)end end end end;c.sync=function(v,h)local r=false;v(function()r=true end)vim.wait(h,function()return r end,10,false)end;c.debounce_next_tick=function(s)local w=false;return function()if w then return end;w=true;vim.schedule(function()w=false;s()end)end end;c.debounce_next_tick_by_keymap=function(s)return function()a.call('','',s)end end;local x={}x._queue={}x._executor=assert(vim.loop.new_check())function x.step()local y=b.get().performance.async_budget*1e6;local z=vim.loop.hrtime()while#x._queue>0 and vim.loop.hrtime()-z<y do local A=table.remove(x._queue,1)A:_step()if A.running then table.insert(x._queue,A)end end;if#x._queue==0 then return x._executor:stop()end end;function x.add(A)table.insert(x._queue,A)if not x._executor:is_active()then x._executor:start(vim.schedule_wrap(x.step))end end;local B={}B.__index=B;function B.new(g)local self=setmetatable({},B)self.callbacks={}self.running=true;self.thread=coroutine.create(g)x.add(self)return self end;function B:_done(C,error)if self.running then self.running=false;self.result=C;self.error=error end;for e,s in ipairs(self.callbacks)do s(C,error)end;self.callbacks={}end;function B:_step()local D,E=coroutine.resume(self.thread)if not D then return self:_done(nil,E)elseif E=='abort'then return self:_done(nil,'abort')elseif coroutine.status(self.thread)=='dead'then return self:_done(E)end end;function B:cancel()self:_done(nil,'abort')end;function B:await(F)if not F then error('callback is required')end;if self.running then table.insert(self.callbacks,F)else F(self.result,self.error)end end;function B:sync()while self.running do vim.wait(10)end;return self.error and error(self.error)or self.result end;function c.is_async(G)return G and type(G)=='table'and getmetatable(G)==B end;function c.wrap(g)return function(...)local n={...}return B.new(function()return g(unpack(n))end)end end;function c.yield(...)if coroutine.running()==nil then error('Trying to yield from a non-yieldable context')return...end;return coroutine.yield(...)end;function c.abort()return c.yield('abort')end;return c
