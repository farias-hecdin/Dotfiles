local a=require('cmp.core')local b=require('cmp.source')local c=require('cmp.config')local d=require('cmp.utils.feedkeys')local e=require('cmp.utils.autocmd')local f=require('cmp.utils.keymap')local g=require('cmp.utils.misc')local h=require('cmp.utils.async')local i={}i.core=a.new()for j,k in pairs(require('cmp.types.cmp'))do i[j]=k end;i.lsp=require('cmp.types.lsp')i.vim=require('cmp.types.vim')i.event=i.core.event;i.mapping=require('cmp.config.mapping')i.config={}i.config.disable=g.none;i.config.compare=require('cmp.config.compare')i.config.sources=require('cmp.config.sources')i.config.mapping=require('cmp.config.mapping')i.config.window=require('cmp.config.window')i.sync=function(l)return function(...)i.core.filter:sync(1000)if l then return l(...)end end end;i.suspend=function()return i.core:suspend()end;i.register_source=function(m,n)local o=b.new(m,n)i.core:register_source(o)return o.id end;i.unregister_source=function(p)i.core:unregister_source(p)end;i.get_config=function()return require('cmp.config').get()end;i.complete=i.sync(function(q)q=q or{}c.set_onetime(q.config)i.core:complete(i.core:get_context({reason=q.reason or i.ContextReason.Manual}))return true end)i.complete_common_string=i.sync(function()return i.core:complete_common_string()end)i.visible=i.sync(function()return i.core.view:visible()or vim.fn.pumvisible()==1 end)i.get_selected_entry=i.sync(function()return i.core.view:get_selected_entry()end)i.get_active_entry=i.sync(function()return i.core.view:get_active_entry()end)i.get_entries=i.sync(function()return i.core.view:get_entries()end)i.close=i.sync(function()if i.core.view:visible()then local r=i.core:suspend()i.core.view:close()vim.schedule(r)return true else return false end end)i.abort=i.sync(function()if i.core.view:visible()then local r=i.core:suspend()i.core.view:abort()vim.schedule(r)return true else return false end end)i.select_next_item=i.sync(function(q)q=q or{}q.behavior=q.behavior or i.SelectBehavior.Insert;q.count=q.count or 1;if i.core.view:visible()then local r=i.core:suspend()i.core.view:select_next_item(q)vim.schedule(r)return true elseif vim.fn.pumvisible()==1 then if q.behavior==i.SelectBehavior.Insert then d.call(f.t(string.rep('<C-n>',q.count)),'in')else d.call(f.t(string.rep('<Down>',q.count)),'in')end;return true end;return false end)i.select_prev_item=i.sync(function(q)q=q or{}q.behavior=q.behavior or i.SelectBehavior.Insert;q.count=q.count or 1;if i.core.view:visible()then local r=i.core:suspend()i.core.view:select_prev_item(q)vim.schedule(r)return true elseif vim.fn.pumvisible()==1 then if q.behavior==i.SelectBehavior.Insert then d.call(f.t(string.rep('<C-p>',q.count)),'in')else d.call(f.t(string.rep('<Up>',q.count)),'in')end;return true end;return false end)i.scroll_docs=i.sync(function(s)if i.core.view.docs_view:visible()then i.core.view:scroll_docs(s)return true else return false end end)i.confirm=i.sync(function(q,l)q=q or{}q.select=q.select or false;q.behavior=q.behavior or i.get_config().confirmation.default_behavior or i.ConfirmBehavior.Insert;l=l or function()end;if i.core.view:visible()then local t=i.core.view:get_selected_entry()if not t and q.select then t=i.core.view:get_first_entry()end;if t then i.core:confirm(t,{behavior=q.behavior},function()l()i.core:complete(i.core:get_context({reason=i.ContextReason.TriggerOnly}))end)return true end elseif vim.fn.pumvisible()==1 then local u=vim.fn.complete_info({'selected'}).selected;if u==-1 and q.select then u=0 end;if u~=-1 then vim.api.nvim_select_popupmenu_item(u,true,true,{})return true end end;return false end)i.status=function()local v={}v.available={}v.unavailable={}v.installed={}v.invalid={}local w={}for x,n in pairs(i.core.sources)do w[n.name]=true;if c.get_source_config(n.name)then if n:is_available()then table.insert(v.available,n:get_debug_name())else table.insert(v.unavailable,n:get_debug_name())end else table.insert(v.installed,n:get_debug_name())end end;for x,n in ipairs(c.get().sources)do if not w[n.name]then table.insert(v.invalid,n.name)end end;if#v.available>0 then vim.api.nvim_echo({{'\n','Normal'}},false,{})vim.api.nvim_echo({{'# ready source names\n','Special'}},false,{})for x,m in ipairs(v.available)do vim.api.nvim_echo({{('- %s\n'):format(m),'Normal'}},false,{})end end;if#v.unavailable>0 then vim.api.nvim_echo({{'\n','Normal'}},false,{})vim.api.nvim_echo({{'# unavailable source names\n','Comment'}},false,{})for x,m in ipairs(v.unavailable)do vim.api.nvim_echo({{('- %s\n'):format(m),'Normal'}},false,{})end end;if#v.installed>0 then vim.api.nvim_echo({{'\n','Normal'}},false,{})vim.api.nvim_echo({{'# unused source names\n','WarningMsg'}},false,{})for x,m in ipairs(v.installed)do vim.api.nvim_echo({{('- %s\n'):format(m),'Normal'}},false,{})end end;if#v.invalid>0 then vim.api.nvim_echo({{'\n','Normal'}},false,{})vim.api.nvim_echo({{'# unknown source names\n','ErrorMsg'}},false,{})for x,m in ipairs(v.invalid)do vim.api.nvim_echo({{('- %s\n'):format(m),'Normal'}},false,{})end end end;i.setup=setmetatable({global=function(y)c.set_global(y)end,filetype=function(z,y)c.set_filetype(y,z)end,buffer=function(y)c.set_buffer(y,vim.api.nvim_get_current_buf())end,cmdline=function(A,y)c.set_cmdline(y,A)end},{__call=function(self,y)self.global(y)end})local B=function()if c.enabled()then i.config.compare.scopes:update()i.config.compare.locality:update()i.core:prepare()i.core:on_change('InsertEnter')end end;e.subscribe({'CmdlineEnter'},h.debounce_next_tick(B))e.subscribe({'InsertEnter'},h.debounce_next_tick_by_keymap(B))local C=function()if c.enabled()then i.core:on_change('TextChanged')end end;e.subscribe({'TextChangedI','TextChangedP'},C)e.subscribe('CmdlineChanged',h.debounce_next_tick(C))e.subscribe('CursorMovedI',function()if c.enabled()then i.core:on_moved()else i.core:reset()i.core.view:close()end end)e.subscribe({'InsertLeave','CmdlineLeave'},function()i.core:reset()i.core.view:close()end)i.event:on('complete_done',function(D)if D.entry then i.config.compare.recently_used:add_entry(D.entry)end;i.config.compare.scopes:update()i.config.compare.locality:update()end)i.event:on('confirm_done',function(D)if D.entry then i.config.compare.recently_used:add_entry(D.entry)end end)return i
