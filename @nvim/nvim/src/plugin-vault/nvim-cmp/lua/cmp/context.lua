local a=require('cmp.utils.misc')local b=require('cmp.utils.pattern')local c=require('cmp.types')local d=require('cmp.utils.cache')local e=require('cmp.utils.api')local f={}f.empty=function()local g=f.new({})g.bufnr=-1;g.input=''g.cursor={}g.cursor.row=-1;g.cursor.col=-1;return g end;f.new=function(h,i)i=i or{}local self=setmetatable({},{__index=f})self.id=a.id('cmp.context.new')self.cache=d.new()self.prev_context=h or f.empty()self.option=i or{reason=c.cmp.ContextReason.None}self.filetype=vim.api.nvim_buf_get_option(0,'filetype')self.time=vim.loop.now()self.bufnr=vim.api.nvim_get_current_buf()local j=e.get_cursor()self.cursor_line=e.get_current_line()self.cursor={}self.cursor.row=j[1]self.cursor.col=j[2]+1;self.cursor.line=self.cursor.row-1;self.cursor.character=a.to_utfindex(self.cursor_line,self.cursor.col)self.cursor_before_line=string.sub(self.cursor_line,1,self.cursor.col-1)self.cursor_after_line=string.sub(self.cursor_line,self.cursor.col)self.aborted=false;return self end;f.abort=function(self)self.aborted=true end;f.get_reason=function(self)return self.option.reason end;f.get_offset=function(self,k)return self.cache:ensure({'get_offset',k,self.cursor_before_line},function()return b.offset([[\%(]]..k..[[\)\m$]],self.cursor_before_line)or self.cursor.col end)end;f.changed=function(self,g)local l=self;if l.bufnr~=g.bufnr then return true end;if l.cursor.row~=g.cursor.row then return true end;if l.cursor.col~=g.cursor.col then return true end;if l:get_reason()==c.cmp.ContextReason.Manual then return true end;return false end;f.clone=function(self)local m={}for n,o in pairs(self)do m[n]=o end;return m end;return f
