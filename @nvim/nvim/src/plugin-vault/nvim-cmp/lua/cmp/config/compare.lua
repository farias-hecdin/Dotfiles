local a=require('cmp.types')local b=require('cmp.utils.cache')local c={}c.offset=function(d,e)local f=d:get_offset()-e:get_offset()if f<0 then return true elseif f>0 then return false end end;c.exact=function(d,e)if d.exact~=e.exact then return d.exact end end;c.score=function(d,e)local f=e.score-d.score;if f<0 then return true elseif f>0 then return false end end;c.recently_used=setmetatable({records={},add_entry=function(self,g)self.records[g.completion_item.label]=vim.loop.now()end},{__call=function(self,d,e)local h=self.records[d.completion_item.label]or-1;local i=self.records[e.completion_item.label]or-1;if h~=i then return h>i end end})c.kind=function(d,e)local j=d:get_kind()j=j==a.lsp.CompletionItemKind.Text and 100 or j;local k=e:get_kind()k=k==a.lsp.CompletionItemKind.Text and 100 or k;if j~=k then if j==a.lsp.CompletionItemKind.Snippet then return true end;if k==a.lsp.CompletionItemKind.Snippet then return false end;local f=j-k;if f<0 then return true elseif f>0 then return false end end end;c.sort_text=function(d,e)if d.completion_item.sortText and e.completion_item.sortText then local f=vim.stricmp(d.completion_item.sortText,e.completion_item.sortText)if f<0 then return true elseif f>0 then return false end end end;c.length=function(d,e)local f=#d.completion_item.label-#e.completion_item.label;if f<0 then return true elseif f>0 then return false end end;c.order=function(d,e)local f=d.id-e.id;if f<0 then return true elseif f>0 then return false end end;c.locality=setmetatable({lines_count=10,lines_cache=b.new(),locality_map={},update=function(self)local l=require('cmp').get_config()if not vim.tbl_contains(l.sorting.comparators,c.locality)then return end;local m,n=vim.api.nvim_get_current_win(),vim.api.nvim_get_current_buf()local o=vim.api.nvim_win_get_cursor(m)[1]-1;local p=vim.api.nvim_buf_line_count(n)if self.lines_cache:get('buf')~=n then self.lines_cache:clear()self.lines_cache:set('buf',n)end;self.locality_map={}for q=math.max(0,o-self.lines_count),math.min(p,o+self.lines_count)do local r=q<o;local s=vim.api.nvim_buf_get_lines(n,q,q+1,false)[1]or''local t=self.lines_cache:ensure({'line',s},function()local t={}local u=vim.regex(l.completion.keyword_pattern)while s~=''do local v,g=u:match_str(s)if v and g then local w=string.sub(s,v+1,g)local x=math.abs(q-o)-(r and 1 or 0)t[w]=math.min(t[w]or math.huge,x)s=string.sub(s,g+1)else break end end;return t end)for w,x in pairs(t)do self.locality_map[w]=math.min(self.locality_map[w]or x,math.abs(q-o))end end end},{__call=function(self,d,e)local y=self.locality_map[d:get_word()]local z=self.locality_map[e:get_word()]if y~=z then if y==nil then return false end;if z==nil then return true end;return y<z end end})c.scopes=setmetatable({scopes_map={},update=function(self)local l=require('cmp').get_config()if not vim.tbl_contains(l.sorting.comparators,c.scopes)then return end;local A,B=pcall(require,'nvim-treesitter.locals')if A then local m,n=vim.api.nvim_get_current_win(),vim.api.nvim_get_current_buf()local o=vim.api.nvim_win_get_cursor(m)[1]-1;local C=nil;for D,E in ipairs(B.get_scopes(n))do if E:start()<=o and o<=E:end_()then if not C then C=E else if C:start()<=E:start()and E:end_()<=C:end_()then C=E end end elseif C and C:end_()<=E:start()then break end end;local F=B.get_definitions_lookup_table(n)local G=0;for E in B.iter_scope_tree(C,n)do local v,g=E:start(),E:end_()for D,H in pairs(F)do if v<=H.node:start()and H.node:end_()<=g then if E:id()==B.containing_scope(H.node,n):id()then local I=vim.treesitter.get_node_text or vim.treesitter.query.get_node_text;local J=I(H.node,n)or''if not self.scopes_map[J]then self.scopes_map[J]=G end end end end;G=G+1 end end end},{__call=function(self,d,e)local y=self.scopes_map[d:get_word()]local z=self.scopes_map[e:get_word()]if y~=z then if y==nil then return false end;if z==nil then return true end;return y<z end end})return c
