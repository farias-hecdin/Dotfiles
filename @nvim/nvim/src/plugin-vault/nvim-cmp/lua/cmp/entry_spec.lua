local a=require('cmp.utils.spec')local b=require('cmp.entry')describe('entry',function()before_each(a.before)it('one char',function()local c=a.state('@.',1,3)c.input('@')local d=b.new(c.manual(),c.source(),{label='@'})assert.are.equal(d:get_offset(),3)assert.are.equal(d:get_vim_item(d:get_offset()).word,'@')end)it('word length (no fix)',function()local c=a.state('a.b',1,4)c.input('.')local d=b.new(c.manual(),c.source(),{label='b'})assert.are.equal(d:get_offset(),5)assert.are.equal(d:get_vim_item(d:get_offset()).word,'b')end)it('word length (fix)',function()local c=a.state('a.b',1,4)c.input('.')local d=b.new(c.manual(),c.source(),{label='b.'})assert.are.equal(d:get_offset(),3)assert.are.equal(d:get_vim_item(d:get_offset()).word,'b.')end)it('semantic index (no fix)',function()local c=a.state('a.bc',1,5)c.input('.')local d=b.new(c.manual(),c.source(),{label='c.'})assert.are.equal(d:get_offset(),6)assert.are.equal(d:get_vim_item(d:get_offset()).word,'c.')end)it('semantic index (fix)',function()local c=a.state('a.bc',1,5)c.input('.')local d=b.new(c.manual(),c.source(),{label='bc.'})assert.are.equal(d:get_offset(),3)assert.are.equal(d:get_vim_item(d:get_offset()).word,'bc.')end)it('[vscode-html-language-server] 1',function()local c=a.state('    </>',1,7)c.input('.')local d=b.new(c.manual(),c.source(),{label='/div',textEdit={range={start={line=0,character=0},['end']={line=0,character=6}},newText='  </div'}})assert.are.equal(d:get_offset(),5)assert.are.equal(d:get_vim_item(d:get_offset()).word,'</div')end)it('[clangd] 1',function()local c=a.state('foo',1,4)c.input('.')local d=b.new(c.manual(),c.source(),{insertText='->foo',label=' foo',textEdit={newText='->foo',range={start={character=3,line=1},['end']={character=4,line=1}}}})assert.are.equal(d:get_vim_item(4).word,'->foo')assert.are.equal(d:get_filter_text(),'foo')end)it('[typescript-language-server] 1',function()local c=a.state('Promise.resolve()',1,18)c.input('.')local d=b.new(c.manual(),c.source(),{label='catch'})assert.are.equal(d:get_vim_item(18).word,'.catch')assert.are.equal(d:get_filter_text(),'catch')end)it('[typescript-language-server] 2',function()local c=a.state('Promise.resolve()',1,18)c.input('.')local d=b.new(c.manual(),c.source(),{filterText='.Symbol',label='Symbol',textEdit={newText='[Symbol]',range={['end']={character=18,line=0},start={character=17,line=0}}}})assert.are.equal(d:get_vim_item(18).word,'[Symbol]')assert.are.equal(d:get_filter_text(),'.Symbol')end)it('[lua-language-server] 1',function()local c=a.state("local m = require'cmp.confi",1,28)local d;c.input('g')d=b.new(c.manual(),c.source(),{insertTextFormat=2,label='cmp.config',textEdit={newText='cmp.config',range={['end']={character=27,line=1},start={character=18,line=1}}}})assert.are.equal(d:get_vim_item(19).word,'cmp.config')assert.are.equal(d:get_filter_text(),'cmp.config')c.input("'")d=b.new(c.manual(),c.source(),{insertTextFormat=2,label='cmp.config',textEdit={newText='cmp.config',range={['end']={character=27,line=1},start={character=18,line=1}}}})assert.are.equal(d:get_vim_item(19).word,'cmp.config')assert.are.equal(d:get_filter_text(),'cmp.config')end)it('[lua-language-server] 2',function()local c=a.state("local m = require'cmp.confi",1,28)local d;c.input('g')d=b.new(c.manual(),c.source(),{insertTextFormat=2,label='lua.cmp.config',textEdit={newText='lua.cmp.config',range={['end']={character=27,line=1},start={character=18,line=1}}}})assert.are.equal(d:get_vim_item(19).word,'lua.cmp.config')assert.are.equal(d:get_filter_text(),'lua.cmp.config')c.input("'")d=b.new(c.manual(),c.source(),{insertTextFormat=2,label='lua.cmp.config',textEdit={newText='lua.cmp.config',range={['end']={character=27,line=1},start={character=18,line=1}}}})assert.are.equal(d:get_vim_item(19).word,'lua.cmp.config')assert.are.equal(d:get_filter_text(),'lua.cmp.config')end)it('[intelephense] 1',function()local c=a.state('\t\t',1,4)c.input('$')local d=b.new(c.manual(),c.source(),{kind=6,label='$this',sortText='$this',textEdit={newText='$this',range={['end']={character=3,line=1},start={character=2,line=1}}}})assert.are.equal(d:get_vim_item(d:get_offset()).word,'$this')assert.are.equal(d:get_filter_text(),'$this')end)it('[odin-language-server] 1',function()local c=a.state('\t\t',1,4)c.input('s')local d=b.new(c.manual(),c.source(),{additionalTextEdits={},command={arguments={},command='',title=''},deprecated=false,detail='string',documentation='',insertText='',insertTextFormat=1,kind=14,label='string',tags={}})assert.are.equal(d:get_vim_item(d:get_offset()).word,'string')end)it('[#47] word should not contain \\n character',function()local c=a.state('',1,1)c.input('_')local d=b.new(c.manual(),c.source(),{kind=6,label='__init__',insertTextFormat=1,insertText='__init__(self) -> None:\n  pass'})assert.are.equal(d:get_vim_item(d:get_offset()).word,'__init__(self) -> None:')assert.are.equal(d:get_filter_text(),'__init__')end)it('[#1533] clang regression test',function()local c=a.state('jsonReader',3,11)local e=c.source()c.input('.')local d=b.new(c.manual(),e,{filterText='getPath()',kind=1,label='getPath()',textEdit={newText='getPath()',range={['end']={character=11,col=12,line=2,row=3},start={character=11,line=2}}}})assert.are.equal(d:get_offset(),12)assert.are.equal(d:get_vim_item(d:get_offset()).word,'getPath()')end)end)
