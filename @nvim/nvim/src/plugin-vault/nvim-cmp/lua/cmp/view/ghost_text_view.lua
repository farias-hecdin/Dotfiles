local a=require('cmp.config')local b=require('cmp.utils.misc')local c=require('cmp.utils.str')local d=require('cmp.types')local e=require('cmp.utils.api')local f={}f.ns=vim.api.nvim_create_namespace('cmp:GHOST_TEXT')local g=(function()return pcall(function()local h=vim.api.nvim_buf_set_extmark(0,f.ns,0,0,{virt_text={{' ','Comment'}},virt_text_pos='inline',hl_mode='combine',ephemeral=true})vim.api.nvim_buf_del_extmark(0,f.ns,h)end)end)()f.new=function()local self=setmetatable({},{__index=f})self.win=nil;self.entry=nil;vim.api.nvim_set_decoration_provider(f.ns,{on_win=function(i,j)return j==self.win end,on_line=function(i,i,i,k)local l=a.get().experimental.ghost_text;if not l then return end;if not self.entry then return end;local m,n=unpack(vim.api.nvim_win_get_cursor(0))if k~=m-1 then return end;local o=vim.api.nvim_get_current_line()if not g then if string.sub(o,n+1)~=''then return end end;local p=self.text_gen(self,o,n)if#p>0 then vim.api.nvim_buf_set_extmark(0,f.ns,m-1,n,{right_gravity=false,virt_text={{p,type(l)=='table'and l.hl_group or'Comment'}},virt_text_pos=g and'inline'or'overlay',hl_mode='combine',ephemeral=true})end end})return self end;f.text_gen=function(self,o,q)local r=self.entry:get_insert_text()if self.entry.completion_item.insertTextFormat==d.lsp.InsertTextFormat.Snippet then r=vim.lsp.util.parse_snippet(r)end;r=c.oneline(r)local s=vim.str_utfindex(r)local t=string.sub(o,self.entry:get_offset(),q)local u=vim.str_utfindex(t)local v=s-u;local p;if v>0 then p=string.sub(r,vim.str_byteindex(r,s-v)+1)else p=''end;return p end;f.show=function(self,w)if not e.is_insert_mode()then return end;local l=a.get().experimental.ghost_text;if not l then return end;local x=w~=self.entry;self.win=vim.api.nvim_get_current_win()self.entry=w;if x then b.redraw(true)end end;f.hide=function(self)if self.win and self.entry then self.win=nil;self.entry=nil;b.redraw(true)end end;return f
