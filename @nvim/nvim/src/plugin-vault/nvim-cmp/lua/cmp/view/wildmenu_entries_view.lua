local a=require('cmp.utils.event')local b=require('cmp.utils.autocmd')local c=require('cmp.utils.feedkeys')local d=require('cmp.config')local e=require('cmp.utils.window')local f=require('cmp.types')local g=require('cmp.utils.keymap')local h=require('cmp.utils.misc')local i=require('cmp.utils.api')local j={}j.ns=vim.api.nvim_create_namespace('cmp.view.statusline_entries_view')j.new=function()local self=setmetatable({},{__index=j})self.event=a.new()self.offset=-1;self.active=false;self.entries={}self.offsets={}self.selected_index=0;self.entries_win=e.new()self.entries_win:option('conceallevel',2)self.entries_win:option('concealcursor','n')self.entries_win:option('cursorlineopt','line')self.entries_win:option('foldenable',false)self.entries_win:option('wrap',false)self.entries_win:option('scrolloff',0)self.entries_win:option('sidescrolloff',0)self.entries_win:option('winhighlight','Normal:Pmenu,FloatBorder:Pmenu,CursorLine:PmenuSel,Search:None')self.entries_win:buffer_option('tabstop',1)b.subscribe('CompleteChanged',vim.schedule_wrap(function()if self:visible()and vim.fn.pumvisible()==1 then self:close()end end))vim.api.nvim_set_decoration_provider(j.ns,{on_win=function(k,l,m,k,k)if l~=self.entries_win.win or m~=self.entries_win:get_buffer()then return end;for n,o in ipairs(self.entries)do if o then local p=o:get_view(self.offset,m)vim.api.nvim_buf_set_extmark(m,j.ns,0,self.offsets[n],{end_line=0,end_col=self.offsets[n]+p.abbr.bytes,hl_group=p.abbr.hl_group,hl_mode='combine',ephemeral=true})if n==self.selected_index then vim.api.nvim_buf_set_extmark(m,j.ns,0,self.offsets[n],{end_line=0,end_col=self.offsets[n]+p.abbr.bytes,hl_group='PmenuSel',hl_mode='combine',ephemeral=true})end;for k,q in ipairs(o.matches or{})do vim.api.nvim_buf_set_extmark(m,j.ns,0,self.offsets[n]+q.word_match_start-1,{end_line=0,end_col=self.offsets[n]+q.word_match_end,hl_group=q.fuzzy and'CmpItemAbbrMatchFuzzy'or'CmpItemAbbrMatch',hl_mode='combine',ephemeral=true})end end end end})return self end;j.close=function(self)self.entries_win:close()end;j.ready=function()return vim.fn.pumvisible()==0 end;j.on_change=function(self)self.active=false end;j.open=function(self,r,s)self.offset=r;self.entries={}self.entries_win:option('winblend',vim.o.pumblend)local t={}local u=0;local n=1;for k,o in ipairs(s)do local p=o:get_view(r,0)if p.dup==1 or not t[o.completion_item.label]then t[o.completion_item.label]=true;table.insert(self.entries,o)if u==0 and o.completion_item.preselect then u=n end;n=n+1 end end;self.entries_win:open({relative='editor',style='minimal',row=vim.o.lines-2,col=0,width=vim.o.columns,height=1,zindex=1001})self:draw()if u>0 and d.get().preselect==f.cmp.PreselectMode.Item then self:_select(u,{behavior=f.cmp.SelectBehavior.Select})elseif not string.match(d.get().completion.completeopt,'noselect')then self:_select(1,{behavior=f.cmp.SelectBehavior.Select})else self:_select(0,{behavior=f.cmp.SelectBehavior.Select})end end;j.abort=function(self)c.call('','n',function()self:close()end)end;j.draw=function(self)self.offsets={}local v=self.entries_win:get_buffer()local w={}local r=0;for k,o in ipairs(self.entries)do local p=o:get_view(self.offset,v)table.insert(self.offsets,r)table.insert(w,p.abbr.text)r=r+p.abbr.bytes+#self:_get_separator()end;vim.api.nvim_buf_set_lines(v,0,1,false,{table.concat(w,self:_get_separator())})vim.api.nvim_buf_set_option(v,'modified',false)vim.api.nvim_win_call(0,function()h.redraw()end)end;j.visible=function(self)return self.entries_win:visible()end;j.info=function(self)return self.entries_win:info()end;j.select_next_item=function(self,x)if self:visible()then local y;if self.selected_index==0 or self.selected_index==#self.entries then y=x.count else y=self.selected_index+x.count end;y=math.max(math.min(y,#self.entries),0)self:_select(y,x)end end;j.select_prev_item=function(self,x)if self:visible()then if self.selected_index==0 or self.selected_index<=1 then self:_select(#self.entries,x)else self:_select(math.max(self.selected_index-x.count,0),x)end end end;j.get_offset=function(self)if self:visible()then return self.offset end;return nil end;j.get_entries=function(self)if self:visible()then return self.entries end;return{}end;j.get_first_entry=function(self)if self:visible()then return self.entries[1]end end;j.get_selected_entry=function(self)if self:visible()and self.active then return self.entries[self.selected_index]end end;j.get_active_entry=function(self)if self:visible()and self.active then return self:get_selected_entry()end end;j._select=function(self,z,x)local A=self.selected_index<z;self.selected_index=z;self.active=z~=0;if self.active then local o=self:get_active_entry()if x.behavior==f.cmp.SelectBehavior.Insert then local y=i.get_cursor()local B=o:get_vim_item(self.offset).word;vim.api.nvim_feedkeys(g.backspace(string.sub(i.get_current_line(),self.offset,y[2]))..B,'int',true)end;vim.api.nvim_win_call(self.entries_win.win,function()local p=o:get_view(self.offset,self.entries_win:get_buffer())vim.api.nvim_win_set_cursor(0,{1,self.offsets[z]+(A and p.abbr.bytes or 0)})vim.cmd([[redraw!]])end)end;self.event:emit('change')end;j._get_separator=function()local C=d.get()return C and C.view and C.view.entries and C.view.entries.separator or'  'end;return j
