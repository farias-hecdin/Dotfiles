local a=require('cmp.utils.event')local b=require('cmp.utils.autocmd')local c=require('cmp.utils.feedkeys')local d=require('cmp.utils.window')local e=require('cmp.config')local f=require('cmp.types')local g=require('cmp.utils.keymap')local h=require('cmp.utils.misc')local i=require('cmp.utils.api')local j=10;local k={}k.ns=vim.api.nvim_create_namespace('cmp.view.custom_entries_view')k.new=function()local self=setmetatable({},{__index=k})self.entries_win=d.new()self.entries_win:option('conceallevel',2)self.entries_win:option('concealcursor','n')self.entries_win:option('cursorlineopt','line')self.entries_win:option('foldenable',false)self.entries_win:option('wrap',false)self.entries_win:buffer_option('tabstop',1)self.entries_win:buffer_option('filetype','cmp_menu')self.entries_win:buffer_option('buftype','nofile')self.event=a.new()self.offset=-1;self.active=false;self.entries={}self.bottom_up=false;b.subscribe('CompleteChanged',vim.schedule_wrap(function()if self:visible()and vim.fn.pumvisible()==1 then self:close()end end))vim.api.nvim_set_decoration_provider(k.ns,{on_win=function(l,m,n,o,p)if m~=self.entries_win.win or n~=self.entries_win:get_buffer()then return end;local q=e.get().formatting.fields;for r=o,p do local s=self.entries[r+1]if s then local t=s:get_view(self.offset,n)local u=e.get().window.completion.side_padding;local v=0;for l,w in ipairs(q)do if w==f.cmp.ItemField.Abbr then v=u end;vim.api.nvim_buf_set_extmark(n,k.ns,r,u,{end_line=r,end_col=u+t[w].bytes,hl_group=t[w].hl_group,hl_mode='combine',ephemeral=true})u=u+t[w].bytes+self.column_width[w]-t[w].width+1 end;for l,x in ipairs(s.matches or{})do vim.api.nvim_buf_set_extmark(n,k.ns,r,v+x.word_match_start-1,{end_line=r,end_col=v+x.word_match_end,hl_group=x.fuzzy and'CmpItemAbbrMatchFuzzy'or'CmpItemAbbrMatch',hl_mode='combine',ephemeral=true})end end end end})return self end;k.ready=function()return vim.fn.pumvisible()==0 end;k.on_change=function(self)self.active=false end;k.is_direction_top_down=function(self)local y=e.get()if(y.view and y.view.entries and y.view.entries.selection_order)=='top_down'then return true elseif y.view.entries==nil or y.view.entries.selection_order==nil then return true else return not self.bottom_up end end;k.open=function(self,z,A)local B=e.get().window.completion;self.offset=z;self.entries={}self.column_width={abbr=0,kind=0,menu=0}local C=self.entries_win:get_buffer()local D={}local E={}local F=0;for l,s in ipairs(A)do local G=s:get_view(z,C)if G.dup==1 or not E[s.completion_item.label]then E[s.completion_item.label]=true;self.column_width.abbr=math.max(self.column_width.abbr,G.abbr.width)self.column_width.kind=math.max(self.column_width.kind,G.kind.width)self.column_width.menu=math.max(self.column_width.menu,G.menu.width)table.insert(self.entries,s)table.insert(D,' ')if F==0 and s.completion_item.preselect then F=#self.entries end end end;vim.api.nvim_buf_set_lines(C,0,-1,false,D)vim.api.nvim_buf_set_option(C,'modified',false)local H=0;H=H+1;H=H+self.column_width.abbr+(self.column_width.kind>0 and 1 or 0)H=H+self.column_width.kind+(self.column_width.menu>0 and 1 or 0)H=H+self.column_width.menu+1;local I=vim.api.nvim_get_option('pumheight')I=I~=0 and I or#self.entries;I=math.min(I,#self.entries)local J=i.get_screen_cursor()local K=i.get_cursor_before_line()local L=vim.fn.strdisplaywidth(K:sub(self.offset))local M,N=J[1],J[2]-L-1;local O=d.get_border_info({style=B})local P=O.top+O.bottom;local Q=O.left+O.right;if math.floor(vim.o.lines*0.5)<=M+P and vim.o.lines-M-P<=math.min(j,I)then I=math.min(I,M-1)M=M-I-P-1;if M<0 then I=I+M end end;if math.floor(vim.o.columns*0.5)<=N+Q and vim.o.columns-N-Q<=H then H=math.min(H,vim.o.columns-1)N=vim.o.columns-H-Q-1;if N<0 then H=H+N end end;if J[1]>M then self.bottom_up=true else self.bottom_up=false end;if not self:is_direction_top_down()then local R=#self.entries;for r=1,math.floor(R/2)do self.entries[r],self.entries[R-r+1]=self.entries[R-r+1],self.entries[r]end;if F~=0 then F=#self.entries-F+1 end end;self.entries_win:option('winblend',vim.o.pumblend)self.entries_win:option('winhighlight',B.winhighlight)self.entries_win:option('scrolloff',B.scrolloff)self.entries_win:open({relative='editor',style='minimal',row=math.max(0,M),col=math.max(0,N+B.col_offset),width=H,height=I,border=B.border,zindex=B.zindex or 1001})vim.api.nvim_win_set_cursor(self.entries_win.win,{1,0})if F>0 and e.get().preselect==f.cmp.PreselectMode.Item then self:_select(F,{behavior=f.cmp.SelectBehavior.Select,active=false})elseif not string.match(e.get().completion.completeopt,'noselect')then if self:is_direction_top_down()then self:_select(1,{behavior=f.cmp.SelectBehavior.Select,active=false})else self:_select(#self.entries,{behavior=f.cmp.SelectBehavior.Select,active=false})end else if self:is_direction_top_down()then self:_select(0,{behavior=f.cmp.SelectBehavior.Select,active=false})else self:_select(#self.entries+1,{behavior=f.cmp.SelectBehavior.Select,active=false})end end end;k.close=function(self)self.prefix=nil;self.offset=-1;self.active=false;self.entries={}self.entries_win:close()self.bottom_up=false end;k.abort=function(self)if self.prefix then self:_insert(self.prefix)end;c.call('','n',function()self:close()end)end;k.draw=function(self)local S=vim.fn.getwininfo(self.entries_win.win)[1]local T=S.topline-1;local U=S.topline+S.height-1;local V={}local q=e.get().formatting.fields;local C=self.entries_win:get_buffer()for r=T,U-1 do local s=self.entries[r+1]if s then local G=s:get_view(self.offset,C)local W={}table.insert(W,string.rep(' ',e.get().window.completion.side_padding))for l,w in ipairs(q)do table.insert(W,G[w].text)table.insert(W,string.rep(' ',1+self.column_width[w]-G[w].width))end;table.insert(W,string.rep(' ',e.get().window.completion.side_padding))table.insert(V,table.concat(W,''))end end;vim.api.nvim_buf_set_lines(C,T,U,false,V)vim.api.nvim_buf_set_option(C,'modified',false)if i.is_cmdline_mode()then vim.api.nvim_win_call(self.entries_win.win,function()h.redraw()end)end end;k.visible=function(self)return self.entries_win:visible()end;k.info=function(self)return self.entries_win:info()end;k.select_next_item=function(self,X)if self:visible()then local Y=vim.api.nvim_win_get_cursor(self.entries_win.win)[1]local Z=self:is_direction_top_down()local _=#self.entries;if not self.entries_win:option('cursorline')then Y=Z and 1 or _ else if Z then if Y==_ then Y=0 else Y=Y+X.count;if _<Y then Y=_ end end else if Y==0 then Y=_ else Y=Y-X.count;if Y<0 then Y=0 end end end end;self:_select(Y,{behavior=X.behavior or f.cmp.SelectBehavior.Insert,active=true})end end;k.select_prev_item=function(self,X)if self:visible()then local Y=vim.api.nvim_win_get_cursor(self.entries_win.win)[1]local Z=self:is_direction_top_down()local _=#self.entries;if not self.entries_win:option('cursorline')then Y=Z and _ or 1 else if Z then if Y==1 then Y=0 else Y=Y-X.count;if Y<0 then Y=1 end end else if Y==_ then Y=0 else Y=Y+X.count;if _<Y then Y=_ end end end end;self:_select(Y,{behavior=X.behavior or f.cmp.SelectBehavior.Insert,active=true})end end;k.get_offset=function(self)if self:visible()then return self.offset end;return nil end;k.get_entries=function(self)if self:visible()then return self.entries end;return{}end;k.get_first_entry=function(self)if self:visible()then return self:is_direction_top_down()and self.entries[1]or self.entries[#self.entries]end end;k.get_selected_entry=function(self)if self:visible()and self.entries_win:option('cursorline')then return self.entries[vim.api.nvim_win_get_cursor(self.entries_win.win)[1]]end end;k.get_active_entry=function(self)if self:visible()and self.active then return self:get_selected_entry()end end;k._select=function(self,Y,X)local a0=(X.behavior or f.cmp.SelectBehavior.Insert)==f.cmp.SelectBehavior.Insert;if a0 and not self.active then self.prefix=string.sub(i.get_current_line(),self.offset,i.get_cursor()[2])or''end;self.active=0<Y and Y<=#self.entries and X.active==true;self.entries_win:option('cursorline',Y>0 and Y<=#self.entries)vim.api.nvim_win_set_cursor(self.entries_win.win,{math.max(math.min(Y,#self.entries),1),0})if a0 then self:_insert(self.entries[Y]and self.entries[Y]:get_vim_item(self.offset).word or self.prefix)end;self.entries_win:update()self:draw()self.event:emit('change')end;k._insert=setmetatable({pending=false},{__call=function(a1,self,a2)a2=a2 or''if i.is_cmdline_mode()then local Y=i.get_cursor()if vim.fn.has('nvim-0.8')==1 then local a3=i.get_current_line()local a4=a3:sub(1,self.offset-1)local a5=a3:sub(Y[2]+1)local J=#a4+#a2+1;vim.fn.setcmdline(a4 ..a2 ..a5,J)vim.api.nvim_feedkeys(g.t('<Cmd>redraw<CR>'),'ni',false)else vim.api.nvim_feedkeys(g.backspace(string.sub(i.get_current_line(),self.offset,Y[2]))..a2,'int',true)end else if a1.pending then return end;a1.pending=true;local a6=require('cmp').suspend()c.call('','',function()local Y=i.get_cursor()local a7={}table.insert(a7,g.indentkeys())table.insert(a7,g.backspace(string.sub(i.get_current_line(),self.offset,Y[2])))table.insert(a7,a2)table.insert(a7,g.indentkeys(vim.bo.indentkeys))c.call(table.concat(a7,''),'int',vim.schedule_wrap(function()a1.pending=false;a6()end))end)end end})return k
