local a=require('cmp.utils.event')local b=require('cmp.utils.autocmd')local c=require('cmp.utils.keymap')local d=require('cmp.utils.feedkeys')local e=require('cmp.types')local f=require('cmp.config')local g=require('cmp.utils.api')local h={}h.new=function()local self=setmetatable({},{__index=h})self.event=a.new()self.offset=-1;self.items={}self.entries={}self.preselect_index=0;b.subscribe('CompleteChanged',function()self.event:emit('change')end)return self end;h.ready=function(i)if vim.fn.pumvisible()==0 then return true end;return vim.fn.complete_info({'mode'}).mode=='eval'end;h.on_change=function(self)if#self.entries>0 and self.offset<=vim.api.nvim_win_get_cursor(0)[2]+1 then local j=f.get().preselect==e.cmp.PreselectMode.Item;local k=vim.o.completeopt;if self.preselect_index==1 and j then vim.o.completeopt='menu,menuone,noinsert'else vim.o.completeopt=f.get().completion.completeopt end;vim.fn.complete(self.offset,self.items)vim.o.completeopt=k;if self.preselect_index>1 and j then self:preselect(self.preselect_index)end end end;h.open=function(self,l,m)local n={}local o={}local p={}local q=0;for i,r in ipairs(m)do local s=r:get_vim_item(l)if s.dup==1 or not n[s.abbr]then n[s.abbr]=true;table.insert(o,s)table.insert(p,r)if q==0 and r.completion_item.preselect then q=#p end end end;self.offset=l;self.items=o;self.entries=p;self.preselect_index=q;self:on_change()end;h.close=function(self)if g.is_insert_mode()and self:visible()then vim.api.nvim_select_popupmenu_item(-1,false,true,{})end;self.offset=-1;self.entries={}self.items={}self.preselect_index=0 end;h.abort=function(i)if g.is_suitable_mode()then vim.api.nvim_select_popupmenu_item(-1,true,true,{})end end;h.visible=function(i)return vim.fn.pumvisible()==1 end;h.info=function(self)if self:visible()then local t=vim.fn.pum_getpos()return{width=t.width+(t.scrollbar and 1 or 0)+(t.col==0 and 0 or 1),height=t.height,row=t.row,col=t.col==0 and 0 or t.col-1}end end;h.preselect=function(self,u)if self:visible()then if u<=#self.entries then vim.api.nvim_select_popupmenu_item(u-1,false,false,{})end end end;h.select_next_item=function(self,v)local w=function()self.event:emit('change')end;if self:visible()then if(v.behavior or e.cmp.SelectBehavior.Insert)==e.cmp.SelectBehavior.Insert then d.call(c.t(string.rep('<C-n>',v.count)),'n',w)else d.call(c.t(string.rep('<Down>',v.count)),'n',w)end end end;h.select_prev_item=function(self,v)local w=function()self.event:emit('change')end;if self:visible()then if(v.behavior or e.cmp.SelectBehavior.Insert)==e.cmp.SelectBehavior.Insert then d.call(c.t(string.rep('<C-p>',v.count)),'n',w)else d.call(c.t(string.rep('<Up>',v.count)),'n',w)end end end;h.get_offset=function(self)if self:visible()then return self.offset end;return nil end;h.get_entries=function(self)if self:visible()then return self.entries end;return{}end;h.get_first_entry=function(self)if self:visible()then return self.entries[1]end end;h.get_selected_entry=function(self)if self:visible()then local x=vim.fn.complete_info({'selected'}).selected;if x>-1 then return self.entries[math.max(0,x)+1]end end end;h.get_active_entry=function(self)if self:visible()and(vim.v.completed_item or{}).word then return self:get_selected_entry()end end;return h
