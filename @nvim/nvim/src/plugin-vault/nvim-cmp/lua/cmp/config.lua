local a=require('cmp.config.mapping')local b=require('cmp.utils.cache')local c=require('cmp.utils.keymap')local d=require('cmp.utils.misc')local e=require('cmp.utils.api')local f={}f.cache=b.new()f.global=require('cmp.config.default')()f.buffers={}f.filetypes={}f.cmdline={}f.onetime={}f.set_global=function(g)f.global=f.normalize(d.merge(g,f.global))f.global.revision=f.global.revision or 1;f.global.revision=f.global.revision+1 end;f.set_buffer=function(g,h)local i=(f.buffers[h]or{}).revision or 1;f.buffers[h]=g or{}f.buffers[h].revision=i+1 end;f.set_filetype=function(g,j)for k,l in ipairs(type(j)=='table'and j or{j})do local i=(f.filetypes[l]or{}).revision or 1;f.filetypes[l]=g or{}f.filetypes[l].revision=i+1 end end;f.set_cmdline=function(g,m)for k,n in ipairs(type(m)=='table'and m or{m})do local i=(f.cmdline[n]or{}).revision or 1;f.cmdline[n]=g or{}f.cmdline[n].revision=i+1 end end;f.set_onetime=function(g)local i=(f.onetime or{}).revision or 1;f.onetime=g or{}f.onetime.revision=i+1 end;f.get=function()local o=f.global;if#vim.tbl_keys(f.onetime)>1 then local p=f.onetime;return f.cache:ensure({'get','onetime',o.revision or 0,p.revision or 0},function()local g={}g=d.merge(g,f.normalize(p))g=d.merge(g,f.normalize(o))return g end)elseif e.is_cmdline_mode()then local n=vim.fn.getcmdtype()local q=f.cmdline[n]or{revision=1,sources={}}return f.cache:ensure({'get','cmdline',o.revision or 0,n,q.revision or 0},function()local g={}g=d.merge(g,f.normalize(q))g=d.merge(g,f.normalize(o))return g end)else local h=vim.api.nvim_get_current_buf()local l=vim.api.nvim_buf_get_option(h,'filetype')local r=f.buffers[h]or{revision=1}local s=f.filetypes[l]or{revision=1}return f.cache:ensure({'get','default',o.revision or 0,l,s.revision or 0,h,r.revision or 0},function()local g={}g=d.merge(f.normalize(g),f.normalize(r))g=d.merge(f.normalize(g),f.normalize(s))g=d.merge(f.normalize(g),f.normalize(o))return g end)end end;f.enabled=function()local t=f.get().enabled;if type(t)=='function'then t=t()end;return t and e.is_suitable_mode()end;f.get_source_config=function(u)local g=f.get()for k,v in ipairs(g.sources)do if v.name==u then return v end end;return nil end;f.is_native_menu=function()local g=f.get()if g.view and g.view.entries then return g.view.entries=='native'or g.view.entries.name=='native'end;return false end;f.normalize=function(g)g=g==nil and{}or g;if g.mapping then local w={}for x,y in pairs(g.mapping)do w[c.normalize(x)]=a(y,{'i'})end;g.mapping=w end;if g.experimental and g.experimental.native_menu then vim.api.nvim_echo({{'[nvim-cmp] ','Normal'},{'experimental.native_menu','WarningMsg'},{' is deprecated.\n','Normal'},{'[nvim-cmp] Please use ','Normal'},{'view.entries = "native"','WarningMsg'},{' instead.','Normal'}},true,{})g.view=g.view or{}g.view.entries=g.view.entries or'native'end;if g.documentation~=nil then vim.api.nvim_echo({{'[nvim-cmp] ','Normal'},{'documentation','WarningMsg'},{' is deprecated.\n','Normal'},{'[nvim-cmp] Please use ','Normal'},{'window.documentation = cmp.config.window.bordered()','WarningMsg'},{' instead.','Normal'}},true,{})g.window=g.window or{}g.window.documentation=g.documentation end;if g.sources then for k,v in ipairs(g.sources)do if v.opts and not v.option then v.option=v.opts;v.opts=nil;vim.api.nvim_echo({{'[nvim-cmp] ','Normal'},{'sources[number].opts','WarningMsg'},{' is deprecated.\n','Normal'},{'[nvim-cmp] Please use ','Normal'},{'sources[number].option','WarningMsg'},{' instead.','Normal'}},true,{})end;v.option=v.option or{}end end;return g end;return f
