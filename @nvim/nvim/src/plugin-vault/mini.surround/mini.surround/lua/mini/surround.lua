local a={}local b={}a.setup=function(c)_G.MiniSurround=a;c=b.setup_config(c)b.apply_config(c)b.create_default_hl()end;a.config={custom_surroundings=nil,highlight_duration=500,mappings={add='sa',delete='sd',find='sf',find_left='sF',highlight='sh',replace='sr',update_n_lines='sn',suffix_last='l',suffix_next='n'},n_lines=20,respect_selection_type=false,search_method='cover',silent=false}a.add=function(d)if b.is_disabled()then return'<Esc>'end;local e=b.get_marks_pos(d)local f;if d=='visual'then f=b.get_surround_spec('output',false)else f=b.get_surround_spec('output',true)end;if f==nil then return'<Esc>'end;if not f.did_count then local g=b.cache.count or vim.v.count1;f.left,f.right=f.left:rep(g),f.right:rep(g)f.did_count=true end;local h=b.get_config().respect_selection_type;if not h or e.selection_type=='charwise'then b.region_replace({from={line=e.second.line,col=e.second.col+1}},f.right)b.region_replace({from=e.first},f.left)b.set_cursor(e.first.line,e.first.col+f.left:len())return end;if e.selection_type=='linewise'then local i,j=e.first.line,e.second.line;local k=b.get_range_indent(i,j)b.shift_indent('>',i,j)b.set_cursor_nonblank(i)vim.fn.append(j,k..f.right)vim.fn.append(i-1,k..f.left)return end;if e.selection_type=='blockwise'then local l,m=e.first.col,e.second.col;l,m=math.min(l,m),math.max(l,m)for n=e.first.line,e.second.line do b.region_replace({from={line=n,col=m+1}},f.right)b.region_replace({from={line=n,col=l}},f.left)end;b.set_cursor(e.first.line,l+f.left:len())return end end;a.delete=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;b.region_replace(o.right,{})b.region_replace(o.left,{})local p=o.left.from;b.set_cursor(p.line,p.col)if not b.get_config().respect_selection_type then return end;local i,j=o.left.from.line,o.right.from.line;local q=i<j and b.is_line_blank(i)and b.is_line_blank(j)if q then b.shift_indent('<',i,j)b.set_cursor_nonblank(i+1)local r=vim.api.nvim_get_current_buf()vim.fn.deletebufline(r,j)vim.fn.deletebufline(r,i)end end;a.replace=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;local s=b.get_surround_spec('output',true)if s==nil then return'<Esc>'end;b.region_replace(o.right,s.right)b.region_replace(o.left,s.left)local p=o.left.from;b.set_cursor(p.line,p.col+s.left:len())end;a.find=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;local t=b.surr_to_pos_array(o)local u=b.cache.direction or'right'b.cursor_cycle(t,u)vim.cmd('normal! zv')end;a.highlight=function()local o=b.find_surrounding(b.get_surround_spec('input',true))if o==nil then return'<Esc>'end;local c=b.get_config()local r=vim.api.nvim_get_current_buf()b.region_highlight(r,o.left)b.region_highlight(r,o.right)vim.defer_fn(function()b.region_unhighlight(r,o.left)b.region_unhighlight(r,o.right)end,c.highlight_duration)end;a.update_n_lines=function()if b.is_disabled()then return'<Esc>'end;local v=a.user_input('New number of neighbor lines',a.config.n_lines)v=math.floor(tonumber(v)or a.config.n_lines)a.config.n_lines=v end;a.user_input=function(w,x)local y=vim.on_key or vim.register_keystroke_callback;local z=false;y(function(A)if A==vim.api.nvim_replace_termcodes('<Esc>',true,true,true)then z=true end end,b.ns_id.input)local B={prompt='(mini.surround) '..w..': ',default=x or''}vim.cmd('echohl Question')local C,D=pcall(vim.fn.input,B)vim.cmd([[echohl None | echo '' | redraw]])y(nil,b.ns_id.input)if not C or z then return end;return D end;a.gen_spec={input={},output={}}a.gen_spec.input.treesitter=function(E,B)B=vim.tbl_deep_extend('force',{use_nvim_treesitter=true},B or{})E=b.prepare_captures(E)return function()local F,G=pcall(require,'nvim-treesitter')local H=F and B.use_nvim_treesitter and b.get_matched_node_pairs_plugin or b.get_matched_node_pairs_builtin;local I=H(E)return vim.tbl_map(function(J)local K,L,M,N=J.outer:range()local O={line=K+1,col=L+1}local P={line=M+1,col=N}local Q,R;if J.inner==nil then Q=P;R=b.pos_to_right(P)P=nil else local S,T,U,V=J.inner:range()Q={line=S+1,col=T+1}R={line=U+1,col=V}Q,R=b.pos_to_left(Q),b.pos_to_right(R)end;return{left={from=O,to=Q},right={from=R,to=P}}end,I)end end;b.default_config=a.config;b.ns_id={highlight=vim.api.nvim_create_namespace('MiniSurroundHighlight'),input=vim.api.nvim_create_namespace('MiniSurroundInput')}b.builtin_surroundings={['(']={input={'%b()','^.%s*().-()%s*.$'},output={left='( ',right=' )'}},[')']={input={'%b()','^.().*().$'},output={left='(',right=')'}},['[']={input={'%b[]','^.%s*().-()%s*.$'},output={left='[ ',right=' ]'}},[']']={input={'%b[]','^.().*().$'},output={left='[',right=']'}},['{']={input={'%b{}','^.%s*().-()%s*.$'},output={left='{ ',right=' }'}},['}']={input={'%b{}','^.().*().$'},output={left='{',right='}'}},['<']={input={'%b<>','^.%s*().-()%s*.$'},output={left='< ',right=' >'}},['>']={input={'%b<>','^.().*().$'},output={left='<',right='>'}},['?']={input=function()local W=a.user_input('Left surrounding')if W==nil or W==''then return end;local X=a.user_input('Right surrounding')if X==nil or X==''then return end;return{vim.pesc(W)..'().-()'..vim.pesc(X)}end,output=function()local W=a.user_input('Left surrounding')if W==nil then return end;local X=a.user_input('Right surrounding')if X==nil then return end;return{left=W,right=X}end},['b']={input={{'%b()','%b[]','%b{}'},'^.().*().$'},output={left='(',right=')'}},['f']={input={'%f[%w_%.][%w_%.]+%b()','^.-%(().*()%)$'},output=function()local Y=a.user_input('Function name')if Y==nil then return nil end;return{left=('%s('):format(Y),right=')'}end},['t']={input={'<(%w-)%f[^<%w][^<>]->.-</%1>','^<.->().*()</[^/]->$'},output=function()local Z=a.user_input('Tag name')if Z==nil then return nil end;local _=Z:match('^%S*')return{left='<'..Z..'>',right='</'.._..'>'}end},['q']={input={{"'.-'",'".-"','`.-`'},'^.().*().$'},output={left='"',right='"'}}}b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({custom_surroundings={c.custom_surroundings,'table',true},highlight_duration={c.highlight_duration,'number'},mappings={c.mappings,'table'},n_lines={c.n_lines,'number'},respect_selection_type={c.respect_selection_type,'boolean'},search_method={c.search_method,b.is_search_method},silent={c.silent,'boolean'}})vim.validate({['mappings.add']={c.mappings.add,'string'},['mappings.delete']={c.mappings.delete,'string'},['mappings.find']={c.mappings.find,'string'},['mappings.find_left']={c.mappings.find_left,'string'},['mappings.highlight']={c.mappings.highlight,'string'},['mappings.replace']={c.mappings.replace,'string'},['mappings.update_n_lines']={c.mappings.update_n_lines,'string'},['mappings.suffix_last']={c.mappings.suffix_last,'string'},['mappings.suffix_next']={c.mappings.suffix_next,'string'}})return c end;b.apply_config=function(c)a.config=c;local a0=function(a1,a2,a3)b.map('n',a1,a2,{expr=true,desc=a3})end;local a4=c.mappings;a0(a4.add,b.make_operator('add',nil,nil,true),'Add surrounding')a0(a4.delete,b.make_operator('delete'),'Delete surrounding')a0(a4.replace,b.make_operator('replace'),'Replace surrounding')a0(a4.find,b.make_operator('find','right'),'Find right surrounding')a0(a4.find_left,b.make_operator('find','left'),'Find left surrounding')a0(a4.highlight,b.make_operator('highlight'),'Highlight surrounding')b.map('n',a4.update_n_lines,a.update_n_lines,{desc='Update `MiniSurround.config.n_lines`'})b.map('x',a4.add,[[:<C-u>lua MiniSurround.add('visual')<CR>]],{desc='Add surrounding to selection'})local a5=function(a1,a6,a2,a3)if a1==''then return end;a0(a1 ..a6,a2,a3)end;if a4.suffix_last~=''then local a7=function(a8,a9)return b.make_operator(a8,a9,'prev')end;local aa=a4.suffix_last;a5(a4.delete,aa,a7('delete'),'Delete previous surrounding')a5(a4.replace,aa,a7('replace'),'Replace previous surrounding')a5(a4.find,aa,a7('find','right'),'Find previous right surrounding')a5(a4.find_left,aa,a7('find','left'),'Find previous left surrounding')a5(a4.highlight,aa,a7('highlight'),'Highlight previous surrounding')end;if a4.suffix_next~=''then local ab=function(a8,a9)return b.make_operator(a8,a9,'next')end;local aa=a4.suffix_next;a5(a4.delete,aa,ab('delete'),'Delete next surrounding')a5(a4.replace,aa,ab('replace'),'Replace next surrounding')a5(a4.find,aa,ab('find','right'),'Find next right surrounding')a5(a4.find_left,aa,ab('find','left'),'Find next left surrounding')a5(a4.highlight,aa,ab('highlight'),'Highlight next surrounding')end end;b.create_default_hl=function()vim.api.nvim_set_hl(0,'MiniSurround',{default=true,link='IncSearch'})end;b.is_disabled=function()return vim.g.minisurround_disable==true or vim.b.minisurround_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minisurround_config or{},c or{})end;b.is_search_method=function(ac,ad)ac=ac or b.get_config().search_method;ad=ad or'`config.search_method`'local ae=vim.tbl_keys(b.span_compare_methods)if vim.tbl_contains(ae,ac)then return true end;table.sort(ae)local af=table.concat(vim.tbl_map(vim.inspect,ae),', ')local ag=([[%s should be one of %s.]]):format(ad,af)return false,ag end;b.validate_search_method=function(ac,ad)local ah,ag=b.is_search_method(ac,ad)if not ah then b.error(ag)end end;b.make_operator=function(ai,a9,aj,ak)return function()if b.is_disabled()then return[[\<Esc>]]end;b.cache={count=vim.v.count1,direction=a9,search_method=aj}vim.o.operatorfunc='v:lua.MiniSurround.'..ai;return'<Cmd>echon ""<CR>g@'..(ak and''or' ')end end;b.get_surround_spec=function(al,am)local D;if am then D=b.cache[al]if D~=nil then return D end else b.cache={}end;local an=b.user_surround_id(al)if an==nil then return nil end;D=b.make_surrounding_table()[an][al]if vim.is_callable(D)then D=D()end;if not b.is_surrounding_info(D,al)then return nil end;if b.is_composed_pattern(D)then D=vim.tbl_map(b.wrap_callable_table,D)end;D=setmetatable(D,{__index={id=an}})if am then b.cache[al]=D end;return D end;b.make_surrounding_table=function()local ao=vim.tbl_deep_extend('force',b.builtin_surroundings,b.get_config().custom_surroundings or{})for an,ap in pairs(ao)do local aq=b.get_default_surrounding_info(an)ao[an]=vim.tbl_deep_extend('force',aq,ap)end;return setmetatable(ao,{__index=function(G,A)return b.get_default_surrounding_info(A)end})end;b.get_default_surrounding_info=function(an)local ar=vim.pesc(an)return{input={ar..'().-()'..ar},output={left=an,right=an}}end;b.is_surrounding_info=function(ac,al)if al=='input'then return b.is_composed_pattern(ac)or b.is_region_pair(ac)or b.is_region_pair_array(ac)elseif al=='output'then return type(ac)=='table'and type(ac.left)=='string'and type(ac.right)=='string'end end;b.is_region=function(ac)if type(ac)~='table'then return false end;local as=type(ac.from)=='table'and type(ac.from.line)=='number'and type(ac.from.col)=='number'local at=true;if ac.to~=nil then at=type(ac.to)=='table'and type(ac.to.line)=='number'and type(ac.to.col)=='number'end;return as and at end;b.is_region_pair=function(ac)if type(ac)~='table'then return false end;return b.is_region(ac.left)and b.is_region(ac.right)end;b.is_region_pair_array=function(ac)if not vim.tbl_islist(ac)then return false end;for G,au in ipairs(ac)do if not b.is_region_pair(au)then return false end end;return true end;b.is_composed_pattern=function(ac)if not(vim.tbl_islist(ac)and#ac>0)then return false end;for G,av in ipairs(ac)do local aw=type(av)if not(aw=='table'or aw=='string'or vim.is_callable(av))then return false end end;return true end;b.find_surrounding=function(ax,B)if ax==nil then return end;if b.is_region_pair(ax)then return ax end;B=vim.tbl_deep_extend('force',b.get_default_opts(),B or{})b.validate_search_method(B.search_method,'search_method')local ay=b.find_surrounding_region_pair(ax,B)if ay==nil then local ag=([[No surrounding '%s%s' found within %d line%s and `config.search_method = '%s'`.]]):format(B.n_times>1 and B.n_times or'',ax.id,B.n_lines,B.n_lines>1 and's'or'',B.search_method)b.message(ag)end;return ay end;b.find_surrounding_region_pair=function(ax,B)local az,aA,v=B.reference_region,B.n_times,B.n_lines;if aA==0 then return end;local aB=b.get_neighborhood(az,0)local aC=aB.region_to_span(az)local aD=function(aE)local D=b.find_best_match(aB,ax,aE,B)if D.span==nil then if v==0 or aB.n_neighbors>0 then return{}end;local aF=aB.span_to_region(aE)aB=b.get_neighborhood(az,v)aC=aB.region_to_span(az)aE=aB.region_to_span(aF)D=b.find_best_match(aB,ax,aE,B)end;return D end;local aG={span=aC}for G=1,aA do aG=aD(aG.span)if aG.span==nil then return end end;local aH=function(aI,aJ)if type(aJ)=='table'then return aJ end;local aK=aB['1d']:sub(aI.from,aI.to-1)local aL=b.extract_surr_spans(aK,aJ)local aM=aI.from-1;local W,X=aL.left,aL.right;return{left={from=W.from+aM,to=W.to+aM},right={from=X.from+aM,to=X.to+aM}}end;local aN=aH(aG.span,aG.extract_pattern)local aO={from=aN.left.from,to=aN.right.to}if b.is_span_covering(aC,aO)then aG=aD(aG.span)if aG.span==nil then return end;aN=aH(aG.span,aG.extract_pattern)aO={from=aN.left.from,to=aN.right.to}if b.is_span_covering(aC,aO)then return end end;return{left=aB.span_to_region(aN.left),right=aB.span_to_region(aN.right)}end;b.get_default_opts=function()local c=b.get_config()local aP=vim.api.nvim_win_get_cursor(0)return{n_lines=c.n_lines,n_times=b.cache.count or vim.v.count1,reference_region={from={line=aP[1],col=aP[2]+1}},search_method=b.cache.search_method or c.search_method}end;b.prepare_captures=function(E)local aQ=function(ac)return type(ac)=='string'and ac:sub(1,1)=='@'end;if not(type(E)=='table'and aQ(E.outer)and aQ(E.inner))then b.error('Wrong format for `captures`. See `MiniSurround.gen_spec.input.treesitter()` for details.')end;return{outer=E.outer,inner=E.inner}end;b.get_matched_node_pairs_plugin=function(E)local aR=require('nvim-treesitter.query')local aS=require('nvim-treesitter.parsers')local aT={}local aU=aS.get_parser(0)if aU then aU:for_each_tree(function(aV,aW)local aX=aW:lang()local aY=aR.get_capture_matches(0,E.outer,'textobjects',aV:root(),aX)for G,a4 in pairs(aY)do a4.lang=aX end;vim.list_extend(aT,aY)end)end;return vim.tbl_map(function(aZ)local a_=aZ.node;local b0=aR.get_capture_matches(0,E.inner,'textobjects',a_,aZ.lang)local b1=vim.tbl_map(function(ac)return ac.node end,b0)return{outer=a_,inner=b.get_biggest_node(b1)}end,aT)end;b.get_matched_node_pairs_builtin=function(E)local aX=vim.bo.filetype;local C,aU=pcall(vim.treesitter.get_parser,0,aX)if not C then b.error_treesitter('parser',aX)end;local b2=vim.treesitter.get_query(aX,'textobjects')if b2==nil then b.error_treesitter('query',aX)end;local b3,b4=E.outer:sub(2),E.inner:sub(2)local b5={}for G,aV in ipairs(aU:trees())do vim.list_extend(b5,b.get_builtin_matched_nodes(b3,aV:root(),b2))end;return vim.tbl_map(function(a_)local b1=b.get_builtin_matched_nodes(b4,a_,b2)return{outer=a_,inner=b.get_biggest_node(b1)}end,b5)end;b.get_builtin_matched_nodes=function(b6,b7,b2)local D={}for b8,b9,G in b2:iter_captures(b7,0)do if b2.captures[b8]==b6 then table.insert(D,b9)end end;return D end;b.get_biggest_node=function(ba)local bb,bc=nil,-math.huge;for G,b9 in ipairs(ba)do local G,G,bd=b9:start()local G,G,be=b9:end_()local bf=be-bd+1;if bc<bf then bb,bc=b9,bf end end;return bb end;b.error_treesitter=function(bg,aX)local bh=vim.api.nvim_get_current_buf()local ag=string.format([[Can not get %s for buffer %d and language '%s'.]],bg,bh,aX)b.error(ag)end;b.find_best_match=function(bi,ax,aC,B)local bj,bk,bl;local bm=function(aI)if b.is_better_span(aI,bj,aC,B)then bj=aI;bk=bl end end;if b.is_region_pair_array(ax)then for G,ay in ipairs(ax)do local bn={from=ay.left.from,to=ay.right.to or ay.right.from}if bi.is_region_inside(bn)then bl={{left=bi.region_to_span(ay.left),right=bi.region_to_span(ay.right)}}bm(bi.region_to_span(bn))end end else for G,bo in ipairs(b.cartesian_product(ax))do bl=bo;b.iterate_matched_spans(bi['1d'],bo,bm)end end;local aJ;if bk~=nil then aJ=bk[#bk]end;return{span=bj,extract_pattern=aJ}end;b.iterate_matched_spans=function(bp,bo,bm)local bq=#bo;local br={}local bs;bs=function(bt,bu,bv)local bw=bo[bt]local bx=function(aK,by)return b.string_find(aK,bw,by)end;if vim.is_callable(bw)then bx=bw end;local bz=type(bw)=='string'and bw:match('^%%b(.)%1$')~=nil;local by=1;while by<=bu:len()do local p,bA=bx(bu,by)if p==nil then break end;if bt==bq then local bB=b.new_span(p+bv,bA+bv)local bC=string.format('%s_%s',bB.from,bB.to)if not br[bC]then bm(bB)br[bC]=true end else local bD=bu:sub(p,bA)local bE=bv+p-1;bs(bt+1,bD,bE)end;by=(bz and bA or p)+1 end end;bs(1,bp,0)end;b.new_span=function(p,bA)return{from=p,to=bA==nil and p or bA+1}end;b.is_better_span=function(bF,bG,bH,B)if b.is_span_covering(bH,bF)or b.is_span_equal(bF,bH)then return false end;return b.span_compare_methods[B.search_method](bF,bG,bH)end;b.span_compare_methods={cover=function(bF,bG,bH)local D=b.is_better_covering_span(bF,bG,bH)if D~=nil then return D end;return false end,cover_or_next=function(bF,bG,bH)local D=b.is_better_covering_span(bF,bG,bH)if D~=nil then return D end;if not b.is_span_on_left(bH,bF)then return false end;if bG==nil then return true end;local bI=b.span_distance.next;return bI(bF,bH)<bI(bG,bH)end,cover_or_prev=function(bF,bG,bH)local D=b.is_better_covering_span(bF,bG,bH)if D~=nil then return D end;if not b.is_span_on_left(bF,bH)then return false end;if bG==nil then return true end;local bI=b.span_distance.prev;return bI(bF,bH)<bI(bG,bH)end,cover_or_nearest=function(bF,bG,bH)local D=b.is_better_covering_span(bF,bG,bH)if D~=nil then return D end;if bG==nil then return true end;local bI=b.span_distance.near;return bI(bF,bH)<bI(bG,bH)end,next=function(bF,bG,bH)if b.is_span_covering(bF,bH)then return false end;if not b.is_span_on_left(bH,bF)then return false end;if bG==nil then return true end;local bI=b.span_distance.next;return bI(bF,bH)<bI(bG,bH)end,prev=function(bF,bG,bH)if b.is_span_covering(bF,bH)then return false end;if not b.is_span_on_left(bF,bH)then return false end;if bG==nil then return true end;local bI=b.span_distance.prev;return bI(bF,bH)<bI(bG,bH)end,nearest=function(bF,bG,bH)if b.is_span_covering(bF,bH)then return false end;if bG==nil then return true end;local bI=b.span_distance.near;return bI(bF,bH)<bI(bG,bH)end}b.span_distance={next=function(bJ,bK)return math.abs(bJ.from-bK.from)end,prev=function(bJ,bK)return math.abs(bJ.to-bK.to)end,near=function(bJ,bK)return math.min(math.abs(bJ.from-bK.from),math.abs(bJ.to-bK.to))end}b.is_better_covering_span=function(bF,bG,bH)local bL=b.is_span_covering(bF,bH)local bM=b.is_span_covering(bG,bH)if bL and bM then return bF.to-bF.from<bG.to-bG.from end;if bL and not bM then return true end;if not bL and bM then return false end;return nil end;b.is_span_covering=function(aI,bN)if aI==nil or bN==nil then return false end;if aI.from==aI.to then return aI.from==bN.from and bN.to==aI.to end;if bN.from==bN.to then return aI.from<=bN.from and bN.to<aI.to end;return aI.from<=bN.from and bN.to<=aI.to end;b.is_span_equal=function(bJ,bK)if bJ==nil or bK==nil then return false end;return bJ.from==bK.from and bJ.to==bK.to end;b.is_span_on_left=function(bJ,bK)if bJ==nil or bK==nil then return false end;return bJ.from<=bK.from and bJ.to<=bK.to end;b.is_point_inside_spans=function(bO,bP)for G,aI in ipairs(bP)do if aI[1]<=bO and bO<=aI[2]then return true end end;return false end;b.get_marks_pos=function(d)local bQ,bR;if d=='visual'then bQ,bR='<','>'else bQ,bR='[',']'end;local bS=vim.api.nvim_buf_get_mark(0,bQ)local bT=vim.api.nvim_buf_get_mark(0,bR)local bU=b.get_selection_type(d)if bU=='linewise'then local G,bV=vim.fn.getline(bS[1]):find('^%s*')bS[2]=bV;bT[2]=vim.fn.col({bT[1],'$'})-2 end;bS[2],bT[2]=bS[2]+1,bT[2]+1;if d=='visual'and vim.o.selection=='exclusive'then bT[2]=bT[2]-1 else local bW=vim.fn.getline(bT[1])local bX=vim.str_utfindex(bW,math.min(#bW,bT[2]))bT[2]=vim.str_byteindex(bW,bX)end;return{first={line=bS[1],col=bS[2]},second={line=bT[1],col=bT[2]},selection_type=bU}end;b.get_selection_type=function(d)if d=='char'or d=='visual'and vim.fn.visualmode()=='v'then return'charwise'end;if d=='line'or d=='visual'and vim.fn.visualmode()=='V'then return'linewise'end;if d=='block'or d=='visual'and vim.fn.visualmode()=='\22'then return'blockwise'end end;b.set_cursor=function(bp,bY)vim.api.nvim_win_set_cursor(0,{bp,bY-1})end;b.set_cursor_nonblank=function(bp)b.set_cursor(bp,1)vim.cmd('normal! ^')end;b.compare_pos=function(bS,bT)if bS.line<bT.line then return'<'end;if bS.line>bT.line then return'>'end;if bS.col<bT.col then return'<'end;if bS.col>bT.col then return'>'end;return'='end;b.cursor_cycle=function(t,u)local aP=vim.api.nvim_win_get_cursor(0)aP={line=aP[1],col=aP[2]+1}local bZ,b_,c0,c1;for G,c2 in pairs(t)do bZ=b.compare_pos(aP,c2)b_=bZ=='>'and u=='left'c0=c1==nil and bZ=='<'and u=='right'if b_ or c0 then c1=c2 end end;c1=c1 or(u=='right'and t[1]or t[#t])b.set_cursor(c1.line,c1.col)end;b.user_surround_id=function(al)local c3=true;vim.defer_fn(function()if not c3 then return end;local ag=string.format('Enter %s surrounding identifier (single character) ',al)b.echo(ag)b.cache.msg_shown=true end,1000)local C,an=pcall(vim.fn.getcharstr)c3=false;b.unecho()if not C or an=='\27'then return nil end;if an:find('^[%w%p%s]$')==nil then b.message('Input must be single character: alphanumeric, punctuation, or space.')return nil end;return an end;b.pos_to_left=function(c2)if c2.line==1 and c2.col==1 then return{line=c2.line,col=c2.col}end;if c2.col==1 then return{line=c2.line-1,col=b.get_line_cols(c2.line-1)}end;return{line=c2.line,col=c2.col-1}end;b.pos_to_right=function(c2)local c4=b.get_line_cols(c2.line)if c2.line==vim.api.nvim_buf_line_count(0)and c2.col>c4 then return{line=c2.line,col=c4}end;if c2.col>c4 then return{line=c2.line+1,col=1}end;return{line=c2.line,col=c2.col+1}end;b.region_replace=function(c5,x)local c6,c7=c5.from.line-1,c5.from.col-1;local c8,c9;if b.region_is_empty(c5)then c8,c9=c6,c7 else c8,c9=c5.to.line-1,c5.to.col;if c8<vim.api.nvim_buf_line_count(0)and b.get_line_cols(c8+1)<c9 then c8,c9=c8+1,0 end end;if type(x)=='string'then x={x}end;if#x>0 then x=vim.split(table.concat(x,'\n'),'\n')end;pcall(vim.api.nvim_buf_set_text,0,c6,c7,c8,c9,x)end;b.surr_to_pos_array=function(o)local D={}local ca=function(c2,cb)if c2==nil then return end;if b.get_line_cols(c2.line)<c2.col and c2.col>1 then c2=cb=='left'and b.pos_to_left(c2)or b.pos_to_right(c2)end;local bp,bY=c2.line,c2.col;local cc=D[#D]if not(cc~=nil and cc.line==bp and cc.col==bY)then table.insert(D,{line=bp,col=bY})end end;if not b.region_is_empty(o.left)then ca(o.left.from,'right')ca(o.left.to,'right')end;if not b.region_is_empty(o.right)then ca(o.right.from,'left')ca(o.right.to,'left')end;return D end;b.region_highlight=function(r,c5)if b.region_is_empty(c5)then return end;local cd=b.ns_id.highlight;local i,l,j,m=c5.from.line-1,c5.from.col-1,c5.to.line-1,c5.to.col;vim.highlight.range(r,cd,'MiniSurround',{i,l},{j,m})end;b.region_unhighlight=function(r,c5)local cd=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(r,cd,c5.from.line-1,(c5.to or c5.from).line)end;b.region_is_empty=function(c5)return c5.to==nil end;b.get_range_indent=function(i,j)local ce,cf=math.huge,nil;local cg=vim.api.nvim_buf_get_lines(0,i-1,j,true)local ch,ci;for G,cj in ipairs(cg)do G,ch,ci=cj:find('^(%s*)')if ch<ce and ch<cj:len()then ce,cf=ch,ci end end;return cf or''end;b.shift_indent=function(ck,i,j)if j<i then return end;vim.cmd('silent '..i..','..j..ck)end;b.is_line_blank=function(cl)return vim.fn.nextnonblank(cl)~=cl end;b.extract_surr_spans=function(aK,aJ)local cm={aK:match(aJ)}local cn=true;for G,c2 in ipairs(cm)do if type(c2)~='number'then cn=false end end;local co=cn and(#cm==2 or#cm==4)if not co then local ag='Could not extract proper positions (two or four empty captures) from '..string.format([[string '%s' with extraction pattern '%s'.]],aK,aJ)b.error(ag)end;if#cm==2 then return{left=b.new_span(1,cm[1]-1),right=b.new_span(cm[2],aK:len())}end;return{left=b.new_span(cm[1],cm[2]-1),right=b.new_span(cm[3],cm[4]-1)}end;b.get_neighborhood=function(az,cp)local i,j=az.from.line,(az.to or az.from).line;local cq=math.max(1,i-cp)local cr=math.min(vim.api.nvim_buf_line_count(0),j+cp)local cs=vim.api.nvim_buf_get_lines(0,cq-1,cr,false)for ct,au in pairs(cs)do cs[ct]=au..'\n'end;local cu=table.concat(cs,'')local cv=function(c2)if c2==nil then return nil end;local cl=cq;local cw=0;while cl<c2.line do cw=cw+cs[cl-cq+1]:len()cl=cl+1 end;return cw+c2.col end;local cx=function(cw)if cw==nil then return nil end;local cl=1;local cy=0;while cl<=#cs and cy+cs[cl]:len()<cw do cy=cy+cs[cl]:len()cl=cl+1 end;return{line=cq+cl-1,col=cw-cy}end;local cz=function(c5)if c5==nil then return nil end;local cA=c5.to==nil;local bA=c5.to or c5.from;return{from=cv(c5.from),to=cv(bA)+(cA and 0 or 1)}end;local cB=function(aI)if aI==nil then return nil end;local D={from=cx(aI.from)}if aI.from<aI.to then D.to=cx(aI.to-1)end;return D end;local cC=function(c5)local D=cq<=c5.from.line;if c5.to~=nil then D=D and c5.to.line<=cr end;return D end;return{n_neighbors=cp,region=az,['1d']=cu,['2d']=cs,pos_to_offset=cv,offset_to_pos=cx,region_to_span=cz,span_to_region=cB,is_region_inside=cC}end;b.echo=function(ag,cD)if b.get_config().silent then return end;ag=type(ag)=='string'and{{ag}}or ag;table.insert(ag,1,{'(mini.surround) ','WarningMsg'})local cE=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local cF,cG={},0;for G,cH in ipairs(ag)do local cI={vim.fn.strcharpart(cH[1],0,cE-cG),cH[2]}table.insert(cF,cI)cG=cG+vim.fn.strdisplaywidth(cI[1])if cG>=cE then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(cF,cD,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(ag)b.echo(ag,true)end;b.error=function(ag)error(string.format('(mini.surround) %s',ag))end;b.map=function(d,a1,a2,B)if a1==''then return end;B=vim.tbl_deep_extend('force',{silent=true},B or{})vim.keymap.set(d,a1,a2,B)end;b.get_line_cols=function(cl)return vim.fn.getline(cl):len()end;b.string_find=function(aK,bw,by)by=by or 1;if bw:sub(1,1)=='^'then if by>1 then return nil end;return string.find(aK,bw)end;local cJ,G,cK=string.find(bw,'(.)%.%-')local cL=cJ~=nil and cK~='%'if not cL then return string.find(aK,bw,by)end;local p,bA=string.find(aK,bw,by)if p==nil then return end;local cM,cN=p,bA;while cN==bA do p,bA=cM,cN;cM,cN=string.find(aK,bw,cM+1)end;return p,bA end;b.cartesian_product=function(cO)if not(type(cO)=='table'and#cO>0)then return{}end;cO=vim.tbl_map(function(ac)return vim.tbl_islist(ac)and ac or{ac}end,cO)local D,cP={},{}local bs;bs=function(bt)for n=1,#cO[bt]do table.insert(cP,cO[bt][n])if bt==#cO then table.insert(D,vim.tbl_flatten(cP))else bs(bt+1)end;table.remove(cP,#cP)end end;bs(1)return D end;b.wrap_callable_table=function(ac)if vim.is_callable(ac)and type(ac)=='table'then return function(...)return ac(...)end end;return ac end;return a
