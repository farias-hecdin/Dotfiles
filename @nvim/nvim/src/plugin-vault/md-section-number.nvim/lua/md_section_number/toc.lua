local a=require("md_section_number.heading.parser")local b={}b.options={width=30,position="right",indent_space_number=2,header_prefix="- ",winopts={number=false,relativenumber=false,wrap=false,winfixwidth=true,list=false,spell=false},bufopts={bufhidden="wipe",filetype="msnumber",modifiable=false}}function b.setup(c)b.options=vim.tbl_deep_extend("force",b.options,c or{})end;b.viewBind={MdHeaders=nil,TocWin=nil,TocBuf=nil,BindBuf=nil,BindWin=nil,changeTick=nil}local d="MSNbindBufEventGroup"local e="MSNtocBufEventGroup"local f="MSNGlobalEventGroup"local g=vim.api.nvim_create_namespace("tocHlNameSpace")local h={markdown=true,md=true}local i={left="H",right="L"}local function j()for k,l in ipairs({d,e,f})do vim.api.nvim_clear_autocmds({group=l,buffer=b.viewBind.BindBuf})end end;function b.unbind()j()b.viewBind={}end;local function m()vim.cmd("vsplit")local n=vim.api.nvim_get_current_win()local o=i[b.options.position]vim.api.nvim_command("wincmd "..o)vim.api.nvim_win_set_width(n,b.options.width)local p=vim.api.nvim_create_buf(false,true)vim.api.nvim_win_set_buf(n,p)for q,r in pairs(b.options.bufopts)do vim.api.nvim_buf_set_option(p,q,r)end;for q,r in pairs(b.options.winopts)do vim.opt_local[q]=r end;return n,p end;local function s(t)local u=t[2]local v=string.rep(" ",b.options.indent_space_number)u=b.options.header_prefix..vim.trim(u:gsub("#","",t[3]))if t[3]>1 then u=string.rep(v,t[3]-1)..u end;return u end;local function w()local x=false;if not b.viewBind.BindBuf then return x end;local y=vim.api.nvim_buf_get_changedtick(b.viewBind.BindBuf)if b.viewBind.MdHeaders==nil or b.viewBind.changeTick~=y then b.viewBind.MdHeaders=a.get_heading_lines(vim.api.nvim_buf_get_lines(b.viewBind.BindBuf,0,-1,false))x=true end;b.viewBind.changeTick=y;return x end;local function z()local x=w()if not x then return end;vim.api.nvim_buf_set_option(b.viewBind.TocBuf,"modifiable",true)local A={}for k,t in ipairs(b.viewBind.MdHeaders)do table.insert(A,s(t))end;vim.api.nvim_buf_set_lines(b.viewBind.TocBuf,0,-1,false,{})vim.api.nvim_buf_set_lines(b.viewBind.TocBuf,0,-1,false,A)vim.api.nvim_buf_set_option(b.viewBind.TocBuf,"modifiable",false)end;local function B()if not b.viewBind.MdHeaders or#b.viewBind.MdHeaders==0 then return 1 end;local C=vim.api.nvim_win_get_cursor(b.viewBind.BindWin)[1]local D=1;local E=#b.viewBind.MdHeaders;if C<b.viewBind.MdHeaders[D][1]then return D end;if C>b.viewBind.MdHeaders[E][1]then return E end;while D<=E do local F=math.floor((D+E)/2)local G=b.viewBind.MdHeaders[F][1]+1;if G==C then return F elseif C>G then D=F+1 elseif C<G then E=F-1 end end;return math.max(math.min(D,E),1)end;local function H()local I=B()vim.api.nvim_win_set_cursor(b.viewBind.TocWin,{I,0})vim.api.nvim_buf_clear_namespace(b.viewBind.TocBuf,g,0,-1)vim.api.nvim_buf_add_highlight(b.viewBind.TocBuf,g,"Search",I-1,0,-1)end;local function J()if not b.viewBind.MdHeaders then w()end;local K=math.min(vim.api.nvim_win_get_cursor(0)[1],#b.viewBind.MdHeaders)local L=math.min(b.viewBind.MdHeaders[K][1]+1,vim.api.nvim_buf_line_count(b.viewBind.BindBuf))vim.api.nvim_win_set_buf(b.viewBind.BindWin,b.viewBind.BindBuf)vim.api.nvim_set_current_win(b.viewBind.BindWin)vim.api.nvim_win_set_cursor(b.viewBind.BindWin,{L,0})vim.api.nvim_feedkeys("zz","n",false)H()end;function b.closeToc()if not b.viewBind.TocWin then return end;vim.api.nvim_win_close(b.viewBind.TocWin,true)b.unbind()end;local function M()local N={["<cr>"]=J,q=function()b.closeToc()end,r=function()local O=vim.api.nvim_win_get_cursor(b.viewBind.TocWin)z()local P=vim.api.nvim_buf_line_count(b.viewBind.TocBuf)if P==0 then return end;local Q=B()local R=vim.api.nvim_buf_get_lines(b.viewBind.TocBuf,Q-1,Q,false)[1]if R==nil then R=""end;local S=math.min(#R,O[2])vim.api.nvim_win_set_cursor(b.viewBind.TocWin,{Q,S})end}for q,r in pairs(N)do vim.keymap.set("n",q,r,{buffer=b.viewBind.TocBuf,silent=true,noremap=true})end end;local function T()local U=vim.api.nvim_create_augroup(d,{clear=true})vim.api.nvim_create_autocmd({"BufWritePost"},{group=U,buffer=b.viewBind.BindBuf,callback=vim.schedule_wrap(function()z()H()end)})vim.api.nvim_create_autocmd("CursorHold",{group=U,buffer=b.viewBind.BindBuf,callback=vim.schedule_wrap(function()H()end)})vim.api.nvim_create_autocmd("WinClosed",{group=U,buffer=b.viewBind.BindBuf,callback=vim.schedule_wrap(function()b.closeToc()end)})end;local function V()local tocBufEventGroup=vim.api.nvim_create_augroup(e,{clear=true})vim.api.nvim_create_autocmd({"WinClosed","QuitPre"},{group=tocBufEventGroup,buffer=b.viewBind.TocBuf,callback=function()b.unbind()end})vim.api.nvim_create_autocmd("BufEnter",{group=tocBufEventGroup,buffer=b.viewBind.TocBuf,callback=vim.schedule_wrap(function()local W=vim.api.nvim_win_get_buf(b.viewBind.BindWin)if W~=b.viewBind.BindBuf then return end;z()H()end)})end;local function X()if not b.viewBind.TocBuf then return end;local Y=vim.api.nvim_buf_get_option(0,"filetype")if not h[Y]then return end;local Z=vim.api.nvim_get_current_buf()local _=vim.api.nvim_get_current_win()if Z==b.viewBind.BindBuf and _==b.viewBind.BindWin then return end;if Z~=b.viewBind.BindBuf then b.viewBind.BindBuf=Z;b.viewBind.MdHeaders=nil;z()end;if Z~=b.viewBind.BindWin then b.viewBind.BindWin=_ end;T()H()end;local function a0()V()T()local a1=vim.api.nvim_create_augroup(f,{clear=true})vim.api.nvim_create_autocmd("BufEnter",{group=a1,pattern="*.md,*.markdown",callback=vim.schedule_wrap(X)})vim.api.nvim_create_autocmd("WinEnter",{group=tocBufEventGroup,pattern="*.md,*.markdown",callback=vim.schedule_wrap(function()local W=vim.api.nvim_win_get_buf(0)if W==b.viewBind.BindBuf then b.viewBind.BindWin=vim.api.nvim_get_current_win()return end end)})end;local function a2()if not b.viewBind.BindWin then return end;vim.api.nvim_set_current_win(b.viewBind.BindWin)end;function b.openToc()if b.viewBind.TocWin then return end;b.viewBind.BindBuf=vim.api.nvim_get_current_buf()b.viewBind.BindWin=vim.api.nvim_get_current_win()local n,p=m()b.viewBind.TocWin=n;b.viewBind.TocBuf=p;z()M()a0()a2()end;function b.toggle()if b.viewBind.TocWin then b.closeToc()else b.openToc()end end;return b
