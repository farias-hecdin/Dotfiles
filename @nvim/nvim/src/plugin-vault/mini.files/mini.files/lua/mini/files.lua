local a={}local b={}a.setup=function(c)_G.MiniFiles=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()end;a.config={content={filter=nil,prefix=nil,sort=nil},mappings={close='q',go_in='l',go_in_plus='L',go_out='h',go_out_plus='H',reset='<BS>',reveal_cwd='@',show_help='g?',synchronize='=',trim_left='<',trim_right='>'},options={permanent_delete=true,use_as_default_explorer=true},windows={max_number=math.huge,preview=false,width_focus=50,width_nofocus=15,width_preview=25}}a.open=function(d,e,f)d=b.fs_full_path(d or vim.fn.getcwd())local g=b.fs_get_type(d)if g==nil then b.error('`path` is not a valid path ("'..d..'")')end;local h;if g=='file'then d,h=b.fs_get_parent(d),b.fs_get_basename(d)end;if e==nil then e=true end;local i=a.close()if i==false then return end;local j;if e then j=b.explorer_path_history[d]end;j=j or b.explorer_new(d)j.opts=b.normalize_opts(nil,f)j.target_window=vim.api.nvim_get_current_win()j=b.explorer_focus_on_entry(j,d,h)b.explorer_refresh(j)b.latest_paths[vim.api.nvim_get_current_tabpage()]=d end;a.refresh=function(f)local j=b.explorer_get()if j==nil then return end;local k=(f or{}).content or{}local l=#vim.tbl_keys(k)>0;if l then l=b.explorer_confirm_modified(j,'buffer updates')end;j.opts=b.normalize_opts(j.opts,f)b.explorer_refresh(j,{force_update=l})end;a.synchronize=function()local j=b.explorer_get()if j==nil then return end;local m=b.explorer_compute_fs_actions(j)if m~=nil and b.fs_actions_confirm(m)then b.fs_actions_apply(m,j.opts)end;b.explorer_refresh(j,{force_update=true})end;a.reset=function()local j=b.explorer_get()if j==nil then return end;j.branch={j.anchor}j.depth_focus=1;for n,o in pairs(j.views)do o.cursor={1,0}end;b.explorer_refresh(j,{skip_update_cursor=true})end;a.close=function()local j=b.explorer_get()if j==nil then return nil end;if not b.explorer_confirm_modified(j,'close')then return false end;j=b.explorer_ensure_target_window(j)pcall(vim.api.nvim_set_current_win,j.target_window)j=b.explorer_update_cursors(j)for p,q in pairs(j.windows)do b.window_close(q)j.windows[p]=nil end;for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do local r=vim.api.nvim_win_get_buf(q)if vim.bo[r].filetype=='minifiles-help'then vim.api.nvim_win_close(q,true)end end;for d,o in pairs(j.views)do j.views[d]=b.view_invalidate_buffer(b.view_encode_cursor(o))end;local s,t=vim.api.nvim_get_current_tabpage(),j.anchor;b.explorer_path_history[t]=j;b.opened_explorers[s]=nil;return true end;a.go_in=function()local j=b.explorer_get()if j==nil then return end;local u=vim.fn.line('.')j=b.explorer_go_in_range(j,vim.api.nvim_get_current_buf(),u,u)b.explorer_refresh(j)end;a.go_out=function()local j=b.explorer_get()if j==nil then return end;if j.depth_focus==1 then j=b.explorer_open_root_parent(j)else j.depth_focus=j.depth_focus-1 end;b.explorer_refresh(j)end;a.trim_left=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_left(j)b.explorer_refresh(j)end;a.trim_right=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_trim_branch_right(j)b.explorer_refresh(j)end;a.reveal_cwd=function()local j=b.explorer_get()if j==nil then return end;local v=b.fs_full_path(vim.fn.getcwd())local w=string.format('^%s/.',vim.pesc(v))while j.branch[1]:find(w)~=nil do local x,y=b.fs_get_parent(j.branch[1]),b.fs_get_basename(j.branch[1])table.insert(j.branch,1,x)j.depth_focus=j.depth_focus+1;local z=j.views[x]or{}z.cursor=y;j.views[x]=z end;b.explorer_refresh(j)end;a.show_help=function()local j=b.explorer_get()if j==nil then return end;local r=vim.api.nvim_get_current_buf()if not b.is_opened_buffer(r)then return end;b.explorer_show_help(r,vim.api.nvim_get_current_win())end;a.get_fs_entry=function(r,A)r=b.validate_opened_buffer(r)A=b.validate_line(r,A)local B=b.match_line_path_id(b.get_bufline(r,A))if B==nil then return nil end;local d=b.path_index[B]return{fs_type=b.fs_get_type(d),name=b.fs_get_basename(d),path=d}end;a.get_target_window=function()local j=b.explorer_get()if j==nil then return end;j=b.explorer_ensure_target_window(j)return j.target_window end;a.set_target_window=function(q)if not b.is_valid_win(q)then b.error('`win_id` should be valid window identifier.')end;local j=b.explorer_get()if j==nil then return end;j.target_window=q end;a.get_latest_path=function()return b.latest_paths[vim.api.nvim_get_current_tabpage()]end;a.default_filter=function(C)return true end;a.default_prefix=function(C)if C.fs_type=='directory'then return' ','MiniFilesDirectory'end;local D,E=pcall(require,'nvim-web-devicons')if not D then return' ','MiniFilesFile'end;local F,G=E.get_icon(C.name,nil,{default=false})return(F or'')..' ',G or'MiniFilesFile'end;a.default_sort=function(H)local I=vim.tbl_map(function(J)return{fs_type=J.fs_type,name=J.name,path=J.path,lower_name=J.name:lower(),is_dir=J.fs_type=='directory'}end,H)table.sort(I,b.compare_fs_entries)return vim.tbl_map(function(J)return{name=J.name,fs_type=J.fs_type,path=J.path}end,I)end;b.default_config=a.config;b.ns_id={highlight=vim.api.nvim_create_namespace('MiniFilesHighlight')}b.path_index={}b.explorer_path_history={}b.opened_explorers={}b.latest_paths={}b.opened_buffers={}b.is_windows=vim.loop.os_uname().sysname=='Windows_NT'b.block_event_trigger={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({content={c.content,'table'},mappings={c.mappings,'table'},options={c.options,'table'},windows={c.windows,'table'}})vim.validate({['content.filter']={c.content.filter,'function',true},['content.prefix']={c.content.prefix,'function',true},['content.sort']={c.content.sort,'function',true},['mappings.close']={c.mappings.close,'string'},['mappings.go_in']={c.mappings.go_in,'string'},['mappings.go_in_plus']={c.mappings.go_in_plus,'string'},['mappings.go_out']={c.mappings.go_out,'string'},['mappings.go_out_plus']={c.mappings.go_out_plus,'string'},['mappings.reset']={c.mappings.reset,'string'},['mappings.reveal_cwd']={c.mappings.reveal_cwd,'string'},['mappings.show_help']={c.mappings.show_help,'string'},['mappings.synchronize']={c.mappings.synchronize,'string'},['mappings.trim_left']={c.mappings.trim_left,'string'},['mappings.trim_right']={c.mappings.trim_right,'string'},['options.use_as_default_explorer']={c.options.use_as_default_explorer,'boolean'},['options.permanent_delete']={c.options.permanent_delete,'boolean'},['windows.max_number']={c.windows.max_number,'number'},['windows.preview']={c.windows.preview,'boolean'},['windows.width_focus']={c.windows.width_focus,'number'},['windows.width_nofocus']={c.windows.width_nofocus,'number'},['windows.width_preview']={c.windows.width_preview,'number'}})return c end;b.apply_config=function(c)a.config=c end;b.create_autocommands=function(c)local K=vim.api.nvim_create_augroup('MiniFiles',{})local L=function(M,N,O,P)vim.api.nvim_create_autocmd(M,{group=K,pattern=N,callback=O,desc=P})end;L('VimResized','*',a.refresh,'Refresh on resize')if c.options.use_as_default_explorer then vim.cmd('silent! autocmd! FileExplorer *')vim.cmd('autocmd VimEnter * ++once silent! autocmd! FileExplorer *')L('BufEnter','*',b.track_dir_edit,'Track directory edit')end end;b.create_default_hl=function()local Q=function(y,f)f.default=true;vim.api.nvim_set_hl(0,y,f)end;Q('MiniFilesBorder',{link='FloatBorder'})Q('MiniFilesBorderModified',{link='DiagnosticFloatingWarn'})Q('MiniFilesDirectory',{link='Directory'})Q('MiniFilesFile',{})Q('MiniFilesNormal',{link='NormalFloat'})Q('MiniFilesTitle',{link='FloatTitle'})Q('MiniFilesTitleFocused',{link='FloatTitle'})end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minifiles_config or{},c or{})end;b.normalize_opts=function(R,f)f=vim.tbl_deep_extend('force',b.get_config(),R or{},f or{})f.content.filter=f.content.filter or a.default_filter;f.content.prefix=f.content.prefix or a.default_prefix;f.content.sort=f.content.sort or a.default_sort;return f end;b.track_dir_edit=function(S)local r=S.buf;if vim.b[r].minifiles_processed_dir then vim.api.nvim_buf_delete(r,{force=true})return end;if vim.api.nvim_get_current_buf()~=r then return end;local d=vim.api.nvim_buf_get_name(r)if vim.fn.isdirectory(d)~=1 then return end;vim.bo[r].bufhidden='wipe'vim.b[r].minifiles_processed_dir=true;vim.schedule(function()a.open(d,false)end)end;b.explorer_new=function(d)return{branch={d},depth_focus=1,views={},windows={},anchor=d,target_window=vim.api.nvim_get_current_win(),opts={}}end;b.explorer_get=function(s)s=s or vim.api.nvim_get_current_tabpage()local I=b.opened_explorers[s]if b.explorer_is_visible(I)then return I end;b.opened_explorers[s]=nil;return nil end;b.explorer_is_visible=function(j)if j==nil then return nil end;for n,q in ipairs(j.windows)do if b.is_valid_win(q)then return true end end;return false end;b.explorer_refresh=function(j,f)j=b.explorer_normalize(j)if#j.branch==0 then return end;f=f or{}if not f.skip_update_cursor then j=b.explorer_update_cursors(j)end;if f.force_update then for d,o in pairs(j.views)do o=b.view_encode_cursor(o)o.children_path_ids=b.buffer_update(o.buf_id,d,j.opts)j.views[d]=o end end;for T=1,#j.branch do j=b.explorer_sync_cursor_and_branch(j,T)end;for n,q in ipairs(j.windows)do local r=vim.api.nvim_win_get_buf(q)b.opened_buffers[r].win_id=nil end;local U=b.compute_visible_depth_range(j,j.opts)local V,W=0,0;for T=U.from,U.to do W=W+1;local X=b.explorer_refresh_depth_window(j,T,W,V)V=V+X+2 end;for T=W+1,#j.windows do b.window_close(j.windows[T])j.windows[T]=nil end;local Y=j.depth_focus-U.from+1;local Z=j.windows[Y]b.window_focus(Z)local s=vim.api.nvim_win_get_tabpage(Z)b.opened_explorers[s]=j;return j end;b.explorer_normalize=function(j)local _={}for n,d in ipairs(j.branch)do if not b.fs_is_present_path(d)then break end;table.insert(_,d)end;local a0=#_;j.branch=_;j.depth_focus=math.min(math.max(j.depth_focus,1),a0)for p=a0+1,#j.windows do b.window_close(j.windows[p])j.windows[p]=nil end;return j end;b.explorer_sync_cursor_and_branch=function(j,T)if#j.branch<T then return j end;local d,a1=j.branch[T],j.branch[T+1]local o=j.views[d]if o==nil then return j end;local r,a2=o.buf_id,o.cursor;if a2==nil then return j end;local a3;if type(a2)=='table'and b.is_valid_buf(r)then local a4=b.get_bufline(r,a2[1])a3=b.path_index[b.match_line_path_id(a4)]elseif type(a2)=='string'then a3=b.fs_child_path(d,a2)else return j end;if a3==a1 then return j end;for p=T+1,#j.branch do j.branch[p]=nil end;j.depth_focus=math.min(j.depth_focus,#j.branch)local a5=j.opts.windows.preview;local a6=type(a3)=='string'and b.fs_is_present_path(a3)local a7=r==vim.api.nvim_get_current_buf()if a5 and a6 and a7 then table.insert(j.branch,a3)end;return j end;b.explorer_go_in_range=function(j,r,a8,a9)local aa,d,A={},nil,nil;for p=a8,a9 do local C=a.get_fs_entry(r,p)or{}if C.fs_type=='file'then table.insert(aa,C.path)end;if C.fs_type=='directory'then d,A=C.path,p end end;for n,ab in ipairs(aa)do j=b.explorer_open_file(j,ab)end;if d~=nil then j=b.explorer_open_directory(j,d,j.depth_focus+1)local q=b.opened_buffers[r].win_id;if b.is_valid_win(q)then vim.api.nvim_win_set_cursor(q,{A,0})end end;return j end;b.explorer_focus_on_entry=function(j,d,h)if h==nil then return j end;j.depth_focus=b.explorer_get_path_depth(j,d)if j.depth_focus==nil then j.branch,j.depth_focus={d},1 end;local ac=j.views[d]or{}ac.cursor=h;j.views[d]=ac;return j end;b.explorer_compute_fs_actions=function(j)local ad={}for n,o in pairs(j.views)do local ae=b.buffer_compute_fs_diff(o.buf_id,o.children_path_ids)if#ae>0 then vim.list_extend(ad,ae)end end;if#ad==0 then return nil end;local af,ag,ah,ai,aj={},{},{},{},{}for n,ak in ipairs(ad)do if ak.from==nil then table.insert(af,ak.to)elseif ak.to==nil then ag[ak.from]=true else table.insert(aj,ak)end end;local al={}for n,ak in pairs(aj)do if ag[ak.from]then if b.fs_get_parent(ak.from)==b.fs_get_parent(ak.to)then table.insert(ah,ak)else table.insert(ai,ak)end;ag[ak.from]=nil else table.insert(al,ak)end end;return{create=af,delete=vim.tbl_keys(ag),copy=al,rename=ah,move=ai}end;b.explorer_update_cursors=function(j)for n,q in ipairs(j.windows)do if b.is_valid_win(q)then local r=vim.api.nvim_win_get_buf(q)local d=b.opened_buffers[r].path;j.views[d].cursor=vim.api.nvim_win_get_cursor(q)end end;return j end;b.explorer_refresh_depth_window=function(j,T,am,an)local d=j.branch[T]local ao,ap,f=j.views,j.windows,j.opts;local o=ao[d]or{}o=b.view_ensure_proper(o,d,f)ao[d]=o;local aq=T==j.depth_focus;local ar=f.windows.preview and T==j.depth_focus+1;local X=aq and f.windows.width_focus or(ar and f.windows.width_preview or f.windows.width_nofocus)local c={col=an,height=vim.api.nvim_buf_line_count(o.buf_id),width=X,title=am==1 and b.fs_shorten_path(b.fs_full_path(d))or b.fs_get_basename(d)}local q=ap[am]if not b.is_valid_win(q)then b.window_close(q)q=b.window_open(o.buf_id,c)ap[am]=q end;b.window_update(q,c)b.window_set_view(q,o)j.views=ao;j.windows=ap;return X end;b.explorer_get_path_depth=function(j,d)for T,as in pairs(j.branch)do if d==as then return T end end end;b.explorer_confirm_modified=function(j,at)local au=false;for n,o in pairs(j.views)do if b.is_modified_buffer(o.buf_id)then au=true end end;if not au then return true end;local av=string.format('There is at least one modified buffer\n\nConfirm %s without synchronization?',at)local aw=vim.fn.confirm(av,'&Yes\n&No',1,'Question')return aw==1 end;b.explorer_open_file=function(j,d)j=b.explorer_ensure_target_window(j)local ax;for n,r in ipairs(vim.api.nvim_list_bufs())do if b.is_valid_buf(r)and vim.api.nvim_buf_get_name(r)==d then ax=r end end;if ax~=nil then vim.api.nvim_win_set_buf(j.target_window,ax)else pcall(vim.fn.win_execute,j.target_window,'edit '..vim.fn.fnameescape(d))end;return j end;b.explorer_ensure_target_window=function(j)if not b.is_valid_win(j.target_window)then j.target_window=b.get_first_valid_normal_window()end;return j end;b.explorer_open_directory=function(j,d,ay)j.depth_focus=ay;local az=d~=j.branch[ay]if az then j.branch[ay]=d;j=b.explorer_trim_branch_right(j)end;return j end;b.explorer_open_root_parent=function(j)local aA=j.branch[1]local aB=b.fs_get_parent(aA)if aB==nil then return j end;table.insert(j.branch,1,aB)return b.explorer_focus_on_entry(j,aB,b.fs_get_basename(aA))end;b.explorer_trim_branch_right=function(j)for p=j.depth_focus+1,#j.branch do j.branch[p]=nil end;return j end;b.explorer_trim_branch_left=function(j)local aC={}for p=j.depth_focus,#j.branch do table.insert(aC,j.branch[p])end;j.branch=aC;j.depth_focus=1;return j end;b.explorer_show_help=function(aD,aE)local aF=vim.api.nvim_buf_get_keymap(aD,'n')local aG,aH={},0;for n,S in ipairs(aF)do if S.desc~=nil then aG[S.desc]=S.lhs:lower()=='<lt>'and'<'or S.lhs;aH=math.max(aH,S.desc:len())end end;local aI=vim.tbl_keys(aG)table.sort(aI)local aJ=string.format('%%-%ds │ %%s',aH)local aK={'Buffer mappings:',''}for n,P in ipairs(aI)do table.insert(aK,string.format(aJ,P,aG[P]))end;table.insert(aK,'')table.insert(aK,'(Press `q` to close)')local r=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_lines(r,0,-1,false,aK)vim.keymap.set('n','q','<Cmd>close<CR>',{buffer=r,desc='Close this window'})vim.b[r].minicursorword_disable=true;vim.b[r].miniindentscope_disable=true;vim.bo[r].filetype='minifiles-help'local aL=vim.tbl_map(vim.fn.strdisplaywidth,aK)local aM=math.max(unpack(aL))local c=vim.api.nvim_win_get_config(aE)c.relative='win'c.row=0;c.col=0;c.width=aM;c.height=#aK;c.title=vim.fn.has('nvim-0.9')==1 and[['mini.files' help]]or nil;c.zindex=c.zindex+1;c.style='minimal'local q=vim.api.nvim_open_win(r,false,c)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')vim.wo[q].cursorline=true;vim.api.nvim_set_current_win(q)return q end;b.compute_visible_depth_range=function(j,f)local aN,aO=f.windows.width_focus+2,f.windows.width_nofocus+2;local aP=j.opts.windows.preview and j.depth_focus<#j.branch;local aQ=aP and f.windows.width_preview+2 or aO;local aR=1;if aN+aQ<=vim.o.columns then aR=aR+1 end;if aN+aQ+aO<=vim.o.columns then aR=aR+math.floor((vim.o.columns-aN-aQ)/aO)end;aR=math.min(math.max(aR,1),f.windows.max_number)local aS,aT=#j.branch,j.depth_focus;local aU=math.min(aS,aR)local aV=math.min(aS,math.floor(aT+0.5*aU))local aW=math.max(1,aV-aU+1)aV=aW+math.min(aU,aS)-1;return{from=aW,to=aV}end;b.view_ensure_proper=function(o,d,f)if not b.is_valid_buf(o.buf_id)then b.buffer_delete(o.buf_id)o.buf_id=b.buffer_create(d,f.mappings)o.children_path_ids=b.buffer_update(o.buf_id,d,f)end;o.cursor=o.cursor or{1,0}if type(o.cursor)=='string'then o=b.view_decode_cursor(o)end;return o end;b.view_encode_cursor=function(o)local r,a2=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a2)~='table'then return o end;local a4=b.get_bufline(r,a2[1])o.cursor=b.match_line_entry_name(a4)return o end;b.view_decode_cursor=function(o)local r,a2=o.buf_id,o.cursor;if not b.is_valid_buf(r)or type(a2)~='string'then return o end;local aK=vim.api.nvim_buf_get_lines(r,0,-1,false)for p,a4 in ipairs(aK)do if a2==b.match_line_entry_name(a4)then o.cursor={p,0}end end;if type(o.cursor)~='table'then o.cursor={1,0}end;return o end;b.view_invalidate_buffer=function(o)b.buffer_delete(o.buf_id)o.buf_id=nil;o.children_path_ids=nil;return o end;b.view_track_cursor=vim.schedule_wrap(function(S)local r=S.buf;local aX=b.opened_buffers[r]if aX==nil then return end;local q=aX.win_id;if not b.is_valid_win(q)then return end;local aY=b.window_tweak_cursor(q,r)local s=vim.api.nvim_win_get_tabpage(q)local j=b.explorer_get(s)if j==nil then return end;local aZ=b.explorer_get_path_depth(j,aX.path)if aZ==nil then return end;local o=j.views[aX.path]if o~=nil then o.cursor=aY;j.views[aX.path]=o end;j=b.explorer_sync_cursor_and_branch(j,aZ)b.block_event_trigger['MiniFilesWindowUpdate']=true;b.explorer_refresh(j)b.block_event_trigger['MiniFilesWindowUpdate']=false end)b.view_track_text_change=function(S)local r=S.buf;local a_=b.opened_buffers[r].n_modified+1;b.opened_buffers[r].n_modified=a_;local q=b.opened_buffers[r].win_id;if a_>0 and b.is_valid_win(q)then b.window_update_border_hl(q)end;if not b.is_valid_win(q)then return end;local b0=vim.api.nvim_buf_line_count(r)local b1=math.min(b0,b.window_get_max_height())vim.api.nvim_win_set_height(q,b1)local b2=vim.fn.line('w0',q)+b1-1;local b3=b2-b0;if b3>0 then vim.cmd('normal! '..b3 ..'\25')end end;b.buffer_create=function(d,b4)local r=vim.api.nvim_create_buf(false,true)b.opened_buffers[r]={path=d}b.buffer_make_mappings(r,b4)local K=vim.api.nvim_create_augroup('MiniFiles',{clear=false})local L=function(b5,P,O)vim.api.nvim_create_autocmd(b5,{group=K,buffer=r,desc=P,callback=O})end;L({'CursorMoved','CursorMovedI'},'Tweak cursor position',b.view_track_cursor)L({'TextChanged','TextChangedI','TextChangedP'},'Track buffer modification',b.view_track_text_change)vim.b[r].minicursorword_disable=true;vim.bo[r].filetype='minifiles'b.trigger_event('MiniFilesBufferCreate',{buf_id=r})return r end;b.buffer_make_mappings=function(r,b4)local b6=function()for n=1,vim.v.count1 do a.go_in()end end;local b7=function()for n=1,vim.v.count1-1 do a.go_in()end;local C=a.get_fs_entry()local b8=C~=nil and C.fs_type=='file'a.go_in()if b8 then a.close()end end;local b9=function()for n=1,vim.v.count1 do a.go_out()end end;local ba=function()b9()a.trim_right()end;local bb=function()if vim.fn.mode()~='V'then return b4.go_in end;local bc,bd=vim.fn.line('v'),vim.fn.line('.')local a8,a9=math.min(bc,bd),math.max(bc,bd)vim.schedule(function()local j=b.explorer_get()j=b.explorer_go_in_range(j,r,a8,a9)b.explorer_refresh(j)end)return[[<C-\><C-n>]]end;local be=function(bf,bg,bh,P)b.map(bf,bg,bh,{buffer=r,desc=P,nowait=true})end;be('n',b4.close,a.close,'Close')be('n',b4.go_in,b6,'Go in entry')be('n',b4.go_in_plus,b7,'Go in entry plus')be('n',b4.go_out,b9,'Go out of directory')be('n',b4.go_out_plus,ba,'Go out of directory plus')be('n',b4.reset,a.reset,'Reset')be('n',b4.reveal_cwd,a.reveal_cwd,'Reveal cwd')be('n',b4.show_help,a.show_help,'Show Help')be('n',b4.synchronize,a.synchronize,'Synchronize')be('n',b4.trim_left,a.trim_left,'Trim branch left')be('n',b4.trim_right,a.trim_right,'Trim branch right')b.map('x',b4.go_in,bb,{buffer=r,desc='Go in selected entries',expr=true})end;b.buffer_update=function(r,d,f)if not(b.is_valid_buf(r)and b.fs_is_present_path(d))then return end;local bi=b.fs_get_type(d)=='directory'and b.buffer_update_directory or b.buffer_update_file;local H=bi(r,d,f)b.trigger_event('MiniFilesBufferUpdate',{buf_id=r,win_id=b.opened_buffers[r].win_id})b.opened_buffers[r].n_modified=-1;return vim.tbl_map(function(J)return J.path_id end,H)end;b.buffer_update_directory=function(r,d,f)local aK,bj,bk={},{},{}local H=b.fs_read_dir(d,f.content)local bl=math.floor(math.log10(#b.path_index))+1;local bm='/%0'..bl..'d/%s/%s'local bn=f.content.prefix;for n,bo in ipairs(H)do local bp,G=bn(bo)bp,G=bp or'',G or''table.insert(aK,string.format(bm,b.path_index[bo.path],bp,bo.name))table.insert(bj,G)table.insert(bk,bo.fs_type=='directory'and'MiniFilesDirectory'or'MiniFilesFile')end;b.set_buflines(r,aK)local bq=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(r,bq,0,-1)local br=function(A,bs,bt)b.set_extmark(r,bq,A,bs,bt)end;for p,a4 in ipairs(aK)do local bu,bv=a4:match('^/%d+/().-()/')local bw={hl_group=bj[p],end_col=bv-1,right_gravity=false}br(p-1,bu-1,bw)local bx={hl_group=bk[p],end_row=p,end_col=0,right_gravity=false}br(p-1,bv-1,bx)end;return H end;b.buffer_update_file=function(r,d,f)local by=vim.loop.fs_open(d,'r',1)local bz=vim.loop.fs_read(by,1024):find('\0')==nil;vim.loop.fs_close(by)if not bz then b.set_buflines(r,{'-Non-text-file'..string.rep('-',f.windows.width_preview)})return{}end;local bA,bB=pcall(vim.fn.readfile,d,'',vim.o.lines)local aK=bA and vim.split(table.concat(bB,'\n'),'\n')or{}b.set_buflines(r,aK)if vim.fn.has('nvim-0.8')==1 then local bC=vim.filetype.match({buf=r,filename=d})local bD,n=pcall(vim.treesitter.start,r,bC)if not bD then vim.bo[r].syntax=bC end end;return{}end;b.buffer_delete=function(r)if r==nil then return end;pcall(vim.api.nvim_buf_delete,r,{force=true})b.opened_buffers[r]=nil end;b.buffer_compute_fs_diff=function(r,bE)if not b.is_modified_buffer(r)then return{}end;local d=b.opened_buffers[r].path;local aK=vim.api.nvim_buf_get_lines(r,0,-1,false)local I,bF={},{}for n,a4 in ipairs(aK)do local B=b.match_line_path_id(a4)local bG=b.path_index[B]local bH=B~=nil and a4:sub(b.match_line_offset(a4))or a4;local bI=b.fs_child_path(d,bH)..(vim.endswith(bH,'/')and'/'or'')if a4:find('^%s*$')==nil and bG~=bI then table.insert(I,{from=bG,to=bI})elseif B~=nil then bF[B]=true end end;for n,bJ in ipairs(bE)do if not bF[bJ]then table.insert(I,{from=b.path_index[bJ],to=nil})end end;return I end;b.is_opened_buffer=function(r)return b.opened_buffers[r]~=nil end;b.is_modified_buffer=function(r)local S=b.opened_buffers[r]return S~=nil and S.n_modified>0 end;b.match_line_entry_name=function(a4)if a4==nil then return nil end;local bK=b.match_line_offset(a4)local I=a4:sub(bK):gsub('/.*$','')return I end;b.match_line_offset=function(a4)if a4==nil then return nil end;return a4:match('^/.-/.-/()')or 1 end;b.match_line_path_id=function(a4)if a4==nil then return nil end;local bL=a4:match('^/(%d+)')local bD,I=pcall(tonumber,bL)if not bD then return nil end;return I end;b.window_open=function(r,c)c.anchor='NW'c.border='single'c.focusable=true;c.relative='editor'c.style='minimal'c.zindex=99;c.row=1;if vim.fn.has('nvim-0.9')==0 then c.title=nil end;local q=vim.api.nvim_open_win(r,false,c)vim.wo[q].concealcursor='nvic'vim.wo[q].foldenable=false;vim.wo[q].wrap=false;vim.api.nvim_win_call(q,function()vim.fn.matchadd('Conceal',[[^/\d\+/]])vim.fn.matchadd('Conceal',[[^/\d\+/[^/]*\zs/\ze]])end)b.window_update_highlight(q,'NormalFloat','MiniFilesNormal')b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')b.trigger_event('MiniFilesWindowOpen',{buf_id=r,win_id=q})return q end;b.window_update=function(q,c)local bM=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local bN=b.window_get_max_height()c.row=bM and 1 or 0;c.height=c.height~=nil and math.min(c.height,bN)or nil;c.width=c.width~=nil and math.min(c.width,vim.o.columns)or nil;if vim.fn.has('nvim-0.9')==1 and c.title~=nil then local bO,bP=c.title,c.width;local bQ=vim.fn.strcharlen(bO)if bP<bQ then bO='…'..vim.fn.strcharpart(bO,bQ-bP+1,bP-1)end;c.title=bO;c.border=vim.api.nvim_win_get_config(q).border else c.title=nil end;c.relative='editor'vim.api.nvim_win_set_config(q,c)b.window_update_highlight(q,'FloatTitle','MiniFilesTitle')vim.wo[q].cursorline=true;vim.wo[q].conceallevel=3;b.trigger_event('MiniFilesWindowUpdate',{buf_id=vim.api.nvim_win_get_buf(q),win_id=q})end;b.window_update_highlight=function(q,bR,bS)local bT=bR..':'..bS;local bU=string.format('(%s:[^,]*)',vim.pesc(bR))local bV,bW=vim.wo[q].winhighlight:gsub(bU,bT)if bW==0 then bV=bV..','..bT end;pcall(function()vim.wo[q].winhighlight=bV end)end;b.window_focus=function(q)vim.api.nvim_set_current_win(q)b.window_update_highlight(q,'FloatTitle','MiniFilesTitleFocused')end;b.window_close=function(q)if q==nil then return end;local bX,r=pcall(vim.api.nvim_win_get_buf,q)if bX then b.opened_buffers[r].win_id=nil end;pcall(vim.api.nvim_win_close,q,true)end;b.window_set_view=function(q,o)local r=o.buf_id;vim.api.nvim_win_set_buf(q,r)b.opened_buffers[r].win_id=q;pcall(b.window_set_cursor,q,o.cursor)vim.wo[q].cursorline=true;b.window_update_border_hl(q)end;b.window_set_cursor=function(q,a2)if type(a2)~='table'then return end;vim.api.nvim_win_set_cursor(q,a2)b.window_tweak_cursor(q,vim.api.nvim_win_get_buf(q))end;b.window_tweak_cursor=function(q,r)local a2=vim.api.nvim_win_get_cursor(q)local a4=b.get_bufline(r,a2[1])local bY=b.match_line_offset(a4)if a2[2]<bY-1 then a2[2]=bY-1;vim.api.nvim_win_set_cursor(q,a2)vim.cmd('normal! 1000zh')end;return a2 end;b.window_update_border_hl=function(q)if not b.is_valid_win(q)then return end;local r=vim.api.nvim_win_get_buf(q)local bZ=b.is_modified_buffer(r)and'MiniFilesBorderModified'or'MiniFilesBorder'b.window_update_highlight(q,'FloatBorder',bZ)end;b.window_get_max_height=function()local bM=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local b_=vim.o.laststatus>0;return vim.o.lines-vim.o.cmdheight-(bM and 1 or 0)-(b_ and 1 or 0)-2 end;b.fs_read_dir=function(d,k)local c0=vim.loop.fs_scandir(d)local I={}if not c0 then return I end;local y,g=vim.loop.fs_scandir_next(c0)while y do if not(g=='file'or g=='directory')then g=b.fs_get_type(b.fs_child_path(d,y))end;table.insert(I,{fs_type=g,name=y,path=b.fs_child_path(d,y)})y,g=vim.loop.fs_scandir_next(c0)end;I=k.sort(vim.tbl_filter(k.filter,I))for n,bo in ipairs(I)do bo.path_id=b.add_path_to_index(bo.path)end;return I end;b.add_path_to_index=function(d)local c1=b.path_index[d]if c1~=nil then return c1 end;local c2=#b.path_index+1;b.path_index[c2]=d;b.path_index[d]=c2;return c2 end;b.compare_fs_entries=function(c3,c4)if c3.is_dir and not c4.is_dir then return true end;if not c3.is_dir and c4.is_dir then return false end;return c3.lower_name<c4.lower_name end;b.fs_normalize_path=function(d)local I=d:gsub('\\','/'):gsub('/+','/'):gsub('(.)/$','%1')return I end;b.fs_is_present_path=function(d)return vim.loop.fs_stat(d)~=nil end;b.fs_child_path=function(c5,y)return b.fs_normalize_path(string.format('%s/%s',c5,y))end;b.fs_full_path=function(d)return b.fs_normalize_path(vim.fn.fnamemodify(d,':p'))end;b.fs_shorten_path=function(d)d=b.fs_normalize_path(d)local c6=b.fs_normalize_path(vim.loop.os_homedir()or'~')local I=d:gsub('^'..vim.pesc(c6),'~')return I end;b.fs_get_basename=function(d)return b.fs_normalize_path(d):match('[^/]+$')end;b.fs_get_parent=function(d)d=b.fs_full_path(d)local c7=b.fs_is_windows_top(d)or d=='/'if c7 then return nil end;local I=b.fs_normalize_path(d:match('^.*/'))local c8=b.fs_is_windows_top(I)and'/'or''return I..c8 end;b.fs_is_windows_top=function(d)return b.is_windows and d:find('^%w:[\\/]?$')~=nil end;b.fs_get_type=function(d)if not b.fs_is_present_path(d)then return nil end;return vim.fn.isdirectory(d)==1 and'directory'or'file'end;b.fs_actions_confirm=function(m)local av=table.concat(b.fs_actions_to_lines(m),'\n')local aw=vim.fn.confirm(av,'&Yes\n&No',1,'Question')return aw==1 end;b.fs_actions_to_lines=function(m)local c9={}local ca=function(d)local cb=b.fs_shorten_path(b.fs_get_parent(d))local cc=c9[cb]or{}c9[cb]=cc;return cc end;local cd=function(d)return string.format("'%s'",b.fs_get_basename(d))end;for n,ak in ipairs(m.copy)do local cc=ca(ak.from)local a4=string.format("    COPY: %s to '%s'",cd(ak.from),b.fs_shorten_path(ak.to))table.insert(cc,a4)end;for n,d in ipairs(m.create)do local cc=ca(d)local g=d:find('/$')==nil and'file'or'directory'local a4=string.format('  CREATE: %s (%s)',cd(d),g)table.insert(cc,a4)end;for n,d in ipairs(m.delete)do local cc=ca(d)local a4=string.format('  DELETE: %s',cd(d))table.insert(cc,a4)end;for n,ak in ipairs(m.move)do local cc=ca(ak.from)local a4=string.format("    MOVE: %s to '%s'",cd(ak.from),b.fs_shorten_path(ak.to))table.insert(cc,a4)end;for n,ak in ipairs(m.rename)do local cc=ca(ak.from)local a4=string.format('  RENAME: %s to %s',cd(ak.from),cd(ak.to))table.insert(cc,a4)end;local I={'CONFIRM FILE SYSTEM ACTIONS',''}for d,cc in pairs(c9)do table.insert(I,d..':')vim.list_extend(I,cc)table.insert(I,'')end;return I end;b.fs_actions_apply=function(m,f)for n,ak in ipairs(m.copy)do local bD,ce=pcall(b.fs_copy,ak.from,ak.to)local S={action='copy',from=ak.from,to=ak.to}if bD and ce then b.trigger_event('MiniFilesActionCopy',S)end end;for n,d in ipairs(m.create)do local bD,ce=pcall(b.fs_create,d)local S={action='create',to=b.fs_normalize_path(d)}if bD and ce then b.trigger_event('MiniFilesActionCreate',S)end end;for n,ak in ipairs(m.move)do local bD,ce=pcall(b.fs_move,ak.from,ak.to)local S={action='move',from=ak.from,to=ak.to}if bD and ce then b.trigger_event('MiniFilesActionMove',S)end end;for n,ak in ipairs(m.rename)do local bD,ce=pcall(b.fs_rename,ak.from,ak.to)local S={action='rename',from=ak.from,to=ak.to}if bD and ce then b.trigger_event('MiniFilesActionRename',S)end end;for n,d in ipairs(m.delete)do local bD,ce=pcall(b.fs_delete,d,f.options.permanent_delete)local S={action='delete',from=d}if bD and ce then b.trigger_event('MiniFilesActionDelete',S)end end end;b.fs_create=function(d)if b.fs_is_present_path(d)then return false end;vim.fn.mkdir(b.fs_get_parent(d),'p')local g=d:find('/$')==nil and'file'or'directory'if g=='directory'then return vim.fn.mkdir(d)==1 else return vim.fn.writefile({},d)==0 end end;b.fs_copy=function(aW,aV)if b.fs_is_present_path(aV)then return false end;local cf=b.fs_get_type(aW)if cf==nil then return false end;if cf=='file'then return vim.loop.fs_copyfile(aW,aV)end;local H=b.fs_read_dir(aW,{filter=function()return true end,sort=function(J)return J end})vim.fn.mkdir(aV)local ce=true;for n,bo in ipairs(H)do ce=ce and b.fs_copy(bo.path,b.fs_child_path(aV,bo.name))end;return ce end;b.fs_delete=function(d,cg)if cg then return vim.fn.delete(d,'rf')==0 end;local ch=b.fs_child_path(vim.fn.stdpath('data'),'mini.files/trash')vim.fn.mkdir(ch,'p')local ci=b.fs_child_path(ch,b.fs_get_basename(d))pcall(vim.fn.delete,ci,'rf')return vim.loop.fs_rename(d,ci)end;b.fs_move=function(aW,aV)if b.fs_is_present_path(aV)then return false end;vim.fn.mkdir(b.fs_get_parent(aV),'p')local ce=vim.loop.fs_rename(aW,aV)for n,r in ipairs(vim.api.nvim_list_bufs())do b.rename_loaded_buffer(r,aW,aV)end;return ce end;b.fs_rename=b.fs_move;b.rename_loaded_buffer=function(r,aW,aV)if not(vim.api.nvim_buf_is_loaded(r)and vim.bo[r].buftype=='')then return end;local cj=b.fs_normalize_path(vim.api.nvim_buf_get_name(r))local ck=cj:gsub('^'..vim.pesc(aW),aV)if cj==ck then return end;vim.api.nvim_buf_set_name(r,ck)vim.api.nvim_buf_call(r,function()vim.cmd('silent! write! | edit')end)end;b.validate_opened_buffer=function(J)if J==nil or J==0 then J=vim.api.nvim_get_current_buf()end;if not b.is_opened_buffer(J)then b.error('`buf_id` should be an identifier of an opened directory buffer.')end;return J end;b.validate_line=function(r,J)J=J or vim.fn.line('.')if not(type(J)=='number'and 1<=J and J<=vim.api.nvim_buf_line_count(r))then b.error('`line` should be a valid line number in buffer '..r..'.')end;return J end;b.error=function(av)error(string.format('(mini.files) %s',av),0)end;b.map=function(bf,bg,bh,f)if bg==''then return end;f=vim.tbl_deep_extend('force',{silent=true},f or{})vim.keymap.set(bf,bg,bh,f)end;b.trigger_event=function(cl,S)if b.block_event_trigger[cl]then return end;if vim.fn.has('nvim-0.8')==0 then S=nil end;vim.api.nvim_exec_autocmds('User',{pattern=cl,data=S})end;b.is_valid_buf=function(r)return type(r)=='number'and vim.api.nvim_buf_is_valid(r)end;b.is_valid_win=function(q)return type(q)=='number'and vim.api.nvim_win_is_valid(q)end;b.get_bufline=function(r,A)return vim.api.nvim_buf_get_lines(r,A-1,A,false)[1]end;b.set_buflines=function(r,aK)local cm=string.format('lockmarks lua vim.api.nvim_buf_set_lines(%d, 0, -1, false, %s)',r,vim.inspect(aK))vim.cmd(cm)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.get_first_valid_normal_window=function()for n,q in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(q).relative==''then return q end end end;return a
