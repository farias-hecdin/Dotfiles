local a=vim.loop;local b=require"fzf-lua.path"local c=require"fzf-lua.libuv"local d={}local e=10;local f=0;local g={}local h={}function d.register_func(i)repeat f=f%e+1 until not h[f]g[f]=i;return f end;function d.get_func(j)return g[j]end;function d.set_protected(j)h[j]=true;assert(e>vim.tbl_count(h))end;function d.clear_protected()h={}end;function d.raw_async_action(i,k,l)if not k then k="{+}"end;local m=function(n,...)local o=a.new_pipe(false)local p={...}pcall(function()local q=loadstring("return require'fzf-lua'")()if q then q.__INFO=vim.tbl_deep_extend("force",q.__INFO or{},{selected=p[1][1]})end end)a.pipe_connect(o,n,function(r)if r then error(string.format("pipe_connect(%s) failed with error: %s",n,r))else vim.schedule(function()i(o,unpack(p))end)end end)end;local j=d.register_func(m)local s=os.getenv("FZF_LUA_NVIM_BIN")or vim.v.progpath;local t=("fzf_lua_server=[[%s]], fnc_id=%d %s"):format(vim.g.fzf_lua_server,j,l and", debug=true"or"")local u=("%s -n --headless --clean --cmd %s -- %s"):format(c.shellescape(s),c.shellescape(("lua loadfile([[%s]])().rpc_nvim_exec_lua({%s})"):format(b.join{vim.g.fzf_lua_directory,"shell_helper.lua"},t)),k)return u,j end;function d.async_action(i,k,l)local v,j=d.raw_async_action(i,k,l)return vim.fn.shellescape(v),j end;function d.raw_action(i,k,l)local m=function(o,...)local w=i(...)local x=function(y)a.close(o)end;if type(w)=="string"then a.write(o,w,x)elseif type(w)==nil then x()elseif type(w)=="table"then if not vim.tbl_isempty(w)then a.write(o,vim.tbl_map(function(z)return z.."\n"end,w),x)else x()end else a.write(o,tostring(w).."\n",x)end end;return d.raw_async_action(m,k,l)end;function d.action(i,k,l)local v,j=d.raw_action(i,k,l)return vim.fn.shellescape(v),j end;d.preview_action_cmd=function(i,k,l)local v,j=d.raw_preview_action_cmd(i,k,l)return vim.fn.shellescape(v),j end;d.raw_preview_action_cmd=function(i,k,l)return d.raw_async_action(function(o,...)local function A(y,y)if o and not a.is_closing(o)then a.close(o)o=nil end end;local function B(C,D)if not o then D(true)else a.write(o,C,D)end end;c.process_kill(d.__pid_preview)d.__pid_preview=nil;return c.spawn({cmd=i(...),cb_finish=A,cb_write=B,cb_pid=function(E)d.__pid_preview=E end},false)end,k,l)end;d.reload_action_cmd=function(F,k)if F.fn_preprocess and type(F.fn_preprocess)=="function"then F=vim.tbl_deep_extend("keep",F,F.fn_preprocess(F))end;return d.raw_async_action(function(o,p)local G=F.__fn_reload(p[1])local H=0;local I=false;local A=function(y,y,y,y)if not o then return end;I=true;if H==0 then a.close(o)o=nil end end;local B=function(C,D,J)assert(not J or J and o and not a.is_closing(o))if not o then return end;if not C then A(nil,nil,5)if D then D(nil)end else H=H+1;a.write(o,tostring(C),function(r)H=H-1;if J then coroutine.resume(J)end;if D then D(r)end;if r then H=0;A(nil,nil,2)end;if H==0 and I then A(nil,nil,3)end end)if J and coroutine.yield()==1 then H=0;A(nil,nil,4)end end end;if type(G)=="string"then c.process_kill(d.__pid_reload)d.__pid_reload=nil;c.async_spawn({cwd=F.cwd,cmd=G,cb_finish=A,cb_write=B,cb_pid=function(E)d.__pid_reload=E end},F.__fn_transform or false)else coroutine.wrap(function()if F.__co then local K=coroutine.status(F.__co)if K~="dead"then coroutine.resume(F.__co,1)end;assert(coroutine.status(F.__co)=="dead")end;F.__co=coroutine.running()local L=function(C,D)C=C and tostring(C).."\n"or nil;return B(C,D)end;local M=function(C,D)C=C and tostring(C).."\n"or nil;return B(C,D,F.__co)end;local N=function(C,D)return B(C,D,F.__co)end;if type(G)=="table"then for y,O in ipairs(G)do M(O)end;A()elseif type(G)=="function"then if F.func_async_callback~=false then G(M,N)else G(L,B)end else end end)()end end,k,F.debug)end;return d
