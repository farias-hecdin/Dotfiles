function _G.dump(...)local a=vim.tbl_map(vim.inspect,{...})print(unpack(a))end;local b={}b.__HAS_NVIM_09=vim.fn.has("nvim-0.9")==1;b.__HAS_NVIM_08=vim.fn.has("nvim-0.8")==1;b.__HAS_NVIM_07=vim.fn.has("nvim-0.7")==1;function b.__FILE__()return debug.getinfo(2,"S").source end;function b.__LINE__()return debug.getinfo(2,"l").currentline end;function b.__FNC__()return debug.getinfo(2,"n").name end;function b.__FNCREF__()return debug.getinfo(2,"f").func end;b.nbsp="\xe2\x80\x82"if _VERSION and type(_VERSION)=="string"then local c=tonumber(_VERSION:match("%d+.%d+"))if c<5.2 then b.nbsp=b.nbsp:gsub("\\x(%x%x)",function(d)return string.char(tonumber(d,16))end)end end;b._if=function(e,f,g)if e then return f else return g end end;b.strsplit=function(h,i)local j={}for k in string.gmatch(h,"([^"..i.."]+)")do table.insert(j,k)end;return j end;local l=string.byte;b.find_last_char=function(k,m)for n=#k,1,-1 do if l(k,n)==m then return n end end end;b.find_next_char=function(k,m,o)for n=o or 1,#k do if l(k,n)==m then return n end end end;function b.round(p,q)if not p then return nil end;if not q then q=0.5 end;local r=p-math.floor(p)if r>q then return math.ceil(p)end;return math.floor(p)end;function b.nvim_has_option(s)return vim.fn.exists("&"..s)==1 end;function b._echo_multiline(t,u)vim.cmd("echohl "..u)for _,v in ipairs(vim.fn.split(t,"\n"))do vim.cmd("echom '"..v:gsub("'","''").."'")end;vim.cmd("echohl None")end;local w=function(t,u)if vim.in_fast_event()then vim.schedule(function()b._echo_multiline("[Fzf-lua] "..t,u)end)else b._echo_multiline("[Fzf-lua] "..t,u)end end;function b.info(t)w(t,"Directory")end;function b.warn(t)w(t,"WarningMsg")end;function b.err(t)w(t,"ErrorMsg")end;function b.shell_error()return vim.v.shell_error~=0 end;function b.is_darwin()return vim.loop.os_uname().sysname=="Darwin"end;function b.rg_escape(k)if not k then return k end;return k:gsub("[\\~$?*|{\\[()^%-%.%+]",function(d)return"\\"..d end)end;function b.sk_escape(k)if not k then return k end;return k:gsub('["`]',function(d)return"\\"..d end):gsub([[\\]],[[\\\\]]):gsub([[\%$]],[[\\\$]])end;function b.lua_escape(k)if not k then return k end;return k:gsub("[%%]",function(d)return"%"..d end)end;function b.lua_regex_escape(k)if not k then return nil end;return k:gsub("[%(%)%.%+%-%*%[%?%^%$%%]",function(d)return"%"..d end)end;function b.glob_escape(k)if not k then return k end;return k:gsub("[\\%{}]",function(d)return[[\]]..d end)end;function b.pcall_expand(x)local y,z=pcall(vim.fn.expand,x:gsub("%-","\\-"))if y and z and#z>0 then return z else return x end end;b.file_is_binary=function(x)x=b.pcall_expand(x)if vim.fn.executable("file")~=1 or not vim.loop.fs_stat(x)then return false end;local A=b.io_system({"file","--dereference","--mime",x})return A:match("charset=binary")~=nil end;b.perl_file_is_binary=function(x)x=b.pcall_expand(x)if vim.fn.executable("perl")~=1 or not vim.loop.fs_stat(x)then return false end;b.io_system({"perl","-E","exit((-B $ARGV[0])?0:1);",x})return not b.shell_error()end;b.read_file=function(x)local B=vim.loop.fs_open(x,"r",438)if B==nil then return""end;local C=assert(vim.loop.fs_fstat(B))if C.type~="file"then return""end;local D=assert(vim.loop.fs_read(B,C.size,0))assert(vim.loop.fs_close(B))return D end;b.read_file_async=function(x,E)vim.loop.fs_open(x,"r",438,function(F,B)if F then vim.schedule(function()b.warn(("Unable to open file '%s', error: %s"):format(x,F))end)return end;vim.loop.fs_fstat(B,function(G,C)assert(not G,G)if C.type~="file"then return E("")end;vim.loop.fs_read(B,C.size,0,function(H,D)assert(not H,H)vim.loop.fs_close(B,function(I)assert(not I,I)return E(D)end)end)end)end)end;function b.deepcopy(j)local y,J=pcall(vim.deepcopy,j)if y then return J else return b.tbl_deep_clone(j)end end;function b.tbl_deep_clone(j)if not j then return end;local K={}for L,M in pairs(j)do if type(M)=="table"then K[L]=b.tbl_deep_clone(M)else K[L]=M end end;return K end;function b.tbl_length(N)local O=0;for _ in pairs(N)do O=O+1 end;return O end;function b.tbl_isempty(N)if not N or not next(N)then return true end;return false end;function b.tbl_extend(P,Q)return table.move(Q,1,#Q,#P+1,P)end;function b.map_get(R,L)if not R then return end;if not L then return R end;local S=b.strsplit(L,".")local T=R;for n=1,#S do T=T[S[n]]if n==#S then return T elseif type(T)~="table"then break end end end;function b.map_set(R,L,M)R=R or{}local S=b.strsplit(L,".")local U=R;for n=1,#S do local V=S[n]if n==#S then U[V]=M else U[V]=type(U[V])=="table"and U[V]or{}U=U[V]end end;return R end;function b.map_tolower(R)if not R then return end;local W={}for L,M in pairs(R)do W[L:lower()]=M end;return W end;b.ansi_codes={}b.ansi_escseq={clear="[0m",bold="[1m",italic="[3m",underline="[4m",black="[0;30m",red="[0;31m",green="[0;32m",yellow="[0;33m",blue="[0;34m",magenta="[0;35m",cyan="[0;36m",white="[0;37m",grey="[0;90m",dark_grey="[0;97m"}b.cache_ansi_escseq=function(X,Y)b.ansi_codes[X]=function(string)if string==nil or#string==0 then return""end;if not Y or#Y==0 then return string end;return Y..string..b.ansi_escseq.clear end end;for Z,Y in pairs(b.ansi_escseq)do b.cache_ansi_escseq(Z,Y)end;local function a0(a1)local a2,a3,g=a1:match("#(..)(..)(..)")if not a2 or not a3 or not g then return end;a2,a3,g=tonumber(a2,16),tonumber(a3,16),tonumber(g,16)return a2,a3,g end;function b.is_hl_cleared(u)if vim.api.nvim_get_hl then local y,a4=pcall(vim.api.nvim_get_hl,0,{name=u,link=false})if not y or vim.tbl_isempty(a4)then return true end else local y,a4=pcall(vim.api.nvim_get_hl_by_name,u,true)if not y or a4[true]then return true end end end;function b.COLORMAP()if not b.__COLORMAP then b.__COLORMAP=vim.api.nvim_get_color_map()end;return b.__COLORMAP end;local function a5(u,a6)return vim.fn.synIDattr(vim.fn.synIDtrans(vim.fn.hlID(u)),a6)end;function b.hexcol_from_hl(a7,a8)if not a7 or not a8 then return end;local a1=a5(a7,a8)if a1 and not a1:match("^#")then local a9=b.COLORMAP()[a1:sub(1,1):upper()..a1:sub(2)]if a9 then a1=("#%06x"):format(a9)end end;return a1 end;function b.ansi_from_hl(u,v)if not u or#u==0 or vim.fn.hlexists(u)~=1 then return v,nil end;local a8={["fg"]={rgb=true,code=38},["bg"]={rgb=true,code=48},["bold"]={code=1},["italic"]={code=3},["underline"]={code=4},["inverse"]={code=7},["reverse"]={code=7},["strikethrough"]={code=9}}local aa={}for a6,ab in pairs(a8)do if ab.rgb then local a1=b.hexcol_from_hl(u,a6)local a2,a3,g=a0(a1)if a2 and a3 and g then table.insert(aa,string.format("[%d;2;%d;%d;%dm",ab.code,a2,a3,g))end else local ac=a5(u,a6)if ac and tonumber(ac)==1 then table.insert(aa,string.format("[%dm",ab.code))end end end;local Y=#aa>0 and table.concat(aa)or nil;if Y then v=string.format("%s%s%s",Y,v or"",b.ansi_escseq.clear)end;return v,Y end;function b.strip_ansi_coloring(k)if not k then return k end;return k:gsub("%[[%d;]-m","")end;function b.mode_is_visual()local ad={v=true,vs=true,V=true,Vs=true,nov=true,noV=true,niV=true,Rv=true,Rvc=true,Rvx=true}local ae=vim.api.nvim_get_mode()return ad[ae.mode]end;function b.get_visual_selection()local _,af,ag,ah,ai;local ae=vim.fn.mode()if ae=="v"or ae=="V"or ae==""then _,af,ag,_=unpack(vim.fn.getpos("."))_,ah,ai,_=unpack(vim.fn.getpos("v"))if ae=="V"then ag,ai=0,999 end;vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>",true,false,true),"n",true)else _,af,ag,_=unpack(vim.fn.getpos("'<"))_,ah,ai,_=unpack(vim.fn.getpos("'>"))end;if ah<af then af,ah=ah,af end;if ai<ag then ag,ai=ai,ag end;local aj=vim.fn.getline(af,ah)local ak=b.tbl_length(aj)if ak<=0 then return""end;aj[ak]=string.sub(aj[ak],1,ai)aj[1]=string.sub(aj[1],ag)return table.concat(aj,"\n"),{start={line=af,char=ag},["end"]={line=ah,char=ai}}end;function b.fzf_exit()vim.cmd([[lua require('fzf-lua.win').win_leave()]])end;function b.fzf_winobj()return loadstring("return require'fzf-lua'.win.__SELF()")()end;function b.reset_info()pcall(loadstring("require'fzf-lua'.set_info(nil)"))end;function b.setup_highlights()pcall(loadstring("require'fzf-lua'.setup_highlights()"))end;function b.load_profile(al,X,am)local an=X or al:match("([^%p]+)%.lua$")or"<unknown>"local y,J=pcall(dofile,al)if y and type(J)=="table"then if not am then b.info(string.format("Succefully loaded profile '%s'",an))end;return J elseif am then return end;if not y then b.warn(string.format("Unable to load profile '%s': %s",an,J:match("[^\n]+")))elseif type(J)~="table"then b.warn(string.format("Unable to load profile '%s': wrong type %s",an,type(J)))end end;function b.send_ctrl_c()vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<C-c>",true,false,true),"n",true)end;function b.feed_keys_termcodes(V)vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(V,true,false,true),"n",true)end;function b.is_term_bufname(ao)if ao and ao:match("term://")then return true end;return false end;function b.is_term_buffer(ap)ap=tonumber(ap)or 0;ap=ap==0 and vim.api.nvim_get_current_buf()or ap;local aq=vim.fn.bufwinid(ap)if tonumber(aq)>0 and vim.api.nvim_win_is_valid(aq)then return vim.fn.getwininfo(aq)[1].terminal==1 end;local ao=vim.api.nvim_buf_is_valid(ap)and vim.api.nvim_buf_get_name(ap)return b.is_term_bufname(ao)end;function b.buffer_is_dirty(ap,ar,as)ap=tonumber(ap)or vim.api.nvim_get_current_buf()local at=ap and vim.fn.getbufinfo(ap)[1]if at and at.changed~=0 then if as and 1<b.tbl_length(vim.fn.win_findbuf(ap))then return false end;if ar then b.warn(("buffer %d:%s has unsaved changes"):format(ap,at.name and#at.name>0 and at.name or"<unnamed>"))end;return true end;return false end;function b.save_dialog(ap)ap=tonumber(ap)or vim.api.nvim_get_current_buf()local at=ap and vim.fn.getbufinfo(ap)[1]if not at.name or#at.name==0 then b.warn(string.format("buffer %d has unsaved changes",ap))return false end;local J=vim.fn.confirm(string.format([[Save changes to "%s"?]],at.name),"&Yes\n&No\n&Cancel")if J==3 then return false end;if J==1 then local A=vim.api.nvim_cmd({cmd="update"},{output=true})b.info(A)end;return true end;function b.win_is_qf(aq,au)au=au or vim.api.nvim_win_is_valid(aq)and vim.fn.getwininfo(aq)[1]if au and au.quickfix==1 then return au.loclist==1 and 2 or 1 end;return false end;function b.buf_is_qf(ap,av)av=av or vim.api.nvim_buf_is_valid(ap)and vim.fn.getbufinfo(ap)[1]if av and av.variables and av.variables.current_syntax=="qf"and not vim.tbl_isempty(av.windows)then return b.win_is_qf(av.windows[1])end;return false end;function b.winid_from_tabh(aw,ap)for _,a6 in ipairs(vim.api.nvim_tabpage_list_wins(aw))do if ap==vim.api.nvim_win_get_buf(a6)then return a6 end end;return nil end;function b.winid_from_tabi(ax,ap)local aw=vim.api.nvim_list_tabpages()[ax]return b.winid_from_tabh(aw,ap)end;function b.nvim_buf_get_name(ap,av)assert(not vim.in_fast_event())if not vim.api.nvim_buf_is_valid(ap)then return end;if av and av.name and#av.name>0 then return av.name end;local ao=vim.api.nvim_buf_get_name(ap)if not ao or#ao==0 then local ay=b.buf_is_qf(ap,av)if ay then ao=ay==1 and"[Quickfix List]"or"[Location List]"else ao="[No Name]"end end;assert(#ao>0)return ao end;function b.zz()if b.is_term_buffer()then return end;local az=vim.api.nvim_win_get_cursor(0)[1]local aA=vim.api.nvim_buf_line_count(0)local aB="keepj norm! %dzb"if az==aA then vim.fn.execute(aB:format(az))return end;vim.cmd("norm! zvzz")az=vim.api.nvim_win_get_cursor(0)[1]vim.cmd("norm! L")local aC=vim.api.nvim_win_get_cursor(0)[1]if aC+vim.fn.getwinvar(0,"&scrolloff")>=aA then vim.fn.execute(aB:format(aC))end;if az~=aC then vim.cmd("keepj norm! ``")end end;function b.win_set_buf_noautocmd(aD,aE)local aF=vim.o.eventignore;vim.o.eventignore="all"vim.api.nvim_win_set_buf(aD,aE)vim.o.eventignore=aF end;function b.nvim_open_win(ap,aG,aH)local aF=vim.o.eventignore;vim.o.eventignore="all"local aq=vim.api.nvim_open_win(ap,aG,aH)vim.o.eventignore=aF;return aq end;function b.nvim_win_close(aD,aI)local aF=vim.o.eventignore;vim.o.eventignore="all"vim.api.nvim_win_close(aD,aI)vim.o.eventignore=aF end;function b.nvim_buf_delete(ap,aI)if not vim.api.nvim_buf_is_valid(ap)then return end;local aF=vim.o.eventignore;vim.o.eventignore="all"vim.api.nvim_buf_delete(ap,aI)vim.o.eventignore=aF end;function b.keymap_set(ae,aJ,aK,aI)if vim.keymap then vim.keymap.set(ae,aJ,aK,aI)else assert(type(ae)=="string"and type(aK)=="string")aI=aI or{}aI.noremap=not aI.remap;if aI.buffer then local ap=type(aI.buffer)=="number"and aI.buffer or 0;aI.buffer=nil;vim.api.nvim_buf_set_keymap(ap,ae,aJ,aK,aI)else vim.api.nvim_set_keymap(ae,aJ,aK,aI)end end end;local aL=false;function b.set_lua_io(g)aL=g;if aL then b.warn("using experimental feature 'lua_io'")end end;function b.io_systemlist(aM,aN)if not aN then aN=aL end;if aN and aM=="string"then local aO=0;local aP=""local aQ=io.popen(aM.." 2>&1; echo $?","r")if aQ then aP={}for aR in aQ:lines()do aP[#aP+1]=aR end;aO=tonumber(aP[#aP])aP[#aP]=nil;aQ:close()end;return aP,aO else return vim.fn.systemlist(aM),vim.v.shell_error end end;function b.io_system(aM,aN)if not aN then aN=aL end;if aN then local aP,aO=b.io_systemlist(aM,true)if type(aP)=="table"then aP=table.concat(aP,"\n")end;return aP,aO else return vim.fn.system(aM),vim.v.shell_error end end;function b.input(aS)local y,J;if false then y,_=pcall(vim.ui.input,{prompt=aS},function(aT)J=aT end)else y,J=pcall(vim.fn.input,{prompt=aS,cancelreturn=3})if J==3 then y,J=false,nil end end;return y and J or nil end;function b.fzf_bind_to_neovim(V)local aU={["alt"]="A",["ctrl"]="C",["shift"]="S"}V=V:lower()for L,M in pairs(aU)do V=V:gsub(L,M)end;return("<%s>"):format(V)end;function b.neovim_bind_to_fzf(V)local aU={["a"]="alt",["c"]="ctrl",["s"]="shift"}V=V:lower():gsub("[<>]","")for L,M in pairs(aU)do V=V:gsub(L.."%-",M.."-")end;return V end;function b.fzf_version(aI)local aV=vim.env.FZF_DEFAULT_OPTS;vim.env.FZF_DEFAULT_OPTS=nil;local A,aO=b.io_system({aI.fzf_bin or"fzf","--version"})vim.env.FZF_DEFAULT_OPTS=aV;if A:match("HEAD")then return 4 end;return tonumber(A:match("(%d+.%d+).")),aO,A end;function b.git_version()local A=b.io_system({"git","--version"})return tonumber(A:match("(%d+.%d+)."))end;function b.find_version()local A,aO=b.io_systemlist({"find","--version"})return aO==0 and tonumber(A[1]:match("(%d+.%d+)"))or nil end;return b
