local a=require"fzf-lua.utils"local b=require"fzf-lua.path"local c={}local d="default"c.expect=function(e)if not e then return nil end;local f={}for g,h in pairs(e)do if g~=d and h~=false then table.insert(f,g)end end;if#f>0 then return string.format("--expect=%s",table.concat(f,","))end;return nil end;c.normalize_selected=function(e,i)if not e or not i then return end;local j=d;if a.tbl_length(e)>1 or not e[d]then if#i[1]>0 then j=i[1]end;local k={}for l=2,#i do table.insert(k,i[l])end;return j,k else return j,i end end;c.act=function(e,i,m)if not e or not i then return end;local n,k=c.normalize_selected(e,i)local j=e[n]if type(j)=="table"then if j.fn then j.fn(k,m)else for o,p in ipairs(j)do p(k,m)end end elseif type(j)=="function"then j(k,m)elseif type(j)=="string"then vim.cmd(j)elseif n~=d then a.warn(("unsupported action: '%s', type:%s"):format(n,type(j)))end end;c.dummy_abort=function()end;c.resume=function(o,o)vim.cmd("lua require'fzf-lua'.resume()")end;c.vimcmd=function(q,i,r)for l=1,#i do vim.cmd(("%s %s"):format(q,r and i[l]or vim.fn.fnameescape(i[l])))end end;c.vimcmd_file=function(q,i,m)local s=vim.api.nvim_buf_get_name(0)local t=a.is_term_buffer(0)for l=1,#i do local u=b.entry_to_file(i[l],m,m.force_uri)if u.path=="<none>"then goto v end;u.ctag=m._ctag and b.entry_to_ctag(i[l])local w=u.path or u.uri and u.uri:match("^%a+://(.*)")if not b.starts_with_separator(w)then w=b.join({m.cwd or vim.loop.cwd(),w})end;if q=="e"and s~=w and not vim.o.hidden and a.buffer_is_dirty(nil,false,true)then if a.save_dialog(nil)then q=q.."!"else return end end;if not t then vim.cmd("normal! m`")end;if q~="e"or s~=w then if u.path then local x=b.relative(u.path,vim.loop.cwd())vim.cmd(q.." "..vim.fn.fnameescape(x))elseif q~="e"then vim.cmd(q)end end;if u.uri then vim.lsp.util.jump_to_location(u,"utf-16")elseif u.ctag then vim.api.nvim_win_set_cursor(0,{1,0})vim.fn.search(u.ctag,"W")elseif u.line>1 or u.col>1 then u.col=u.col and u.col>0 and u.col or 1;vim.api.nvim_win_set_cursor(0,{tonumber(u.line),tonumber(u.col)-1})end;if not t and not m.no_action_zz then vim.cmd("norm! zvzz")end::v::end end;c.file_edit=function(i,m)local q="e"c.vimcmd_file(q,i,m)end;c.file_split=function(i,m)local q="new"c.vimcmd_file(q,i,m)end;c.file_vsplit=function(i,m)local q="vnew"c.vimcmd_file(q,i,m)end;c.file_tabedit=function(i,m)local q="tabnew"c.vimcmd_file(q,i,m)end;c.file_open_in_background=function(i,m)local q="badd"c.vimcmd_file(q,i,m)end;local y=function(i,m,z)local A={}for l=1,#i do local B=b.entry_to_file(i[l],m)local C=i[l]:match(":%d+:%d?%d?%d?%d?:?(.*)$")table.insert(A,{filename=B.bufname or B.path,lnum=B.line,col=B.col,text=C})end;local D=string.format("[FzfLua] %s%s",m.__INFO and m.__INFO.cmd..": "or"",m.__resume_data.last_query)if z then vim.fn.setloclist(0,{}," ",{nr="$",items=A,title=D})vim.cmd(m.lopen or"lopen")else vim.fn.setqflist({}," ",{nr="$",items=A,title=D})vim.cmd(m.copen or"copen")end end;c.file_sel_to_qf=function(i,m)y(i,m)end;c.file_sel_to_ll=function(i,m)y(i,m,true)end;c.file_edit_or_qf=function(i,m)if#i>1 then return c.file_sel_to_qf(i,m)else return c.file_edit(i,m)end end;c.file_switch=function(i,m)local E=nil;local u=b.entry_to_file(i[1])local w=u.path;if not b.starts_with_separator(w)then w=b.join({m.cwd or vim.loop.cwd(),w})end;for o,F in ipairs(vim.api.nvim_list_bufs())do local G=vim.api.nvim_buf_get_name(F)if G and G==w then E=F;break end end;if not E then return false end;local t=a.is_term_buffer(0)if not t then vim.cmd("normal! m`")end;local H=a.winid_from_tabh(0,E)if H then vim.api.nvim_set_current_win(H)end;if u.line>1 or u.col>1 then vim.api.nvim_win_set_cursor(0,{tonumber(u.line),tonumber(u.col)-1})end;if not t and not m.no_action_zz then vim.cmd("norm! zvzz")end;return true end;c.file_switch_or_edit=function(...)c.file_switch(...)c.file_edit(...)end;c.vimcmd_buf=function(q,i,m)local s=vim.api.nvim_get_current_buf()local I=vim.api.nvim_win_get_cursor(0)[1]local t=a.is_term_buffer(0)for l=1,#i do local u=b.entry_to_file(i[l],m)if not u.bufnr then return end;assert(type(u.bufnr)=="number")if q=="b"and s~=u.bufnr and not vim.o.hidden and a.buffer_is_dirty(nil,false,true)then if a.save_dialog(nil)then q=q.."!"else return end end;if not t then vim.cmd("normal! m`")end;if q~="b"or s~=u.bufnr then local J=q.." "..u.bufnr;local K,L=pcall(vim.cmd,J)if not K then a.warn(("':%s' failed: %s"):format(J,L))end end;if q~="bd"and not m.no_action_set_cursor then if s~=u.bufnr or I~=u.line then u.col=u.col and u.col>0 and u.col or 1;vim.api.nvim_win_set_cursor(0,{tonumber(u.line),tonumber(u.col)-1})end;if not t and not m.no_action_zz then vim.cmd("norm! zvzz")end end end end;c.buf_edit=function(i,m)local q="b"c.vimcmd_buf(q,i,m)end;c.buf_split=function(i,m)local q="split | b"c.vimcmd_buf(q,i,m)end;c.buf_vsplit=function(i,m)local q="vertical split | b"c.vimcmd_buf(q,i,m)end;c.buf_tabedit=function(i,m)local q="tab split | b"c.vimcmd_buf(q,i,m)end;c.buf_del=function(i,m)local q="bd"local M=vim.tbl_filter(function(N)local F=tonumber(N:match("%[(%d+)"))return F and not a.buffer_is_dirty(F,true,false)end,i)c.vimcmd_buf(q,M,m)end;c.buf_switch=function(i,o)local O=tonumber(i[1]:match("(%d+)%)"))local P=O and vim.api.nvim_list_tabpages()[O]if P then vim.api.nvim_set_current_tabpage(P)else P=vim.api.nvim_win_get_tabpage(0)end;local E=tonumber(string.match(i[1],"%[(%d+)"))if E then local H=a.winid_from_tabh(P,E)if H then vim.api.nvim_set_current_win(H)end end end;c.buf_switch_or_edit=function(...)c.buf_switch(...)c.buf_edit(...)end;c.buf_sel_to_qf=function(i,m)return y(i,m)end;c.buf_sel_to_ll=function(i,m)return y(i,m,true)end;c.buf_edit_or_qf=function(i,m)if#i>1 then return c.buf_sel_to_qf(i,m)else return c.buf_edit(i,m)end end;c.colorscheme=function(i)local Q=i[1]vim.cmd("colorscheme "..Q)a.setup_highlights()end;c.ensure_insert_mode=function()a.warn("calling 'ensure_insert_mode' is no longer required and can be safely omitted.")end;c.run_builtin=function(i)local R=i[1]vim.cmd(string.format("lua require'fzf-lua'.%s()",R))end;c.ex_run=function(i)local J=i[1]vim.cmd("stopinsert")vim.fn.feedkeys(string.format(":%s",J),"n")return J end;c.ex_run_cr=function(i)local J=i[1]vim.cmd(J)vim.fn.histadd("cmd",J)end;c.exec_menu=function(i)local J=i[1]vim.cmd("emenu "..J)end;c.search=function(i,m)local S=i[1]vim.cmd("stopinsert")vim.fn.feedkeys(string.format("%s%s",m.reverse_search and"?"or"/",S),"n")return S end;c.search_cr=function(i,m)c.search(i,m)a.feed_keys_termcodes("<CR>")end;c.goto_mark=function(i)local T=i[1]T=T:match("[^ ]+")vim.cmd("stopinsert")vim.cmd("normal! '"..T)end;c.goto_jump=function(i,m)if m.jump_using_norm then local U,o,o,o=i[1]:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")if tonumber(U)then vim.cmd(("normal! %d"):format(U))end else local o,I,V,W=i[1]:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")local K,L=pcall(vim.fn.expand,W)if not K then W=""else W=L end;if not W or not vim.loop.fs_stat(W)then W=vim.api.nvim_buf_get_name(0)end;local u=("%s:%d:%d:"):format(W,tonumber(I),tonumber(V)+1)c.file_edit({u},m)end end;c.keymap_apply=function(i)local X=i[1]:match("[â”‚]%s+(.*)%s+[â”‚]")vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(X,true,false,true),"t",true)end;c.spell_apply=function(i)local Y=i[1]vim.cmd("normal! ciw"..Y)vim.cmd("stopinsert")end;c.set_filetype=function(i)vim.api.nvim_buf_set_option(0,"filetype",i[1])end;c.packadd=function(i)for l=1,#i do vim.cmd("packadd "..i[l])end end;local function Z(_)return vim.tbl_map(function(a0)return a0:match("[^%s]+")end,_)end;c.help=function(i)local q="help"c.vimcmd(q,Z(i),true)end;c.help_vert=function(i)local q="vert help"c.vimcmd(q,Z(i),true)end;c.help_tab=function(i)local q="tab help"c.vimcmd(q,Z(i),true)end;local function a1(_)return vim.tbl_map(function(a0)return a0:match("[^[,( ]+")end,_)end;c.man=function(i)local q="Man"c.vimcmd(q,a1(i))end;c.man_vert=function(i)local q="vert Man"c.vimcmd(q,a1(i))end;c.man_tab=function(i)local q="tab Man"c.vimcmd(q,a1(i))end;c.git_switch=function(i,m)local J=b.git_cwd({"git","checkout"},m)local a2=a.git_version()if a2 and a2>=2.23 then J=b.git_cwd({"git","switch"},m)end;local a3=i[1]:match("[^ ]+")if a3:find("%*")~=nil then return end;if a3:find("^remotes/")then table.insert(J,"--detach")end;table.insert(J,a3)local a4=a.io_systemlist(J)if a.shell_error()then a.err(unpack(a4))else a.info(unpack(a4))vim.cmd("edit!")end end;c.git_yank_commit=function(i,o)local a5=i[1]:match("[^ ]+")vim.fn.setreg([[0]],a5)vim.fn.setreg([["]],a5)end;c.git_checkout=function(i,m)local a6=b.git_cwd({"git","checkout"},m)local a7=b.git_cwd({"git","rev-parse","--short HEAD"},m)local a5=i[1]:match("[^ ]+")if a.input("Checkout commit "..a5 .."? [y/n] ")=="y"then local a8=a.io_systemlist(a7)if a5==a8 then return end;table.insert(a6,a5)local a4=a.io_systemlist(a6)if a.shell_error()then a.err(unpack(a4))else a.info(unpack(a4))vim.cmd("edit!")end end end;local a9=function(i,m,J,aa)local ab;for o,ac in ipairs(i)do local B=b.relative(b.entry_to_file(ac,m).path,m.cwd)local ad=vim.deepcopy(J)table.insert(ad,B)local a4=a.io_systemlist(ad)ab=not a.shell_error()if not ab and not aa then a.err(unpack(a4)or string.format("exit code %d",vim.v.shell_error))end end;return ab end;c.git_stage=function(i,m)for o,_ in ipairs(i)do if string.byte(_,1)~=68 then local J=b.git_cwd({"git","add","--"},m)a9({_},m,J)end end end;c.git_unstage=function(i,m)local J=b.git_cwd({"git","reset","--"},m)a9(i,m,J)end;c.git_stage_unstage=function(i,m)for o,_ in ipairs(i)do local J=b.git_cwd({"git","diff","--cached","--quiet","--"},m)local ae=a9({_},m,J,true)if ae then c.git_stage({_},m)else c.git_unstage({_},m)end end end;c.git_reset=function(i,m)for o,_ in ipairs(i)do _=a.strip_ansi_coloring(_)local af=_:sub(5,5)=="?"local J=af and b.git_cwd({"git","clean","-f"},m)or b.git_cwd({"git","checkout","HEAD","--"},m)a9({_},m,J)end end;c.git_stash_drop=function(i,m)local J=b.git_cwd({"git","stash","drop"},m)a9(i,m,J)end;c.git_stash_pop=function(i,m)if a.input("Pop "..#i.." stash(es)? [y/n] ")=="y"then local J=b.git_cwd({"git","stash","pop"},m)a9(i,m,J)vim.cmd("e!")end end;c.git_stash_apply=function(i,m)if a.input("Apply "..#i.." stash(es)? [y/n] ")=="y"then local J=b.git_cwd({"git","stash","apply"},m)a9(i,m,J)vim.cmd("e!")end end;c.git_buf_edit=function(i,m)local J=b.git_cwd({"git","show"},m)local ag=b.git_root(m,true)local ah=vim.api.nvim_get_current_win()local ai=vim.bo.filetype;local B=b.relative(vim.fn.expand("%:p"),ag)local a5=i[1]:match("[^ ]+")table.insert(J,a5 ..":"..B)local aj=a.io_systemlist(J)local ak=vim.api.nvim_create_buf(true,true)local al=string.gsub(B,"$","["..a5 .."]")vim.api.nvim_buf_set_lines(ak,0,0,true,aj)vim.api.nvim_buf_set_name(ak,al)vim.api.nvim_buf_set_option(ak,"buftype","nofile")vim.api.nvim_buf_set_option(ak,"bufhidden","wipe")vim.api.nvim_buf_set_option(ak,"filetype",ai)vim.api.nvim_buf_set_option(ak,"modifiable",false)vim.api.nvim_win_set_buf(ah,ak)end;c.git_buf_tabedit=function(i,m)vim.cmd("tab split")c.git_buf_edit(i,m)end;c.git_buf_split=function(i,m)vim.cmd("split")c.git_buf_edit(i,m)end;c.git_buf_vsplit=function(i,m)vim.cmd("vsplit")c.git_buf_edit(i,m)end;c.arg_add=function(i,m)local q="argadd"c.vimcmd_file(q,i,m)end;c.arg_del=function(i,m)local q="argdel"c.vimcmd_file(q,i,m)end;c.grep_lgrep=function(o,m)assert(m.__MODULE__ and type(m.__MODULE__.grep)=="function"or type(m.__MODULE__.live_grep)=="function")local am=vim.tbl_extend("keep",{search=false,resume=true,resume_search_default="",rg_glob=m.rg_glob or m.__call_opts.rg_glob,requires_processing=m.rg_glob or m.__call_opts.rg_glob,__prev_query=not m.fn_reload and m.__resume_data.last_query,query=m.fn_reload and m.__call_opts.__prev_query,ctags_file=m.ctags_file},m.__call_opts or{})if m.fn_reload then m.__MODULE__.grep(am)else m.__MODULE__.live_grep(am)end end;c.sym_lsym=function(o,m)assert(m.__MODULE__ and type(m.__MODULE__.workspace_symbols)=="function"or type(m.__MODULE__.live_workspace_symbols)=="function")local am=vim.tbl_extend("keep",{resume=true,lsp_query=false,__prev_query=not m.fn_reload and m.__resume_data.last_query,query=m.fn_reload and m.__call_opts.__prev_query},m.__call_opts or{})if m.fn_reload then m.__MODULE__.workspace_symbols(am)else m.__MODULE__.live_workspace_symbols(am)end end;c.tmux_buf_set_reg=function(i,m)local ak=i[1]:match("^%[(.-)%]")local an=vim.fn.system({"tmux","show-buffer","-b",ak})if not a.shell_error()and an and#an>0 then m.register=m.register or[["]]local K,ao=pcall(vim.fn.setreg,m.register,an)if K then a.info(string.format("%d characters copied into register %s",#an,m.register))else a.err(string.format("setreg(%s) failed: %s",m.register,ao))end end end;c.paste_register=function(i)local ap=i[1]:match("%[(.-)%]")local K,an=pcall(vim.fn.getreg,ap)if K and#an>0 then vim.api.nvim_paste(an,false,-1)end end;c.set_qflist=function(i,m)local aq=i[1]:match("[(%d+)]")vim.cmd(string.format("%d%s",tonumber(aq),m._is_loclist and"lhistory"or"chistory"))vim.cmd(m._is_loclist and"lopen"or"copen")end;c.apply_profile=function(i,m)local ar=i[1]:match("[^:]+")local as=i[1]:match(":([^%s]+)")local K=a.load_profile(ar,as,m.silent)if K then vim.cmd(string.format([[lua require("fzf-lua").setup({"%s"})]],as))end end;c.complete_insert=function(i,m)local N=vim.api.nvim_get_current_line()local at=m.cmp_string_col>1 and N:sub(1,m.cmp_string_col-1)or""local au=N:sub(m.cmp_string_col+(m.cmp_string and#m.cmp_string or 0))local u=i[1]if m.cmp_is_file then u=b.relative(b.entry_to_file(i[1],m).path,m.cwd)elseif m.cmp_is_line then u=i[1]:match("^.*:%d+:%s(.*)")end;local av=(m.cmp_prefix or"")..u;vim.api.nvim_set_current_line(at..av..au)vim.api.nvim_win_set_cursor(0,{m.cmp_string_row,m.cmp_string_col+#av-2})if m.cmp_mode=="i"then vim.cmd[[noautocmd lua vim.api.nvim_feedkeys('a', 'n', true)]]end end;return c
