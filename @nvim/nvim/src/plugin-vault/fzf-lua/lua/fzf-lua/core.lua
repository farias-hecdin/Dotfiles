local a=require"fzf-lua.fzf"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.config"local e=require"fzf-lua.actions"local f=require"fzf-lua.win"local g=require"fzf-lua.libuv"local h=require"fzf-lua.shell"local i=require"fzf-lua.make_entry"local j={}local k={[e.grep_lgrep]={"Regex Search",fn_reload="Fuzzy Search"},[e.sym_lsym]={"Live Query",fn_reload="Fuzzy Search"},[e.buf_del]={"close"},[e.arg_del]={"delete"},[e.git_reset]={"reset"},[e.git_stage]={"stage",pos=1},[e.git_unstage]={"unstage",pos=2},[e.git_stage_unstage]={"[un-]stage",pos=1},[e.git_stash_drop]={"drop a stash"},[e.git_yank_commit]={"copy commit hash"}}local l=function(m)assert(m[1].contents)local n=type(m[1].contents)local o;if n=="table"then o={}for _,p in ipairs(m)do assert(type(p.contents)==n,"Unable to combine contents of different types")o=c.tbl_extend(o,p.prefix and vim.tbl_map(function(q)return p.prefix..q end,p.contents)or p.contents)end elseif n=="function"then o=function(r)coroutine.wrap(function()local s=coroutine.running()for _,p in ipairs(m)do assert(type(p.contents)==n,"Unable to combine contents of different types")local t=true;p.contents(function(u,v)t=s~=coroutine.running()if u then r(p.prefix and p.prefix..u or u,v)elseif t then coroutine.resume(s)end end)if t then coroutine.yield()end end;r()end)()end elseif n=="string"then assert(false,"Not yet supported")end;return o end;j.fzf_exec=function(o,w)if type(o)=="table"and type(o[1])=="table"then o=l(o)end;if not w or not w._normalized then w=d.normalize_opts(w or{},{})if not w then return end end;_,w.__INFO=pcall(loadstring("return require'fzf-lua'.get_info()"))w.fn_selected=w.fn_selected or function(x)if not x then return end;e.act(w.actions,x,w)end;if type(o)=="string"and(w.fn_transform or w.fn_preprocess)then o=g.spawn_nvim_fzf_cmd({cmd=o,cwd=w.cwd,cb_pid=w._set_pid},w.fn_transform or function(q)return q end,w.fn_preprocess)end;if type(w.fn_reload)=="string"then if not w.fn_transform then w=j.setup_fzf_interactive_native(w.fn_reload,w)o=w.__fzf_init_cmd else local y=w.fn_reload;w.fn_reload=function(z)if y:match(j.fzf_query_placeholder)then return y:gsub(j.fzf_query_placeholder,z or"")else return string.format("%s %s",y,z or"")end end end end;if type(w.fn_reload)=="function"then w.__fn_transform=w.fn_transform;w.__fn_reload=function(A)if d.__resume_data then d.__resume_data.last_query=A end;return w.fn_reload(A)end;w=j.setup_fzf_interactive_wrap(w)o=w.__fzf_init_cmd end;return j.fzf_wrap(w,o)()end;j.fzf_live=function(o,w)assert(o)w=w or{}w.fn_reload=o;return j.fzf_exec(nil,w)end;j.fzf_resume=function(w)if not d.__resume_data or not d.__resume_data.opts then c.info("No resume data available, is 'global_resume' enabled?")return end;w=vim.tbl_deep_extend("force",d.__resume_data.opts,w or{})local B=d.__resume_data.last_query;if not B or#B==0 then B=false end;w.__resume=true;w.query=B;j.fzf_exec(d.__resume_data.contents,w)end;j.fzf_wrap=function(w,o,C)w=w or{}return coroutine.wrap(function()w.fn_selected=w.fn_selected or C;local x=j.fzf(o,w)if w.fn_selected then w.fn_selected(x,w)end end)end;j.fzf=function(o,w)if vim.fn.win_gettype()=="command"then c.info("Unable to open from the command-line window. See `:help E11`.")return end;if not w or not w._normalized then w=d.normalize_opts(w or{},{})if not w then return end end;if w.fn_pre_win then w.fn_pre_win(w)end;if w.global_resume then d.__resume_data=d.__resume_data or{}d.__resume_data.opts=c.deepcopy(w)d.__resume_data.contents=o and c.deepcopy(o)or nil;if not w.__resume then d.__resume_data.last_query=nil;h.clear_protected()end;w.__resume_data=d.__resume_data;w.fzf_opts["--print-query"]=""w.actions=w.actions or{}w.keymap=w.keymap or{}w.keymap.fzf=w.keymap.fzf or{}for _,D in ipairs({"ctrl-c","ctrl-q","esc"})do if w.actions[D]==nil and(w.keymap.fzf[D]==nil or w.keymap.fzf[D]=="abort")then w.actions[D]=e.dummy_abort end end end;local E=f(w)if not E then return end;local F,G=nil,nil;if w.previewer and type(w.previewer)=="string"then G=d.globals.previewers[w.previewer]if not G then c.warn(("invalid previewer '%s'"):format(w.previewer))end elseif w.previewer and type(w.previewer)=="table"then G=w.previewer end;if G and type(G.new)=="function"then F=G:new(G,w,E)elseif G and type(G._new)=="function"then F=G._new()(G,w,E)elseif G and type(G._ctor)=="function"then F=G._ctor()(G,w,E)end;if F then w.preview=F:cmdline()if w.__FZF_VERSION and w.__FZF_VERSION>=0.40 and F.zero then w.keymap=w.keymap or{}w.keymap.fzf=w.keymap.fzf or{}w.keymap.fzf["zero"]=F:zero()end;if type(F.preview_window)=="function"then w.fzf_opts["--preview-window"]=F:preview_window(w.preview_window)end;if type(F.fzf_delimiter)=="function"then w.fzf_opts["--delimiter"]=F:fzf_delimiter()end;if type(F.preview_offset)=="function"then w.preview_offset=F:preview_offset()end elseif not w.preview and not w.fzf_opts["--preview"]then w.fzf_opts["--preview-window"]="hidden:right:0"end;if w.__fn_pre_fzf then w.__fn_pre_fzf(w)end;if w._fn_pre_fzf then w._fn_pre_fzf(w)end;if w.fn_pre_fzf then w.fn_pre_fzf(w)end;E:attach_previewer(F)local H=E:create()w.winopts.preview=E.winopts.preview;w=j.convert_reload_actions(w.__reload_cmd or o,w)w=j.convert_exec_silent_actions(w)local x,I=a.raw_fzf(o,j.build_fzf_cli(w),{fzf_bin=w.fzf_bin,cwd=w.cwd,silent_fail=w.silent_fail,is_fzf_tmux=w._is_fzf_tmux,debug=w.debug_cmd or w.debug and not(w.debug_cmd==false)})if type(w._get_pid=="function")then g.process_kill(w._get_pid())end;if x and#x>0 and w.fzf_opts["--print-query"]~=nil then if not(w._is_skim and w.fn_reload)then local A=x[1]d.__resume_data=d.__resume_data or{}d.__resume_data.last_query=type(A)=="string"and A or nil end;table.remove(x,1)end;if w.__fn_post_fzf then w.__fn_post_fzf(w,x)end;if w._fn_post_fzf then w._fn_post_fzf(w,x)end;if w.fn_post_fzf then w.fn_post_fzf(w,x)end;E:check_exit_status(I,H)local J=e.normalize_selected(w.actions,x)local K=J and w.actions and w.actions[J]local L=type(K)=="table"and(K[1]~=nil or K.reload or K.noclose)if not E:autoclose()==false and not L then E:close(H)end;return x end;j.preview_window=function(M)local N=("%s:%s:%s:"):format(M.winopts.preview.hidden,M.winopts.preview.border,M.winopts.preview.wrap)if M.winopts.preview.layout=="horizontal"or M.winopts.preview.layout=="flex"and vim.o.columns>M.winopts.preview.flip_columns then N=N..M.winopts.preview.horizontal else N=N..M.winopts.preview.vertical end;return N end;j.create_fzf_colors=function(w)local O=w and w.fzf_colors;if type(O)=="function"then O=O(w)end;if not O then return end;local P={}for Q,R in pairs(O)do if type(R)=="table"then local S=c.hexcol_from_hl(R[2],R[1])if S and#S>0 then table.insert(P,("%s:%s"):format(Q,S))end;for T=3,#R do table.insert(P,("%s:%s"):format(Q,R[T]))end elseif type(R)=="string"then table.insert(P,("%s:%s"):format(Q,R))end end;return not vim.tbl_isempty(P)and table.concat(P,",")end;j.create_fzf_binds=function(U)if not U or vim.tbl_isempty(U)then return end;local P={}local V={}for D,W in pairs(U)do if type(W)=="table"then W=W[1]end;if W then local X,K=W:match("(.*):(.*)")if K then D,W=X,K end;V[D]=W end end;for X,K in pairs(V)do table.insert(P,string.format("%s:%s",X,K))end;return vim.fn.shellescape(table.concat(P,","))end;j.build_fzf_cli=function(w)w.fzf_opts=vim.tbl_extend("force",d.globals.fzf_opts,w.fzf_opts or{})for _,M in ipairs({"fzf_ansi","fzf_colors","fzf_layout","keymap"})do w[M]=w[M]or d.globals[M]end;for _,M in ipairs({"query","preview"})do local Y=string.format("--%s",M)if w[M]~=nil then w.fzf_opts[Y]=w[M]and g.shellescape(w[M])else w.fzf_opts[Y]=w.fzf_opts[Y]end end;w.fzf_opts["--bind"]=j.create_fzf_binds(w.keymap.fzf)if w.fzf_colors then w.fzf_opts["--color"]=j.create_fzf_colors(w)end;w.fzf_opts["--expect"]=e.expect(w.actions)if w.fzf_opts["--preview-window"]==nil then w.fzf_opts["--preview-window"]=j.preview_window(w)end;if w.preview_offset and#w.preview_offset>0 then w.fzf_opts["--preview-window"]=w.fzf_opts["--preview-window"]..":"..w.preview_offset end;w.fzf_opts["--prompt"]=(w.prompt or w.fzf_opts["--prompt"])and vim.fn.shellescape(w.prompt or w.fzf_opts["--prompt"])if w.nomulti or w.fzf_opts["--no-multi"]then w.fzf_opts["--multi"]=nil;w.fzf_opts["--no-multi"]=""else w.fzf_opts["--multi"]=""w.fzf_opts["--no-multi"]=nil end;for D,W in pairs({["--ansi"]="fzf_ansi",["--layout"]="fzf_layout"})do if w[W]and#w[W]==0 then w.fzf_opts[D]=nil elseif w[W]then w.fzf_opts[D]=w[W]end end;local Z=""for _,M in ipairs({"fzf_args","fzf_raw_args","fzf_cli_args","_fzf_cli_args"})do if w[M]then Z=Z.." "..w[M]end end;if w._is_skim then local a0=w.fzf_opts["--info"]w.fzf_opts["--info"]=nil;if a0=="inline"then w.fzf_opts["--inline-info"]=""end;local a1=w.fzf_opts["--border"]if a1=="none"then w.fzf_opts["--border"]=nil else w.fzf_opts["--border"]=""end end;local a2=""if w._is_fzf_tmux then for D,W in pairs(w.fzf_tmux_opts or{})do if W then a2=a2 ..string.format(" %s %s",D,W)end end end;for D,W in pairs(w.fzf_opts)do if type(W)=="table"then W=nil elseif type(W)=="number"then W=string.format("%d",W)end;if W then W=W:gsub(D.."=","")a2=a2 ..(" %s%s"):format(D,#W>0 and"="..W or"")end end;return a2 ..Z end;j.mt_cmd_wrapper=function(w)assert(w and w.cmd)local a3=function(a4)return"[["..a4:gsub("[%]]",function(q)return"\\"..q end).."]]"end;local a5=function(M)local a6={"debug","argv_expr","cmd","cwd","stdout","stderr","stderr_to_stdout","git_dir","git_worktree","git_icons","file_icons","color_icons","path_shorten","strip_cwd_prefix","file_ignore_patterns","rg_glob","__module__"}if M.rg_glob then table.insert(a6,"glob_flag")table.insert(a6,"glob_separator")end;local a7=""for _,a8 in ipairs(a6)do if M[a8]~=nil then if#a7>0 then a7=a7 ..","end;local a9=M[a8]if type(a9)=="string"then a9=a3(a9)end;if type(a9)=="table"then a9=vim.inspect(a9)end;a7=a7 ..("%s=%s"):format(a8,a9)end end;return"{"..a7 .."}"end;if not w.requires_processing and not w.git_icons and not w.file_icons and not w.path_shorten then return w.cmd elseif w.multiprocess then assert(not w.__mt_transform or type(w.__mt_transform)=="string")assert(not w.__mt_preprocess or type(w.__mt_preprocess)=="string")local aa=w.__mt_preprocess or[[return require("make_entry").preprocess]]local ab=w.__mt_transform or[[return require("make_entry").file]]if not w.no_remote_config then ab=([[_G._fzf_lua_server=%s; %s]]):format(g.shellescape(vim.g.fzf_lua_server),ab)end;if d._devicons_setup then ab=([[_G._devicons_setup=%s; %s]]):format(g.shellescape(d._devicons_setup),ab)end;if d._devicons_path then ab=([[_G._devicons_path=%s; %s]]):format(g.shellescape(d._devicons_path),ab)end;local y=g.wrap_spawn_stdio(a5(w),ab,aa)if w.debug_cmd or w.debug and not(w.debug_cmd==false)then c.info(string.format("multiprocess cmd: %s",y))end;return y else assert(not w.__mt_transform or type(w.__mt_transform)=="function")assert(not w.__mt_preprocess or type(w.__mt_preprocess)=="function")return g.spawn_nvim_fzf_cmd(w,function(q)return w.__mt_transform and w.__mt_transform(q,w)or i.file(q,w)end,function(M)return w.__mt_preprocess and w.__mt_preprocess(M)or i.preprocess(M)end)end end;j.set_fzf_field_index=function(w,ac,ad)w.line_field_index=w.line_field_index or ac or 2;w.field_index_expr=w.field_index_expr or ad or"{1}"return w end;j.set_header=function(w,ae)local function af(ag)if b.starts_with_separator(ag)and ag~=vim.loop.cwd()then ag=b.relative(ag,vim.loop.cwd())end;return b.HOME_to_tilde(ag)end;if not w then w={}end;if w.cwd_prompt then w.prompt=af(w.cwd or vim.loop.cwd())if tonumber(w.cwd_prompt_shorten_len)and#w.prompt>=tonumber(w.cwd_prompt_shorten_len)then w.prompt=b.shorten(w.prompt,tonumber(w.cwd_prompt_shorten_val)or 1)end;if not b.ends_with_separator(w.prompt)then w.prompt=w.prompt..b.separator()end end;if w.no_header or w.headers==false then return w end;local ah={cwd={hdr_txt_opt="cwd_header_txt",hdr_txt_str="cwd: ",hdr_txt_col=w.hls.header_text,val=function()if w.cwd_header==false or w.cwd_prompt and w.cwd_header==nil or w.cwd_header==nil and(not w.cwd or w.cwd==vim.loop.cwd())then return end;return af(w.cwd or vim.loop.cwd())end},search={hdr_txt_opt="grep_header_txt",hdr_txt_str="Grep string: ",hdr_txt_col=w.hls.header_text,val=function()return w.search and#w.search>0 and w.search end},lsp_query={hdr_txt_opt="lsp_query_header_txt",hdr_txt_str="Query: ",hdr_txt_col=w.hls.header_text,val=function()return w.lsp_query and#w.lsp_query>0 and w.lsp_query end},regex_filter={hdr_txt_opt="regex_header_txt",hdr_txt_str="Regex filter: ",hdr_txt_col=w.hls.header_text,val=function()return w.regex_filter and#w.regex_filter>0 and w.regex_filter end},actions={hdr_txt_opt="interactive_header_txt",hdr_txt_str="",val=function()if w.no_header_i then return end;local ai=k;local aj={}for D,W in pairs(w.actions)do local K=type(W)=="function"and W or type(W)=="table"and(W.fn or W[1])if type(K)=="function"and ai[K]then local ak=ai[K]local al=w.fn_reload and ak.fn_reload or ak[1]table.insert(aj,ak.pos or#aj+1,string.format("<%s> to %s",c.ansi_from_hl(w.hls.header_bind,D),c.ansi_from_hl(w.hls.header_text,al)))end end;return not vim.tbl_isempty(aj)and(function()local p={}for _,T in pairs(aj)do table.insert(p,T)end;p[1]=(w.header_prefix or":: ")..p[1]return table.concat(p,w.header_separator or"")end)()or nil end}}if not w.headers then w.headers=ae or{"cwd"}end;for _,am in ipairs(w.headers)do assert(ah[am])local an=w[ah[am].hdr_txt_opt]if an then ah[am].hdr_txt_str=an end end;local ao;for _,am in ipairs(w.headers)do assert(ah[am])local ak=ah[am]local ap=ak.val()if ak and ap then ao=not ao and""or ao..", "ao=("%s%s%s"):format(ao,ak.hdr_txt_str,not ak.hdr_txt_col and ap or c.ansi_from_hl(ak.hdr_txt_col,ap))end end;if ao and#ao>0 then w.fzf_opts["--header"]=g.shellescape(ao)end;return w end;j.convert_reload_actions=function(aq,w)local ar;local as;if w._is_skim or type(aq)~="string"then ar=true end;if not w.__FZF_VERSION or w.__FZF_VERSION<0.36 then ar=true end;for D,W in pairs(w.actions)do if type(W)~="function"and type(W)~="table"then goto at end;assert(type(W)=="function"or W.fn and W[1]==nil or W[1]and W.fn==nil)if type(W)=="table"and W.reload then as=true;assert(type(W.fn)=="function")if ar then w.actions[D]={W.fn,e.resume}end elseif not ar and type(W)=="table"and type(W[1])=="function"and W[2]==e.resume then w.actions[D]={fn=W[1],reload=true}end::at::end;if as and aq and type(aq)~="string"then c.warn("actions with `reload` are only supported with string commands, using resume fallback")end;if ar then return w end;local au={}for D,W in pairs(w.actions)do if type(W)=="table"and W.reload then assert(type(W.fn)=="function")table.insert(au,D)end end;local av=function(P,aw)if#P==0 then return nil end;return table.concat(vim.tbl_map(function(q)return string.format("%s(%s)",aw,q)end,P),"+")end;local ax=av(au,"unbind")local ay=av(au,"rebind")for D,W in pairs(w.actions)do if type(W)=="table"and W.reload then local az=h.raw_action(function(aA,_,_)W.fn(aA,w)end,W.field_index==false and""or W.field_index or"{+}",w.debug)w.keymap.fzf[D]={string.format("%s%sexecute-silent(%s)+reload(%s)",type(W.prefix)=="string"and W.prefix or"",ax and ax.."+"or"",az,aq),desc=d.get_action_helpstr(W.fn)}w.actions[D]=nil end end;w.keymap.fzf["load"]=ay;return w end;j.convert_exec_silent_actions=function(w)if w._is_skim then return w end;for D,W in pairs(w.actions)do if type(W)=="table"and W.exec_silent then assert(type(W.fn)=="function")local az=h.raw_action(function(aA,_,_)W.fn(aA,w)end,W.field_index==false and""or W.field_index or"{+}",w.debug)w.keymap.fzf[D]={string.format("%sexecute-silent(%s)",type(W.prefix)=="string"and W.prefix or"",az),desc=d.get_action_helpstr(W.fn)}w.actions[D]=nil end end;return w end;j.setup_fzf_interactive_flags=function(aB,aC,w)w.query=w.query or""local aD=aB;if w.stderr_to_stdout~=false and not aD:match("2>")then aD=aB.." 2>&1"end;local aE=aD;if type(w.query_delay)=="number"then aE=string.format("sleep %.2f; %s",w.query_delay/1000,aE)end;if not w.exec_empty_query then aE=("[ -z %s ] || %s"):format(aC,aE)end;if w._is_skim then w.__fzf_init_cmd=nil;w.prompt=w.__prompt or w.prompt or w.fzf_opts["--prompt"]if w.prompt then w.fzf_opts["--prompt"]=w.prompt:match("[^%*]+")w.fzf_opts["--cmd-prompt"]=g.shellescape(w.prompt)w.__prompt=w.prompt;w.prompt=nil end;w.fzf_opts["--cmd-query"]=g.shellescape(c.sk_escape(w.query))w.fzf_opts["--query"]=nil;w.query=nil;w._fzf_cli_args=string.format("--interactive --cmd %s",g.shellescape(aE))else w.__fzf_init_cmd="true"if w.exec_empty_query or w.query and#w.query>0 then w.__fzf_init_cmd=aD:gsub(aC,g.shellescape(w.query:gsub("%%","%%%%")))end;w.fzf_opts["--disabled"]=""w.fzf_opts["--query"]=g.shellescape(w.query)if w.silent_fail~=false then aE=("%s || true"):format(aE)end;w._fzf_cli_args=string.format("--bind=%s",g.shellescape(("change:reload:%s"):format(("%s"):format(aE))))end;return w end;j.fzf_query_placeholder="<query>"j.fzf_field_expression=function(w)return w and w._is_skim and[["{}"]]or"{q}"end;j.setup_fzf_interactive_wrap=function(w)assert(w and w.__fn_reload)local aC=j.fzf_field_expression(w)local aB=h.reload_action_cmd(w,aC)return j.setup_fzf_interactive_flags(aB,aC,w)end;j.setup_fzf_interactive_native=function(aB,w)local aC=j.fzf_field_expression(w)if aB:match(j.fzf_query_placeholder)then aB=w.fn_reload:gsub(j.fzf_query_placeholder,aC)else aB=("%s %s"):format(aB,aC)end;return j.setup_fzf_interactive_flags(aB,aC,w)end;return j
