local a={}local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=nil;do local e,f=pcall(require,"fzf-lua.config")if e then d=f end end;a._fzf_lua_server=_G._fzf_lua_server;a._devicons_path=_G._devicons_path;a._devicons_setup=_G._devicons_setup;local function g(h,i,j)if d then local k=c.strsplit(h,".")local l,m=d,nil;for n=1,#k do l=l[k[n]]if not l then break end;if n==#k and type(l)==i then m=l end end;return m elseif a._fzf_lua_server then local o=nil;local p=false;local q,r=nil,nil;if i=="function"then p=true;r={h,i}q=("return require'fzf-lua'.config.bytecode(...)"):format(h)else r={}q=("return require'fzf-lua'.config.%s"):format(h)end;local e,s=pcall(function()local t=vim.fn.sockconnect("pipe",a._fzf_lua_server,{rpc=true})o=vim.rpcrequest(t,"nvim_exec_lua",q,r)vim.fn.chanclose(t)end)if e and p then e,o=pcall(loadstring,o)end;if not e and not j then io.stderr:write(("Error loading remote config section '%s': %s\n"):format(h,s))elseif e and type(o)==i then return o end end end;local function u(h,v)if a._fzf_lua_server then local e,s=pcall(function()local t=vim.fn.sockconnect("pipe",a._fzf_lua_server,{rpc=true})vim.rpcrequest(t,"nvim_exec_lua",([[
        local data = select(1, ...)
        require'fzf-lua'.config.%s = data
      ]]):format(h),{v})vim.fn.chanclose(t)end)if not e then io.stderr:write(("Error setting remote config section '%s': %s\n"):format(h,s))end;return e elseif d then local k=c.strsplit(h,".")local l=d;for n=1,#k do l=l[k[n]]if not l then break end;if n==#k-1 then l[k[n+1]]=v;return l end end end end;local w=function()local function x(y)local z,A,B=y:match(".(..)(..)(..)")z,A,B=tonumber(z,16),tonumber(A,16),tonumber(B,16)return z,A,B end;for C,D in pairs(a._devicons and a._devicons.get_icons()or a._devicons_map)do local E=D.name or type(C)=="string"and C;if E then local F="DevIcon"..E;local G=D.color or c.hexcol_from_hl(F,"fg")if G and#G>0 then local z,A,B=x(G)c.cache_ansi_escseq(F,string.format("[38;2;%s;%s;%sm",z,A,B))end end end end;local function H()if d and d._has_devicons then a._devicons=d._devicons elseif a._fzf_lua_server and g("_has_devicons","boolean")then a._devicons_map=g("_devicons_geticons()","table")end;if not a._devicons and not a._devicons_map and a._devicons_path and vim.loop.fs_stat(a._devicons_path)then package.path=(";%s/?.lua;"):format(vim.fn.fnamemodify(a._devicons_path,":h"))..package.path;a._devicons=require("nvim-web-devicons")a._devicons_setup=a._devicons_setup and vim.fn.expand(a._devicons_setup)if a._devicons and a._devicons_setup and vim.loop.fs_stat(a._devicons_setup)then local I=loadfile(a._devicons_setup)if I then I()end end end;if a._devicons and a._devicons.setup and not a._devicons.has_loaded()then pcall(a._devicons.setup)end;if a._devicons and a._devicons.has_loaded()or a._devicons_map then w()end end;pcall(H)if not d then local J={globals={git={},files={},grep={}}}J.globals.git.icons=g("globals.git.icons","table")or{}J.globals.file_icon_colors=g("globals.file_icon_colors","table")or{}J.globals.file_icon_padding=g("globals.file_icon_padding","string")J.globals.files.git_status_cmd=g("globals.files.git_status_cmd","table")J.globals.grep.rg_glob_fn=g("__resume_data.opts.rg_glob_fn","function",true)or g("globals.grep.rg_glob_fn","function",true)J.globals.nbsp=g("globals.nbsp","string")if J.globals.nbsp then c.nbsp=J.globals.nbsp end;d=J end;a.get_devicon=function(I,K)local L,M;if a._devicons then L,M=a._devicons.get_icon(I,K:lower(),{default=true})elseif a._devicons_map then local D=a._devicons_map[K:lower()]or a._devicons_map["<default>"]if D then L=D.icon;M="DevIcon"..D.name end else L,M="ïƒ¶","dark_grey"end;local N=d.globals.file_icon_colors and d.globals.file_icon_colors[K]if N then M=N end;if d.globals.file_icon_padding and#d.globals.file_icon_padding>0 then L=L..d.globals.file_icon_padding end;return L,M end;a.get_diff_files=function(O)local P={}local Q=O.git_status_cmd or d.globals.files.git_status_cmd;if not Q then return{}end;local e,R,S=pcall(c.io_systemlist,b.git_cwd(Q,O))if e and S==0 then for n=1,#R do local T=R[n]local L=T:match("[MUDARCT?]+")local I=T:match("[^ ]*$")if L and I then local U=#T>0 and string.byte(T,1)local V=U~=32 and U~=63 or nil;P[I]={L:gsub("%?%?","?"),V}end end end;return P end;a.glob_parse=function(W,O)if not W or not W:find(O.glob_separator)then return W,nil end;local X=O.rg_glob_fn or d.globals.grep.rg_glob_fn;if X then return X(W,O)end;local Y=""local Z,_=W:match("(.*)"..O.glob_separator.."(.*)")for a0,h in ipairs(c.strsplit(_,"%s"))do Y=Y..("%s %s "):format(O.glob_flag,vim.fn.shellescape(h))end;return Z,Y end;a.rg_insert_args=function(Q,a1,a2)local a3={}for a0,a4 in ipairs({{"%s+%-e","-e"},{"%s+%-%-","--"}})do if a2 and#a2>0 then table.insert(a3,{a4[1].."%s-"..a2,a4[2].." "..a2})else table.insert(a3,{a4[1].."$",a4[2]})table.insert(a3,{a4[1].."%s",a4[2]})end end;if a2 and#a2>0 then table.insert(a3,{a2,a2})end;for a0,a4 in ipairs(a3)do if Q:match(a4[1])then return string.format("%s %s %s",Q:gsub(a4[1]," "),a1,a4[2])end end;return string.format("%s %s",Q,a1)end;a.preprocess=function(O)if O.cwd_only and not O.cwd then O.cwd=vim.loop.cwd()end;if O.git_icons then O.diff_files=a.get_diff_files(O)end;local a5=function(n,a6)local a7=tonumber(n)and tonumber(n)+6 or#vim.v.argv;if a6 then io.stdout:write(("[DEBUG]: argv(%d) = %s\n"):format(a7,vim.fn.shellescape(vim.v.argv[a7])))end;return vim.v.argv[a7]end;local a8="{argvz}"local a9=O.cmd and O.cmd:match(a8)if O.argv_expr and a9 then local W=a5(nil,O.debug)u("__resume_data.last_query",W)if O.__module__ then u(("globals.%s._last_search"):format(O.__module__),{query=W,no_esc=true})end end;if O.rg_glob and a9 then local W=a5()local Z,Y=a.glob_parse(W,O)if Y then Z=Z:gsub("%%","%%%%")O.cmd=a.rg_insert_args(O.cmd,Y,a8)O.cmd=O.cmd:gsub(a8,vim.fn.shellescape(Z))end end;if O.argv_expr then O.cmd=O.cmd:gsub("{argv.*}",function(aa)local a7=aa:match("{argv(.*)}")return vim.fn.shellescape(a5(a7))end)end;return O end;a.lcol=function(ab,O)if not ab then return nil end;local ac=ab.filename or vim.api.nvim_buf_get_name(ab.bufnr)return string.format("%s:%s:%s:%s%s",ac,c.ansi_codes.green(tostring(ab.lnum)),c.ansi_codes.blue(tostring(ab.col)),ab.text and#ab.text>0 and" "or"",not ab.text and""or O and O.trim_entry and vim.trim(ab.text)or ab.text)end;local ad=string.byte(":")a.file=function(aa,O)O=O or{}local ae={}local L,M;local af=c.find_next_char(aa,ad)or 0;local ag=af>1 and aa:sub(1,af-1)or aa;local ah=af>1 and aa:sub(af)or nil;local ai,aj=c.strip_ansi_coloring(ag)local ak=ai;if not(O.strip_cwd_prefix==false)and b.starts_with_cwd(ak)then ak=b.strip_cwd_prefix(ak)end;if O.cwd and#O.cwd>0 then ak=b.relative(ak,O.cwd)end;if b.starts_with_separator(ak)then if O.cwd_only then local al=O.cwd or vim.loop.cwd()if not b.is_relative(ak,al)then return nil end end;ak=b.HOME_to_tilde(ak)end;if O.file_ignore_patterns then for a0,am in ipairs(O.file_ignore_patterns)do if#am>0 and ak:match(am)then return nil end end end;local an=ak;if O.path_shorten then ak=b.shorten(ak,tonumber(O.path_shorten))end;if O.git_icons then local ao=O.diff_files and O.diff_files[an]local ap=ao and ao[1]or c.nbsp;for n=1,#ap do L=ap:sub(n,n)local aq=d.globals.git.icons[L]if aq then L=aq.icon;if O.color_icons then local ar=ao[2]and n==1 and"green"or aq.color or"dark_grey"L=c.ansi_codes[ar](L)end end;ae[#ae+1]=L end;ae[#ae+1]=c.nbsp end;if O.file_icons then local ac=b.tail(an)local K=b.extension(ac)L,M=a.get_devicon(ac,K)if O.color_icons then local as=c.ansi_codes[M]or c.ansi_codes["dark_grey"]L=as(L)end;ae[#ae+1]=L;ae[#ae+1]=c.nbsp end;ae[#ae+1]=aj>0 and ag:gsub(c.lua_regex_escape(ai),ak)or ak;ae[#ae+1]=ah;return table.concat(ae)end;a.tag=function(aa,O)local E,I,at=aa:match("([^\t]+)\t([^\t]+)\t(.*)")if not I or not E or not at then return aa end;at=at:match([[(.*);"]])or at;for a0,h in ipairs({"/","\\"})do at=at:gsub([[\]]..h,h)end;local T,au=at:match("(%d-);?(/.*/)")T=T and#T>0 and tonumber(T)return("%s%s: %s %s"):format(a.file(I,O),not T and""or":"..c.ansi_codes.green(tostring(T)),c.ansi_codes.magenta(E),c.ansi_codes.green(au)),T end;return a
