local a=require"fzf-lua.path"local b=require"fzf-lua.shell"local c=require"fzf-lua.utils"local d=require"fzf-lua.class"local e=vim.api;local f=vim.loop;local g=vim.fn;local h={}h.base=d:extend()function h.base:new(i,j,k)local function l(m,n)if m~=nil then return m else return n end end;i=i or{}self.type="builtin"self.opts=j;self.win=k;self.delay=self.win.winopts.preview.delay or 100;self.title=self.win.winopts.preview.title;self.title_fnamemodify=i.title_fnamemodify;self.title_pos=self.win.winopts.preview.title_pos;self.winopts=self.win.winopts.preview.winopts;self.syntax=l(i.syntax,true)self.syntax_delay=l(i.syntax_delay,0)self.syntax_limit_b=l(i.syntax_limit_b,1024*1024)self.syntax_limit_l=l(i.syntax_limit_l,0)self.limit_b=l(i.limit_b,1024*1024*10)self.treesitter=i.treesitter or{}self.toggle_behavior=i.toggle_behavior;self.ext_ft_override=i.ext_ft_override;self.winopts_orig={}if i.extensions then self.extensions={}for o,p in pairs(i.extensions)do self.extensions[o:lower()]=p end end;local q={["crop"]="crop",["distort"]="distort",["contain"]="contain",["fit_contain"]="fit_contain",["cover"]="cover",["forced_cover"]="forced_cover"}self.ueberzug_scaler=i.ueberzug_scaler and q[i.ueberzug_scaler]if i.ueberzug_scaler and not self.ueberzug_scaler then c.warn(("Invalid ueberzug image scaler '%s', option will be omitted."):format(i.ueberzug_scaler))end;self.cached_bufnrs={}self.cached_buffers={}self.listed_buffers=(function()local r={}vim.tbl_map(function(s)if vim.fn.buflisted(s)==1 then r[tostring(s)]=true end end,vim.api.nvim_list_bufs())return r end)()return self end;function h.base:close()self:restore_winopts()self:clear_preview_buf()self:clear_cached_buffers()self.winopts_orig={}end;function h.base:gen_winopts()local t={wrap=self.win.preview_wrap}return vim.tbl_extend("keep",t,self.winopts)end;function h.base:backup_winopts()if rawequal(next(self.winopts_orig),nil)then self.winopts_orig=self.win:get_winopts(self.win.src_winid,self:gen_winopts())end end;function h.base:restore_winopts()self.win:set_winopts(self.win.preview_winid,self.winopts_orig)end;function h.base:set_style_winopts()self.win:set_winopts(self.win.preview_winid,self:gen_winopts())end;function h.base:preview_is_terminal()if not self.win or not self.win:validate_preview()then return end;return vim.fn.getwininfo(self.win.preview_winid)[1].terminal==1 end;function h.base:get_tmp_buffer()local u=e.nvim_create_buf(false,true)e.nvim_buf_set_option(u,"bufhidden","wipe")return u end;function h.base:safe_buf_delete(v,w)if not v then return end;assert(type(v)=="number"and v>0)if self.listed_buffers[tostring(v)]then return elseif not vim.api.nvim_buf_is_valid(v)then return elseif not w and self.cached_bufnrs[tostring(v)]then return end;vim.api.nvim_buf_call(v,function()vim.cmd([[delm \"]])end)vim.api.nvim_buf_delete(v,{force=true})end;function h.base:set_preview_buf(x,y)if not self.win or not self.win:validate_preview()then return end;local z=vim.api.nvim_win_get_buf(self.win.preview_winid)if z==x then return end;assert(z~=x)c.win_set_buf_noautocmd(self.win.preview_winid,x)self.preview_bufnr=x;if y then self.win:set_style_minimal(self.win.preview_winid)else self:set_style_winopts()end;self:safe_buf_delete(z)end;function h.base:cache_buffer(v,A,y)if not A then return end;if not v then return end;local B=self.cached_buffers[A]if B then if B.bufnr==v then return else self.cached_bufnrs[tostring(B.bufnr)]=nil;self:safe_buf_delete(B.bufnr)end end;self.cached_bufnrs[tostring(v)]=true;self.cached_buffers[A]={bufnr=v,min_winopts=y}e.nvim_buf_set_option(v,"bufhidden","hide")end;function h.base:clear_cached_buffers()for _,C in pairs(self.cached_buffers)do self:safe_buf_delete(C.bufnr,true)end;self.cached_bufnrs={}self.cached_buffers={}end;function h.base:clear_preview_buf(x)local D=nil;if(self.win and self.win._reuse or x)and self.win and self.win.preview_winid and tonumber(self.win.preview_winid)>0 and e.nvim_win_is_valid(self.win.preview_winid)then D=self:get_tmp_buffer()c.win_set_buf_noautocmd(self.win.preview_winid,D)self.win:redraw_preview_border()self.win:update_scrollbar(true)end;self:safe_buf_delete(self.preview_bufnr)self.preview_bufnr=nil;self.loaded_entry=nil;return D end;function h.base:display_last_entry()self:display_entry(self.last_entry)end;function h.base:display_entry(E)if not E then return end;self.last_entry=E;if not self.win or not self.win:validate_preview()then return end;self:backup_winopts()if self.should_clear_preview and self:should_clear_preview(E)then self.preview_bufnr=self:clear_preview_buf(true)end;local F=function(G)if not self.win or not self.win:validate_preview()then return end;self.win:redraw_preview_border()self:populate_preview_buf(G)self.win:reset_win_highlights(self.win.preview_winid)end;if tonumber(self.delay)>0 then if not self._entry_count then self._entry_count=1 else self._entry_count=self._entry_count+1 end;local H=self._entry_count;vim.defer_fn(function()if self._entry_count==H then F(E)end end,self.delay)else F(E)end end;function h.base:cmdline(_)local I=b.raw_action(function(J,_,_)self:display_entry(J[1])return""end,"{}",self.opts.debug)return I end;function h.base:zero(_)local I=string.format("execute-silent(%s)",b.raw_action(function(_,_,_)self:clear_preview_buf(true)self.last_entry=nil end,"",self.opts.debug))return I end;function h.base:preview_window(_)if self.win and not self.win.winopts.split then return"nohidden:right:0"else return nil end end;function h.base:scroll(K)local L=self.win.preview_winid;if L<0 or not K then return end;if not e.nvim_win_is_valid(L)then return end;if K==0 then pcall(vim.api.nvim_win_call,L,function()e.nvim_win_set_cursor(0,{1,0})if self.orig_pos then e.nvim_win_set_cursor(0,self.orig_pos)end;c.zz()end)elseif not self:preview_is_terminal()then local M=("%c"):format(c._if(K>0,0x04,0x15))pcall(vim.api.nvim_win_call,L,function()vim.cmd([[norm! ]]..M)c.zz()end)else local M=K>0 and"<C-d>"or"<C-u>"vim.cmd("stopinsert")c.feed_keys_termcodes((":noa lua vim.api.nvim_win_call("..[[%d, function() vim.cmd("norm! <C-v>%s") vim.cmd("startinsert") end)<CR>]]):format(tonumber(L),M))end;if self.orig_pos and self.winopts.cursorline then local N=vim.fn.getwininfo(L)if N and N[1]and self.orig_pos[1]>=N[1].topline and self.orig_pos[1]<=N[1].botline then vim.api.nvim_win_set_cursor(L,self.orig_pos)vim.api.nvim_win_set_option(L,"cursorline",true)else vim.api.nvim_win_set_option(L,"cursorline",false)end end;self.win:update_scrollbar()end;h.buffer_or_file=h.base:extend()function h.buffer_or_file:new(i,j,k)h.buffer_or_file.super.new(self,i,j,k)return self end;function h.buffer_or_file:close()self:restore_winopts()self:clear_preview_buf()self:clear_cached_buffers()self:stop_ueberzug()self.winopts_orig={}end;function h.buffer_or_file:parse_entry(E)local O=a.entry_to_file(E,self.opts)return O end;function h.buffer_or_file:should_clear_preview(_)return false end;function h.buffer_or_file:should_load_buffer(O)if not self.loaded_entry then return true end;if type(O)=="string"then O=self:parse_entry(O)end;if O.bufnr and O.bufnr==self.loaded_entry.bufnr or not O.bufnr and O.path and O.path==self.loaded_entry.path then return false end;return true end;function h.buffer_or_file:start_ueberzug()if self._ueberzug_fifo then return self._ueberzug_fifo end;local P=("fzf-lua-%d-ueberzug"):format(vim.fn.getpid())self._ueberzug_fifo=vim.fn.systemlist({"mktemp","--dry-run","--suffix",P})[1]vim.fn.system({"mkfifo",self._ueberzug_fifo})self._ueberzug_job=vim.fn.jobstart({"sh","-c",("tail --follow %s | ueberzug layer --parser json"):format(vim.fn.shellescape(self._ueberzug_fifo))},{on_exit=function(_,Q,_)if Q~=0 and Q~=143 then c.warn(("ueberzug exited with error %d"):format(Q)..", run ':messages' to see the detailed error.")end end,on_stderr=function(_,R,_)for _,S in ipairs(R or{})do if#S>0 then c.info(S)end end;if self.preview_bufnr and self.preview_bufnr>0 and vim.api.nvim_buf_is_valid(self.preview_bufnr)then local T=vim.api.nvim_buf_get_lines(self.preview_bufnr,0,-1,false)for _,S in ipairs(R or{})do table.insert(T,S)end;vim.api.nvim_buf_set_lines(self.preview_bufnr,0,-1,false,T)end end})self._ueberzug_pid=vim.fn.jobpid(self._ueberzug_job)return self._ueberzug_fifo end;function h.buffer_or_file:stop_ueberzug()if self._ueberzug_job then vim.fn.jobstop(self._ueberzug_job)if type(f.os_getpriority(self._ueberzug_pid))=="number"then f.kill(self._ueberzug_pid,9)end;self._ueberzug_job=nil;self._ueberzug_pid=nil end;if self._ueberzug_fifo and f.fs_stat(self._ueberzug_fifo)then vim.fn.delete(self._ueberzug_fifo)self._ueberzug_fifo=nil end end;function h.buffer_or_file:populate_terminal_cmd(U,V,O)if not V then return end;V=type(V)=="table"and c.deepcopy(V)or{V}if not V[1]or vim.fn.executable(V[1])~=1 then return false end;O.do_not_cache=true;O.no_scrollbar=true;self.clear_on_redraw=true;self:set_preview_buf(U,true)if V[1]:match("ueberzug")then local P=self:start_ueberzug()if not P then return end;local W=vim.api.nvim_win_get_config(self.win.preview_winid)local X=vim.api.nvim_win_get_position(self.win.preview_winid)local Y={action="add",identifier="preview",x=X[2],y=X[1],width=W.width,height=W.height,scaler=self.ueberzug_scaler,path=a.starts_with_separator(O.path)and O.path or a.join({self.opts.cwd or f.cwd(),O.path})}local Z=vim.json.encode(Y)local a0=f.fs_open(self._ueberzug_fifo,"a",-1)if a0 then f.fs_write(a0,Z.."\n",nil,function(_)f.fs_close(a0)end)end else table.insert(V,O.path)vim.bo[U].modifiable=true;vim.api.nvim_buf_call(U,function()self._job_id=vim.fn.termopen(V,{cwd=self.opts.cwd,on_exit=function()if self._job_id then self:preview_buf_post(O,true)self._job_id=nil end end})end)end;self:preview_buf_post(O,true)return true end;function h.buffer_or_file:key_from_entry(O)assert(O)return O.bufname or O.bufnr and string.format("bufnr:%d",O.bufnr)or O.uri or O.path end;function h.buffer_or_file:populate_from_cache(O)local A=self:key_from_entry(O)local B=self.cached_buffers[A]assert(not B or self.cached_bufnrs[tostring(B.bufnr)])assert(not B or vim.api.nvim_buf_is_valid(B.bufnr))if B and vim.api.nvim_buf_is_valid(B.bufnr)then self:set_preview_buf(B.bufnr,B.min_winopts)self:preview_buf_post(O,B.min_winopts)return true end;return false end;function h.buffer_or_file:populate_preview_buf(E)if not self.win or not self.win:validate_preview()then return end;local O=self:parse_entry(E)if vim.tbl_isempty(O)then return end;if O.bufnr and not e.nvim_buf_is_loaded(O.bufnr)and vim.api.nvim_buf_is_valid(O.bufnr)then O.path=a.relative(vim.api.nvim_buf_get_name(O.bufnr),vim.loop.cwd())end;if not self:should_load_buffer(O)then self:preview_buf_post(O)return elseif self:populate_from_cache(O)then return end;self.clear_on_redraw=false;self:stop_ueberzug()if self._job_id and self._job_id>0 then vim.fn.jobstop(self._job_id)self._job_id=nil end;if O.bufnr and e.nvim_buf_is_loaded(O.bufnr)then O.filetype=vim.api.nvim_buf_get_option(O.bufnr,"filetype")local T=vim.api.nvim_buf_get_lines(O.bufnr,0,-1,false)local U=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(U,0,-1,false,T)self:set_preview_buf(U,O.terminal)self:preview_buf_post(O,O.terminal)elseif O.uri then vim.api.nvim_win_call(self.win.preview_winid,function()local a1,a2=pcall(vim.lsp.util.jump_to_location,O,"utf-16",false)if a1 then self.preview_bufnr=vim.api.nvim_get_current_buf()else local T=vim.split(a2,"\n")or{"null"}table.insert(T,1,string.format("lsp.util.jump_to_location failed for '%s':",O.uri))table.insert(T,2,"")local U=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(U,0,-1,false,T)self:set_preview_buf(U)end end)self:preview_buf_post(O)else assert(O.path)local U=self:get_tmp_buffer()if self.extensions and not vim.tbl_isempty(self.extensions)then local a3=a.extension(O.path)local V=a3 and self.extensions[a3:lower()]if V and self:populate_terminal_cmd(U,V,O)then return end end;do local T=nil;local a4=vim.loop.fs_stat(O.path)if not O.path or not a4 then T={string.format("Unable to stat file %s",O.path)}elseif a4.size>0 and c.perl_file_is_binary(O.path)then T={"Preview is not supported for binary files."}elseif tonumber(self.limit_b)>0 and a4.size>self.limit_b then T={("Preview file size limit (>%dMB) reached, file size %dMB."):format(self.limit_b/(1024*1024),a4.size/(1024*1024))}end;if T then vim.api.nvim_buf_set_lines(U,0,-1,false,T)self:set_preview_buf(U)self:preview_buf_post(O)return end end;c.read_file_async(O.path,vim.schedule_wrap(function(R)local T=vim.split(R,"[\r]?\n")if R:sub(#R,#R)=="\n"or R:sub(#R-1,#R)=="\r\n"then table.remove(T)end;vim.api.nvim_buf_set_lines(U,0,-1,false,T)self:set_preview_buf(U)self:preview_buf_post(O)end))end end;local a5,a6,a7;local a8=function(v,a9)if not a5 then a5,_=pcall(require,"nvim-treesitter")if a5 then _,a6=pcall(require,"nvim-treesitter.configs")_,a7=pcall(require,"nvim-treesitter.parsers")end end;if not a5 or not a9 or a9==""then return false end;local aa=a7.ft_to_lang(a9)if not a6.is_enabled("highlight",aa,v)then return false end;local ab=a6.get_module"highlight"vim.treesitter.highlighter.new(a7.get_parser(v,aa))local ac=type(ab.additional_vim_regex_highlighting)=="table"if ab.additional_vim_regex_highlighting and(not ac or vim.tbl_contains(ab.additional_vim_regex_highlighting,aa))then vim.api.nvim_buf_set_option(v,"syntax",a9)end;return true end;local ad=function(v,a9)local aa=vim.treesitter.language.get_lang(a9)local ae=pcall(vim.treesitter.language.add,aa)if aa and ae then local a1,af=pcall(vim.treesitter.start,v,aa)if not a1 then c.warn(string.format("unable to attach treesitter highlighter for filetype '%s': %s",a9,af))end;return a1 end end;function h.buffer_or_file:do_syntax(O)if not self.preview_bufnr then return end;if not O or not O.path then return end;local v=self.preview_bufnr;local L=self.win.preview_winid;if e.nvim_buf_is_valid(v)and vim.bo[v].filetype==""then if g.bufwinid(v)==L then local ag=e.nvim_buf_line_count(v)local ah=e.nvim_buf_get_offset(v,ag)local ai=0;if self.syntax_limit_l>0 and ag>self.syntax_limit_l then ai=1 end;if self.syntax_limit_b>0 and ah>self.syntax_limit_b then ai=2 end;if ai>0 then c.info(string.format("syntax disabled for '%s' (%s), consider increasing '%s(%d)'",O.path,c._if(ai==1,("%d lines"):format(ag),("%db"):format(ah)),c._if(ai==1,"syntax_limit_l","syntax_limit_b"),c._if(ai==1,self.syntax_limit_l,self.syntax_limit_b)))end;if ai==0 then local aj=not c.__HAS_NVIM_08;if c.__HAS_NVIM_08 then aj=(function()local a9=O.filetype or self.ext_ft_override and self.ext_ft_override[a.extension(O.path)]or vim.filetype.match({buf=v,filename=O.path})if type(a9)~="string"then return true end;local ak=(function()if not self.treesitter or self.treesitter.enable==false or self.treesitter.disable==true or type(self.treesitter.enable)=="table"and not vim.tbl_contains(self.treesitter.enable,a9)or type(self.treesitter.disable)=="table"and vim.tbl_contains(self.treesitter.disable,a9)then return false end;return true end)()local al;if ak then if c.__HAS_NVIM_09 then al=ad(v,a9)else al=a8(v,a9)end end;if not ak or not al then pcall(vim.api.nvim_buf_set_option,v,"syntax",a9)end end)()end;if aj then if O.filetype=="help"then pcall(e.nvim_buf_set_option,v,"filetype",O.filetype)else local am=a.join({tostring(v),O.path})pcall(e.nvim_buf_set_name,v,am)end;local a1,_=pcall(e.nvim_buf_call,v,function()vim.cmd("filetype detect")end)if not a1 then c.warn(("syntax highlighting failed for filetype '%s', "):format(O.path and a.extension(O.path)or"<null>").."open the file and run ':filetype detect' for more info.")end end end end end end;function h.buffer_or_file:set_cursor_hl(O)pcall(vim.api.nvim_win_call,self.win.preview_winid,function()local an,ao=tonumber(O.line),tonumber(O.col)local ap=O.pattern or O.text;if not an or an<1 then e.nvim_win_set_cursor(0,{1,0})if ap~=""then g.search(ap,"c")end else if not pcall(e.nvim_win_set_cursor,0,{an,math.max(0,ao-1)})then return end end;c.zz()self.orig_pos=e.nvim_win_get_cursor(0)g.clearmatches()if self.win.hls.cursor and not(an<=1 and ao<=1)then g.matchaddpos(self.win.hls.cursor,{{an,math.max(1,ao)}},11)end end)end;function h.buffer_or_file:update_border(O)if self.title then local aq=O.path;if aq then if self.opts.cwd then aq=a.relative(O.path,self.opts.cwd)end;aq=a.HOME_to_tilde(aq)end;local ar=aq or O.uri;if self.title_fnamemodify then ar=self.title_fnamemodify(ar)end;if O.bufnr then ar=string.format("buf %d: %s",O.bufnr,ar)end;self.win:update_title(" "..ar.." ")end;self.win:update_scrollbar(O.no_scrollbar)end;function h.buffer_or_file:preview_buf_post(O,y)if not self.win or not self.win:validate_preview()then return end;if not self:preview_is_terminal()then self:set_cursor_hl(O)if self.syntax then if self.syntax_delay>0 then vim.defer_fn(function()self:do_syntax(O)end,self.syntax_delay)else self:do_syntax(O)end end end;self:update_border(O)self.loaded_entry=O;if not O.do_not_cache then self:cache_buffer(self.preview_bufnr,self:key_from_entry(O),y)end end;h.help_tags=h.buffer_or_file:extend()function h.help_tags:new(i,j,k)h.help_tags.super.new(self,i,j,k)return self end;function h.help_tags:parse_entry(E)local as,at=E:match("(.*)%s+(.*)$")return{htag=as,hregex=([[\V*%s*]]):format(as:gsub([[\]],[[\\]])),path=at,filetype="help"}end;function h.help_tags:gen_winopts()local t={wrap=self.win.preview_wrap,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.help_tags:set_cursor_hl(O)pcall(e.nvim_win_call,self.win.preview_winid,function()e.nvim_win_set_cursor(0,{1,0})g.clearmatches()g.search(O.hregex,"W")if self.win.hls.search then g.matchadd(self.win.hls.search,O.hregex)end;self.orig_pos=e.nvim_win_get_cursor(0)c.zz()end)end;h.man_pages=h.base:extend()function h.man_pages:should_clear_preview(_)return false end;function h.man_pages:gen_winopts()local t={wrap=self.win.preview_wrap,cursorline=false,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.man_pages:new(i,j,k)h.man_pages.super.new(self,i,j,k)self.filetype="man"self.cmd=i.cmd or"man -c %s | col -bx"return self end;function h.man_pages:parse_entry(E)return E:match("[^[,( ]+")end;function h.man_pages:populate_preview_buf(E)local O=self:parse_entry(E)local V=self.cmd:format(O)if type(V)=="string"then V={"sh","-c",V}end;local au,_=c.io_systemlist(V)local U=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(U,0,-1,false,au)vim.api.nvim_buf_set_option(U,"filetype",self.filetype)self:set_preview_buf(U)self.win:update_scrollbar()end;h.marks=h.buffer_or_file:extend()function h.marks:new(i,j,k)h.marks.super.new(self,i,j,k)return self end;function h.marks:parse_entry(E)local v=nil;local av,an,ao,aq=E:match("(.)%s+(%d+)%s+(%d+)%s+(.*)")local aw=vim.api.nvim_buf_get_mark(self.win.src_bufnr,av)if aw and aw[1]>0 and aw[1]==tonumber(an)then v=self.win.src_bufnr;aq=e.nvim_buf_get_name(v)end;if aq and#aq>0 then local a1,a2=pcall(vim.fn.expand,aq)if not a1 then aq=""else aq=a2 end;aq=a.relative(aq,vim.loop.cwd())end;return{bufnr=v,path=aq,line=tonumber(an)or 1,col=tonumber(ao)or 1}end;h.jumps=h.buffer_or_file:extend()function h.jumps:new(i,j,k)h.jumps.super.new(self,i,j,k)return self end;function h.jumps:parse_entry(E)local v=nil;local _,an,ao,aq=E:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")if aq then local a1,a2=pcall(vim.fn.expand,aq)if a1 then aq=a.relative(a2,vim.loop.cwd())end;if not vim.loop.fs_stat(aq)then v=self.win.src_bufnr;aq=vim.api.nvim_buf_get_name(self.win.src_bufnr)end end;return{bufnr=v,path=aq,line=tonumber(an)or 1,col=tonumber(ao)+1 or 1}end;h.tags=h.buffer_or_file:extend()function h.tags:new(i,j,k)h.tags.super.new(self,i,j,k)return self end;function h.tags:parse_entry(E)local O=self.super.parse_entry(self,E)O.ctag=a.entry_to_ctag(E)return O end;function h.tags:set_cursor_hl(O)pcall(e.nvim_win_call,self.win.preview_winid,function()e.nvim_win_set_cursor(0,{1,0})g.clearmatches()g.search(O.ctag,"W")if self.win.hls.search then g.matchadd(self.win.hls.search,O.ctag)end;self.orig_pos=e.nvim_win_get_cursor(0)c.zz()end)end;h.highlights=h.base:extend()function h.highlights:should_clear_preview(_)return false end;function h.highlights:gen_winopts()local t={wrap=self.win.preview_wrap,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.highlights:new(i,j,k)h.highlights.super.new(self,i,j,k)self.ns_previewer=vim.api.nvim_create_namespace("fzf-lua.previewer.hl")return self end;function h.highlights:close()self.listed_buffers[tostring(self.tmpbuf)]=nil;h.highlights.super.close(self)self.tmpbuf=nil end;function h.highlights:populate_preview_buf(E)if not self.tmpbuf then local au=vim.split(vim.fn.execute"highlight","\n")local ax={}for _,p in ipairs(au)do if p~=""then if p:sub(1,1)==" "then local ay=p:match"%s+(.*)"ax[#ax]=ax[#ax]..ay else table.insert(ax,p)end end end;self.tmpbuf=e.nvim_create_buf(false,true)self.listed_buffers[tostring(self.tmpbuf)]=true;vim.api.nvim_buf_set_lines(self.tmpbuf,0,-1,false,ax)for o,p in ipairs(ax)do local az=string.find(p,"xxx",1,true)-1;local aA=az+3;local aB=string.match(p,"([^ ]*)%s+.*")pcall(vim.api.nvim_buf_add_highlight,self.tmpbuf,0,aB,o-1,az,aA)end end;if not self.preview_bufnr then self:set_preview_buf(self.tmpbuf)end;local aC="^"..c.strip_ansi_coloring(E).."\\>"pcall(vim.api.nvim_buf_clear_namespace,self.tmpbuf,self.ns_previewer,0,-1)pcall(e.nvim_win_call,self.win.preview_winid,function()e.nvim_win_set_cursor(0,{1,0})g.clearmatches()g.search(aC,"W")if self.win.hls.search then g.matchadd(self.win.hls.search,aC)end;self.orig_pos=e.nvim_win_get_cursor(0)c.zz()end)self.win:update_scrollbar()end;h.quickfix=h.base:extend()function h.quickfix:should_clear_preview(_)return true end;function h.quickfix:gen_winopts()local t={wrap=self.win.preview_wrap,cursorline=false,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.quickfix:new(i,j,k)h.quickfix.super.new(self,i,j,k)return self end;function h.quickfix:close()h.quickfix.super.close(self)end;function h.quickfix:populate_preview_buf(E)local aD=E:match("[(%d+)]")if not aD or tonumber(aD)<=0 then return end;local aE=self.opts._is_loclist and vim.fn.getloclist(self.win.src_winid,{all="",nr=tonumber(aD)})or vim.fn.getqflist({all="",nr=tonumber(aD)})if vim.tbl_isempty(aE)or vim.tbl_isempty(aE.items)then return end;local T={}for _,aF in ipairs(aE.items)do table.insert(T,string.format("%s|%d col %d|%s",a.HOME_to_tilde(a.relative(vim.api.nvim_buf_get_name(aF.bufnr),vim.loop.cwd())),aF.lnum,aF.col,aF.text))end;self.tmpbuf=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(self.tmpbuf,0,-1,false,T)vim.api.nvim_buf_set_option(self.tmpbuf,"filetype","qf")self:set_preview_buf(self.tmpbuf)self.win:update_title(string.format("%s: %s",aD,aE.title))self.win:update_scrollbar()end;h.autocmds=h.buffer_or_file:extend()function h.autocmds:new(i,j,k)h.autocmds.super.new(self,i,j,k)return self end;function h.autocmds:gen_winopts()if not self._is_vimL_command then return self.winopts end;local t={wrap=true,cursorline=false,number=false}return vim.tbl_extend("keep",t,self.winopts)end;function h.autocmds:populate_preview_buf(E)if not self.win or not self.win:validate_preview()then return end;local O=self:parse_entry(E)if vim.tbl_isempty(O)then return end;self._is_vimL_command=false;if O.path=="<none>"then self._is_vimL_command=true;O.path=E:match("[^:]+│")local aG=E:match("[^│]+$")local T=vim.split(aG,"\n")local U=self:get_tmp_buffer()vim.api.nvim_buf_set_lines(U,0,-1,false,T)vim.api.nvim_buf_set_option(U,"filetype","vim")self:set_preview_buf(U)self:preview_buf_post(O)else self.super.populate_preview_buf(self,E)end end;return h
