local a=require"fzf-lua.utils"local b=string.sub;local c=string.byte;local d={}d.separator=function()return"/"end;d.dot_byte=c(".")d.separator_byte=c(d.separator())d.starts_with_separator=function(e)return c(e,1)==d.separator_byte end;d.ends_with_separator=function(e)return c(e,#e)==d.separator_byte end;d.starts_with_cwd=function(e)return#e>1 and c(e,1)==d.dot_byte and c(e,2)==d.separator_byte end;d.strip_cwd_prefix=function(e)return#e>2 and e:sub(3)end;function d.tail(e)local f=c(d.separator())for g=#e,1,-1 do if c(e,g)==f then return e:sub(g+1)end end;return e end;function d.extension(e)for g=#e,1,-1 do if c(e,g)==46 then return e:sub(g+1)end end;return e end;function d.to_matching_str(e)return a.lua_regex_escape(e)end;function d.join(h)return table.concat(h,d.separator()):gsub(d.separator()..d.separator(),d.separator())end;function d.split(e)return e:gmatch("[^"..d.separator().."]+"..d.separator().."?")end;function d.basename(e)e=d.remove_trailing(e)local g=e:match("^.*()"..d.separator())if not g then return e end;return e:sub(g+1,#e)end;function d.parent(e,i)e=" "..d.remove_trailing(e)local g=e:match("^.+()"..d.separator())if not g then return nil end;e=e:sub(2,g)if i then e=d.remove_trailing(e)end;return e end;function d.relative(e,j)local k,l=e:gsub("^"..d.to_matching_str(d.add_trailing(j)),"")return k end;function d.is_relative(e,j)local k=e:match("^"..d.to_matching_str(d.add_trailing(j)))return k~=nil end;function d.add_trailing(e)if e:sub(-1)==d.separator()then return e end;return e..d.separator()end;function d.remove_trailing(e)local k,l=e:gsub(d.separator().."$","")return k end;local function m(n,o,p)local q=c(o,1)for g=p or 1,#n do if c(n,g)==q then return g end end end;d.HOME=function()if not d.__HOME then d.__HOME=os.getenv("HOME")end;return d.__HOME end;function d.tilde_to_HOME(e)return e and e:gsub("^~",d.HOME())or nil end;function d.HOME_to_tilde(e)return e and e:gsub("^"..a.lua_regex_escape(d.HOME()),"~")or nil end;function d.shorten(e,r)local s=d.separator()local t={}local p=1;r=r and tonumber(r)>0 and r or 1;repeat local g=m(e,s,p)local u=g and p+math.min(g-p,r)-1 or nil;local v=b(e,p,u)if u and v=="."and g-p>1 then v=b(e,p,u+1)end;table.insert(t,v)if g then p=g+1 end until not g;return table.concat(t,s)end;function d.lengthen(e)e=a.glob_escape(e)return vim.fn.glob(e:gsub(d.separator(),"%*"..d.separator()):gsub("^%*"..d.separator(),d.separator())):match("[^\n]+")or string.format("<glob expand failed for '%s'>",e)end;local function w(x,y)local g=x:match(".*"..y.."()")if g==nil then return nil else return g-1 end end;local function z(n,s)local A=w(n,s)or 0;return n:sub(A+1),A end;function d.entry_to_ctag(B,C)local D=B:match("%:.-/^?\t?(.*)/")D=D and D:match("/^(.*)")or D;if D and not C then D=D:gsub("[\\%]~*]",function(E)return"\\"..E end)end;return D end;function d.entry_to_location(B,l)local F,G,H=B:match("^(.*://.*):(%d+):(%d+):")G=G and tonumber(G)or 1;H=H and tonumber(H)or 1;return{stripped=B,line=G,col=H,uri=F,range={start={line=G-1,character=H-1}}}end;function d.entry_to_file(B,I,J)I=I or{}local K=I.cwd;B=a.strip_ansi_coloring(B)local L,A=z(B,a.nbsp)L=d.tilde_to_HOME(L)local M=L:match("^%a+://")if K and#K>0 and not M and not d.starts_with_separator(L)then L=d.join({K,L})end;if not M and J then M=true;L="file://"..L end;local N=A>1 and B:sub(1,A):match("%[(%d+)")or nil;if M and not N then return d.entry_to_location(L,I)end;local O=a.strsplit(L,":")if not O[1]then return{}end;local P=O[1]local G=tonumber(O[2])local H=tonumber(O[3])if#O>1 then local Q=P;for g=2,#O do Q=("%s:%s"):format(Q,O[g])if vim.loop.fs_stat(Q)then P=Q;G=O[g+1]H=O[g+2]end end end;local R;if N then R=a.is_term_buffer(N)if R then P,G=L:match("([^:]+):(%d+)")end end;if I.path_shorten and not L:match("^%a+://")then P=d.lengthen(P)end;return{stripped=L,bufnr=tonumber(N),bufname=N and vim.api.nvim_buf_is_valid(tonumber(N))and vim.api.nvim_buf_get_name(tonumber(N)),terminal=R,path=P,line=tonumber(G)or 1,col=tonumber(H)or 1}end;function d.git_cwd(S,I)local T=I or{}if type(T)=="string"then T={cwd=T}end;local U={{"cwd","-C"},{"git_dir","--git-dir"},{"git_worktree","--work-tree"},{"git_config","-c",noexpand=true}}if type(S)=="string"then local V=""for l,W in ipairs(U)do if T[W[1]]then T[W[1]]=W.noexpand and T[W[1]]or vim.fn.expand(T[W[1]])V=V..("%s %s "):format(W[2],vim.fn.shellescape(T[W[1]]))end end;S=S:gsub("^git ","git "..V)else local A=2;S=a.tbl_deep_clone(S)for l,W in ipairs(U)do if T[W[1]]then T[W[1]]=W.noexpand and T[W[1]]or vim.fn.expand(T[W[1]])table.insert(S,A,W[2])table.insert(S,A+1,T[W[1]])A=A+2 end end end;return S end;function d.is_git_repo(I,X)return not not d.git_root(I,X)end;function d.git_root(I,X)local S=d.git_cwd({"git","rev-parse","--show-toplevel"},I)local Y,Z=a.io_systemlist(S)if Z~=0 then if not X then a.info(unpack(Y))end;return nil end;return Y[1]end;return d
