local a=require"fzf-lua.core"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.shell"local e=require"fzf-lua.config"local f=require"fzf-lua.make_entry"local g={}local h={}local i=function()h={curtabidx=vim.fn.tabpagenr(),curtab=vim.api.nvim_win_get_tabpage(0),curbuf=vim.api.nvim_get_current_buf(),prevbuf=vim.fn.bufnr("#"),buflist=vim.api.nvim_list_bufs(),bufmap=(function()local j={}for k,l in ipairs(vim.api.nvim_list_bufs())do j[l]=true end;return j end)()}end;local m=function()local n=vim.fn.getwininfo(vim.api.nvim_get_current_win())[1]if n.terminal~=1 or vim.bo[n.bufnr].ft~="fzf"then i()end end;local o=function(p,q)if type(q)=="function"then q=q()end;local r={}if p.current_tab_only then for k,s in ipairs(vim.api.nvim_tabpage_list_wins(h.curtab))do local l=vim.api.nvim_win_get_buf(s)r[l]=true end end;local t,u={},0;local v=vim.tbl_filter(function(l)if not vim.api.nvim_buf_is_valid(l)then t[l]=true elseif not p.show_unlisted and vim.fn.buflisted(l)~=1 then t[l]=true elseif not p.show_unloaded and not vim.api.nvim_buf_is_loaded(l)then t[l]=true elseif p.ignore_current_buffer and l==h.curbuf then t[l]=true elseif p.current_tab_only and not r[l]then t[l]=true elseif p.no_term_buffers and c.is_term_buffer(l)then t[l]=true elseif p.cwd_only and not b.is_relative(vim.api.nvim_buf_get_name(l),vim.loop.cwd())then t[l]=true elseif p.cwd and not b.is_relative(vim.api.nvim_buf_get_name(l),p.cwd)then t[l]=true end;if c.buf_is_qf(l)then if p.show_quickfix then t[l]=nil else t[l]=true end end;if not t[l]and l>u then u=l end;return not t[l]end,q)return v,t,u end;local w=function(p,v,x)local y={}for k,z in ipairs(v)do local A=z==h.curbuf and"%"or z==h.prevbuf and"#"or" "local B={bufnr=z,flag=A,info=vim.fn.getbufinfo(z)[1],readonly=vim.api.nvim_buf_get_option(z,"readonly")}if not B.info.name or#B.info.name==0 then B.info.name=c.nvim_buf_get_name(B.bufnr,B.info)end;if x then local C=c.winid_from_tabh(x,z)if C then B.info.lnum=vim.api.nvim_win_get_cursor(C)[1]end end;table.insert(y,B)end;if p.sort_lastused then local D=os.time({year=2100,month=1,day=1,hour=0,minute=00})local E=function(F)if F.flag=="%"then return D elseif F.flag=="#"then return D-1 else return F.info.lastused end end;table.sort(y,function(G,l)return E(G)>E(l)end)end;return y end;local function H(p,F,u,I)local J=""local K=F.readonly and"="or" "local L=F.info.changed==1 and"+"or" "local M=J..K..L;local N="["local O="]"local P=#F.info.name>0 and b.relative(F.info.name,I or vim.loop.cwd())if p.filename_only then P=b.basename(P)end;P=b.HOME_to_tilde(P)if p.path_shorten and not P:match("^%a+://")then P=b.shorten(P,tonumber(p.path_shorten))end;P=("%s:%s"):format(P,F.info.lnum>0 and F.info.lnum or"")if F.flag=="%"then M=c.ansi_codes[p.hls.buf_flag_cur](F.flag)..M elseif F.flag=="#"then M=c.ansi_codes[p.hls.buf_flag_alt](F.flag)..M else M=c.nbsp..M end;local Q=string.format("%s%s%s",N,c.ansi_codes[p.hls.buf_nr](tostring(F.bufnr)),O)local R=""local S=""if p.file_icons then if c.is_term_bufname(F.info.name)then R,S=f.get_devicon(F.info.name,"sh")else local T=b.tail(F.info.name)local U=b.extension(T)R,S=f.get_devicon(T,U)end;if p.color_icons then local V=c.ansi_codes[S]or c.ansi_codes["dark_grey"]R=V(R)end end;local W=26+#tostring(u)local X=string.format("%s%s%s%s%s%s%s%s",c._if(p._prefix,p._prefix,""),string.format("%-"..tostring(W).."s",Q),c.nbsp,M,c.nbsp,R,c.nbsp,P)return X end;g.buffers=function(p)p=e.normalize_opts(p,e.globals.buffers)if not p then return end;p.__fn_reload=p.__fn_reload or function(k)return function(Y)local Z,k,u=o(p,h.buflist)if next(Z)then local y=w(p,Z)for k,_ in pairs(y)do local a0,a1=pcall(H,p,_,u)assert(a0 and a1)Y(a1)end end;Y(nil)end end;local a2,a3=d.reload_action_cmd(p,"{+}")local a4=a2:gsub("%-%-%s+{%+}$","")p.__reload_cmd=a2;p._fn_pre_fzf=function()d.set_protected(a3)m()end;if p.fzf_opts["--header-lines"]==nil then p.fzf_opts["--header-lines"]=not p.ignore_current_buffer and p.sort_lastused and"1"end;p=a.set_header(p,p.headers or{"actions","cwd"})p=a.set_fzf_field_index(p)a.fzf_exec(a4,p)end;g.lines=function(p)p=e.normalize_opts(p,e.globals.lines)g.buffer_lines(p)end;g.blines=function(p)p=e.normalize_opts(p,e.globals.blines)p.current_buffer_only=true;p.line_field_index=p.line_field_index or 2;g.buffer_lines(p)end;g.buffer_lines=function(p)if not p then return end;p.fn_pre_fzf=i;p.fn_pre_fzf()local a4=function(Y)local function a5(a6,a7)Y(a6,function(a8)coroutine.resume(a7)if a8 then Y(nil)end end)coroutine.yield()end;coroutine.wrap(function()local a7=coroutine.running()local y=o(p,p.current_buffer_only and{h.curbuf}or h.buflist)for k,z in ipairs(y)do local a9={}local P,R,S;vim.schedule(function()local aa=vim.api.nvim_buf_get_name(z)if vim.api.nvim_buf_is_loaded(z)then a9=vim.api.nvim_buf_get_lines(z,0,-1,false)elseif vim.fn.filereadable(aa)~=0 then a9=vim.fn.readfile(aa,"")end;P=b.basename(aa)if p.file_icons then local T=b.tail(P)local U=b.extension(T)R,S=f.get_devicon(T,U)if p.color_icons then R=c.ansi_codes[S](R)end end;if not P or#P==0 then P=c.nvim_buf_get_name(z)end;coroutine.resume(a7)end)coroutine.yield()for ab,ac in ipairs(a9)do a5(string.format("[%s]%s%s%s%s:%s: %s",c.ansi_codes[p.hls.buf_nr](tostring(z)),c.nbsp,R or"",R and c.nbsp or"",c.ansi_codes[p.hls.buf_name](P),c.ansi_codes[p.hls.buf_linenr](tostring(ab)),ac),a7)end end;Y(nil)end)()end;if p.search and#p.search>0 then p.fzf_opts["--query"]=vim.fn.shellescape(p.search)end;p=a.set_fzf_field_index(p,3,p._is_skim and"{}"or"{..-2}")a.fzf_exec(a4,p)end;g.tabs=function(p)p=e.normalize_opts(p,e.globals.tabs)if not p then return end;p._list_bufs=function()local ad={}for ae,af in ipairs(vim.api.nvim_list_tabpages())do for k,s in ipairs(vim.api.nvim_tabpage_list_wins(af))do local l=vim.api.nvim_win_get_buf(s)if h.bufmap[l]then p._tab_to_buf[ae]=p._tab_to_buf[ae]or{}p._tab_to_buf[ae][l]=af;table.insert(ad,l)end end end;return ad end;p.__fn_reload=p.__fn_reload or function(k)local ag={}local ah=function(Y)p._tab_to_buf={}local Z,t,u=o(p,p._list_bufs)if not next(Z)then return end;for l,k in pairs(t)do for k,v in pairs(p._tab_to_buf)do v[l]=nil end end;for af,v in pairs(p._tab_to_buf)do local ai=vim.fn.getcwd(-1,af)local aj=function(ak,al,am)local S=am;local an=al and al(p[ak])or p[ak]if type(p[ak])=="table"then if type(p[ak][1])=="function"then an=p[ak][1](af,af==h.curtabidx)elseif type(p[ak][1])=="string"then an=al(p[ak][1])else an=al("Tab")end;if type(p[ak][2])=="string"then S=function(ao)return c.ansi_from_hl(p[ak][2],ao)end end elseif type(p[ak])=="function"then an=p[ak](af,af==h.curtabidx)end;return an,S end;local ap,aq=aj("tab_title",function(ao)return string.format("%s%s#%d%s",ao,c.nbsp,af,vim.loop.cwd()==ai and""or string.format(": %s",b.HOME_to_tilde(ai)))end,c.ansi_codes[p.hls.tab_title])local ar,as=aj("tab_marker",function(ao)return ao end,c.ansi_codes[p.hls.tab_marker])if not p.current_tab_only then Y(string.format("%d)%s%s\t%s",af,c.nbsp,aq(ap),af==h.curtabidx and as(ar)or""))end;local at={}for l,k in pairs(v)do table.insert(at,l)end;p.sort_lastused=false;p._prefix=("%d)%s%s%s"):format(af,c.nbsp,c.nbsp,c.nbsp)local x=vim.api.nvim_list_tabpages()[af]local y=w(p,at,x)for k,_ in pairs(y)do Y(H(p,_,u,ai))end end;Y(nil)end;ah(function(au)if au then table.insert(ag,au)end end)return ag end;local a2,a3=d.reload_action_cmd(p,"{+}")local a4=a2:gsub("%-%-%s+{%+}$","")p.__reload_cmd=a2;p._fn_pre_fzf=function()d.set_protected(a3)m()end;p=a.set_header(p,p.headers or{"actions","cwd"})p=a.set_fzf_field_index(p,3,"{}")a.fzf_exec(a4,p)end;return g
