local a=require"fzf-lua.core"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.config"local e=require"fzf-lua.shell"local f=require"fzf-lua.make_entry"local g={}local function h(i)local j=b.git_root(i)if not i.cwd or not j then i.cwd=j end;if i.git_dir or i.git_worktree then i.cmd=b.git_cwd(i.cmd,i)end;return i end;g.files=function(i)i=d.normalize_opts(i,d.globals.git.files)if not i then return end;i=h(i)if not i.cwd then return end;local k=a.mt_cmd_wrapper(i)i=a.set_header(i,i.headers or{"cwd"})return a.fzf_exec(k,i)end;g.status=function(i)i=d.normalize_opts(i,d.globals.git.status)if not i then return end;i=h(i)if not i.cwd then return end;if i.preview then i.preview=b.git_cwd(i.preview,i)end;i.git_icons=false;local function l(m,n)local o=m;local p=d.globals.git.icons[m]if p then o=p.icon;if i.color_icons then o=c.ansi_codes[n and"green"or p.color or"dark_grey"](o)end end;return o end;i.__fn_transform=i.__fn_transform or function(m)if not m or#m<4 then return m end;m=c.strip_ansi_coloring(m)local q,r=m:sub(4):gsub([["]],""),nil;if q:match("%s%->%s")then q,r=q:match("(.*)%s%->%s(.*)")end;q=q and f.file(q,i)if not q then return end;r=r and f.file(r,i)local n=l(m:sub(1,1):gsub("?"," "),true)local s=l(m:sub(2,2))local t=("%s%s%s%s%s"):format(n,c.nbsp,s,c.nbsp..c.nbsp,r and("%s -> %s"):format(q,r)or q)return t end;i.fn_preprocess=i.fn_preprocess or function(u)return f.preprocess(u)end;i.__fn_reload=function(v)return i.cmd end;local w,x=e.reload_action_cmd(i,"{+}")local k=w:gsub("%-%-%s+{%+}$","")i.__reload_cmd=w;i._fn_pre_fzf=function()e.set_protected(x)end;i.header_prefix=i.header_prefix or"+ -  "i.header_separator=i.header_separator or"|"i=a.set_header(i,i.headers or{"actions","cwd"})return a.fzf_exec(k,i)end;local function y(i)i=h(i)if not i.cwd then return end;i=a.set_header(i,i.headers or{"cwd"})a.fzf_exec(i.cmd,i)end;g.commits=function(i)i=d.normalize_opts(i,d.globals.git.commits)if not i then return end;if i.preview then i.preview=b.git_cwd(i.preview,i)if i.preview_pager then i.preview=string.format("%s | %s",i.preview,i.preview_pager)end end;i=a.set_header(i,i.headers or{"actions","cwd"})return y(i)end;g.bcommits=function(i)i=d.normalize_opts(i,d.globals.git.bcommits)if not i then return end;local z=vim.api.nvim_buf_get_name(0)if not z or#z==0 then c.info("'bcommits' is not available for unnamed buffers.")return end;if not i.cwd and not i.git_dir then i.cwd=b.git_root({cwd=vim.fn.expand("%:p:h")},true)end;local j=b.git_root(i)if not j then return end;local A=b.relative(vim.fn.expand("%:p"),j)local B;if c.mode_is_visual()then local v,C=c.get_visual_selection()B=string.format("-L %d,%d:%s --no-patch",C.start.line,C["end"].line,A)end;if i.cmd:match("<file")then i.cmd=i.cmd:gsub("<file>",B or A)else i.cmd=i.cmd.." "..(B or A)end;if type(i.preview)=="string"then i.preview=i.preview:gsub("<file>",vim.fn.shellescape(A))i.preview=b.git_cwd(i.preview,i)if i.preview_pager then i.preview=string.format("%s | %s",i.preview,i.preview_pager)end end;i=a.set_header(i,i.headers or{"actions","cwd"})return y(i)end;g.branches=function(i)i=d.normalize_opts(i,d.globals.git.branches)if not i then return end;i.fzf_opts["--no-multi"]=""if i.preview then i.__preview=b.git_cwd(i.preview,i)i.preview=e.raw_preview_action_cmd(function(D)local E=D[1]:match("[^%s%*]*$"):gsub("%)$","")return i.__preview:gsub("{.*}",E)end,nil,i.debug)end;return y(i)end;g.stash=function(i)i=d.normalize_opts(i,d.globals.git.stash)if not i then return end;i=h(i)if not i.cwd then return end;if i.preview then i.preview=b.git_cwd(i.preview,i)end;i.__fn_transform=i.__fn_transform or function(m)local F,G=m:match("([^:]+)(.*)")if F then F=c.ansi_codes.yellow(F)F=F:gsub("{%d+}",function(H)return("%s"):format(c.ansi_codes.green(tostring(H)))end)end;return(not F or not G)and m or F..G end;i.__fn_reload=function(v)return i.cmd end;local w,x=e.reload_action_cmd(i,"{+}")local k=w:gsub("%-%-%s+{%+}$","")i.__reload_cmd=w;i._fn_pre_fzf=function()e.set_protected(x)end;i=a.set_header(i,i.headers or{"actions","cwd"})return a.fzf_exec(k,i)end;return g
