local a=require"fzf-lua.core"local b=require"fzf-lua.path"local c=require"fzf-lua.utils"local d=require"fzf-lua.shell"local e=require"fzf-lua.config"local f=require"fzf-lua.make_entry"local g={}g.commands=function(h)h=e.normalize_opts(h,e.globals.commands)if not h then return end;local i=vim.api.nvim_get_commands{}local j=vim.api.nvim_buf_get_commands(0,{})local k=vim.tbl_extend("force",{},i,j)local l=d.action(function(m)local n=m[1]if k[n]then n=vim.inspect(k[n])end;return n end,nil,h.debug)local o={}if h.sort_lastused then local p=vim.split(vim.fn.execute("history"),"\n")for q=#p,#p-3,-1 do local n=p[q]:match("%d+%s+([^%s]+)")if j[n]then table.insert(o,c.ansi_codes.green(n))j[n]=nil end;if i[n]then table.insert(o,c.ansi_codes.magenta(n))i[n]=nil end end end;for r,s in pairs(i)do table.insert(o,c.ansi_codes.magenta(r))end;for r,t in pairs(j)do if type(t)=="table"then table.insert(o,c.ansi_codes.green(r))end end;if not h.sort_lastused then table.sort(o,function(u,v)return u<v end)end;h.fzf_opts["--no-multi"]=""h.fzf_opts["--preview"]=l;a.fzf_exec(o,h)end;local p=function(h,w)local p=vim.fn.execute("history "..w)p=vim.split(p,"\n")local o={}for q=#p,3,-1 do local x=p[q]local s,y=string.find(x,"%d+ +")table.insert(o,h.reverse_list and 1 or#o+1,string.sub(x,y+1))end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;local z=function(A,B,C)A=c.ansi_codes.yellow(A)B=c.ansi_codes.yellow(B)return vim.fn.shellescape((":: %s to %s, %s to edit"):format(A,C,B))end;g.command_history=function(h)h=e.normalize_opts(h,e.globals.command_history)if not h then return end;h.fzf_opts["--header"]=z("<CR>","<Ctrl-e>","execute")p(h,"cmd")end;g.search_history=function(h)h=e.normalize_opts(h,e.globals.search_history)if not h then return end;h.fzf_opts["--header"]=z("<CR>","<Ctrl-e>","search")p(h,"search")end;g.changes=function(h)h=h or{}h.cmd="changes"h.prompt=h.prompt or"Changes> "return g.jumps(h)end;g.jumps=function(h)h=e.normalize_opts(h,e.globals.jumps)if not h then return end;local D=vim.fn.execute(h.cmd)D=vim.split(D,"\n")local o={}for q=#D-1,3,-1 do local E,F,G,C=D[q]:match("(%d+)%s+(%d+)%s+(%d+)%s+(.*)")table.insert(o,string.format("%-15s %-15s %-15s %s",c.ansi_codes.yellow(E),c.ansi_codes.blue(F),c.ansi_codes.green(G),C))end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.tagstack=function(h)h=e.normalize_opts(h,e.globals.tagstack)if not h then return end;local H=vim.fn.gettagstack().items;local I={}for q=#H,1,-1 do local J=H[q]J.bufnr=J.from[1]if vim.api.nvim_buf_is_valid(J.bufnr)then I[#I+1]=J;J.filename=vim.fn.bufname(J.bufnr)J.lnum=J.from[2]J.col=J.from[3]J.text=vim.api.nvim_buf_get_lines(J.bufnr,J.lnum-1,J.lnum,false)[1]or""end end;if vim.tbl_isempty(I)then c.info("No tagstack available")return end;local o={}for q,J in ipairs(I)do local K=b.HOME_to_tilde(b.relative(J.filename,vim.loop.cwd()))local L,M;if h.file_icons then local N=b.tail(K)local O=b.extension(N)L,M=f.get_devicon(N,O)if h.color_icons then L=c.ansi_codes[M](L)end end;table.insert(o,("%s)%s%s%s%s:%s:%s: %s %s"):format(c.ansi_codes.yellow(tostring(q)),c.nbsp,L or"",L and c.nbsp or"",c.ansi_codes.magenta(#K>0 and K or"[No Name]"),c.ansi_codes.green(tostring(J.lnum)),J.col,c.ansi_codes.red("["..J.tagname.."]"),J.text))end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.marks=function(h)h=e.normalize_opts(h,e.globals.marks)if not h then return end;local P=vim.fn.execute(string.format("marks %s",h.marks and h.marks or""))P=vim.split(P,"\n")local o={}local Q=h.marks and vim.split(h.marks,"")for q=#P,3,-1 do local R,F,G,C=P[q]:match("(.)%s+(%d+)%s+(%d+)%s+(.*)")if not Q or vim.tbl_contains(Q,R)then table.insert(o,string.format("%-15s %-15s %-15s %s",c.ansi_codes.yellow(R),c.ansi_codes.blue(F),c.ansi_codes.green(G),C))end end;table.sort(o,function(u,v)return u<v end)h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.registers=function(h)h=e.normalize_opts(h,e.globals.registers)if not h then return end;local S={[["]],"_","#","=","_","/","*","+",":",".","%"}for q=0,9 do table.insert(S,tostring(q))end;for q=65,90 do table.insert(S,string.char(q))end;local function T(U,V)if not U then return end;local W={["\3"]="^C",["\27"]="^[",["\18"]="^R"}for r,t in pairs(W)do U=U:gsub(r,c.ansi_codes.magenta(t))end;return not V and U or U:gsub("\n",c.ansi_codes.magenta("\\n"))end;local l=d.action(function(m)local X=m[1]:match("%[(.*)%] ")local s,Y=pcall(vim.fn.getreg,X)return Y and T(Y)or m[1]end,nil,h.debug)local o={}for s,X in ipairs(S)do local s,Y=pcall(vim.fn.getreg,X)Y=T(Y,true)if Y and#Y>0 or not h.ignore_empty then table.insert(o,string.format("[%s] %s",c.ansi_codes.yellow(X),Y))end end;h.fzf_opts["--no-multi"]=""h.fzf_opts["--preview"]=l;a.fzf_exec(o,h)end;g.keymaps=function(h)h=e.normalize_opts(h,e.globals.keymaps)if not h then return end;local Z={n="blue",i="red",c="yellow",v="magenta"}local _={}local a0=function(a1)local a2=a1.desc or a1.rhs or string.format("%s",a1.callback)if type(a1.rhs)=="string"and#a1.rhs==0 then return end;a1.str=string.format("%s │ %-40s │ %s",c.ansi_codes[Z[a1.mode]or"blue"](a1.mode),a1.lhs:gsub("%s","<Space>"),a2 or"")local r=string.format("[%s:%s:%s]",a1.buffer,a1.mode,a1.lhs)_[r]=a1 end;for a3,s in pairs(Z)do local a4=vim.api.nvim_get_keymap(a3)for s,a1 in pairs(a4)do a0(a1)end;local a5=vim.api.nvim_buf_get_keymap(0,a3)for s,a1 in pairs(a5)do a0(a1)end end;local o={}for s,t in pairs(_)do table.insert(o,t.str)end;h.fzf_opts["--no-multi"]=""table.sort(o)a.fzf_exec(o,h)end;g.spell_suggest=function(h)h=e.normalize_opts(h,e.globals.spell_suggest)if not h then return end;local a6=vim.fn.expand"<cword>"local o=vim.fn.spellsuggest(a6)if vim.tbl_isempty(o)then return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.filetypes=function(h)h=e.normalize_opts(h,e.globals.filetypes)if not h then return end;local o=vim.fn.getcompletion("","filetype")if vim.tbl_isempty(o)then return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.packadd=function(h)h=e.normalize_opts(h,e.globals.packadd)if not h then return end;local o=vim.fn.getcompletion("","packadd")if vim.tbl_isempty(o)then return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.menus=function(h)h=e.normalize_opts(h,e.globals.menus)if not h then return end;local function a7(a8,a9)local aa=a8 and("%s.%s"):format(a8,a9.name)or a9.name;if a9.submenus then return vim.tbl_map(function(ab)return a7(aa,ab)end,a9.submenus)else return aa end end;local o=vim.tbl_flatten(vim.tbl_map(function(ab)return a7(nil,ab)end,vim.fn.menu_get("")))if vim.tbl_isempty(o)then c.info("No menus available")return end;h.fzf_opts["--no-multi"]=""a.fzf_exec(o,h)end;g.autocmds=function(h)h=e.normalize_opts(h,e.globals.autocmds)if not h then return end;local ac=vim.api.nvim_get_autocmds({})if not ac or vim.tbl_isempty(ac)then return end;local Y=function(ad)coroutine.wrap(function()local ae=coroutine.running()for s,u in ipairs(ac)do local af,F="<none>",0;if u.callback then local ag=debug.getinfo(u.callback,"S")af=ag and ag.source and ag.source:sub(2)or""F=ag and ag.linedefined or 0 end;local ah=u.group_name and vim.trim(u.group_name)or" "local a9=string.format("%s:%d:%-28s │ %-34s │ %-18s │ %s",af,F,c.ansi_codes.yellow(u.event),c.ansi_codes.blue(ah),u.pattern,u.callback and c.ansi_codes.red(tostring(u.callback))or u.command)ad(a9,function(ai)coroutine.resume(ae)if ai then ad(nil)end end)coroutine.yield()end;ad(nil)end)()end;return a.fzf_exec(Y,h)end;return g
