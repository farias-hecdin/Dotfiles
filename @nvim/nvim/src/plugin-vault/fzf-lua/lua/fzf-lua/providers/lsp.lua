local a=require"fzf-lua.core"local b=require"fzf-lua.utils"local c=require"fzf-lua.config"local d=require"fzf-lua.make_entry"local e={}local function f()if not __CTX or not b.fzf_winobj()then __CTX={winid=vim.api.nvim_get_current_win(),bufnr=vim.api.nvim_get_current_buf(),bufname=vim.api.nvim_buf_get_name(0),cursor=vim.api.nvim_win_get_cursor(0)}end end;local function g(h)if b.__HAS_NVIM_08 then return h.server_capability else return h.resolved_capability end end;local function i(j,k)f()local l=vim.lsp.buf_get_clients(__CTX and __CTX.bufnr or 0)local m=0;for _,n in pairs(l)do if b.__HAS_NVIM_08 then if n.server_capabilities[j]then m=m+1 end else if n.resolved_capabilities[j]then m=m+1 end end end;if m>0 then return m end;if b.tbl_isempty(l)then if not k then b.info("LSP: no client attached")end;return nil else if not k then b.info("LSP: server does not support "..j)end;return false end end;local function o(p,q)local r=vim.lsp.util.locations_to_items({p},q)[1]return("%s:%d:%d:"):format(r.filename,r.lnum,r.col)end;local s=function(t,u,q)b.fzf_exit()local v=t.jump_to_single_result_action;if v then local w=o(u,q)return t.jump_to_single_result_action({w},t)end;return vim.lsp.util.jump_to_location(u,q)end;local function x(t,y,_,u,z,_)local A=vim.lsp.get_client_by_id(z.client_id).offset_encoding;u=vim.tbl_islist(u)and u or{u}if t.ignore_current_line then local B=__CTX.cursor[1]-1;u=vim.tbl_filter(function(C)if C.range and C.range.start and C.range.start.line==B then return false end;return true end,u)end;if t.jump_to_single_result and#u==1 then s(t,u[1],A)end;local D=vim.lsp.util.locations_to_items(u,A)if t.filter and type(t.filter)=="function"then D=t.filter(D)end;for _,w in ipairs(D)do if not t.current_buffer_only or __CTX.bufname==w.filename then w=d.lcol(w,t)w=d.file(w,t)if w then y(w)end end end end;local function E(t,y,_,u,_,_)for _,F in pairs(u)do local G=F.from or F.to;for _,H in pairs(F.fromRanges)do local p={filename=assert(vim.uri_to_fname(G.uri)),text=G.name,lnum=H.start.line+1,col=H.start.character+1}local w=d.lcol(p,t)w=d.file(w,t)if w then y(w)end end end end;local function I(J,K,L)local function M(N,O,P,Q)for _,R in ipairs(N)do local S=vim.lsp.protocol.SymbolKind[R.kind]or"Unknown"if R.location then local H=R.location.range;table.insert(O,{filename=vim.uri_to_fname(R.location.uri),lnum=H.start.line+1,col=H.start.character+1,kind=S,text=Q.."["..S.."] "..R.name})elseif R.selectionRange then table.insert(O,{filename=vim.api.nvim_buf_get_name(P),lnum=R.selectionRange.start.line+1,col=R.selectionRange.start.character+1,kind=S,text=Q.."["..S.."] "..R.name})if R.children then for _,T in ipairs(M(R.children,O,P,Q..L))do for _,U in ipairs(T)do table.insert(O,U)end end end end end;return O end;return M(J,{},K or 0,"")end;local function V(t,y,_,u,_,_)u=vim.tbl_islist(u)and u or{u}local D;if t.child_prefix then D=I(u,__CTX.bufnr,t.child_prefix==true and string.rep("\xc2\xa0",2)or t.child_prefix)else D=vim.lsp.util.symbols_to_items(u,__CTX.bufnr)end;for _,w in ipairs(D)do if(not t.current_buffer_only or __CTX.bufname==w.filename)and(not t.regex_filter or w.text:match(t.regex_filter))then if e._sym2style then local S=w.text:match("%[(.-)%]")if S and e._sym2style[S]then w.text=w.text:gsub("%[.-%]",e._sym2style[S],1)end end;w=d.lcol(w,t)w=d.file(w,t)if w then y(w)end end end end;local function W(t,y,_,X,Y,_)if not t.code_actions then t.code_actions={}end;local Z=vim.tbl_count(t.code_actions)+1;for _,v in ipairs(X)do local a0=string.format("%s %s",b.ansi_codes.magenta(string.format("%d:",Z)),v.title)local w={client_id=Y.client_id,command=v}t.code_actions[tostring(Z)]=w;y(a0)Z=Z+1 end end;local a1={["code_actions"]={label="Code Actions",resolved_capability="code_action",server_capability="codeActionProvider",method="textDocument/codeAction",handler=W},["references"]={label="References",resolved_capability="find_references",server_capability="referencesProvider",method="textDocument/references",handler=x},["definitions"]={label="Definitions",resolved_capability="goto_definition",server_capability="definitionProvider",method="textDocument/definition",handler=x},["declarations"]={label="Declarations",resolved_capability="goto_declaration",server_capability="declarationProvider",method="textDocument/declaration",handler=x},["typedefs"]={label="Type Definitions",resolved_capability="type_definition",server_capability="typeDefinitionProvider",method="textDocument/typeDefinition",handler=x},["implementations"]={label="Implementations",resolved_capability="implementation",server_capability="implementationProvider",method="textDocument/implementation",handler=x},["document_symbols"]={label="Document Symbols",resolved_capability="document_symbol",server_capability="documentSymbolProvider",method="textDocument/documentSymbol",handler=V},["workspace_symbols"]={label="Workspace Symbols",resolved_capability="workspace_symbol",server_capability="workspaceSymbolProvider",method="workspace/symbol",handler=V},["live_workspace_symbols"]={label="Workspace Symbols",resolved_capability="workspace_symbol",server_capability="workspaceSymbolProvider",method="workspace/symbol",handler=V},["incoming_calls"]={label="Incoming Calls",resolved_capability="call_hierarchy",server_capability="callHierarchyProvider",method="callHierarchy/incomingCalls",handler=E},["outgoing_calls"]={label="Outgoing Calls",resolved_capability="call_hierarchy",server_capability="callHierarchyProvider",method="callHierarchy/outgoingCalls",handler=E}}local a2=function(a3)return function(...)local a4=not select(4,...)or type(select(4,...))~="number"if a4 then a3(...)else local a5=select(1,...)local a6=select(2,...)local u=select(3,...)local a7=select(4,...)local K=select(5,...)local a8=select(6,...)a3(a5,u,{method=a6,client_id=a7,bufnr=K},a8)end end end;local function a9(aa,h,t)return a2(function(a5,u,Y,a8)t.num_callbacks=t.num_callbacks+1;t.num_results=(t.num_results or 0)+(u and vim.tbl_count(u)or 0)if a5 then if not t.silent then b.err(string.format("Error executing '%s': %s",h.method,a5))end;if not t.no_autoclose then b.fzf_exit()end;coroutine.resume(aa,true,a5)else local ab=t.num_callbacks==t.num_clients;if ab and t.num_results==0 then if not t.silent then b.info(string.format("No %s found",string.lower(h.label)))end;if not t.no_autoclose then b.fzf_exit()end end;coroutine.resume(aa,ab,a5,u,Y,a8)end end)end;local function ac(t)assert(t.lsp_handler)if t.async==nil then if type(t.async_or_timeout)=="number"then t.async=false elseif type(t.async_or_timeout)=="boolean"then t.async=t.async_or_timeout end end;local ad,ae=t.lsp_params,t.lsp_handler;if not ad then ad=vim.lsp.util.make_position_params(__CTX.winid)ad.context={includeDeclaration=t.includeDeclaration==nil and true or t.includeDeclaration}end;if not t.async then local af=5000;if type(t.async_or_timeout)=="number"then af=t.async_or_timeout end;local ag,a5=vim.lsp.buf_request_sync(__CTX.bufnr,ae.method,ad,af)if a5 then b.err(string.format("Error executing '%s': %s",ae.method,a5))else local ah={}local y=function(a0)table.insert(ah,a0)end;for a7,ai in pairs(ag)do if ai.result then local Y={client_id=a7}ae.handler(t,y,ae.method,ai.result,Y)end end;if vim.tbl_isempty(ah)then if not t.fn_reload and not t.silent then b.info(string.format("No %s found",string.lower(ae.label)))else t.__contents={}end elseif not(t.jump_to_single_result and#ah==1)then t.__contents=function(aj)coroutine.wrap(function()local aa=coroutine.running()for _,ak in ipairs(ah)do aj(ak,function()coroutine.resume(aa)end)coroutine.yield()end;aj(nil)end)()end end end else local al=function(am)if am and am._cancel_all then am._cancel_all()am._cancel_all=nil end end;t._fn_post_fzf=al;t.__contents=function(aj)coroutine.wrap(function()local aa=coroutine.running()local an={num_results=0,num_callbacks=0,num_clients=i(ae.capability,t.silent),no_autoclose=t.no_autoclose or t.fn_reload,silent=t.silent or t.fn_reload}al(t)local ao=function()_,t._cancel_all=vim.lsp.buf_request(__CTX.bufnr,ae.method,ad,a9(aa,ae,an))end;if vim.in_fast_event()then vim.schedule(function()ao()end)else ao()end;local a5,u,Y,a8,ab;repeat ab,a5,u,Y,a8=coroutine.yield()if not a5 and type(u)=="table"then local y=function(ak)aj(ak,function()coroutine.resume(aa)end)coroutine.yield()end;ae.handler(t,y,ae.method,u,Y,a8)end until ab or a5;aj(nil)t._cancel_all=nil end)()end end;return t,t.__contents end;local function ap(t)local ad=vim.lsp.util.make_position_params(__CTX and __CTX.winid or 0)local a6="textDocument/prepareCallHierarchy"local aq,a5=vim.lsp.buf_request_sync(0,a6,ad,2000)if a5 then b.err(("Error executing '%s': %s"):format(a6,a5))else local _,ai=next(aq)if vim.tbl_isempty(ai)or not ai.result[1]then if not t.silent then b.info(("No %s found"):format(t.lsp_handler.label:lower()))end;return end;assert(ai.result and ai.result[1])t.lsp_params={item=ai.result[1]}return ac(t)end end;local ar=function(t,as)t=c.normalize_opts(t,as)if not t then return end;if not t.prompt and t.prompt_postfix then t.prompt=t.lsp_handler.label..(t.prompt_postfix or"")end;if not t.cwd or#t.cwd==0 then t.cwd=vim.loop.cwd()else t.cwd_only=true end;return t end;local function at(t,au)t=ar(t,c.globals.lsp)if not t then return end;if t.force_uri==nil then t.force_uri=true end;t=a.set_fzf_field_index(t)t=au(t)if not t.__contents then return end;return a.fzf_exec(t.__contents,t)end;e.references=function(t)return at(t,ac)end;e.definitions=function(t)return at(t,ac)end;e.declarations=function(t)return at(t,ac)end;e.typedefs=function(t)return at(t,ac)end;e.implementations=function(t)return at(t,ac)end;e.incoming_calls=function(t)return at(t,ap)end;e.outgoing_calls=function(t)return at(t,ap)end;e.finder=function(t)t=ar(t,c.globals.lsp.finder)if not t then return end;if t.force_uri==nil then t.force_uri=true end;local av={}for _,aw in ipairs(t.providers)do local a6=aw[1]if not t._providers[a6]then b.warn(string.format("Unsupported provider: %s",a6))else t.silent=t.silent==nil and true or t.silent;t.no_autoclose=true;t.lsp_handler=a1[a6]t.lsp_handler.capability=g(t.lsp_handler)t.lsp_params=nil;local ax=i(t.lsp_handler.capability,true)if ax==nil then b.info("LSP: no client attached")return elseif ax then local _,ay=(function()if a6=="incoming_calls"or a6=="outgoing_calls"then return ap(t)else return ac(t)end end)()if type(ay)=="function"then table.insert(av,{prefix=(aw.prefix or"")..(t.separator or""),contents=ay})end end end end;if#av==0 then b.info("LSP: no locations found")return end;t=a.set_fzf_field_index(t)return a.fzf_exec(av,t)end;local function az(t)assert(e._sym2style==nil)assert(t.symbol_style~=nil)e._sym2style={}for S,aA in pairs(t.symbol_icons)do local U=nil;if t.symbol_style==1 and c._has_devicons then U=("%s %s"):format(aA,S)elseif t.symbol_style==2 and c._has_devicons then U=aA elseif t.symbol_style==3 then U=S end;if U and t.symbol_hl then e._sym2style[S]=b.ansi_from_hl(t.symbol_hl(S),U)elseif U then e._sym2style[S]=U else e._sym2style[S]=S end end;if type(t.symbol_fmt)=="function"then for aB,T in pairs(e._sym2style)do e._sym2style[aB]=t.symbol_fmt(T,t)or T end end end;e.document_symbols=function(t)t=ar(t,c.globals.lsp.symbols)if not t then return end;t.__MODULE__=t.__MODULE__ or e;t=a.set_header(t,t.headers or{"regex_filter"})t=a.set_fzf_field_index(t)if t.force_uri==nil then t.force_uri=true end;if not t.fzf_opts or t.fzf_opts["--with-nth"]==nil then t.fzf_opts=t.fzf_opts or{}t.fzf_opts["--with-nth"]="2.."t.fzf_opts["--tiebreak"]="index"end;t=ac(t)if not t.__contents then return end;if t.symbol_style or t.symbol_fmt then t.fn_pre_fzf=function()az(t)end;t.fn_post_fzf=function()e._sym2style=nil end end;return a.fzf_exec(t.__contents,t)end;local function aC(_)return e.__last_ws_lsp_query end;local function aD(_,aE)e.__last_ws_lsp_query=aE;if c.__resume_data then c.__resume_data.last_query=aE end end;e.workspace_symbols=function(t)t=ar(t,c.globals.lsp.symbols)if not t then return end;t.__MODULE__=t.__MODULE__ or e;if not t.lsp_query and t.resume then t.lsp_query=aC(t)end;aD(t,t.lsp_query)t.lsp_params={query=t.lsp_query or""}t=a.set_header(t,t.headers or{"actions","cwd","lsp_query","regex_filter"})t=a.set_fzf_field_index(t)if t.force_uri==nil then t.force_uri=true end;t=ac(t)if not t.__contents then return end;if t.symbol_style or t.symbol_fmt then t.fn_pre_fzf=function()az(t)end;t.fn_post_fzf=function(am,_)e._sym2style=nil;local aF=aC(am)local aG=c.__resume_data and c.__resume_data.last_query;if not aF or#aF==0 and(aG and#aG>0)then aD(t,aG)end end end;return a.fzf_exec(t.__contents,t)end;e.live_workspace_symbols=function(t)t=ar(t,c.globals.lsp.symbols)if not t then return end;t.__MODULE__=t.__MODULE__ or e;t.prompt=t.prompt and t.prompt:match("^%*")or"*"..t.prompt;if t.exec_empty_query==nil then t.exec_empty_query=true end;if not t.lsp_query and t.resume then t.lsp_query=aC(t)end;t.lsp_params={query=t.lsp_query or t.query or""}t.query=t.lsp_query or t.query;t.func_async_callback=false;t.fn_reload=function(aE)if aE and not(t.save_last_search==false)then aD(t,aE)end;t.lsp_params={query=aE or""}t=ac(t)return t.__contents end;t=a.set_header(t,t.headers or{"actions","cwd","regex_filter"})t=a.set_fzf_field_index(t)if t.force_uri==nil then t.force_uri=true end;if t.symbol_style or t.symbol_fmt then t.fn_pre_fzf=function()az(t)end;t.fn_post_fzf=function()e._sym2style=nil end end;a.fzf_exec(nil,t)end;local function aH(_)if not vim.diagnostic then return vim.lsp.diagnostic.get_line_diagnostics()end;local aI=vim.diagnostic.get(__CTX.bufnr,{lnum=vim.api.nvim_win_get_cursor(0)[1]-1})return aI and aI[1]and{{source=aI[1].source,message=aI[1].message,severity=aI[1].severity,code=aI[1].user_data and aI[1].user_data.lsp and aI[1].user_data.lsp.code,codeDescription=aI[1].user_data and aI[1].user_data.lsp and aI[1].user_data.lsp.codeDescription,range={["start"]={line=aI[1].lnum,character=aI[1].col},["end"]={line=aI[1].end_lnum,character=aI[1].end_col}},data=aI[1].user_data and aI[1].user_data.lsp and aI[1].user_data.lsp.data}}or{}end;e.code_actions=function(t)t=ar(t,c.globals.lsp.code_actions)if not t then return end;if vim.fn.has("nvim-0.6")~=1 then b.info("LSP code actions requires neovim >= 0.6")return end;local aJ=require"fzf-lua.providers.ui_select"local aK=aJ.is_registered()if not aK then t.jump_to_single_result=false;t.lsp_params=vim.lsp.util.make_range_params(0)t.lsp_params.context={diagnostics=vim.lsp.diagnostic.get_line_diagnostics(__CTX and __CTX.bufnr or 0)or{}}t.async=false;local _,aL=ac(t)if not aL then return end end;t.previewer=false;t.actions=t.actions or{}t.actions.default=nil;if not aK then t.post_action_cb=function()aJ.deregister({},true,true)end end;aJ.register(t,true,t)vim.lsp.buf.code_action()end;local function aM(aN,a3)return function(t)t=t or{}t.lsp_handler=a1[aN]t.lsp_handler.capability=g(t.lsp_handler)if not i(t.lsp_handler.capability)then return end;a3(t)end end;return setmetatable({},{__index=function(_,aN)if a1[aN]then return aM(aN,e[aN])else return e[aN]end end})
