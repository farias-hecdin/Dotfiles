local a=require"fzf-lua.utils"local b=require"fzf-lua.config"local c=require"fzf-lua.actions"local d=vim.api;local e=vim.fn;local f={}local g=nil;function f.__SELF()return g end;setmetatable(f,{__call=function(h,...)return h:new(...)end})local i={["toggle-preview"]={module="win",fnc="toggle_preview()"},["toggle-preview-wrap"]={module="win",fnc="toggle_preview_wrap()"},["toggle-preview-cw"]={module="win",fnc="toggle_preview_cw(1)"},["toggle-preview-ccw"]={module="win",fnc="toggle_preview_cw(-1)"},["preview-page-up"]={module="win",fnc="preview_scroll(-1)"},["preview-page-down"]={module="win",fnc="preview_scroll(1)"},["preview-page-reset"]={module="win",fnc="preview_scroll(0)"}}function f:setup_keybinds()if not self:validate()then return end;if not self.keymap or not self.keymap.builtin then return end;if self.keymap.fzf then for j,k in pairs(self.keymap.fzf)do if k=="toggle-preview"then self._fzf_toggle_prev_bind=a.fzf_bind_to_neovim(j)end end end;local l={["toggle-help"]={module="win",fnc="toggle_help()"},["toggle-fullscreen"]={module="win",fnc="toggle_fullscreen()"}}if self.previewer_is_builtin then l=vim.tbl_deep_extend("keep",l,i)end;local function m(n)return([[<Cmd>lua require('fzf-lua.%s').%s<CR>]]):format(n.module,n.fnc)end;for o,p in pairs(self.keymap.builtin)do local n=l[p]if n and not vim.tbl_isempty(n)and p~=false then a.keymap_set("t",o,m(n),{nowait=true,buffer=self.fzf_bufnr})end end;if self.actions["esc"]==c.dummy_abort then a.keymap_set("t","<Esc>","<Esc>",{buffer=0})end end;function f:generate_layout(q)local r,s=q.row,q.col;local t,u=q.height,q.width;local v=q.signcol_width or 0;local w=q.preview_pos;local x=q.preview_size;local y,z=r+1,s+1;local A,B;local C=2;local D;local E=q.split and q.split:match("vnew")~=nil;if w=="down"or w=="up"then t=t-C;B=u;A=a.round(t*x/100,0.6)t=t-A;if w=="up"then r=r+A+C;if q.split then D="NW"y=1;z=1;B=B-2;A=A-1 else D="SW"y=r-1 end else D="NW"if q.split then z=1;y=t+C;A=A-1;B=B-2 else y=r+t+3 end end elseif w=="left"or w=="right"then A=t;B=a.round(u*x/100)u=u-B-2;if w=="left"then D="NE"s=s+B+2;z=s-1;if q.split then y=1;B=B-1-v;A=A-C;if E then D="NW"z=1 else z=s-3-v end end else D="NW"if q.split then y=1;z=u+4-v;B=B-3+v;A=A-C else z=s+u+3 end end end;return{fzf={row=r,col=s,height=t,width=u},preview={anchor=D,row=y,col=z,height=A,width=B}}end;local F=function(G)local H=nil;if type(G)=="string"then H=b.globals.winopts._borderchars[G]end;if not H then H=b.globals.winopts._borderchars["rounded"]end;if not G or type(G)~="table"or#G<8 then return H end;local I={}for J=1,8 do if type(G[J])=="string"then table.insert(I,#G[J]>0 and G[J]or" ")elseif type(G[J])=="table"and type(G[J][1])=="string"then table.insert(I,#G[J][1]>0 and G[J][1]or" ")else table.insert(I,H[J])end end;return I end;local K=function(L)local q=a.tbl_deep_clone(L.winopts)q.__winhls={main={{"Normal",L.hls.normal},{"FloatBorder",L.hls.border},{"CursorLine",L.hls.cursorline},{"CursorLineNr",L.hls.cursorlinenr}},prev={{"Normal",L.hls.preview_normal},{"FloatBorder",L.hls.preview_border},{"CursorLine",L.hls.cursorline},{"CursorLineNr",L.hls.cursorlinenr}},prev_border={{"Normal",L.hls.preview_border}}}if type(q.title)=="string"and type(L.hls.title)=="string"then q.title={{q.title,L.hls.title}}end;local M=vim.o.columns-2;local N=vim.o.lines-vim.o.cmdheight-2;q.width=math.min(M,q.width)q.height=math.min(N,q.height)if not q.height or q.height<=1 then q.height=math.floor(N*q.height)end;if not q.width or q.width<=1 then q.width=math.floor(M*q.width)end;if q.relative=="cursor"then local O=vim.api.nvim_win_get_cursor(0)local P=vim.fn.screenpos(0,O[1],O[2])q.row=math.floor((q.row or 0)+P.row-1)q.col=math.floor((q.col or 0)+P.col-1)q.relative=nil else if not q.row or q.row<=1 then q.row=math.floor((vim.o.lines-q.height)*q.row)end;if not q.col or q.col<=1 then q.col=math.floor((vim.o.columns-q.width)*q.col)end;q.col=math.min(q.col,M-q.width)q.row=math.min(q.row,N-q.height)end;if q.border==false then q.border="none"elseif not q.border or q.border==true then q.border="rounded"end;if type(q.border)=="string"then q._border=q.border;q.border=b.globals.winopts._borderchars[q.border]or b.globals.winopts._borderchars["rounded"]end;q.nohl_borderchars=F(q.border)local Q;if q.preview.layout=="horizontal"or q.preview.layout=="flex"and vim.o.columns>q.preview.flip_columns then Q=q.preview.horizontal else Q=q.preview.vertical end;q.preview_pos=Q:match("[^:]+")or"right"q.preview_size=tonumber(Q:match(":(%d+)%%"))or 50;return q end;function f:reset_win_highlights(R)local o="main"if R==self.preview_winid then o="prev"elseif R==self.border_winid then o="prev_border"end;local S;for T,U in ipairs(self.winopts.__winhls[o])do if U[2]then S=string.format("%s%s:%s",S and S..","or"",U[1],U[2])end end;vim.api.nvim_win_set_option(R,"winhighlight",S)end;function f:check_exit_status(V,W)if W and W~=self.fzf_bufnr then return end;if not self:validate()then return end;if V==2 then local X=vim.api.nvim_buf_get_lines(self.fzf_bufnr,0,1,false)a.warn(string.format("fzf error %d: %s",V,X and#X[1]>0 and X[1]or"<null>"))end end;function f:_set_autoclose(Y)if Y~=nil then self._autoclose=Y else self._autoclose=true end;return self._autoclose end;function f.set_autoclose(Y)if not g then return nil end;return g:_set_autoclose(Y)end;function f.autoclose()if not g then return nil end;return g._autoclose end;local function Z(_,o,a0)local a1=_.winopts.preview[o]or b.globals.winopts.preview[o]return a1 and a1:match(a0)end;function f:new(L)if g then g._reuse=true;return g end;L=L or{}self._o=L;self=setmetatable({},{__index=self})self.hls=L.hls;self.actions=L.actions;self.winopts=K(L)self.fullscreen=self.winopts.fullscreen;self.preview_wrap=not Z(L,"wrap","nowrap")self.preview_hidden=not Z(L,"hidden","nohidden")self.preview_border=not Z(L,"border","noborder")self.keymap=L.keymap;self.previewer=L.previewer;self.prompt=L.prompt or L.fzf_opts["--prompt"]self:_set_autoclose(L.autoclose)g=self;return self end;function f:get_winopts(R,_)if not R or not d.nvim_win_is_valid(R)then return end;local a2={}for a1,T in pairs(_)do if a.nvim_has_option(a1)then a2[a1]=d.nvim_win_get_option(R,a1)end end;return a2 end;function f:set_winopts(R,_)if not R or not d.nvim_win_is_valid(R)then return end;for a1,a3 in pairs(_)do if a.nvim_has_option(a1)then pcall(vim.api.nvim_win_set_option,R,a1,a3)end end end;function f:attach_previewer(a4)if self._previewer and self._previewer.close then if not self._previewer.preview_bufnr and self:validate_preview()then self._previewer.preview_bufnr=vim.api.nvim_win_get_buf(self.preview_winid)end;self._previewer:close()end;if self._previewer and self._previewer.win_leave then self._previewer:win_leave()end;self._previewer=a4;self.previewer_is_builtin=a4 and type(a4.display_entry)=="function"end;function f:fs_preview_layout(a5)local a6=self.prev_winopts;local a7=self.border_winopts;if not a5 or self.winopts.split or not a6 or not a7 or vim.tbl_isempty(a6)or vim.tbl_isempty(a7)then return a6,a7 end;local w=self.winopts.preview_pos;local a8=0;local a9=0;if w=="down"or w=="up"then a9=vim.o.columns-a7.width;if w=="down"then a8=vim.o.lines-a7.row-a7.height-vim.o.cmdheight elseif w=="up"then a8=a7.row-a7.height end;a7.col=0;a6.col=a7.col+1 elseif w=="left"or w=="right"then a8=vim.o.lines-a7.height-vim.o.cmdheight;if w=="left"then a7.col=a7.col-1;a6.col=a6.col-1;a9=a7.col-a7.width elseif w=="right"then a9=vim.o.columns-a7.col-a7.width end;a7.row=0;a6.row=a7.row+1 end;a6.height=a6.height+a8;a7.height=a7.height+a8;a6.width=a6.width+a9;a7.width=a7.width+a9;return a6,a7 end;function f:preview_layout()if self.winopts.split and self.previewer_is_builtin then local aa=e.getwininfo(self.fzf_winid)[1]local v=vim.wo[self.fzf_winid].signcolumn=="no"and 1 or 0;self.layout=self:generate_layout({row=aa.winrow,col=aa.wincol,height=aa.height,width=d.nvim_win_get_width(self.fzf_winid),signcol_width=v,preview_pos=self.winopts.preview_pos,preview_size=self.winopts.preview_size,split=self.winopts.split})end;if not self.layout then return{},{}end;local D=self.layout.preview.anchor;local r,s=self.layout.preview.row,self.layout.preview.col;local u,t=self.layout.preview.width,self.layout.preview.height;if not D or not u or u<1 or not t or t<1 then return{},{}end;local q={relative="editor",focusable=false,style="minimal"}if self.winopts.split then q.relative="win"end;local ab=vim.tbl_extend("force",q,{focusable=true,anchor=D,width=u,height=t,col=s,row=r})local a7=vim.tbl_extend("force",q,{anchor=D,width=u+2,height=t+2,col=D:match("W")and s-1 or s+1,row=D:match("N")and r-1 or r+1})return ab,a7 end;function f:validate_preview()return not self.closing and self.preview_winid and self.preview_winid>0 and d.nvim_win_is_valid(self.preview_winid)and self.border_winid and self.border_winid>0 and d.nvim_win_is_valid(self.border_winid)end;function f:preview_winids()return self.preview_winid,self.border_winid end;function f:redraw_preview_border()local ac=self.border_buf;local a7=self.border_winopts;local I=self.winopts.nohl_borderchars;local u,t=a7.width,a7.height;local ad=I[1]..I[2]:rep(u-2)..I[3]local ae=I[8]..(" "):rep(u-2)..I[4]local af=I[7]..I[6]:rep(u-2)..I[5]local X={ad}for T=1,t-2 do table.insert(X,ae)end;table.insert(X,af)if not ac then ac=d.nvim_create_buf(false,true)vim.bo[ac].modifiable=true;vim.bo[ac].bufhidden="wipe"end;d.nvim_buf_set_lines(ac,0,-1,1,X)if self.border_winid and vim.api.nvim_win_is_valid(self.border_winid)then vim.fn.clearmatches(self.border_winid)end;return ac end;function f:redraw_preview()if not self.previewer_is_builtin or self.preview_hidden then return end;self.prev_winopts,self.border_winopts=self:preview_layout()if vim.tbl_isempty(self.prev_winopts)or vim.tbl_isempty(self.border_winopts)then return-1,-1 end;if self.fullscreen then self.prev_winopts,self.border_winopts=self:fs_preview_layout(self.fullscreen)end;if self:validate_preview()then self.border_buf=d.nvim_win_get_buf(self.border_winid)self:redraw_preview_border()d.nvim_win_set_config(self.border_winid,self.border_winopts)local ag=self:get_winopts(self.preview_winid,self._previewer:gen_winopts())d.nvim_win_set_config(self.preview_winid,self.prev_winopts)self:set_winopts(self.preview_winid,ag)else local ah=d.nvim_create_buf(false,true)self.prev_winopts.noautocmd=true;self.border_winopts.noautocmd=true;d.nvim_buf_set_option(ah,"bufhidden","wipe")self.border_buf=self:redraw_preview_border()self.preview_winid=d.nvim_open_win(ah,false,self.prev_winopts)self.border_winid=d.nvim_open_win(self.border_buf,false,self.border_winopts)d.nvim_win_set_option(self.border_winid,"wrap",false)d.nvim_win_set_var(self.preview_winid,"fzf_lua_preview",true)d.nvim_win_set_var(self.border_winid,"fzf_lua_preview",true)end;self:reset_win_highlights(self.border_winid)self:reset_win_highlights(self.preview_winid)self._previewer:display_last_entry()return self.preview_winid,self.border_winid end;function f:validate()return self.fzf_winid and self.fzf_winid>0 and d.nvim_win_is_valid(self.fzf_winid)end;function f:fs_fzf_layout(a5,q)if not a5 or self.winopts.split then return q end;if not self.previewer_is_builtin or self.preview_hidden then q.col=0;q.row=0;q.width=vim.o.columns;q.height=vim.o.lines-vim.o.cmdheight-2 else local w=self.winopts.preview_pos;if w=="down"or w=="up"then q.col=0;q.width=vim.o.columns;if w=="down"then q.height=q.height+q.row;q.row=0 elseif w=="up"then q.height=q.height+vim.o.lines-q.row-q.height-vim.o.cmdheight-2 end elseif w=="left"or w=="right"then q.row=0;q.height=vim.o.lines-vim.o.cmdheight-2;if w=="right"then q.width=q.width+q.col;q.col=0 elseif w=="left"then q.width=q.width+vim.o.columns-q.col-q.width-1 end end end;return q end;function f:redraw()self.winopts=K(self._o)if not self.winopts.split and self.previewer_is_builtin then self.layout=self:generate_layout(self.winopts)end;if self:validate()then self:redraw_main()end;if self:validate_preview()then self:redraw_preview()end end;function f:redraw_main()if self.winopts.split then return end;local ai=self._previewer and self.preview_hidden and self._previewer.toggle_behavior~="extend"local aj=self.winopts.relative or"editor"local ak,X=vim.o.columns,vim.o.lines;if aj=="win"then ak,X=vim.api.nvim_win_get_width(0),vim.api.nvim_win_get_height(0)end;local q=a.tbl_deep_clone(self.winopts)if self.layout and not ai then q=a.tbl_deep_clone(self.layout.fzf)end;if self.fullscreen then q=self:fs_fzf_layout(self.fullscreen,q)end;local al={width=q.width or math.min(ak-4,math.max(80,ak-20)),height=q.height or math.min(X-4,math.max(20,X-10)),style="minimal",relative=aj,border=self.winopts.border,title=a.__HAS_NVIM_09 and self.winopts.title or nil,title_pos=a.__HAS_NVIM_09 and self.winopts.title_pos or nil}al.row=q.row or math.floor((X-al.height)/2-1)al.col=q.col or math.floor((ak-al.width)/2)if self.winopts._border and self.winopts._border=="none"then al.border=self.winopts._border;al.width=al.width+2;al.height=al.height+2 end;if type(al.border)=="table"then local function am(an,ao)for T,J in ipairs(ao)do if an[J]and#an[J]>0 then return false end end;return true end;al.height=al.height+(am(al.border,{2})and 1 or 0)+(am(al.border,{6})and 1 or 0)al.width=al.width+(am(al.border,{4})and 1 or 0)+(am(al.border,{8})and 1 or 0)end;if self:validate()then if self._previewer and self._previewer.clear_on_redraw and self._previewer.clear_preview_buf then self._previewer:clear_preview_buf(true)self._previewer:clear_cached_buffers()end;d.nvim_win_set_config(self.fzf_winid,al)else local ap=vim.o.cursorline;self.fzf_bufnr=vim.api.nvim_create_buf(false,true)self.fzf_winid=a.nvim_open_win(self.fzf_bufnr,true,al)if vim.o.hlsearch and vim.v.hlsearch==1 then self.hls_on_close=true;vim.cmd("nohls")end;if vim.o.cursorline~=ap then vim.o.cursorline=ap end end end;function f:set_redraw_autocmd()vim.cmd("augroup FzfLua")vim.cmd(string.format([[au VimResized <buffer=%d> lua require("fzf-lua").redraw()]],self.fzf_bufnr))vim.cmd("augroup END")end;function f:set_winleave_autocmd()vim.cmd("augroup FzfLua")vim.cmd("au!")vim.cmd(string.format("au WinLeave <buffer=%d> %s",self.fzf_bufnr,[[lua require('fzf-lua.win').win_leave()]]))vim.cmd("augroup END")end;function f:set_tmp_buffer()if not self:validate()then return end;local aq=self.fzf_bufnr;self.fzf_bufnr=d.nvim_create_buf(false,true)vim.api.nvim_win_set_buf(self.fzf_winid,self.fzf_bufnr)a.nvim_buf_delete(aq,{force=true})self:set_winleave_autocmd()self:set_redraw_autocmd()vim.api.nvim_win_set_option(self.fzf_winid,"cursorline",false)return self.fzf_bufnr end;function f:set_style_minimal(ar)if not tonumber(ar)or not d.nvim_win_is_valid(ar)then return end;vim.wo[ar].number=false;vim.wo[ar].relativenumber=false;vim.wo[ar].cursorline=false;vim.wo[ar].cursorcolumn=false;vim.wo[ar].spell=false;vim.wo[ar].list=false;vim.wo[ar].signcolumn="no"vim.wo[ar].foldcolumn="0"vim.wo[ar].colorcolumn=""end;function f:create()if self._o._is_fzf_tmux then return end;if self._reuse then self:set_tmp_buffer()self:setup_keybinds()if self.winopts.on_create and type(self.winopts.on_create)=="function"then self.winopts.on_create()end;vim.cmd("redraw")return self.fzf_bufnr end;if not self.winopts.split and self.previewer_is_builtin then self.layout=self:generate_layout(self.winopts)end;self.src_bufnr=vim.api.nvim_get_current_buf()self.src_winid=vim.api.nvim_get_current_win()if self.winopts.split then vim.cmd(self.winopts.split)self.fzf_bufnr=vim.api.nvim_get_current_buf()self.fzf_winid=vim.api.nvim_get_current_win()self:set_style_minimal(self.fzf_winid)else self:redraw_main()end;self:set_winleave_autocmd()self:set_redraw_autocmd()self:reset_win_highlights(self.fzf_winid)if self.winopts.on_create and type(self.winopts.on_create)=="function"then self.winopts.on_create()end;self:redraw_preview()self:setup_keybinds()return self.fzf_bufnr end;function f:close_preview()if self._previewer and self._previewer.close then self._previewer:close()end;if self.border_winid and vim.api.nvim_win_is_valid(self.border_winid)then a.nvim_win_close(self.border_winid,true)end;if self.border_buf and vim.api.nvim_buf_is_valid(self.border_buf)then vim.api.nvim_buf_delete(self.border_buf,{force=true})end;if self.preview_winid and vim.api.nvim_win_is_valid(self.preview_winid)then a.nvim_win_close(self.preview_winid,true)end;if self._sbuf1 and vim.api.nvim_buf_is_valid(self._sbuf1)then vim.api.nvim_buf_delete(self._sbuf1,{force=true})end;if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then a.nvim_win_close(self._swin1,true)end;if self._sbuf2 and vim.api.nvim_buf_is_valid(self._sbuf2)then vim.api.nvim_buf_delete(self._sbuf2,{force=true})end;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then a.nvim_win_close(self._swin2,true)end;self._sbuf1,self._sbuf2,self._swin1,self._swin2=nil,nil,nil,nil;self.border_buf=nil;self.border_winid=nil;self.preview_winid=nil end;function f:close(W)if W and W~=self.fzf_bufnr then return end;self.closing=true;self.close_help()self:close_preview()if self.fzf_winid and vim.api.nvim_win_is_valid(self.fzf_winid)then pcall(vim.api.nvim_win_close,self.fzf_winid,true)end;if self.fzf_bufnr and vim.api.nvim_buf_is_valid(self.fzf_bufnr)then vim.api.nvim_buf_delete(self.fzf_bufnr,{force=true})end;if self.winopts and self.winopts.split and self.src_winid and self.src_winid>0 and self.src_winid~=vim.api.nvim_get_current_win()and vim.api.nvim_win_is_valid(self.src_winid)then vim.api.nvim_set_current_win(self.src_winid)end;if self.hls_on_close then vim.o.hlsearch=true;self.hls_on_close=nil end;if self.winopts and type(self.winopts.on_close)=="function"then self.winopts.on_close()end;self.closing=nil;self._reuse=nil;g=nil;a.reset_info()end;function f.win_leave()local self=g;if not self then return end;if self._previewer and self._previewer.win_leave then self._previewer:win_leave()end;if not self or self.closing then return end;g:close()end;function f:update_scrollbar_border(L)if L.bar_height>=L.line_count then return end;local I=self.winopts.nohl_borderchars;local as=self.winopts.preview.scrollchars;local at=self.hls.scrollborder_f;local au=self.hls.scrollborder_e;if type(self.winopts.preview.scrollchar)=="string"and#self.winopts.preview.scrollchar>0 then as[1]=self.winopts.preview.scrollchar end;for J=1,2 do if not as[J]or#as[J]==0 then as[J]=I[4]end end;L.bar_offset=L.bar_offset+1;local av=function(an,aw)local ax=a.tbl_length(an)if ax==0 or a.tbl_length(an[ax])==8 then table.insert(an,{})ax=ax+1 end;table.insert(an[ax],aw)end;local ay,az={},{}local X=d.nvim_buf_get_lines(self.border_buf,1,-2,true)for J=1,#X do local aA,aB=X[J],e.strwidth(X[J])local aC;if J>=L.bar_offset and J<L.bar_offset+L.bar_height then aC=as[1]av(ay,{J+1,aB+2,1})else aC=as[2]av(az,{J+1,aB+2,1})end;X[J]=e.strcharpart(aA,0,aB-1)..aC end;d.nvim_buf_set_lines(self.border_buf,1,-2,0,X)if at or au then pcall(vim.api.nvim_win_call,self.border_winid,function()if at then for J=1,#ay do e.matchaddpos(at,ay[J],11)end end;if au then for J=1,#az do e.matchaddpos(au,az[J],11)end end end)end end;local function aD(aE)if aE and vim.api.nvim_buf_is_valid(aE)then return aE end;aE=d.nvim_create_buf(false,true)vim.bo[aE].modifiable=true;vim.bo[aE].bufhidden="wipe"return aE end;function f:hide_scrollbar()if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then vim.api.nvim_win_hide(self._swin1)self._swin1=nil end;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then vim.api.nvim_win_hide(self._swin2)self._swin2=nil end end;function f:update_scrollbar_float(L)if L.bar_height>=L.line_count then self:hide_scrollbar()else local aF=L.wininfo;local aG={}aG.relative="editor"aG.style="minimal"aG.width=1;aG.height=aF.height;aG.row=aF.winrow-1;aG.col=aF.wincol+aF.width+(tonumber(self.winopts.preview.scrolloff)or-2)aG.zindex=aF.zindex or 997;if self._swin1 and vim.api.nvim_win_is_valid(self._swin1)then vim.api.nvim_win_set_config(self._swin1,aG)else aG.noautocmd=true;self._sbuf1=aD(self._sbuf1)self._swin1=vim.api.nvim_open_win(self._sbuf1,false,aG)local S=self.hls.scrollfloat_e or"PmenuSbar"vim.api.nvim_win_set_option(self._swin1,"winhighlight",("Normal:%s,NormalNC:%s,NormalFloat:%s"):format(S,S,S))end;local aH=a.tbl_deep_clone(aG)aH.height=L.bar_height;aH.row=aG.row+L.bar_offset;aH.zindex=aG.zindex+1;if self._swin2 and vim.api.nvim_win_is_valid(self._swin2)then vim.api.nvim_win_set_config(self._swin2,aH)else aH.noautocmd=true;self._sbuf2=aD(self._sbuf2)self._swin2=vim.api.nvim_open_win(self._sbuf2,false,aH)local S=self.hls.scrollfloat_f or"PmenuThumb"vim.api.nvim_win_set_option(self._swin2,"winhighlight",("Normal:%s,NormalNC:%s,NormalFloat:%s"):format(S,S,S))end end end;function f:update_scrollbar(aI)if not self.winopts.preview.scrollbar or self.winopts.preview.scrollbar=="none"or not self:validate_preview()then return end;if aI then if self.winopts.preview.scrollbar=="float"then self:hide_scrollbar()end;return end;local aJ=d.nvim_win_get_buf(self.preview_winid)local L={}L.wininfo=e.getwininfo(self.preview_winid)[1]L.line_count=d.nvim_buf_line_count(aJ)local aK,t=L.wininfo.topline,L.wininfo.height;L.bar_height=math.min(t,math.ceil(t*t/L.line_count))L.bar_offset=math.min(t-L.bar_height,math.floor(t*aK/L.line_count))if self.winopts.preview.scrollbar=="float"then self:update_scrollbar_float(L)else self:update_scrollbar_border(L)end end;function f:update_title(aL)local aM=7;local ac=d.nvim_win_get_buf(self.border_winid)local ad=d.nvim_buf_get_lines(ac,0,1,0)[1]local u=e.strwidth(ad)if#aL>u-aM then aL=aL:sub(1,u-aM).." "end;local aN=e.strwidth(aL)local aO=e.strcharpart(ad,0,3)if self.winopts.preview.title_pos=="center"then aO=e.strcharpart(ad,0,a.round((u-aN)/2))elseif self.winopts.preview.title_pos=="right"then aO=e.strcharpart(ad,0,u-(aN+3))end;local aP=e.strcharpart(ad,aN+e.strwidth(aO),u)local aA=("%s%s%s"):format(aO,aL,aP)d.nvim_buf_set_lines(ac,0,1,1,{aA})if self.hls.preview_title and#aL>0 then pcall(vim.api.nvim_win_call,self.border_winid,function()e.matchaddpos(self.hls.preview_title,{{1,#aO+1,#aL}},11)end)end end;function f.toggle_fullscreen()if not g or g.winopts.split then return end;local self=g;self.fullscreen=not self.fullscreen;self:hide_scrollbar()if self:validate()then self:redraw_main()end;if self:validate_preview()then self:redraw_preview()end end;function f.toggle_preview()if not g then return end;local self=g;self.preview_hidden=not self.preview_hidden;if self.winopts.split and self._fzf_toggle_prev_bind then a.feed_keys_termcodes(self._fzf_toggle_prev_bind)end;if self.preview_hidden and self:validate_preview()then self:close_preview()self:redraw_main()elseif not self.preview_hidden then self:redraw_main()self:redraw_preview()end;g=self end;function f.toggle_preview_wrap()if not g then return end;local self=g;self.preview_wrap=not d.nvim_win_get_option(self.preview_winid,"wrap")if self and self:validate_preview()then d.nvim_win_set_option(self.preview_winid,"wrap",self.preview_wrap)end end;function f.toggle_preview_cw(aQ)if not g or g.winopts.split or not g:validate_preview()then return end;local self=g;local O={"up","right","down","left"}local aR;for J=1,#O do if O[J]==self.winopts.preview_pos then aR=J;break end end;if not aR then return end;local aS=aQ>0 and aR+1 or aR-1;if aS<1 then aS=#O end;if aS>#O then aS=1 end;self.winopts.preview_pos=O[aS]self.layout=self:generate_layout(self.winopts)self:hide_scrollbar()if self:validate()then self:redraw_main()end;if self:validate_preview()then self:redraw_preview()end end;function f.preview_scroll(aQ)if not g then return end;local self=g;if self:validate_preview()and self._previewer and self._previewer.scroll then self._previewer:scroll(aQ)end end;function f.close_help()if not g or not g.km_winid then return end;local self=g;if vim.api.nvim_win_is_valid(self.km_winid)then a.nvim_win_close(self.km_winid,true)end;if vim.api.nvim_buf_is_valid(self.km_bufnr)then vim.api.nvim_buf_delete(self.km_bufnr,{force=true})end;self.km_winid=nil;self.km_bufnr=nil end;function f.toggle_help()if not g then return end;local self=g;if self.km_winid then self.close_help()return end;local _={}_.max_height=_.max_height or math.floor(0.4*vim.o.lines)_.mode_width=_.mode_width or 10;_.name_width=_.name_width or 28;_.keybind_width=_.keybind_width or 14;_.normal_hl=_.normal_hl or self.hls.help_normal;_.border_hl=_.border_hl or self.hls.help_border;_.winblend=_.winblend or 0;_.column_padding=_.column_padding or"  "_.column_width=_.keybind_width+_.name_width+#_.column_padding+2;_.close_with_action=_.close_with_action or true;local function aT(aU,j,k,aV,aW,aX)return("%s%%-%ds %%-%ds %%-%ds"):format(_.column_padding,aV,aW,aX):format("`"..aU.."`","|"..j.."|","*"..k.."*")end;local aY={}local aZ=self.previewer_is_builtin and"builtin"or"fzf"local a_={["load"]=true,["zero"]=true}for T,aU in ipairs({"builtin","fzf"})do for j,k in pairs(self.keymap[aU])do if a_[j]then goto b0 end;if type(k)=="table"then k=k.desc or k[1]end;if k and(not i[k]or aU==aZ)then if aU=="builtin"then j=a.neovim_bind_to_fzf(j)end;table.insert(aY,aT(aU,j,k,_.mode_width,_.keybind_width,_.name_width))end::b0::end end;if self.actions then for j,k in pairs(self.actions)do if j=="default"then j="enter"end;if type(k)=="table"then k=b.get_action_helpstr(k[1])or k elseif k then k=b.get_action_helpstr(k)or k end;if k then table.insert(aY,aT("action",j,("%s"):format(k):gsub(" ",""),_.mode_width,_.keybind_width,_.name_width))end end end;table.sort(aY,function(b1,b2)if b1<b2 then return true else return false end end)local function b3(an,b4)local b5=#an>0 and an[#an]if not b5 or#b5+#b4>vim.o.columns then table.insert(an,b4)else an[#an]=b5 ..b4 end end;local X={}for T,b6 in ipairs(aY)do b3(X,b6)end;local t=#X<_.max_height and#X or _.max_height;X={}for b7=0,math.floor(vim.o.columns/(_.column_width+#_.column_padding))do for J=1,t do local aR=t*b7+J;X[J]=b7==0 and aY[aR]or X[J]..(aY[aR]or"")end end;local q={relative="editor",style="minimal",width=vim.o.columns,height=t,row=vim.o.lines-t-vim.o.cmdheight-2,col=1,border={" ","─"," "," "," "," "," "," "},zindex=999}self.km_bufnr=vim.api.nvim_create_buf(false,true)vim.api.nvim_buf_set_option(self.km_bufnr,"bufhidden","wipe")self.km_winid=vim.api.nvim_open_win(self.km_bufnr,false,q)vim.api.nvim_buf_set_name(self.km_bufnr,"_FzfLuaHelp")vim.api.nvim_win_set_option(self.km_winid,"winhl",string.format("Normal:%s,FloatBorder:%s",_.normal_hl,_.border_hl))vim.api.nvim_win_set_option(self.km_winid,"winblend",_.winblend)vim.api.nvim_win_set_option(self.km_winid,"foldenable",false)vim.api.nvim_win_set_option(self.km_winid,"wrap",false)vim.api.nvim_buf_set_option(self.km_bufnr,"filetype","help")vim.cmd(string.format("autocmd BufLeave <buffer> ++once lua %s",table.concat({string.format("pcall(vim.api.nvim_win_close, %s, true)",self.km_winid),string.format("pcall(vim.api.nvim_buf_delete, %s, {force=true})",self.km_bufnr)},";")))vim.api.nvim_buf_set_lines(self.km_bufnr,0,-1,false,X)end;return f
