local a=require('gitsigns.async')local b=a.wrap;local c=a.void;local d=a.scheduler;local e=require('gitsigns.cache').cache;local f=require('gitsigns.config').config;local g=require('gitsigns.util')local h=vim.loop;local i=vim.api;local j=i.nvim_get_current_buf;local k=i.nvim_create_namespace('gitsigns_blame')local l=assert(h.new_timer())local m={}local n=b(h.timer_start,4)local function o(p,q,r)r=r or{}r.id=1;i.nvim_buf_set_extmark(p,k,q-1,0,r)end;local function s(p)local t=i.nvim_buf_get_extmark_by_id(p,k,1,{})if t[1]then return t[1]+1 end end;local function u(p)p=p or j()if not i.nvim_buf_is_valid(p)then return end;i.nvim_buf_del_extmark(p,k,1)vim.b[p].gitsigns_blame_line_dict=nil end;local v=1000;local w={}w.contents={}function w:add(p,x,y)if not y then return end;if not f._blame_cache then return end;local z=self.contents[p]if z.size<=v then z.cache[x]=y;z.size=z.size+1 end end;function w:get(p,x)if not f._blame_cache then return end;local A=vim.b[p].changedtick;if not self.contents[p]or self.contents[p].tick~=A then self.contents[p]={tick=A,cache={},size=0}end;return self.contents[p].cache[x]end;local function B(C,D,E)if E.author==D then E.author='You'end;return g.expand_format(C,E,f.current_line_blame_formatter_opts.relative_time)end;local function F(G)local H={}for I,J in ipairs(G)do H[#H+1]=J[1]end;return table.concat(H)end;local K=false;local function L(p,x,r)local M=w:get(p,x)if M then return M end;if K then return end;K=true;local N=g.buf_lines(p)local O=e[p]M=O.git_obj:run_blame(N,x,r.ignore_whitespace)w:add(p,x,M)K=false;return M end;local function P(p,x,Q,r)local O=e[p]local G;local R=Q.author=='Not Committed Yet'and f.current_line_blame_formatter_nc or f.current_line_blame_formatter;if type(R)=='string'then G={{B(R,O.git_obj.repo.username,Q),'GitSignsCurrentLineBlame'}}else G=R(O.git_obj.repo.username,Q,f.current_line_blame_formatter_opts)end;vim.b[p].gitsigns_blame_line=F(G)if r.virt_text then o(p,x,{virt_text=G,virt_text_pos=r.virt_text_pos,priority=r.virt_text_priority,hl_mode='combine'})end end;local function S()return i.nvim_win_get_cursor(0)[1]end;local function T()local p=j()local x=S()local U=s(p)if U and x==U and w:get(p,x)then return end;if i.nvim_get_mode().mode=='i'then u(p)return end;if s(p)then u(p)o(p,x)end;if vim.fn.foldclosed(x)~=-1 then return end;local r=f.current_line_blame_opts;n(l,r.delay,0)d()local O=e[p]if not O or not O.git_obj.object_name then return end;local Q=L(p,x,r)d()local V=S()if p==j()and x~=V then T()return end;if not i.nvim_buf_is_loaded(p)then return end;vim.b[p].gitsigns_blame_line_dict=Q;if Q then P(p,x,Q,r)end end;local W=c(T)function m.setup()local X=i.nvim_create_augroup('gitsigns_blame',{})for Y,I in pairs(e)do u(Y)end;if f.current_line_blame then i.nvim_create_autocmd({'FocusGained','BufEnter','CursorMoved','CursorMovedI'},{group=X,callback=W})i.nvim_create_autocmd({'InsertEnter','FocusLost','BufLeave'},{group=X,callback=function()u()end})vim.schedule(W)end end;return m
