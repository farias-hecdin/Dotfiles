local a=require('gitsigns.hunks').create_hunk;local b=require('gitsigns.config').config;local c=require('gitsigns.async')local d={}local e=function(f,g,h,i,j)local k=vim.tbl_isempty(f)and''or table.concat(f,'\n')..'\n'local l=vim.tbl_isempty(g)and''or table.concat(g,'\n')..'\n'return vim.diff(k,l,{result_type='indices',algorithm=h,indent_heuristic=i,linematch=j})end;local m=c.wrap(function(f,g,h,i,j,n)local k=vim.tbl_isempty(f)and''or table.concat(f,'\n')..'\n'local l=vim.tbl_isempty(g)and''or table.concat(g,'\n')..'\n'vim.loop.new_work(function(o,p,q,r,s)return vim.mpack.encode(vim.diff(o,p,{result_type='indices',algorithm=q,indent_heuristic=r,linematch=s}))end,function(t)n(vim.mpack.decode(t))end):queue(k,l,h,i,j)end,6)d.run_diff=c.void(function(f,g,u,i,j)local v;if b._threaded_diff and vim.is_thread then v=m else v=e end;local w=v(f,g,u,i,j)local x={}for y,t in ipairs(w)do local z,A,B,C=t[1],t[2],t[3],t[4]local D=a(z,A,B,C)if A>0 then for E=z,z+A-1 do D.removed.lines[#D.removed.lines+1]=f[E]or''end end;if C>0 then for E=B,B+C-1 do D.added.lines[#D.added.lines+1]=g[E]or''end end;x[#x+1]=D end;return x end)local F=5;local function G(x)local H={x[1]}for I=2,#x do local J,K=H[#H],x[I]if not J or not K then break end;if K.added.start-J.added.start-J.added.count<F then J.added.count=K.added.start+K.added.count-J.added.start;J.removed.count=K.removed.start+K.removed.count-J.removed.start;if J.added.count>0 or J.removed.count>0 then J.type='change'end else H[#H+1]=K end end;return H end;function d.run_word_diff(L,M)local N={}local O={}if#L~=#M then return O,N end;for E=1,#L do local k,l=vim.split(L[E],''),vim.split(M[E],'')local x={}for y,t in ipairs(e(k,l))do local z,A,B,C=t[1],t[2],t[3],t[4]if A==0 then z=z+1 end;if C==0 then B=B+1 end;x[#x+1]=a(z,A,B,C)end;x=G(x)for y,J in ipairs(x)do N[#N+1]={E,J.type,J.added.start,J.added.start+J.added.count}O[#O+1]={E,J.type,J.removed.start,J.removed.start+J.removed.count}end end;return O,N end;return d
