local a=vim.api;local b=vim.loop;local c=require('gitsigns.status')local d=require('gitsigns.async')local e=require('gitsigns.debug.log')local f=require('gitsigns.util')local g=require('gitsigns.cache').cache;local h=require('gitsigns.config').config;local i=require('gitsigns.debounce').debounce_trailing;local j=e.dprint;local k=e.dprintf;local function l(m,n)local o=g[m]local p=o.git_obj;local q=p:has_moved()if q then k('File moved to %s',q)p.relpath=q;if not p.orig_relpath then p.orig_relpath=n end elseif p.orig_relpath then local r=p.repo.toplevel..f.path_sep..p.orig_relpath;if not p:file_info(r).relpath then return end;k('Moved file reset')p.relpath=p.orig_relpath;p.orig_relpath=nil else return end;p.file=p.repo.toplevel..f.path_sep..p.relpath;o.file=p.file;p:update_file_info()d.scheduler()local s=f.bufexists(o.file)local t=a.nvim_buf_get_name(m)if not s then f.buf_rename(m,o.file)end;local u=s and'Cannot rename'or'Renamed'k('%s buffer %d from %s to %s',u,m,t,o.file)end;local v=d.void(function(m)if not g[m]then j('Has detached, aborting')return end;local p=g[m].git_obj;p.repo:update_abbrev_head()d.scheduler()c:update(m,{head=p.repo.abbrev_head})local w=p.object_name~=nil;local n=p.relpath;p:update_file_info()if h.watch_gitdir.follow_files and w and not p.object_name then l(m,n)end;g[m]:invalidate()require('gitsigns.manager').update(m,g[m])end)local function x(y)return vim.inspect(y,{indent='',newline=' '})end;local z={}function z.watch_gitdir(m,A)local B=i(200,v)k('Watching git dir')local C=assert(b.new_fs_event())C:start(A,{},function(D,E,F)local G='watcher_cb'if D then k('Git dir update error: %s',D)return end;local H=string.format("Git dir update: '%s' %s",E,x(F))if vim.endswith(E,'.lock')then k('%s (ignoring)',H)return end;j(H)B(m)end)return C end;return z
