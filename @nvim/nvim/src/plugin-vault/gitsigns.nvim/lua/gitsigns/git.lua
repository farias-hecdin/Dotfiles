local a=require('gitsigns.async')local b=require('gitsigns.async').scheduler;local c=require('gitsigns.debug.log')local d=require('gitsigns.util')local e=require('gitsigns.subprocess')local f=require('gitsigns.config')local g=f.config;local h=require('gitsigns.hunks')local i=vim.loop;local j=vim.startswith;local k=require('gitsigns.debug.log').dprint;local l=require('gitsigns.debug.log').eprint;local m=require('gitsigns.message').error;local n={}local function o(p)for q,r in ipairs(vim.split(p,d.path_sep))do if r=='.git'then return true end end;return false end;local s={}n.Obj=s;local t={}n.Repo=t;local function u(v)assert(v:match('%d+%.%d+%.%w+'),'Invalid git version: '..v)local w={}local x=vim.split(v,'%.')w.major=assert(tonumber(x[1]))w.minor=assert(tonumber(x[2]))if x[3]=='GIT'then w.patch=0 else w.patch=assert(tonumber(x[3]))end;return w end;local function y(v)if not n.version then return false end;if n.version.major<v[1]then return false end;if v[2]and n.version.minor<v[2]then return false end;if v[3]and n.version.patch<v[3]then return false end;return true end;function n._set_version(v)if v~='auto'then n.version=u(v)return end;local q,q,z,A=a.wait(2,e.run_job,{command='git',args={'--version'}})local B=vim.split(z or'','\n',{plain=true})[1]if not B then m("Unable to detect git version as 'git --version' failed to return anything")l(A)return end;assert(type(B)=='string','Unexpected output: '..B)assert(j(B,'git version'),'Unexpected output: '..B)local x=vim.split(B,'%s+')n.version=u(x[3])end;local C=a.create(function(D,E)if not n.version then n._set_version(g._git_version)end;E=E or{}E.command=E.command or'git'E.args=E.command=='git'and{'--no-pager','--literal-pathspecs','-c','gc.auto=0',unpack(D)}or D;if not E.cwd and not i.cwd()then E.cwd=vim.env.HOME end;local q,q,z,A=a.wait(2,e.run_job,E)if not E.suppress_stderr then if A then local F=table.concat({E.command,unpack(D)},' ')c.eprintf("Received stderr when running command\n'%s':\n%s",F,A)end end;local G=vim.split(z or'','\n',{plain=true})if G[#G]==''then G[#G]=nil end;if c.verbose then c.vprintf('%d lines:',#G)for H=1,math.min(10,#G)do c.vprintf('\t%s',G[H])end end;return G,A end,2)function n.diff(I,J,K,L)return C({'-c','core.safecrlf=false','diff','--color=never','--'..(K and''or'no-')..'indent-heuristic','--diff-algorithm='..L,'--patch-with-raw','--unified=0',I,J})end;local function M(N,O,P,Q)if not N then return O end;if O=='HEAD'then local R=C({'rev-parse','--short','HEAD'},{command=Q or'git',suppress_stderr=true,cwd=P})[1]or''if c.debug_mode and R~=''then R='HEAD'end;if d.path_exists(N..'/rebase-merge')or d.path_exists(N..'/rebase-apply')then return R..'(rebasing)'end;return R end;return O end;local S=jit and jit.os=='Windows'and vim.fn.executable('cygpath')==1;local T;if S then T=function(P)return C({'-aw',P},{command='cygpath'})[1]end end;local function U(P)if P and S and not i.fs_stat(P)then P=T(P)end;return P end;function n.get_repo_info(P,Q,N,V)local W=y({2,13})local X=W and'--absolute-git-dir'or'--git-dir'b()local D={}if N then vim.list_extend(D,{'--git-dir',N})end;if V then vim.list_extend(D,{'--work-tree',V})end;vim.list_extend(D,{'rev-parse','--show-toplevel',X,'--abbrev-ref','HEAD'})local Y=C(D,{command=Q or'git',suppress_stderr=true,cwd=V or P})local w={toplevel=U(Y[1]),gitdir=U(Y[2])}w.abbrev_head=M(w.gitdir,Y[3],P,Q)if w.gitdir and not W then w.gitdir=assert(i.fs_realpath(w.gitdir))end;w.detached=w.toplevel and w.gitdir~=w.toplevel..'/.git'return w end;function t:command(D,E)E=E or{}E.cwd=self.toplevel;local Z={'--git-dir',self.gitdir}if self.detached then vim.list_extend(Z,{'--work-tree',self.toplevel})end;vim.list_extend(Z,D)return C(Z,E)end;function t:files_changed()local Y=self:command({'status','--porcelain','--ignore-submodules'})local w={}for q,B in ipairs(Y)do if B:sub(1,2):match('^.M')then w[#w+1]=B:sub(4,-1)end end;return w end;local function _(...)local a0={}for H,a1 in ipairs({...})do a0[H]=string.char(a1)end;return table.concat(a0)end;local a2={['utf-8']=_(0xef,0xbb,0xbf),['utf-16le']=_(0xff,0xfe),['utf-16']=_(0xfe,0xff),['utf-16be']=_(0xfe,0xff),['utf-32le']=_(0xff,0xfe,0x00,0x00),['utf-32']=_(0xff,0xfe,0x00,0x00),['utf-32be']=_(0x00,0x00,0xfe,0xff),['utf-7']=_(0x2b,0x2f,0x76),['utf-1']=_(0xf7,0x54,0x4c)}local function a3(a4,a5)local a6=a2[a5]if a6 and vim.startswith(a4,a6)then return a4:sub(a6:len()+1)end;return a4 end;local function a7(a5)if vim.startswith(a5,'utf-16')then return false elseif vim.startswith(a5,'utf-32')then return false end;return true end;function t:get_show_text(a8,a5)local z,A=self:command({'show',a8},{suppress_stderr=true})if a5 and a5~='utf-8'and a7(a5)then z[1]=a3(z[1],a5)for H,a9 in ipairs(z)do z[H]=vim.iconv(a9,a5,'utf-8')end end;return z,A end;function t:update_abbrev_head()self.abbrev_head=n.get_repo_info(self.toplevel).abbrev_head end;function t.new(aa,N,V)local self=setmetatable({},{__index=t})self.username=C({'config','user.name'})[1]local ab=n.get_repo_info(aa,nil,N,V)for ac,ad in pairs(ab)do self[ac]=ad end;if g.yadm.enable and not self.gitdir then if vim.startswith(aa,assert(os.getenv('HOME')))and#C({'ls-files',aa},{command='yadm'})~=0 then n.get_repo_info(aa,'yadm',N,V)local ae=n.get_repo_info(aa,'yadm',N,V)for ac,ad in pairs(ae)do self[ac]=ad end end end;return self end;function s:command(D,E)return self.repo:command(D,E)end;function s:update_file_info(af,ag)local ah=self.object_name;local ai=self:file_info(self.file,ag)if af then self.relpath=ai.relpath end;self.object_name=ai.object_name;self.mode_bits=ai.mode_bits;self.has_conflicts=ai.has_conflicts;self.i_crlf=ai.i_crlf;self.w_crlf=ai.w_crlf;return ah~=self.object_name end;function s:file_info(p,ag)local Y,A=self:command({'-c','core.quotepath=off','ls-files','--stage','--others','--exclude-standard','--eol',p or self.file},{suppress_stderr=true})if A and not ag then if not A:match('^warning: could not open directory .*: No such file or directory')then c.eprint(A)end end;local aj={}for q,B in ipairs(Y)do local x=vim.split(B,'\t')if#x>2 then local ak=vim.split(x[2],'%s+')aj.i_crlf=ak[1]=='i/crlf'aj.w_crlf=ak[2]=='w/crlf'aj.relpath=x[3]local al=vim.split(x[1],'%s+')local am=tonumber(al[3])if am<=1 then aj.mode_bits=al[1]aj.object_name=al[2]else aj.has_conflicts=true end else aj.relpath=x[2]end end;return aj end;function s:get_show_text(an)if not self.relpath then return{}end;local z,A=self.repo:get_show_text(an..':'..self.relpath,self.encoding)if not self.i_crlf and self.w_crlf then for H=1,#z do z[H]=z[H]..'\r'end end;return z,A end;s.unstage_file=function(self)self:command({'reset',self.file})end;function s:run_blame(ao,ap,aq)local ar={author='Not Committed Yet',['author_mail']='<not.committed.yet>',committer='Not Committed Yet',['committer_mail']='<not.committed.yet>'}if not self.object_name or self.repo.abbrev_head==''then return ar end;local D={'blame','--contents','-','-L',ap..',+1','--line-porcelain',self.file}if aq then D[#D+1]='-w'end;local as=self.repo.toplevel..'/.git-blame-ignore-revs'if i.fs_stat(as)then vim.list_extend(D,{'--ignore-revs-file',as})end;local Y=self:command(D,{writer=ao})if#Y==0 then return end;local at=vim.split(table.remove(Y,1),' ')local w={}w.sha=at[1]w.orig_lnum=tonumber(at[2])w.final_lnum=tonumber(at[3])w.abbrev_sha=string.sub(w.sha,1,8)for q,a9 in ipairs(Y)do if not j(a9,'\t')then local au=vim.split(a9,' ')local av=table.remove(au,1):gsub('-','_')w[av]=table.concat(au,' ')if av=='previous'then w.previous_sha=au[1]w.previous_filename=au[2]end end end;if w.author_mail=='<external.file>'then w=vim.tbl_extend('force',w,ar)end;return w end;local function aw(ax)if ax.object_name and not ax.has_conflicts then return end;if not ax.object_name then ax:command({'add','--intent-to-add',ax.file})else local ab=string.format('%s,%s,%s',ax.mode_bits,ax.object_name,ax.relpath)ax:command({'update-index','--add','--cacheinfo',ab})end;ax:update_file_info()end;function s:stage_lines(ao)local z=self:command({'hash-object','-w','--path',self.relpath,'--stdin'},{writer=ao})local ay=z[1]self:command({'update-index','--cacheinfo',string.format('%s,%s,%s',self.mode_bits,ay,self.relpath)})end;function s.stage_hunks(self,az,aA)aw(self)local aB=h.create_patch(self.relpath,az,self.mode_bits,aA)if not self.i_crlf and self.w_crlf then for H=1,#aB do aB[H]=aB[H]:gsub('\r$','')end end;self:command({'apply','--whitespace=nowarn','--cached','--unidiff-zero','-'},{writer=aB})end;function s:has_moved()local aC=self:command({'diff','--name-status','-C','--cached'})local aD=self.orig_relpath or self.relpath;for q,a9 in ipairs(aC)do local x=vim.split(a9,'%s+')if#x==3 then local aE,aF=x[2],x[3]if aD==aE then self.orig_relpath=aD;self.relpath=aF;self.file=self.repo.toplevel..'/'..aF;return aF end end end end;function s.new(p,a5,N,V)if o(p)then k('In git dir')return nil end;local self=setmetatable({},{__index=s})self.file=p;self.encoding=a5;self.repo=t.new(d.dirname(p),N,V)if not self.repo.gitdir then k('Not in git repo')return nil end;local ag=N~=nil and V~=nil;self:update_file_info(true,ag)return self end;return n
