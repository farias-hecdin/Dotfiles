local a={}local b=vim.api;local function c(d,e)return b.nvim_buf_call(d,function()local f=0;for g,h in ipairs(e)do if vim.fn.type(h)==vim.v.t_string then local i=vim.fn.strdisplaywidth(h)if i>f then f=i end end end;return f+1 end)end;local function j(k,l)local m=0;for g=0,50 do local n=b.nvim_win_get_height(k)if m>n then break end;local o=b.nvim_win_call(k,function()return vim.fn.line('w$')end)if o>=l then break end;m=n+l-o;b.nvim_win_set_height(k,m)end end;local function p(q,r)for g,s in ipairs(q)do if s.start_row then s.start_row=s.start_row+r end;if s.end_row then s.end_row=s.end_row+r end end end;local function t(u)local e={}local v={}local w=0;for g,x in ipairs(u)do local y={}local z=0;for g,A in ipairs(x)do local B=A[1]local C=A[2]y[#y+1]=B;local D=w;local E=z;local F=vim.split(B,'\n')if#F>1 then z=0;w=w+#F-1 else z=z+#B end;if type(C)=='string'then v[#v+1]={hl_group=C,start_row=D,end_row=w,start_col=E,end_col=z}else p(C,D)vim.list_extend(v,C)end end;for g,h in ipairs(vim.split(table.concat(y,''),'\n'))do e[#e+1]=h end;w=w+1 end;return e,v end;local function G(H)for g,k in ipairs(b.nvim_list_wins())do if vim.w[k].gitsigns_preview~=nil and vim.w[k].gitsigns_preview~=H then pcall(b.nvim_win_close,k,true)end end end;function a.close(H)for g,k in ipairs(b.nvim_list_wins())do if vim.w[k].gitsigns_preview==H then pcall(b.nvim_win_close,k,true)end end end;function a.create0(e,I,H)G(H)local F=vim.bo.tabstop;local d=b.nvim_create_buf(false,true)assert(d,'Failed to create buffer')vim.bo[d].modifiable=true;b.nvim_buf_set_lines(d,0,-1,true,e)vim.bo[d].modifiable=false;vim.bo[d].tabstop=F;local J=vim.deepcopy(I or{})J.height=J.height or#e;J.width=J.width or c(d,e)local k=b.nvim_open_win(d,false,J)vim.w[k].gitsigns_preview=H or true;if not I.height then j(k,#e)end;if J.style=='minimal'then vim.wo[k].signcolumn='no'end;local K='gitsigns_popup'local L=b.nvim_create_augroup(K,{})local M=b.nvim_win_get_cursor(0)b.nvim_create_autocmd({'CursorMoved','CursorMovedI'},{group=L,callback=function()local N=b.nvim_win_get_cursor(0)if(M[1]~=N[1]or M[2]~=N[2])and b.nvim_get_current_win()~=k then b.nvim_create_augroup(K,{})pcall(b.nvim_win_close,k,true)return end;M=N end})b.nvim_create_autocmd('WinClosed',{pattern=tostring(k),group=L,callback=function()b.nvim_create_augroup(K,{})end})b.nvim_create_autocmd('WinScrolled',{buffer=b.nvim_get_current_buf(),group=L,callback=function()if b.nvim_win_is_valid(k)then b.nvim_win_set_config(k,J)end end})return k,d end;local O=b.nvim_create_namespace('gitsigns_popup')function a.create(P,I,H)local e,Q=t(P)local k,d=a.create0(e,I,H)for g,C in ipairs(Q)do local R,S=pcall(b.nvim_buf_set_extmark,d,O,C.start_row,C.start_col or 0,{hl_group=C.hl_group,end_row=C.end_row,end_col=C.end_col,hl_eol=true})if not R then error(vim.inspect(C)..'\n'..S)end end;return k,d end;function a.is_open(H)for g,k in ipairs(b.nvim_list_wins())do if vim.w[k].gitsigns_preview==H then return k end end;return nil end;function a.focus_open(H)local k=a.is_open(H)if k then b.nvim_set_current_win(k)end;return k end;return a
