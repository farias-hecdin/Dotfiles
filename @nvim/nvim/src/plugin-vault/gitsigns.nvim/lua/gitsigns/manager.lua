local a=require('gitsigns.async').void;local b=require('gitsigns.async').wrap;local c=require('gitsigns.cache')local d=c.cache;local e=require('gitsigns.signs')local f=require('gitsigns.status')local g=require('gitsigns.debounce').debounce_trailing;local h=require('gitsigns.debounce').throttle_by_id;local i=require('gitsigns.debug.log')local j=i.dprint;local k=i.dprintf;local l=i.eprint;local m=require('gitsigns.subprocess')local n=require('gitsigns.util')local o=require('gitsigns.diff')local p=require('gitsigns.hunks')local q=require('gitsigns.config').config;local r=vim.api;local s;local t;local u={}local v=b(function(w,x)vim.schedule(function()if vim.api.nvim_buf_is_valid(w)then x()end end)end,2)local function y(z,A,B,C,D,E,F)if E then A:remove(z)end;for G,H in ipairs(B or{})do if E and G==1 then A:add(z,p.calc_signs(H,H.added.start,H.added.start,F))end;if C<=H.vend and D>=H.added.start then A:add(z,p.calc_signs(H,C,D,F))end;if H.added.start>D then break end end end;local function I(z,C,D,E,F)local J=d[z]if not J then return end;y(z,s,J.hunks,C,D,E,F)if t then y(z,t,J.hunks_staged,C,D,E,false)end end;function u.on_lines(w,K,L,M)local J=d[w]if not J then j('Cache for buffer was nil. Detaching')return true end;s:on_lines(w,K,L,M)if t then t:on_lines(w,K,L,M)end;if J.hunks and s:contains(w,K,M)then J.force_next_update=true end;if t then if J.hunks_staged and t:contains(w,K,M)then J.force_next_update=true end end;u.update_debounced(w,d[w])end;local N=r.nvim_create_namespace('gitsigns')local function O(z,P)if vim.fn.foldclosed(P+1)~=-1 then return end;local J=d[z]if not J or not J.hunks then return end;local Q=r.nvim_buf_get_lines(z,P,P+1,false)[1]if not Q then return end;local R=P+1;local H=p.find_hunk(R,J.hunks)if not H then return end;if H.added.count~=H.removed.count then return end;local S=R-H.added.start+1;local T=H.added.lines[S]local U=H.removed.lines[S]local V,W=require('gitsigns.diff_int').run_word_diff({U},{T})local X=#Q;for V,Y in ipairs(W)do local Z,_,a0=Y[2],Y[3]-1,Y[4]-1;if a0==_ then a0=_+1 end;local a1=Z=='add'and'GitSignsAddLnInline'or Z=='change'and'GitSignsChangeLnInline'or'GitSignsDeleteLnInline'local a2={ephemeral=true,priority=1000}if a0>X and a0==_+1 then a2.virt_text={{' ',a1}}a2.virt_text_pos='overlay'else a2.end_col=a0;a2.hl_group=a1 end;r.nvim_buf_set_extmark(z,N,P,_,a2)r.nvim__buf_redraw_range(z,P,P+1)end end;local a3=r.nvim_create_namespace('gitsigns_removed')local a4=300;local function a5(z)local a6=r.nvim_buf_get_extmarks(z,a3,0,-1,{})for V,a7 in ipairs(a6)do r.nvim_buf_del_extmark(z,a3,a7[1])end end;function u.show_deleted(z,a8,H)local a9={}for G,Q in ipairs(H.removed.lines)do local aa={}local ab=1;if q.word_diff then local ac=require('gitsigns.diff_int').run_word_diff({H.removed.lines[G]},{H.added.lines[G]})for V,Y in ipairs(ac)do local ad,_,a0=Y[1],Y[3],Y[4]if ad>1 then break end;aa[#aa+1]={Q:sub(ab,_-1),'GitSignsDeleteVirtLn'}aa[#aa+1]={Q:sub(_,a0-1),'GitSignsDeleteVirtLnInline'}ab=a0 end end;if#Q>0 then aa[#aa+1]={Q:sub(ab,-1),'GitSignsDeleteVirtLn'}end;local ae=string.rep(' ',a4-#Q)aa[#aa+1]={ae,'GitSignsDeleteVirtLn'}a9[G]=aa end;local af=H.added.start==0 and H.type=='delete'local P=af and 0 or H.added.start-1;r.nvim_buf_set_extmark(z,a8,P,-1,{virt_lines=a9,virt_lines_above=H.type~='delete'or af})end;local function ag(ah,R,ai)local aj,ak=pcall(r.nvim_get_option_value,'statuscolumn',{win=ah,scope='local'})if aj and ak and ak~=''then local al,am=pcall(r.nvim_eval_statusline,ak,{winid=ah,use_statuscol_lnum=R,highlights=true})if al then return am.str,am.highlights end end;return string.format('%'..ai..'d',R)end;function u.show_deleted_in_float(z,a8,H)local an=r.nvim_get_current_win()local a9={}local ao=vim.fn.getwininfo(an)[1].textoff;for G=1,H.removed.count do local ap=ag(an,H.removed.start+G,ao-1)a9[G]={{ap,'LineNr'}}end;local af=H.added.start==0 and H.type=='delete'local aq=H.type~='delete'or af;local P=af and 0 or H.added.start-1;r.nvim_buf_set_extmark(z,a8,P,-1,{virt_lines=a9,virt_lines_above=aq,virt_lines_leftcol=true})local J=d[z]local ar=r.nvim_create_buf(false,true)r.nvim_buf_set_lines(ar,0,-1,false,J.compare_text)local ai=r.nvim_win_get_width(0)local as=aq and not af and 1 or 0;local at=r.nvim_open_win(ar,false,{relative='win',win=an,width=ai-ao,height=H.removed.count,anchor='SW',bufpos={H.added.start-as,0},style='minimal'})vim.bo[ar].filetype=vim.bo[z].filetype;vim.bo[ar].bufhidden='wipe'vim.wo[at].scrolloff=0;r.nvim_win_call(at,function()vim.cmd('normal '..'zR')vim.cmd('normal '..tostring(H.removed.start)..'gg')vim.cmd('normal '..vim.api.nvim_replace_termcodes('z<CR>',true,false,true))end)for G=H.removed.start,H.removed.start+H.removed.count do r.nvim_buf_set_extmark(ar,a8,G-1,0,{hl_group='GitSignsDeleteVirtLn',hl_eol=true,end_row=G,priority=1000})end;local au=require('gitsigns.diff_int').run_word_diff(H.removed.lines,H.added.lines)for V,Y in ipairs(au)do local av=H.removed.start-1+Y[1]-1;local aw=Y[3]-1;local ax=Y[4]-1;r.nvim_buf_set_extmark(ar,a8,av,aw,{hl_group='GitSignsDeleteVirtLnInline',end_col=ax,end_row=av,priority=1001})end;return at end;function u.show_added(z,ay,H)local av=H.added.start-1;for az=0,H.added.count-1 do local P=av+az;r.nvim_buf_set_extmark(z,ay,P,0,{end_row=P+1,hl_group='GitSignsAddPreview',hl_eol=true,priority=1000})end;local V,W=require('gitsigns.diff_int').run_word_diff(H.removed.lines,H.added.lines)for V,Y in ipairs(W)do local az,Z,_,a0=Y[1]-1,Y[2],Y[3]-1,Y[4]-1;r.nvim_buf_set_extmark(z,ay,av+az,_,{end_col=a0,hl_group=Z=='add'and'GitSignsAddInline'or Z=='change'and'GitSignsChangeInline'or'GitSignsDeleteInline',priority=1001})end end;local function aA(z)local J=d[z]a5(z)if q.show_deleted then for V,H in ipairs(J.hunks or{})do u.show_deleted(z,a3,H)end end end;local aB=0;u.update=h(function(z,J)local aC='update'J=J or d[z]if not J then l('Cache for buffer '..z..' was nil')return end;local aD,aE=J.hunks,J.hunks_staged;J.hunks,J.hunks_staged=nil,nil;v(z)local aF=n.buf_lines(z)local aG=J.git_obj;if not J.compare_text or q._refresh_staged_on_update then J.compare_text=aG:get_show_text(J:get_compare_rev())end;J.hunks=o(J.compare_text,aF)if q._signs_staged_enable then if not J.compare_text_head or q._refresh_staged_on_update then J.compare_text_head=aG:get_show_text(J:get_staged_compare_rev())end;local aH=o(J.compare_text_head,aF)J.hunks_staged=p.filter_common(aH,J.hunks)end;v(z)if J.force_next_update or p.compare_heads(J.hunks,aD)or p.compare_heads(J.hunks_staged,aE)then I(z,vim.fn.line('w0'),vim.fn.line('w$'),true,aG.object_name==nil)aA(z)J.force_next_update=false;r.nvim_exec_autocmds('User',{pattern='GitSignsUpdate',modeline=false})end;local aI=p.get_summary(J.hunks)aI.head=aG.repo.abbrev_head;f:update(z,aI)aB=aB+1;k('updates: %s, jobs: %s',aB,m.job_cnt)end,true)function u.detach(z,aJ)if not aJ then s:remove(z)if t then t:remove(z)end end end;function u.reset_signs()if s then s:reset()end;if t then t:reset()end end;local function aK(aL,aM,z,aN,aO)local J=d[z]if not J or not J.hunks then return false end;local aP=math.min(aO,r.nvim_buf_line_count(z))local F=J.git_obj.object_name==nil;I(z,aN+1,aP+1,false,F)if not(q.word_diff and q.diff_opts.internal)then return false end end;local function aQ(aL,aM,z,P)O(z,P)end;function u.setup()r.nvim_set_decoration_provider(N,{on_win=aK,on_line=aQ})s=e.new(q.signs)if q._signs_staged_enable then t=e.new(q._signs_staged,'staged')end;u.update_debounced=g(q.update_debounce,a(u.update))end;return u
