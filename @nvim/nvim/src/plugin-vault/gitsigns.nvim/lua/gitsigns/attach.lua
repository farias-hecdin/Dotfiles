local a=require('gitsigns.async')local b=require('gitsigns.git')local c=require('gitsigns.debug.log')local d=c.dprintf;local e=c.dprint;local f=require('gitsigns.manager')local g=require('gitsigns.highlight')local h=require('gitsigns.cache')local i=h.cache;local j=h.CacheEntry;local k=require('gitsigns.status')local l=require('gitsigns.config')local m=l.config;local n=require('gitsigns.async').void;local o=require('gitsigns.util')local p=require('gitsigns.debounce').throttle_by_id;local q=vim.api;local r=vim.loop;local s={}local t=false;local function u(v)if vim.fn.exists('*FugitiveReal')==0 then e('Fugitive not installed')return end;local w=vim.fn.FugitiveReal(v)local x=vim.fn.FugitiveParse(v)[1]:match('([^:]+):.*')if x=='0'then x=nil end;return w,x end;local function y(v)local z,z,A,x,B=v:find([[^gitsigns://(.*)/%.git/(.*):(.*)]])if x==':0'then x=nil end;if A then v=A..'/'..B end;return v,x end;local function C(D)local E=r.fs_realpath(q.nvim_buf_get_name(D))or q.nvim_buf_call(D,function()return vim.fn.expand('%:p')end)if not vim.wo.diff then if vim.startswith(E,'fugitive://')then local w,x=u(E)d("Fugitive buffer for file '%s' from path '%s'",w,E)w=r.fs_realpath(w)if w then return w,x end end;if vim.startswith(E,'gitsigns://')then local w,x=y(E)d("Gitsigns buffer for file '%s' from path '%s'",w,E)w=r.fs_realpath(w)if w then return w,x end end end;return E end;local function F(z,D,z,G,H,I,J)if G==H and H==I and J==0 then return end;return f.on_lines(D,G,H,I)end;local function K(z,D)local L='on_reload'e('Reload')f.update_debounced(D)end;local function M(z,D)s.detach(D,true)end;local function N(D)local O,P;if m._on_attach_pre then local Q=a.wrap(m._on_attach_pre,2)(D)d('ran on_attach_pre with result %s',vim.inspect(Q))if type(Q)=='table'then if type(Q.gitdir)=='string'then O=Q.gitdir end;if type(Q.toplevel)=='string'then P=Q.toplevel end end end;return O,P end;local function R(S,E,T)if not m.worktrees then return end;for z,U in ipairs(m.worktrees)do local V=b.Obj.new(E,T,U.gitdir,U.toplevel)if V and V.object_name then d('Using worktree %s',vim.inspect(U))return V end end end;local W=false;function s._setup()if W then return end;W=true;f.setup()g.setup_highlights()q.nvim_create_autocmd('ColorScheme',{group='gitsigns',callback=g.setup_highlights})q.nvim_create_autocmd('OptionSet',{group='gitsigns',pattern='fileformat',callback=function()require('gitsigns.actions').refresh()end})q.nvim_create_autocmd('QuickFixCmdPre',{group='gitsigns',pattern='*vimgrep*',callback=function()t=true end})q.nvim_create_autocmd('QuickFixCmdPost',{group='gitsigns',pattern='*vimgrep*',callback=function()t=false end})require('gitsigns.current_line_blame').setup()q.nvim_create_autocmd('VimLeavePre',{group='gitsigns',callback=s.detach_all})end;local X=p(function(Y,Z,_)local L='attach's._setup()if t then e('attaching is disabled')return end;if i[Y]then e('Already attached')return end;if _ then d('Attaching (trigger=%s)',_)else e('Attaching')end;if not q.nvim_buf_is_loaded(Y)then e('Non-loaded buffer')return end;local T=vim.bo[Y].fileencoding;if T==''then T='utf-8'end;local E;local x;local a0;local a1;if Z then a0=Z.gitdir;a1=Z.toplevel;E=Z.toplevel..o.path_sep..Z.file;x=Z.commit else if q.nvim_buf_line_count(Y)>m.max_file_length then e('Exceeds max_file_length')return end;if vim.bo[Y].buftype~=''then e('Non-normal buffer')return end;E,x=C(Y)local a2=o.dirname(E)if not a2 or not o.path_exists(a2)then e('Not a path')return end;a0,a1=N(Y)end;local V=b.Obj.new(E,T,a0,a1)if not V and not Z then V=R(Y,E,T)a.scheduler()end;if not V then e('Empty git obj')return end;local a3=V.repo;a.scheduler()k:update(Y,{head=a3.abbrev_head,root=a3.toplevel,gitdir=a3.gitdir})if vim.startswith(E,a3.gitdir..o.path_sep)then e('In non-standard git dir')return end;if not Z and(not o.path_exists(E)or r.fs_stat(E).type=='directory')then e('Not a file')return end;if not V.relpath then e('Cannot resolve file in repo')return end;if not m.attach_to_untracked and V.object_name==nil then e('File is untracked')return end;a.scheduler()if m.on_attach and m.on_attach(Y)==false then e('User on_attach() returned false')return end;i[Y]=j.new({base=Z and Z.base or m.base,file=E,commit=x,git_obj=V})if m.watch_gitdir.enable then local a4=require('gitsigns.watcher')i[Y].gitdir_watcher=a4.watch_gitdir(Y,a3.gitdir)end;if not q.nvim_buf_is_loaded(Y)then e('Un-loaded buffer')return end;q.nvim_buf_attach(Y,false,{on_lines=F,on_reload=K,on_detach=M})f.update(Y,i[Y])end)function s.detach_all()for a5,z in pairs(i)do s.detach(a5)end end;function s.detach(D,a6)D=D or q.nvim_get_current_buf()e('Detached')local a7=i[D]if not a7 then e('Cache was nil')return end;f.detach(D,a6)k:clear(D)h.destroy(D)end;s.attach=n(function(D,Z,a8)X(D or q.nvim_get_current_buf(),Z,a8)end)return s
