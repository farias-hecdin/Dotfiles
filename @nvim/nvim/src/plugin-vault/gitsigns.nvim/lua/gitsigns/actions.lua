local a=require('gitsigns.async').void;local b=require('gitsigns.async').scheduler;local c=require('gitsigns.config').config;local d=require('gitsigns.repeat').mk_repeatable;local e=require('gitsigns.popup')local f=require('gitsigns.util')local g=require('gitsigns.manager')local h=require('gitsigns.git')local i=require('gitsigns.diff')local j=require('gitsigns.cache')local k=j.cache;local l=require('gitsigns.hunks')local m=vim.api;local n=m.nvim_get_current_buf;local o={}local p={}local q={}local r=m.nvim_create_namespace('gitsigns_preview_inline')local function s(t)local u=vim.fn.systemlist({'git','rev-parse','--symbolic','--branches','--tags','--remotes'})return vim.tbl_filter(function(v)return vim.startswith(v,t)end,u)end;o.toggle_signs=function(w)if w~=nil then c.signcolumn=w else c.signcolumn=not c.signcolumn end;o.refresh()return c.signcolumn end;o.toggle_numhl=function(w)if w~=nil then c.numhl=w else c.numhl=not c.numhl end;o.refresh()return c.numhl end;o.toggle_linehl=function(w)if w~=nil then c.linehl=w else c.linehl=not c.linehl end;o.refresh()return c.linehl end;o.toggle_word_diff=function(w)if w~=nil then c.word_diff=w else c.word_diff=not c.word_diff end;m.nvim__buf_redraw_range(0,vim.fn.line('w0')-1,vim.fn.line('w$'))return c.word_diff end;o.toggle_current_line_blame=function(w)if w~=nil then c.current_line_blame=w else c.current_line_blame=not c.current_line_blame end;o.refresh()return c.current_line_blame end;o.toggle_deleted=function(w)if w~=nil then c.show_deleted=w else c.show_deleted=not c.show_deleted end;o.refresh()return c.show_deleted end;local function x(y,z)y=y or n()if not z then z={}vim.list_extend(z,k[y].hunks or{})vim.list_extend(z,k[y].hunks_staged or{})end;local A=m.nvim_win_get_cursor(0)[1]return l.find_hunk(A,z)end;local function B(y)g.update(y)b()if vim.wo.diff then require('gitsigns.diffthis').update(y)end end;local function C(D)local E;if D.range>0 then E={D.line1,D.line2}end;return E end;local function F(y,G,H,I)local z;if H then local J=f.buf_lines(y)local K;if I then K=G.compare_text_head else K=G.compare_text end;if not K then return end;z=i(K,J,false)b()return z end;if I then return G.hunks_staged end;return G.hunks end;local function L(y,E,H,I)local G=k[y]local z=F(y,G,H,I)local M;if E then table.sort(E)local N,O=E[1],E[2]M=l.create_partial_hunk(z,N,O)M.added.lines=m.nvim_buf_get_lines(y,N-1,O,false)M.removed.lines=vim.list_slice(G.compare_text,M.removed.start,M.removed.start+M.removed.count-1)else M=x(y,z)end;return M end;o.stage_hunk=d(a(function(E,P)P=P or{}local y=n()local G=k[y]if not G then return end;if not f.path_exists(G.file)then print('Error: Cannot stage lines. Please add the file to the working tree.')return end;local M=L(y,E,P.greedy~=false,false)local Q=false;if not M then Q=true;M=L(y,E,P.greedy~=false,true)end;if not M then return end;G.git_obj:stage_hunks({M},Q)table.insert(G.staged_diffs,M)G:invalidate()B(y)end))p.stage_hunk=function(R,D)o.stage_hunk(C(D))end;o.reset_hunk=d(a(function(E,P)P=P or{}local y=n()local G=k[y]if not G then return end;local M=L(y,E,P.greedy~=false,false)if not M then return end;local S,T;if M.type=='delete'then S=M.added.start;T=M.added.start else S=M.added.start-1;T=M.added.start-1+M.added.count end;f.set_lines(y,S,T,M.removed.lines)end))p.reset_hunk=function(R,D)o.reset_hunk(C(D))end;o.reset_buffer=function()local y=n()local G=k[y]if not G then return end;f.set_lines(y,0,-1,G.compare_text)end;o.undo_stage_hunk=a(function()local y=n()local G=k[y]if not G then return end;local M=table.remove(G.staged_diffs)if not M then print('No hunks to undo')return end;G.git_obj:stage_hunks({M},true)G:invalidate()B(y)end)o.stage_buffer=a(function()local y=n()local G=k[y]if not G then return end;local z=G.hunks;if#z==0 then print('No unstaged changes in file to stage')return end;if not f.path_exists(G.git_obj.file)then print('Error: Cannot stage file. Please add it to the working tree.')return end;G.git_obj:stage_hunks(z)for R,M in ipairs(z)do table.insert(G.staged_diffs,M)end;G:invalidate()B(y)end)o.reset_buffer_index=a(function()local y=n()local G=k[y]if not G then return end;G.staged_diffs={}G.git_obj:unstage_file()G:invalidate()B(y)end)local function U(P)if P.navigation_message==nil then P.navigation_message=not vim.opt.shortmess:get().S end;if P.wrap==nil then P.wrap=vim.opt.wrapscan:get()end;if P.foldopen==nil then P.foldopen=vim.tbl_contains(vim.opt.foldopen:get(),'search')end;if P.greedy==nil then P.greedy=true end end;local function V(W)if vim.in_fast_event()then vim.schedule(W)else vim.defer_fn(W,1)end end;local function X(y)return#m.nvim_buf_get_extmarks(y,r,0,-1,{limit=1})>0 end;local Y=a(function(P)U(P)local y=n()local G=k[y]if not G then return end;local z={}vim.list_extend(z,F(y,G,P.greedy,false)or{})local Z=F(y,G,P.greedy,true)or{}vim.list_extend(z,l.filter_common(Z,G.hunks)or{})if not z or vim.tbl_isempty(z)then if P.navigation_message then m.nvim_echo({{'No hunks','WarningMsg'}},false,{})end;return end;local _=m.nvim_win_get_cursor(0)[1]local M,a0=l.find_nearest_hunk(_,z,P.forwards,P.wrap)if M==nil then if P.navigation_message then m.nvim_echo({{'No more hunks','WarningMsg'}},false,{})end;return end;local a1=P.forwards and M.added.start or M.vend;if a1 then if a1==0 then a1=1 end;vim.cmd([[ normal! m' ]])m.nvim_win_set_cursor(0,{a1,0})if P.foldopen then vim.cmd('silent! foldopen!')end;if P.preview or e.is_open('hunk')~=nil then V(function()e.close('hunk')o.preview_hunk()end)elseif X(y)then V(o.preview_hunk_inline)end;if a0~=nil and P.navigation_message then m.nvim_echo({{string.format('Hunk %d of %d',a0,#z),'None'}},false,{})end end end)o.next_hunk=function(P)P=P or{}P.forwards=true;Y(P)end;o.prev_hunk=function(P)P=P or{}P.forwards=false;Y(P)end;local function a2(a3,a4)local a5=vim.deepcopy(a3)for R,_ in ipairs(a5)do for R,a6 in ipairs(_)do a6[1]=f.expand_format(a6[1],a4)end end;return a5 end;local function a7(M,a8)local a9={}local aa,ab=M.removed,M.added;if a8 then a9[#a9+1]={hl_group=a8,start_row=0,end_row=aa.count+ab.count}end;a9[#a9+1]={hl_group='GitSignsDeletePreview',start_row=0,end_row=aa.count}a9[#a9+1]={hl_group='GitSignsAddPreview',start_row=aa.count,end_row=aa.count+ab.count}if c.diff_opts.internal then local ac,ad=require('gitsigns.diff_int').run_word_diff(aa.lines,ab.lines)for R,ae in ipairs(ac)do a9[#a9+1]={hl_group='GitSignsDeleteInline',start_row=ae[1]-1,start_col=ae[3],end_col=ae[4]}end;for R,ae in ipairs(ad)do a9[#a9+1]={hl_group='GitSignsAddInline',start_row=ae[1]+aa.count-1,start_col=ae[3],end_col=ae[4]}end end;return a9 end;local function af(a3,M)for R,_ in ipairs(a3)do for R,a6 in ipairs(_)do local a8=a6[2]if a6[1]=='<hunk>'and type(a8)=='string'then a6[2]=a7(M,a8)end end end end;local function ag(ah)return function()local ai=vim.o.eventignore;vim.o.eventignore='all'ah()vim.o.eventignore=ai end end;o.preview_hunk=ag(function()if e.focus_open('hunk')then return end;local y=n()local M,a0=x(y)if not M then return end;local aj={{{'Hunk <hunk_no> of <num_hunks>','Title'}},{{'<hunk>','NormalFloat'}}}af(aj,M)local ak=a2(aj,{hunk_no=a0,num_hunks=#k[y].hunks,hunk=l.patch_lines(M,vim.bo[y].fileformat)})e.create(ak,c.preview_config,'hunk')end)local function al(y)m.nvim_buf_clear_namespace(y,r,0,-1)end;o.preview_hunk_inline=function()local y=n()local M=x(y)if not M then return end;al(y)local am;g.show_added(y,r,M)if c._inline2 then if M.removed.count>0 then am=g.show_deleted_in_float(y,r,M)end else g.show_deleted(y,r,M)end;m.nvim_create_autocmd({'CursorMoved','InsertEnter'},{buffer=y,desc='Clear gitsigns inline preview',callback=function()if am then pcall(m.nvim_win_close,am,true)end;al(y)end,once=true})if m.nvim_win_get_cursor(0)[1]==1 then local an=M.removed.count..'<C-y>'local ao=m.nvim_replace_termcodes(an,true,false,true)m.nvim_feedkeys(ao,'n',false)end end;o.select_hunk=function()local M=x()if not M then return end;vim.cmd('normal! '..M.added.start..'GV'..M.vend..'G')end;o.get_hunks=function(y)y=y or n()if not k[y]then return end;local a5={}for R,ap in ipairs(k[y].hunks or{})do a5[#a5+1]={head=ap.head,lines=l.patch_lines(ap,vim.bo[y].fileformat),type=ap.type,added=ap.added,removed=ap.removed}end;return a5 end;local function aq(ar,a4)local as={}if a4.previous then as=ar:get_show_text(a4.previous_sha..':'..a4.previous_filename)end;local at=ar:get_show_text(a4.sha..':'..a4.filename)local z=i(as,at,false)local M,au=l.find_hunk(a4.orig_lnum,z)return M,au,#z end;local function av(aw,ax)if not aw then return{{{'<author>','Label'}}}end;local ay={{'<abbrev_sha> ','Directory'},{'<author> ','MoreMsg'},{'(<author_time:%Y-%m-%d %H:%M>)','Label'},{':','NormalFloat'}}if ax then return{ay,{{'<body>','NormalFloat'}},{{'Hunk <hunk_no> of <num_hunks>','Title'},{' <hunk_head>','LineNr'}},{{'<hunk>','NormalFloat'}}}end;return{ay,{{'<summary>','NormalFloat'}}}end;o.blame_line=a(function(P)if e.focus_open('blame')then return end;P=P or{}local y=n()local G=k[y]if not G then return end;local az=vim.defer_fn(function()e.create({{{'Loading...','Title'}}},c.preview_config)end,1000)b()local J=f.buf_lines(y)local aA=vim.bo[y].fileformat;local A=m.nvim_win_get_cursor(0)[1]local aB=G.git_obj:run_blame(J,A,P.ignore_whitespace)pcall(function()az:close()end)assert(aB)local aw=aB.sha and tonumber('0x'..aB.sha)~=0;local aC=av(aw,P.full)if aw and P.full then aB.body=G.git_obj:command({'show','-s','--format=%B',aB.sha})local M;M,aB.hunk_no,aB.num_hunks=aq(G.git_obj.repo,aB)aB.hunk=l.patch_lines(M,aA)aB.hunk_head=M.head;af(aC,M)end;b()e.create(a2(aC,aB),c.preview_config,'blame')end)local function aD(aE,G,aF)G.base=aF;G:invalidate()B(aE)end;o.change_base=a(function(aF,aG)aF=f.calc_base(aF)if aG then c.base=aF;for y,G in pairs(k)do aD(y,G,aF)end else local y=n()local G=k[y]if not G then return end;aD(y,G,aF)end end)p.change_base=function(aH,R)o.change_base(aH[1],aH[2]or aH.global)end;q.change_base=s;o.reset_base=function(aG)o.change_base(nil,aG)end;p.reset_base=function(aH,R)o.change_base(nil,aH[1]or aH.global)end;o.diffthis=function(aF,P)if aF~=nil then aF=tostring(aF)end;P=P or{}local aI=require('gitsigns.diffthis')if not P.vertical then P.vertical=c.diff_opts.vertical end;aI.diffthis(aF,P)end;p.diffthis=function(aH,D)local P={vertical=aH.vertical,split=aH.split}if D.smods then if D.smods.split~=''and P.split==nil then P.split=D.smods.split end;if P.vertical==nil then P.vertical=D.smods.vertical end end;o.diffthis(aH[1],P)end;q.diffthis=s;o.show=function(aJ)local aI=require('gitsigns.diffthis')aI.show(aJ)end;q.show=s;local function aK(aL,z,aM)for au,M in ipairs(z)do aM[#aM+1]={bufnr=type(aL)=='number'and aL or nil,filename=type(aL)=='string'and aL or nil,lnum=M.added.start,text=string.format('Lines %d-%d (%d/%d)',M.added.start,M.vend,au,#z)}end end;local function aN(aO)aO=aO or n()if aO==0 then aO=n()end;local aM={}if type(aO)=='number'then local y=aO;if not k[y]then return end;aK(y,k[y].hunks,aM)elseif aO=='attached'then for y,G in pairs(k)do aK(y,G.hunks,aM)end elseif aO=='all'then local aP={}for R,G in pairs(k)do local ar=G.git_obj.repo;if not aP[ar.gitdir]then aP[ar.gitdir]=ar end end;local ar=h.Repo.new(assert(vim.loop.cwd()))if not aP[ar.gitdir]then aP[ar.gitdir]=ar end;for R,aQ in pairs(aP)do for R,ah in ipairs(aQ:files_changed())do local aR=aQ.toplevel..'/'..ah;local aS=vim.loop.fs_stat(aR)if aS and aS.type=='file'then local as=aQ:get_show_text(':0:'..ah)b()local z=i(as,f.file_lines(aR))aK(aR,z,aM)end end end end;return aM end;o.setqflist=a(function(aO,P)P=P or{}if P.open==nil then P.open=true end;local aT={items=aN(aO),title='Hunks'}b()if P.use_location_list then local aU=P.nr or 0;vim.fn.setloclist(aU,{},' ',aT)if P.open then if c.trouble then require('trouble').open('loclist')else vim.cmd([[lopen]])end end else vim.fn.setqflist({},' ',aT)if P.open then if c.trouble then require('trouble').open('quickfix')else vim.cmd([[copen]])end end end end)o.setloclist=function(aU,aO)o.setqflist(aO,{nr=aU,use_location_list=true})end;o.get_actions=function()local y=n()local G=k[y]if not G then return end;local M=x()local aV={}local function aW(aX)aV[#aV+1]=aX end;if M then aW('stage_hunk')aW('reset_hunk')aW('preview_hunk')aW('select_hunk')else aW('blame_line')end;if not vim.tbl_isempty(G.staged_diffs)then aW('undo_stage_hunk')end;local aY={}for R,as in ipairs(aV)do aY[as]=o[as]end;return aY end;o.refresh=a(function()g.reset_signs()require('gitsigns.highlight').setup_highlights()require('gitsigns.current_line_blame').setup()for aZ,a_ in pairs(k)do a_:invalidate()g.update(aZ,a_)end end)function o._get_cmd_func(b0)return p[b0]end;function o._get_cmp_func(b0)return q[b0]end;return o
