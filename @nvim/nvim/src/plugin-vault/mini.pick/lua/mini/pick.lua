local a={}local b={}a.setup=function(c)_G.MiniPick=a;c=b.setup_config(c)b.apply_config(c)b.create_autocommands(c)b.create_default_hl()vim.api.nvim_create_user_command('Pick',function(d)local e,f=b.command_parse_fargs(d.fargs)local g=a.registry[e]if g==nil then b.error(string.format('There is no picker named "%s" in registry.',e))end;g(f)end,{nargs='+',complete=b.command_complete,desc="Pick from 'mini.pick' registry"})end;a.config={delay={async=10,busy=50},mappings={caret_left='<Left>',caret_right='<Right>',choose='<CR>',choose_in_split='<C-s>',choose_in_tabpage='<C-t>',choose_in_vsplit='<C-v>',choose_marked='<M-CR>',delete_char='<BS>',delete_char_right='<Del>',delete_left='<C-u>',delete_word='<C-w>',mark='<C-x>',mark_all='<C-a>',move_down='<C-n>',move_start='<C-g>',move_up='<C-p>',paste='<C-r>',refine='<C-Space>',refine_marked='<M-Space>',scroll_down='<C-f>',scroll_left='<C-h>',scroll_right='<C-l>',scroll_up='<C-b>',stop='<Esc>',toggle_info='<S-Tab>',toggle_preview='<Tab>'},options={content_from_bottom=false,use_cache=false},source={items=nil,name=nil,cwd=nil,match=nil,show=nil,preview=nil,choose=nil,choose_marked=nil},window={config=nil}}a.start=function(h)if a.is_picker_active()then a.stop()return vim.defer_fn(function()if a.is_picker_active()then b.picker_stop(b.pickers.active,true)end;a.start(h)end,0.5)end;b.cache={}h=b.validate_picker_opts(h)local i=b.picker_new(h)b.pickers.active=i;b.picker_set_busy(i,true)local j=b.expand_callable(h.source.items)if vim.tbl_islist(j)then vim.schedule(function()a.set_picker_items(j)end)end;b.picker_track_lost_focus(i)return b.picker_advance(i)end;a.stop=function()if not a.is_picker_active()then return end;b.cache.is_force_stop_advance=true;if b.cache.is_in_getcharstr then vim.api.nvim_feedkeys('\3','t',true)end end;a.refresh=function()if not a.is_picker_active()then return end;b.picker_update(b.pickers.active,false,true)end;a.default_match=function(k,l,m)local n=a.is_picker_active()local o=n and a.set_picker_match_inds or function(p)return p end;local g=function()if#m==0 then return o(b.seq_along(k))end;local q,r=b.match_filter(l,k,m)if q==nil then return end;if r=='nosort'then return o(b.seq_along(k))end;local s=b.match_sort(q)if s==nil then return end;return o(s)end;if not n then return g()end;coroutine.resume(coroutine.create(g))end;a.default_show=function(t,j,m,h)local u={directory=' ',file=' ',none='  '}h=vim.tbl_deep_extend('force',{show_icons=false,icons=u},h or{})local v=vim.tbl_map(b.item_to_string,j)local w=string.rep(' ',vim.o.tabstop)v=vim.tbl_map(function(x)return x:gsub('\n',' '):gsub('\t',w)end,v)local y=h.show_icons and function(z)return b.get_icon(z,h.icons)end or function()return{text=''}end;local A=vim.tbl_map(y,v)local B={}for C,x in ipairs(v)do B[C]=A[C].text..x end;b.set_buflines(t,B)local D=b.ns_id.ranges;b.clear_namespace(t,D)if b.query_is_ignorecase(m)then v,m=vim.tbl_map(b.tolower,v),vim.tbl_map(b.tolower,m)end;local q,r,E=b.match_filter(b.seq_along(v),v,m)if q==nil then return end;local F=r=='fuzzy'and b.match_ranges_fuzzy or b.match_ranges_exact;local G=F(q,E,v)local H={hl_group='MiniPickMatchRanges',hl_mode='combine',priority=200}for C=1,#q do local I,J=q[C][3],G[C]local K=A[I].text:len()for L,M in ipairs(J)do H.end_row,H.end_col=I-1,K+M[2]b.set_extmark(t,D,I-1,K+M[1]-1,H)end end;if not h.show_icons then return end;local N={hl_mode='combine',priority=200}for C=1,#A do N.hl_group=A[C].hl;N.end_row,N.end_col=C-1,A[C].text:len()b.set_extmark(t,D,C-1,0,N)end end;a.default_preview=function(t,O,h)h=vim.tbl_deep_extend('force',{n_context_lines=2*vim.o.lines,line_position='top'},h or{})local P=b.parse_item(O)if P.type=='file'then return b.preview_file(t,P,h)end;if P.type=='directory'then return b.preview_directory(t,P)end;if P.type=='buffer'then return b.preview_buffer(t,P,h)end;b.preview_inspect(t,O)end;a.default_choose=function(O)if O==nil then return end;local Q=a.get_picker_state()local R=Q~=nil and Q.windows.target or vim.api.nvim_get_current_win()if not b.is_valid_win(R)then R=b.get_first_valid_normal_window()end;local P=b.parse_item(O)if P.type=='file'or P.type=='directory'then return b.choose_path(R,P)end;if P.type=='buffer'then return b.choose_buffer(R,P)end;b.choose_print(O)end;a.default_choose_marked=function(j,h)if not vim.tbl_islist(j)then b.error('`items` should be an array')end;if#j==0 then return end;h=vim.tbl_deep_extend('force',{list_type='quickfix'},h or{})local S={}for L,O in ipairs(j)do local P=b.parse_item(O)if P.type=='file'or P.type=='buffer'then local T={bufnr=P.buf_id,filename=P.path}T.lnum,T.col,T.text=P.lnum or 1,P.col or 1,P.text or''T.end_lnum,T.end_col=P.end_lnum,P.end_col;table.insert(S,T)end end;local n=a.is_picker_active()if#S==0 then if not n then return end;local U=a.get_picker_opts().source.choose;return U(j[1])end;local V='<No picker>'if n then local W,X=a.get_picker_opts().source.name,table.concat(a.get_picker_query())V=W..(X==''and''or' : '..X)end;local Y={items=S,title=V,nr='$'}if h.list_type=='location'then local R=a.get_picker_state().windows.target;if not b.is_valid_win(R)then R=b.get_first_valid_normal_window()end;vim.fn.setloclist(R,{},' ',Y)vim.schedule(function()vim.cmd('lopen')end)else vim.fn.setqflist({},' ',Y)vim.schedule(function()vim.cmd('copen')end)end end;a.ui_select=function(j,h,Z)local _=h.format_item or b.item_to_string;local a0={}for C=1,#j do table.insert(a0,{text=_(j[C]),item=j[C],index=C})end;local a1=vim.is_callable(h.preview_item)and h.preview_item or function(p)return vim.split(vim.inspect(p),'\n')end;local a2=function(t,O)b.set_buflines(t,a1(O.item))end;local a3=true;local U=function(O)a3=false;if O==nil then return end;Z(O.item,O.index)a.set_picker_target_window(vim.api.nvim_get_current_win())end;local a4={items=a0,name=h.kind or h.prompt,preview=a2,choose=U}local O=a.start({source=a4})if O==nil and a3 then Z(nil)end end;a.builtin={}a.builtin.files=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil},f or{})local a5=f.tool or b.files_get_tool()local a6=b.get_config().source.show or b.show_with_icons;local a7={source={name=string.format('Files (%s)',a5),show=a6}}h=vim.tbl_deep_extend('force',a7,h or{})if a5=='fallback'then h.source.items=function()b.files_fallback_items(h.source.cwd)end;return a.start(h)end;return a.builtin.cli({command=b.files_get_command(a5)},h)end;a.builtin.grep=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil,pattern=nil},f or{})local a5=f.tool or b.grep_get_tool()local a6=b.get_config().source.show or b.show_with_icons;local a7={source={name=string.format('Grep (%s)',a5),show=a6}}h=vim.tbl_deep_extend('force',a7,h or{})local a8=type(f.pattern)=='string'and f.pattern or vim.fn.input('Grep pattern: ')if a5=='fallback'then h.source.items=function()b.grep_fallback_items(a8,h.source.cwd)end;return a.start(h)end;return a.builtin.cli({command=b.grep_get_command(a5,a8)},h)end;a.builtin.grep_live=function(f,h)f=vim.tbl_deep_extend('force',{tool=nil},f or{})local a5=f.tool or b.grep_get_tool()if a5=='fallback'or not b.is_executable(a5)then b.error('`grep_live` needs non-fallback executable tool.')end;local a6=b.get_config().source.show or b.show_with_icons;local a7={source={name=string.format('Grep live (%s)',a5),show=a6}}h=vim.tbl_deep_extend('force',a7,h or{})local a9,aa={do_match=false,querytick=b.querytick},{cwd=h.source.cwd}local ab;local ac=function(L,L,m)pcall(vim.loop.process_kill,ab)if b.querytick==a9.querytick then return end;if#m==0 then return a.set_picker_items({},a9)end;a9.querytick=b.querytick;local ad=b.grep_get_command(a5,table.concat(m))ab=a.set_picker_items_from_cli(ad,{set_items_opts=a9,spawn_opts=aa})end;h=vim.tbl_deep_extend('force',h or{},{source={items={},match=ac}})return a.start(h)end;a.builtin.help=function(f,h)local ae=vim.api.nvim_create_buf(false,true)vim.bo[ae].buftype='help'local af=vim.api.nvim_buf_call(ae,function()return vim.fn.taglist('.*')end)vim.api.nvim_buf_delete(ae,{force=true})vim.tbl_map(function(ag)ag.text=ag.name end,af)local U=function(O)if O==nil then return end;vim.schedule(function()vim.cmd('help '..(O.name or''))end)end;local a2=function(t,O)vim.api.nvim_buf_call(t,function()vim.cmd('noautocmd edit '..vim.fn.fnameescape(O.filename))vim.bo.buflisted,vim.bo.bufhidden,vim.bo.syntax=false,'wipe','help'local ah=vim.v.hlsearch;local ai=string.gsub(O.cmd,'^/','/\\V')vim.cmd('silent keeppatterns '..ai)vim.cmd('let v:hlsearch='..ah)vim.cmd('normal! zt')end)end;local a4={items=af,name='Help',choose=U,choose_marked=choose_marked,preview=a2}h=vim.tbl_deep_extend('force',{source=a4},h or{})return a.start(h)end;a.builtin.buffers=function(f,h)f=vim.tbl_deep_extend('force',{include_current=true,include_unlisted=false},f or{})local aj=vim.api.nvim_exec('buffers'..(f.include_unlisted and'!'or''),true)local ak,al=vim.api.nvim_get_current_buf(),f.include_current;local j={}for L,x in ipairs(vim.split(aj,'\n'))do local am,e=x:match('^%s*%d+'),x:match('"(.*)"')local t=tonumber(am)local O={text=e,bufnr=t}if t~=ak or al then table.insert(j,O)end end;local a6=b.get_config().source.show or b.show_with_icons;local a7={source={name='Buffers',show=a6}}h=vim.tbl_deep_extend('force',a7,h or{},{source={items=j}})return a.start(h)end;a.builtin.cli=function(f,h)f=vim.tbl_deep_extend('force',{command={},postprocess=nil,spawn_opts={}},f or{})local e=string.format('CLI (%s)',tostring(f.command[1]or''))h=vim.tbl_deep_extend('force',{source={name=e}},h or{})f.spawn_opts.cwd=f.spawn_opts.cwd or h.source.cwd;local ad=f.command;local an={postprocess=f.postprocess,spawn_opts=f.spawn_opts}h.source.items=vim.schedule_wrap(function()a.set_picker_items_from_cli(ad,an)end)return a.start(h)end;a.builtin.resume=function()local i=b.pickers.latest;if i==nil then b.error('There is no picker to resume.')end;local t=b.picker_new_buf()local R=vim.api.nvim_get_current_win()local ao=b.picker_new_win(t,i.opts.window.config)i.buffers={main=t}i.windows={main=ao,target=R}i.view_state='main'b.pickers.active,b.cache=i,{}return b.picker_advance(i)end;a.registry={}for e,g in pairs(a.builtin)do a.registry[e]=function(f)return g(f)end end;if type(MiniExtra)=='table'then for e,g in pairs(MiniExtra.pickers)do a.registry[e]=function(f)return g(f)end end end;a.get_picker_items=function()return vim.deepcopy((b.pickers.active or{}).items)end;a.get_picker_stritems=function()return vim.deepcopy((b.pickers.active or{}).stritems)end;a.get_picker_matches=function()if not a.is_picker_active()then return end;local i=b.pickers.active;local j=i.items;if j==nil or#j==0 then return{}end;local ap={all_inds=vim.deepcopy(i.match_inds),current_ind=i.match_inds[i.current_ind]}ap.all=vim.tbl_map(function(aq)return j[aq]end,i.match_inds)ap.current=i.items[ap.current_ind]local ar=vim.tbl_keys(i.marked_inds_map)table.sort(ar)ap.marked_inds,ap.marked=ar,vim.tbl_map(function(aq)return j[aq]end,ar)return ap end;a.get_picker_opts=function()return vim.deepcopy((b.pickers.active or{}).opts)end;a.get_picker_state=function()if not a.is_picker_active()then return end;local i=b.pickers.active;return vim.deepcopy({buffers=i.buffers,windows=i.windows,caret=i.caret,is_busy=i.is_busy})end;a.get_picker_query=function()return vim.deepcopy((b.pickers.active or{}).query)end;a.set_picker_items=function(j,h)if not vim.tbl_islist(j)then b.error('`items` should be an array.')end;if not a.is_picker_active()then return end;h=vim.tbl_deep_extend('force',{do_match=true,querytick=nil},h or{})coroutine.wrap(b.picker_set_items)(b.pickers.active,j,h)end;a.set_picker_items_from_cli=function(ad,h)if not a.is_picker_active()then return end;local as=b.is_array_of(ad,'string')and#ad>=1;if not as then b.error('`command` should be an array of strings.')end;local a7={postprocess=b.cli_postprocess,set_items_opts={},spawn_opts={}}h=vim.tbl_deep_extend('force',a7,h or{})local at,au=ad[1],vim.list_slice(ad,2,#ad)local ab,av,aw=nil,nil,vim.loop.new_pipe()local aa=vim.tbl_deep_extend('force',h.spawn_opts,{args=au,stdio={nil,aw,nil}})if type(aa.cwd)=='string'then aa.cwd=b.full_path(aa.cwd)end;ab,av=vim.loop.spawn(at,aa,function()ab:close()end)local ax={}aw:read_start(function(ay,az)assert(not ay,ay)if az~=nil then return table.insert(ax,az)end;local j=vim.split(table.concat(ax),'\n')ax=nil;aw:close()vim.schedule(function()a.set_picker_items(h.postprocess(j),h.set_items_opts)end)end)return ab,av end;a.set_picker_match_inds=function(s)if not a.is_picker_active()then return end;if not b.is_array_of(s,'number')then b.error('`match_inds` should be an array of numbers.')end;b.picker_set_match_inds(b.pickers.active,s)b.picker_update(b.pickers.active,false)end;a.set_picker_opts=function(h)if not a.is_picker_active()then return end;b.pickers.active.opts=vim.tbl_deep_extend('force',b.pickers.active.opts,h or{})b.picker_update(b.pickers.active,true,true)end;a.set_picker_target_window=function(ao)if not a.is_picker_active()then return end;if not b.is_valid_win(ao)then b.error('`win_id` is not a valid window identifier.')end;b.pickers.active.windows.target=ao end;a.set_picker_query=function(m)if not a.is_picker_active()then return end;if not b.is_array_of(m,'string')then b.error('`query` should be an array of strings.')end;b.pickers.active.query,b.pickers.active.caret=m,#m+1;b.querytick=b.querytick+1;b.pickers.active.match_inds=b.seq_along(a.get_picker_items())b.picker_update(b.pickers.active,true)end;a.get_querytick=function()return b.querytick end;a.is_picker_active=function()return b.pickers.active~=nil end;a.poke_is_picker_active=function()local aA=coroutine.running()if aA==nil then return a.is_picker_active()end;b.schedule_resume_is_active(aA)return coroutine.yield()end;b.default_config=vim.deepcopy(a.config)b.ns_id={matches=vim.api.nvim_create_namespace('MiniPickMatches'),headers=vim.api.nvim_create_namespace('MiniPickHeaders'),preview=vim.api.nvim_create_namespace('MiniPickPreview'),ranges=vim.api.nvim_create_namespace('MiniPickRanges')}b.timers={busy=vim.loop.new_timer(),focus=vim.loop.new_timer(),getcharstr=vim.loop.new_timer()}b.pickers={active=nil,latest=nil}b.querytick=0;b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',vim.deepcopy(b.default_config),c or{})vim.validate({delay={c.delay,'table'},mappings={c.mappings,'table'},options={c.options,'table'},source={c.source,'table'},window={c.window,'table'}})vim.validate({['delay.async']={c.delay.async,'number'},['delay.busy']={c.delay.busy,'number'},['mappings.caret_left']={c.mappings.caret_left,'string'},['mappings.caret_right']={c.mappings.caret_right,'string'},['mappings.choose']={c.mappings.choose,'string'},['mappings.choose_in_split']={c.mappings.choose_in_split,'string'},['mappings.choose_in_tabpage']={c.mappings.choose_in_tabpage,'string'},['mappings.choose_in_vsplit']={c.mappings.choose_in_vsplit,'string'},['mappings.choose_marked']={c.mappings.choose_marked,'string'},['mappings.delete_char']={c.mappings.delete_char,'string'},['mappings.delete_char_right']={c.mappings.delete_char_right,'string'},['mappings.delete_left']={c.mappings.delete_left,'string'},['mappings.delete_word']={c.mappings.delete_word,'string'},['mappings.mark']={c.mappings.mark,'string'},['mappings.mark_all']={c.mappings.mark_all,'string'},['mappings.move_down']={c.mappings.move_down,'string'},['mappings.move_start']={c.mappings.move_start,'string'},['mappings.move_up']={c.mappings.move_up,'string'},['mappings.paste']={c.mappings.paste,'string'},['mappings.refine']={c.mappings.refine,'string'},['mappings.refine_marked']={c.mappings.refine_marked,'string'},['mappings.scroll_down']={c.mappings.scroll_down,'string'},['mappings.scroll_up']={c.mappings.scroll_up,'string'},['mappings.scroll_left']={c.mappings.scroll_left,'string'},['mappings.scroll_right']={c.mappings.scroll_right,'string'},['mappings.stop']={c.mappings.stop,'string'},['mappings.toggle_info']={c.mappings.toggle_info,'string'},['mappings.toggle_preview']={c.mappings.toggle_preview,'string'},['options.content_from_bottom']={c.options.content_from_bottom,'boolean'},['options.use_cache']={c.options.use_cache,'boolean'},['source.items']={c.source.items,'table',true},['source.name']={c.source.name,'string',true},['source.cwd']={c.source.cwd,'string',true},['source.match']={c.source.match,'function',true},['source.show']={c.source.show,'function',true},['source.preview']={c.source.preview,'function',true},['source.choose']={c.source.choose,'function',true},['source.choose_marked']={c.source.choose_marked,'function',true},['window.config']={c.window.config,function(p)return p==nil or type(p)=='table'or vim.is_callable(p)end,'table or callable'}})return c end;b.apply_config=function(c)a.config=c end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minipick_config or{},c or{})end;b.create_autocommands=function(c)local aB=vim.api.nvim_create_augroup('MiniPick',{})local aC=function(aD,a8,aE,aF)vim.api.nvim_create_autocmd(aD,{group=aB,pattern=a8,callback=aE,desc=aF})end;aC('VimResized','*',a.refresh,'Refresh on resize')end;b.create_default_hl=function()local aG=function(e,h)h.default=true;vim.api.nvim_set_hl(0,e,h)end;aG('MiniPickBorder',{link='FloatBorder'})aG('MiniPickBorderBusy',{link='DiagnosticFloatingWarn'})aG('MiniPickBorderText',{link='FloatTitle'})aG('MiniPickIconDirectory',{link='Directory'})aG('MiniPickIconFile',{link='MiniPickNormal'})aG('MiniPickHeader',{link='DiagnosticFloatingHint'})aG('MiniPickMatchCurrent',{link='CursorLine'})aG('MiniPickMatchMarked',{link='Visual'})aG('MiniPickMatchRanges',{link='DiagnosticFloatingHint'})aG('MiniPickNormal',{link='NormalFloat'})aG('MiniPickPreviewLine',{link='CursorLine'})aG('MiniPickPreviewRegion',{link='IncSearch'})aG('MiniPickPrompt',{link='DiagnosticFloatingInfo'})end;b.command_parse_fargs=function(aH)local e,aI=aH[1],vim.tbl_map(b.expandcmd,vim.list_slice(aH,2,#aH))local aJ=string.format('{ %s }',table.concat(aI,', '))local aK=loadstring('return '..aJ)if aK==nil then b.error('Could not convert extra command arguments to table: '..aJ)end;return e,aK()end;b.command_complete=function(L,z,aL)local aM,aN,aO=string.find(z,'^%S+%s+(%S*)')if aL<aM or aN<aL then return{}end;local aP=vim.tbl_filter(function(p)return tostring(p):find(aO,1,true)~=nil end,vim.tbl_keys(a.registry))table.sort(aP)return aP end;b.validate_picker_opts=function(h)h=h or{}if type(h)~='table'then b.error('Picker options should be table.')end;h=vim.deepcopy(b.get_config(h))local aQ=function(p,aR)if not vim.is_callable(p)then b.error(string.format('`%s` should be callable.',aR))end end;local a4=h.source;local j=a4.items or{}local aS=vim.tbl_islist(j)or vim.is_callable(j)if not aS then b.error('`source.items` should be array or callable.')end;a4.name=tostring(a4.name or'<No name>')if type(a4.cwd)=='string'then a4.cwd=b.full_path(a4.cwd)end;if a4.cwd==nil then a4.cwd=vim.fn.getcwd()end;if vim.fn.isdirectory(a4.cwd)==0 then b.error('`source.cwd` should be a valid directory path.')end;a4.match=a4.match or a.default_match;aQ(a4.match,'source.match')a4.show=a4.show or a.default_show;aQ(a4.show,'source.show')a4.preview=a4.preview or a.default_preview;aQ(a4.preview,'source.preview')a4.choose=a4.choose or a.default_choose;aQ(a4.choose,'source.choose')a4.choose_marked=a4.choose_marked or a.default_choose_marked;aQ(a4.choose_marked,'source.choose_marked')for aT,aU in pairs(h.delay)do local aV=type(aU)=='number'and aU>0;if not aV then b.error(string.format('`delay.%s` should be a positive number.',aT))end end;local aW=b.default_config.mappings;for aX,p in pairs(h.mappings)do if type(aX)~='string'then b.error('`mappings` should have only string fields.')end;local aY=aW[aX]~=nil;if aY and type(p)~='string'then b.error(string.format('Mapping for built-in action "%s" should be string.',aX))end;if not aY and not(type(p)=='table'and type(p.char)=='string'and vim.is_callable(p.func))then b.error(string.format('Mapping for custom action "%s" should be table with `char` and `func`.',aX))end end;local aZ=h.options;if type(aZ.content_from_bottom)~='boolean'then b.error('`options.content_from_bottom` should be boolean.')end;if type(aZ.use_cache)~='boolean'then b.error('`options.use_cache` should be boolean.')end;local a_=h.window.config;local b0=a_==nil or type(a_)=='table'or vim.is_callable(a_)if not b0 then b.error('`window.config` should be table or callable.')end;return h end;b.picker_new=function(h)local t=b.picker_new_buf()local R=vim.api.nvim_get_current_win()local ao=b.picker_new_win(t,h.window.config)local i={opts=h,items=nil,stritems=nil,stritems_ignorecase=nil,buffers={main=t,preview=nil,info=nil},windows={main=ao,target=R},query={},caret=1,match_inds=nil,marked_inds_map={},is_busy=false,cache={},view_state='main',visible_range={from=nil,to=nil},current_ind=nil}b.querytick=b.querytick+1;return i end;b.picker_advance=function(i)vim.schedule(function()vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStart'})end)local b1=b.picker_get_char_data(i)local b2,b3=false,false;for L=1,1000000 do if b.cache.is_force_stop_advance then break end;b.picker_update(i,b2)local b4=b.getcharstr(i.opts.delay.async)if b.cache.is_force_stop_advance then break end;b3=b4==nil;if b3 then break end;local b5=b1[b4]or{}b2=b5.name==nil or vim.startswith(b5.name,'delete')or b5.name=='paste'b3=b5.name=='stop'local b6;if b5.is_custom then b6=b5.func()else b6=(b5.func or b.picker_query_add)(i,b4)end;if b6 then break end end;local O;if not b3 then O=b.picker_get_current_item(i)end;b.cache.is_force_stop_advance=nil;b.picker_stop(i)return O end;b.picker_update=function(i,b2,b7)if b2 then b.picker_match(i)end;if b7 then local c=b.picker_compute_win_config(i.opts.window.config)vim.api.nvim_win_set_config(i.windows.main,c)b.picker_set_current_ind(i,i.current_ind,true)end;b.picker_set_bordertext(i)b.picker_set_lines(i)b.redraw()end;b.picker_new_buf=function()local t=b.create_scratch_buf()vim.bo[t].filetype='minipick'return t end;b.picker_new_win=function(t,a_)if vim.fn.mode()=='n'then b.cache.cmdheight=vim.o.cmdheight;vim.o.cmdheight=1;vim.cmd('noautocmd normal! :')end;local ao=vim.api.nvim_open_win(t,true,b.picker_compute_win_config(a_,true))vim.wo[ao].foldenable=false;vim.wo[ao].list=true;vim.wo[ao].listchars='extends:…'vim.wo[ao].scrolloff=0;vim.wo[ao].wrap=false;b.win_update_hl(ao,'NormalFloat','MiniPickNormal')b.win_update_hl(ao,'FloatBorder','MiniPickBorder')return ao end;b.picker_compute_win_config=function(a_,b8)local b9=vim.o.showtabline==2 or vim.o.showtabline==1 and#vim.api.nvim_list_tabpages()>1;local ba=vim.o.laststatus>0;local bb=vim.o.lines-vim.o.cmdheight-(b9 and 1 or 0)-(ba and 1 or 0)local bc=vim.o.columns;local bd={relative='editor',anchor='SW',width=math.floor(0.618*bc),height=math.floor(0.618*bb),col=0,row=bb+(b9 and 1 or 0),border='single',style='minimal',noautocmd=b8}local c=vim.tbl_deep_extend('force',bd,b.expand_callable(a_)or{})if c.border=='none'then c.border={'',' ','','','',' ','',''}end;c.height=math.min(c.height,bb-2)c.width=math.min(c.width,bc-2)return c end;b.picker_track_lost_focus=function(i)local be=vim.schedule_wrap(function()local bf=vim.api.nvim_get_current_win()==i.windows.main;local bg=bf and(b.cache.is_in_getcharstr or vim.fn.mode()~='n')if bg then return end;b.picker_stop(i,true)end)b.timers.focus:start(1000,1000,be)end;b.picker_set_items=function(i,j,h)local k,bh,bi={},{},b.tolower;local bj=b.poke_picker_throttle(h.querytick)for C,p in ipairs(j)do if not bj()then return end;local bk=b.item_to_string(p)table.insert(k,bk)table.insert(bh,bi(bk))end;i.items,i.stritems,i.stritems_ignorecase=j,k,bh;i.cache,i.marked_inds_map={},{}b.picker_set_busy(i,false)b.picker_set_match_inds(i,b.seq_along(j))b.picker_update(i,h.do_match)end;b.item_to_string=function(O)O=b.expand_callable(O)if type(O)=='string'then return O end;if type(O)=='table'and type(O.text)=='string'then return O.text end;return vim.inspect(O,{newline=' ',indent=''})end;b.picker_set_busy=function(i,aU)i.is_busy=aU;local bl=function()b.timers.busy:stop()b.win_update_hl(i.windows.main,'FloatBorder',i.is_busy and'MiniPickBorderBusy'or'MiniPickBorder')end;if aU then return b.timers.busy:start(i.opts.delay.busy,0,vim.schedule_wrap(bl))end;bl()end;b.picker_set_match_inds=function(i,l)if l==nil then return end;b.picker_set_busy(i,false)i.match_inds=l;local bm=table.concat(i.query)if i.opts.options.use_cache then i.cache[bm]={inds=l}end;b.picker_show_main(i)b.picker_set_current_ind(i,1)end;b.picker_set_current_ind=function(i,aq,bn)if i.items==nil or#i.match_inds==0 then i.current_ind,i.visible_range=nil,{}return end;local bo=#i.match_inds;aq=(aq-1)%bo+1;local bp,bq,br=i.visible_range.from,i.visible_range.to,i.visible_range.querytick;local bs=b.querytick~=br or bp==nil or bq==nil or not(bp<=aq and aq<=bq)if(bn or bs)and b.is_valid_win(i.windows.main)then local bt=vim.api.nvim_win_get_height(i.windows.main)bq=math.min(bo,math.floor(aq+0.5*bt))bp=math.max(1,bq-bt+1)bq=bp+math.min(bt,bo)-1 end;i.current_ind=aq;i.visible_range={from=bp,to=bq,querytick=b.querytick}end;b.picker_set_lines=function(i)local t,ao=i.buffers.main,i.windows.main;if not(b.is_valid_buf(t)and b.is_valid_win(ao))then return end;if i.is_busy then return end;local bu,m=i.visible_range,i.query;if i.items==nil or bu.from==nil or bu.to==nil then i.opts.source.show(t,{},m)b.clear_namespace(t,b.ns_id.matches)return end;local bv,j,s={},i.items,i.match_inds;local bw,bx=i.current_ind,nil;local by,bz=i.marked_inds_map,{}local bA=i.opts.options.content_from_bottom;local bp=bA and bu.to or bu.from;local bq=bA and bu.from or bu.to;for C=bp,bq,bp<=bq and 1 or-1 do table.insert(bv,j[s[C]])if C==bw then bx=#bv end;if by[s[C]]then table.insert(bz,#bv)end end;local bB=bA and vim.api.nvim_win_get_height(ao)-#bv or 0;bx=bx+bB;bz=vim.tbl_map(function(p)return p+bB end,bz)i.opts.source.show(t,bv,m)if bB>0 then local bC=vim.fn['repeat']({''},bB)vim.api.nvim_buf_set_lines(t,0,0,true,bC)end;local D=b.ns_id.matches;b.clear_namespace(t,D)local bD={end_col=0,hl_group='MiniPickMatchMarked',priority=202}for L,bE in ipairs(bz)do bD.end_row=bE;b.set_extmark(t,D,bE-1,0,bD)end;if bx>vim.api.nvim_buf_line_count(t)then return end;local bF={end_row=bx,end_col=0,hl_eol=true,hl_group='MiniPickMatchCurrent',priority=201}b.set_extmark(t,D,bx-1,0,bF)local bG=vim.api.nvim_win_get_cursor(ao)if i.view_state=='main'and bG[1]~=bx then b.set_cursor(ao,bx,bG[2]+1)end end;b.picker_match=function(i)if i.items==nil then return end;local bH;if i.opts.options.use_cache then bH=i.cache[table.concat(i.query)]end;if bH~=nil then return b.picker_set_match_inds(i,bH.inds)end;local bI=b.query_is_ignorecase(i.query)local k=bI and i.stritems_ignorecase or i.stritems;local m=bI and vim.tbl_map(b.tolower,i.query)or i.query;b.picker_set_busy(i,true)local bJ=i.opts.source.match(k,i.match_inds,m)b.picker_set_match_inds(i,bJ)end;b.query_is_ignorecase=function(m)if not vim.o.ignorecase then return false end;if not vim.o.smartcase then return true end;return vim.fn.match(table.concat(m),'[[:upper:]]')<0 end;b.picker_get_char_data=function(i,bK)local bL=b.replace_termcodes;local ap={}local bM={}if not bK then bM={move_down='<Down>',move_start='<Home>',move_up='<Up>'}end;for e,bN in pairs(i.opts.mappings)do local bO=type(bN)=='table'local b4=bO and bN.char or bN;local az={char=b4,name=e,func=bO and bN.func or b.actions[e],is_custom=bO}ap[bL(b4)]=az;local bP=bM[e]if bP~=nil then ap[bL(bP)]=az end end;return ap end;b.picker_set_bordertext=function(i)local ao=i.windows.main;if not b.is_valid_win(ao)then return end;local bQ=i.view_state;local c;if bQ=='main'then local m,bR=i.query,i.caret;local bS=table.concat(vim.list_slice(m,1,bR-1),'')local bT=table.concat(vim.list_slice(m,bR,#m),'')local bU='> '..bS..'▏'..bT;local X={{b.win_trim_to_width(ao,bU),'MiniPickPrompt'}}c={title=X}end;local bV=i.items~=nil;if bQ=='preview'and bV then local bW=i.stritems[i.match_inds[i.current_ind]]or''bW=bW:gsub('[%s%z]',' ')c={title={{b.win_trim_to_width(ao,bW),'MiniPickBorderText'}}}end;if bQ=='info'then c={title={{b.win_trim_to_width(ao,'Info'),'MiniPickBorderText'}}}end;local bX=vim.fn.has('nvim-0.10')==1;if bX and not i.is_busy then c.footer,c.footer_pos=b.picker_compute_footer(i,ao),'left'end;if bX and i.opts.options.content_from_bottom then c.title,c.footer=c.footer,c.title end;vim.api.nvim_win_set_config(ao,c)vim.wo[ao].list=true end;if vim.fn.has('nvim-0.9')==0 then b.picker_set_bordertext=function()end end;b.picker_compute_footer=function(i,ao)local bY=b.picker_get_general_info(i)local W=string.format(' %s ',bY.source_name)local bZ=bY.n_marked==0 and''or bY.n_marked..'/'local l=string.format(' %s|%s|%s%s ',bY.relative_current_ind,bY.n_matched,bZ,bY.n_total)local b_,c0,c1=vim.api.nvim_win_get_width(ao),vim.fn.strchars(W),vim.fn.strchars(l)local c2={{W,'MiniPickBorderText'}}local c3=b_-(c0+c1)if c3>0 then local c4=i.is_busy and'MiniPickBorderBusy'or'MiniPickBorder'c2[2]={b.win_get_bottom_border(ao):rep(c3),c4}c2[3]={l,'MiniPickBorderText'}end;return c2 end;b.picker_stop=function(i,c5)vim.tbl_map(function(c6)pcall(vim.loop.timer_stop,c6)end,b.timers)pcall(function()vim.o.cmdheight=b.cache.cmdheight end)if i==nil then return end;vim.api.nvim_exec_autocmds('User',{pattern='MiniPickStop'})if c5 then b.pickers={}else local c7=vim.deepcopy(i)b.picker_free(b.pickers.latest)b.pickers={active=nil,latest=c7}end;b.set_curwin(i.windows.target)pcall(vim.api.nvim_win_close,i.windows.main,true)pcall(vim.api.nvim_buf_delete,i.buffers.main,{force=true})pcall(vim.api.nvim_buf_delete,i.buffers.info,{force=true})i.windows,i.buffers={},{}b.querytick=b.querytick+1 end;b.picker_free=function(i)if i==nil then return end;i.match_inds=nil;i.cache=nil;i.stritems,i.stritems_ignorecase,i.marked_inds_map=nil,nil,nil;i.items=nil;i=nil;vim.schedule(function()collectgarbage('collect')end)end;b.actions={caret_left=function(i,L)b.picker_move_caret(i,-1)end,caret_right=function(i,L)b.picker_move_caret(i,1)end,choose=function(i,L)return b.picker_choose(i,nil)end,choose_in_split=function(i,L)return b.picker_choose(i,'split')end,choose_in_tabpage=function(i,L)return b.picker_choose(i,'tabnew')end,choose_in_vsplit=function(i,L)return b.picker_choose(i,'vsplit')end,choose_marked=function(i,L)return not i.opts.source.choose_marked(a.get_picker_matches().marked)end,delete_char=function(i,L)b.picker_query_delete(i,1)end,delete_char_right=function(i,L)b.picker_query_delete(i,0)end,delete_left=function(i,L)b.picker_query_delete(i,i.caret-1)end,delete_word=function(i,L)local c8,c9=i.caret-1,0;if c8==0 then return end;local ca=vim.fn.match(i.query[c8],'[[:keyword:]]')>=0;for C=c8,1,-1 do local cb=vim.fn.match(i.query[C],'[[:keyword:]]')>=0;if ca and not cb or not ca and cb then break end;c9=c9+1 end;b.picker_query_delete(i,c9)end,mark=function(i,L)b.picker_mark_indexes(i,'current')end,mark_all=function(i,L)b.picker_mark_indexes(i,'all')end,move_down=function(i,L)b.picker_move_current(i,1)end,move_start=function(i,L)b.picker_move_current(i,nil,1)end,move_up=function(i,L)b.picker_move_current(i,-1)end,paste=function(i,L)local cc=b.getcharstr(i.opts.delay.async)local cd,ce=pcall(vim.fn.getreg,cc)if not cd then return end;ce=ce:gsub('[\n\t]',' ')for C=1,vim.fn.strchars(ce)do b.picker_query_add(i,vim.fn.strcharpart(ce,C-1,1))end end,refine=function(i,L)b.picker_refine(i,'all')end,refine_marked=function(i,L)b.picker_refine(i,'marked')end,scroll_down=function(i,L)b.picker_scroll(i,'down')end,scroll_up=function(i,L)b.picker_scroll(i,'up')end,scroll_left=function(i,L)b.picker_scroll(i,'left')end,scroll_right=function(i,L)b.picker_scroll(i,'right')end,toggle_info=function(i,L)if i.view_state=='info'then return b.picker_show_main(i)end;b.picker_show_info(i)end,toggle_preview=function(i,L)if i.view_state=='preview'then return b.picker_show_main(i)end;b.picker_show_preview(i)end,stop=function(L,L)return true end}b.picker_query_add=function(i,b4)if vim.fn.strchars(b4)>1 or vim.fn.char2nr(b4)<=31 then return end;table.insert(i.query,i.caret,b4)i.caret=i.caret+1;b.querytick=b.querytick+1;local cf=i.items~=nil and i.caret<=#i.query;if cf then i.match_inds=b.seq_along(i.items)end end;b.picker_query_delete=function(i,cg)local ch=cg>0;local ci=ch and math.max(i.caret-cg,1)or i.caret;local cj=ch and i.caret-1 or math.min(i.caret+cg,#i.query)for C=cj,ci,-1 do table.remove(i.query,C)end;i.caret=ci;b.querytick=b.querytick+1;if i.items~=nil then i.match_inds=b.seq_along(i.items)end end;b.picker_choose=function(i,ck)local cl=b.picker_get_current_item(i)if cl==nil then return true end;local cm=i.windows.target;if ck~=nil and b.is_valid_win(cm)then vim.api.nvim_win_call(cm,function()vim.cmd(ck)i.windows.target=vim.api.nvim_get_current_win()end)end;return not i.opts.source.choose(cl)end;b.picker_mark_indexes=function(i,cn)if i.items==nil then return end;local co=cn=='current'and{i.match_inds[i.current_ind]}or i.match_inds;local by,cp=i.marked_inds_map,true;for L,aq in ipairs(co)do cp=cp and by[aq]end;local cq;if not cp then cq=true end;for L,aq in ipairs(co)do by[aq]=cq end;if i.view_state=='info'then b.picker_show_info(i)end end;b.picker_move_caret=function(i,cg)i.caret=math.min(math.max(i.caret+cg,1),#i.query+1)end;b.picker_move_current=function(i,cr,bq)if i.items==nil then return end;local bo=#i.match_inds;if bo==0 then return end;if bq==nil then cr=(i.opts.options.content_from_bottom and-1 or 1)*cr;bq=i.current_ind;if bq==1 and cr<0 then bq=bo elseif bq==bo and cr>0 then bq=1 else bq=bq+cr end;bq=math.min(math.max(bq,1),bo)end;b.picker_set_current_ind(i,bq)if i.view_state=='info'then b.picker_show_info(i)end;if i.view_state=='preview'then b.picker_show_preview(i)end end;b.picker_refine=function(i,cs)if i.items==nil then return end;i.opts.source.match=b.get_config().source.match or a.default_match;i.query,i.caret={},1;a.set_picker_items(a.get_picker_matches()[cs]or{})i._refine=i._refine or{orig_name=i.opts.source.name,count=0}i._refine.count=i._refine.count+1;local ct=i._refine.count==1 and''or' '..i._refine.count;i.opts.source.name=string.format('%s (Refine%s)',i._refine.orig_name,ct)end;b.picker_scroll=function(i,cu)local ao=i.windows.main;if i.view_state=='main'and(cu=='down'or cu=='up')then local cg=(cu=='down'and 1 or-1)*vim.api.nvim_win_get_height(ao)b.picker_move_current(i,cg)else local cv=({down='<C-f>',up='<C-b>',left='zH',right='zL'})[cu]vim.api.nvim_win_call(ao,function()vim.cmd('normal! '..b.replace_termcodes(cv))end)end end;b.picker_get_current_item=function(i)if i.items==nil then return nil end;return i.items[i.match_inds[i.current_ind]]end;b.picker_show_main=function(i)b.set_winbuf(i.windows.main,i.buffers.main)i.view_state='main'end;b.picker_show_info=function(i)local bY=b.picker_get_general_info(i)local v={'General','Source name   │ '..bY.source_name,'Source cwd    │ '..bY.source_cwd,'Total items   │ '..bY.n_total,'Matched items │ '..bY.n_matched,'Marked items  │ '..bY.n_marked,'Current index │ '..bY.relative_current_ind}local cw={1}local cx=function(az,cy)if#az==0 then return end;table.insert(v,'')table.insert(v,cy)table.insert(cw,#v)local cz=0;for L,ag in ipairs(az)do local aF=ag.name:gsub('[%s%p]',' ')ag.desc=vim.fn.toupper(aF:sub(1,1))..aF:sub(2)ag.width=vim.fn.strchars(ag.desc)cz=math.max(cz,ag.width)end;table.sort(az,function(cA,cB)return cA.desc<cB.desc end)for L,ag in ipairs(az)do table.insert(v,string.format('%s%s │ %s',ag.desc,string.rep(' ',cz-ag.width),ag.char))end end;local b1=b.picker_get_char_data(i,true)cx(vim.tbl_filter(function(p)return p.is_custom end,b1),'Mappings (custom)')cx(vim.tbl_filter(function(p)return not p.is_custom end,b1),'Mappings (built-in)')local cC=i.buffers.info;if not b.is_valid_buf(cC)then cC=b.create_scratch_buf()end;i.buffers.info=cC;b.set_buflines(cC,v)b.set_winbuf(i.windows.main,cC)i.view_state='info'local D=b.ns_id.headers;b.clear_namespace(cC,D)for L,bE in ipairs(cw)do b.set_extmark(cC,D,bE-1,0,{end_row=bE,end_col=0,hl_group='MiniPickHeader'})end end;b.picker_get_general_info=function(i)local bV=i.items~=nil;return{source_name=i.opts.source.name or'---',source_cwd=vim.fn.fnamemodify(i.opts.source.cwd,':~')or'---',n_total=bV and#i.items or'-',n_matched=bV and#i.match_inds or'-',n_marked=bV and vim.tbl_count(i.marked_inds_map)or'-',relative_current_ind=bV and i.current_ind or'-'}end;b.picker_show_preview=function(i)local a2=i.opts.source.preview;local O=b.picker_get_current_item(i)if O==nil then return end;local ao,t=i.windows.main,b.create_scratch_buf()vim.bo[t].bufhidden='wipe'b.set_winbuf(ao,t)a2(t,O)i.buffers.preview=t;i.view_state='preview'end;b.match_filter=function(l,k,m)local cD,cE,cF,cG=m[1]=='*',m[1]=="'",m[1]=='^',m[#m]=='$'local cH,cI=b.match_query_group(m)if cD or cE or cF or cG then local K=(cD or cE or cF)and 2 or 1;local cJ=#m-(not cD and not cE and cG and 1 or 0)m=vim.list_slice(m,K,cJ)elseif cH then m=cI end;if#m==0 then return{},'nosort',m end;local cK=not(cE or cF or cG)and#m>1;if cD or cK then return b.match_filter_fuzzy(l,k,m),'fuzzy',m end;local aO=cF and'^'or''local cL=cG and'$'or''local a8=aO..vim.pesc(table.concat(m))..cL;return b.match_filter_exact(l,k,m,a8),'exact',m end;b.match_filter_exact=function(l,k,m,a8)local cM=b.match_filter_exact_single;local bj=b.poke_picker_throttle(b.querytick)local q={}for L,aq in ipairs(l)do if not bj()then return nil end;local az=cM(k[aq],aq,a8)if az~=nil then table.insert(q,az)end end;return q end;b.match_filter_exact_single=function(cN,cO,a8)local cP=string.find(cN,a8)if cP==nil then return nil end;return{0,cP,cO}end;b.match_ranges_exact=function(q,m)local cQ,cR=0,{}for C=1,#m do cR[C]={cQ,cQ+m[C]:len()-1}cQ=cR[C][2]+1 end;local ap={}for C=1,#q do local cP=q[C][2]ap[C]=vim.tbl_map(function(p)return{cP+p[1],cP+p[2]}end,cR)end;return ap end;b.match_filter_fuzzy=function(l,k,m)local cM,cS=b.match_filter_fuzzy_single,b.match_find_query;local bj=b.poke_picker_throttle(b.querytick)local q={}for L,aq in ipairs(l)do if not bj()then return nil end;local az=cM(k[aq],aq,m,cS)if az~=nil then table.insert(q,az)end end;return q end;b.match_filter_fuzzy_single=function(cN,cO,m,cS)local cT,cU=cS(cN,m,1)if cT==nil then return nil end;if cT==cU then return{0,cT,cO,{cT}}end;local cV,cW,cX=cT,cU,cU-cT;while cU do local cY=cU-cT;if cY<cX then cV,cW,cX=cT,cU,cY end;cT,cU=cS(cN,m,cT+1)end;return{cW-cV,cV,cO}end;b.match_ranges_fuzzy=function(q,m,k)local ap,cZ,c_={},#m,vim.tbl_map(string.len,m)for d0,az in ipairs(q)do local d1,bp,bq=k[az[3]],az[2],az[2]+c_[1]-1;local J={{bp,bq}}for d2=2,cZ do bp,bq=string.find(d1,m[d2],bq+1,true)J[d2]={bp,bq}end;ap[d0]=J end;return ap end;b.match_find_query=function(d1,m,c8)local cT,bq=string.find(d1,m[1],c8,true)if cT==nil then return nil,nil end;local cU=cT;for C=2,#m do cU,bq=string.find(d1,m[C],bq+1,true)if not cU then return nil,nil end end;return cT,cU end;b.match_query_group=function(m)local d3={{}}for L,p in ipairs(m)do local d4=p:find('^%s+$')~=nil;if d4 then table.insert(d3,{})end;if not d4 then table.insert(d3[#d3],p)end end;return#d3>1,vim.tbl_map(table.concat,d3)end;b.match_sort=function(q)local d5,bc,d6={},0,{}for C=1,#q do local az,cY,cP=q[C],q[C][1],q[C][2]local d7=d5[cY]or{}local d8=d7[cP]or{}table.insert(d8,az[3])d7[cP]=d8;d5[cY]=d7;bc=math.max(bc,cY)d6[cY]=math.max(d6[cY]or 0,cP)end;local bj=b.poke_picker_throttle(b.querytick)for L,d7 in pairs(d5)do for L,d8 in pairs(d7)do if not bj()then return nil end;table.sort(d8)end end;local ap={}for cY=0,bc do local d7=d5[cY]for cP=1,d6[cY]or 0 do local d8=d7[cP]or{}for C=1,#d8 do table.insert(ap,d8[C])end end end;return ap end;b.get_icon=function(p,d9)local da,db=b.parse_path(p)if da==nil then return{text=''}end;if da=='directory'then return{text=d9.directory,hl='MiniPickIconDirectory'}end;if da=='none'then return{text=d9.none,hl='MiniPickNormal'}end;local dc,dd=pcall(require,'nvim-web-devicons')if not dc then return{text=d9.file,hl='MiniPickIconFile'}end;local de,df=dd.get_icon(vim.fn.fnamemodify(db,':t'),nil,{default=false})de=type(de)=='string'and de..' 'or d9.file;return{text=de,hl=df or'MiniPickIconFile'}end;b.show_with_icons=function(t,j,m)a.default_show(t,j,m,{show_icons=true})end;b.parse_item=function(O)if type(O)=='table'then return b.parse_item_table(O)end;local dg=b.item_to_string(O)local dh,di=pcall(tonumber,dg)if dh and b.is_valid_buf(di)then return{type='buffer',buf_id=di}end;local da,db,bE,aL,dj=b.parse_path(dg)if da~='none'then return{type=da,path=db,lnum=bE,col=aL,text=dj}end;return{}end;b.parse_item_table=function(O)local t=O.bufnr or O.buf_id or O.buf;if b.is_valid_buf(t)then return{type='buffer',buf_id=t,lnum=O.lnum,end_lnum=O.end_lnum,col=O.col,end_col=O.end_col,text=O.text}end;if type(O.path)=='string'then local da,db,bE,aL,dj=b.parse_path(O.path)if da=='file'then return{type='file',path=db,lnum=bE or O.lnum,end_lnum=O.end_lnum,col=aL or O.col,end_col=O.end_col,text=dj~=''and dj or O.text}end;if da=='directory'then return{type='directory',path=O.path}end end;return{}end;b.parse_path=function(p)if type(p)~='string'or p==''then return nil end;local dk=':(%d+):?(%d*):?(.*)$'local bE,aL,dj=p:match(dk)local db=p:gsub(dk,'',1)db=db:sub(1,1)=='~'and(vim.loop.os_homedir()or'~')..db:sub(2)or db;local da=b.get_fs_type(db)if da=='none'and db~=''then local dl=b.pickers.active==nil and vim.fn.getcwd()or b.pickers.active.opts.source.cwd;db=string.format('%s/%s',dl,db)da=b.get_fs_type(db)end;return da,db,tonumber(bE),tonumber(aL),dj or''end;b.get_fs_type=function(db)if db==''then return'none'end;if vim.fn.filereadable(db)==1 then return'file'end;if vim.fn.isdirectory(db)==1 then return'directory'end;return'none'end;b.preview_file=function(t,P,h)if not b.is_file_text(P.path)then return b.set_buflines(t,{'-Non-text-file-'})end;local dm,v=pcall(vim.fn.readfile,P.path,'',(P.lnum or 1)+h.n_context_lines)if not dm then return end;P.line_position=h.line_position;b.preview_set_lines(t,v,P)end;b.preview_directory=function(t,P)local db=P.path;local dn=function(p)return p..(vim.fn.isdirectory(db..'/'..p)==1 and'/'or'')end;local v=vim.tbl_map(dn,vim.fn.readdir(db))b.set_buflines(t,v)end;b.preview_buffer=function(t,P,h)local dp=P.buf_id;local dq=vim.o.eventignore;vim.o.eventignore='BufEnter'vim.fn.bufload(dp)vim.o.eventignore=dq;local v=vim.api.nvim_buf_get_lines(dp,0,(P.lnum or 1)+h.n_context_lines,false)P.filetype,P.line_position=vim.bo[dp].filetype,h.line_position;b.preview_set_lines(t,v,P)end;b.preview_inspect=function(t,dr)b.set_buflines(t,vim.split(vim.inspect(dr),'\n'))end;b.preview_set_lines=function(t,v,ds)b.set_buflines(t,v)b.preview_highlight_region(t,ds.lnum,ds.col,ds.end_lnum,ds.end_col)if b.preview_should_highlight(t)then local dt=ds.filetype or vim.filetype.match({buf=t,filename=ds.path})local du,dv=pcall(vim.treesitter.language.get_lang,dt)local dw,L=pcall(vim.treesitter.start,t,du and dv or dt)if not dw then vim.bo[t].syntax=dt end end;local dx=a.get_picker_state()local ao=dx~=nil and dx.windows.main or vim.fn.bufwinid(t)b.set_cursor(ao,ds.lnum,ds.col)local dy=({top='zt',center='zz',bottom='zb'})[ds.line_position]or'zt'pcall(vim.api.nvim_win_call,ao,function()vim.cmd('normal! '..dy)end)end;b.preview_should_highlight=function(t)if vim.fn.has('nvim-0.8')==0 then return false end;local dz=vim.api.nvim_buf_call(t,function()return vim.fn.line2byte(vim.fn.line('$')+1)end)return dz<=1000000 and dz<=1000*vim.api.nvim_buf_line_count(t)end;b.preview_highlight_region=function(t,bE,aL,dA,dB)if bE==nil then return end;local dC={end_row=bE,end_col=0,hl_eol=true,hl_group='MiniPickPreviewLine',priority=201}b.set_extmark(t,b.ns_id.preview,bE-1,0,dC)if aL==nil then return end;local dD,dE=bE-1,aL;if dA~=nil and dB~=nil then dD,dE=dA-1,dB-1 end;dE=b.get_next_char_bytecol(vim.fn.getbufline(t,dD+1)[1],dE)local dF={end_row=dD,end_col=dE,priority=202}dF.hl_group='MiniPickPreviewRegion'b.set_extmark(t,b.ns_id.preview,bE-1,aL-1,dF)end;b.choose_path=function(R,P)local db,dG=P.path,nil;for L,t in ipairs(vim.api.nvim_list_bufs())do local dH=b.is_valid_buf(t)and vim.bo[t].buflisted and vim.api.nvim_buf_get_name(t)==db;if dH then dG=t end end;if dG~=nil then b.set_winbuf(R,dG)else local dI=vim.fn.fnameescape(vim.fn.fnamemodify(db,':.'))vim.api.nvim_win_call(R,function()pcall(vim.cmd,'edit '..dI)end)end;b.choose_set_cursor(R,P.lnum,P.col)end;b.choose_buffer=function(R,P)b.set_winbuf(R,P.buf_id)b.choose_set_cursor(R,P.lnum,P.col)end;b.choose_print=function(p)print(vim.inspect(p))end;b.choose_set_cursor=function(ao,bE,aL)if bE==nil then return end;b.set_cursor(ao,bE,aL)pcall(vim.api.nvim_win_call,ao,function()vim.cmd('normal! zvzz')end)end;b.cli_postprocess=function(j)while j[#j]==''do j[#j]=nil end;return j end;b.is_executable=function(a5)if a5=='fallback'then return true end;return vim.fn.executable(a5)==1 end;b.files_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('fd')then return'fd'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.files_get_command=function(a5)if a5=='rg'then return{'rg','--files','--no-follow','--color=never'}end;if a5=='fd'then return{'fd','--type=f','--no-follow','--color=never'}end;if a5=='git'then return{'git','ls-files','--cached','--others','--exclude-standard'}end;b.error([[Wrong 'tool' for `files` builtin.]])end;b.files_fallback_items=function(dl)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `files` builtin needs Neovim>=0.9.')end;dl=dl or'.'local bj=b.poke_picker_throttle()local g=function()local j={}for db,da in vim.fs.dir(dl,{depth=math.huge})do if not bj()then return end;if da=='file'and b.is_file_text(string.format('%s/%s',dl,db))then table.insert(j,db)end end;a.set_picker_items(j)end;vim.schedule(coroutine.wrap(g))end;b.grep_get_tool=function()if b.is_executable('rg')then return'rg'end;if b.is_executable('git')then return'git'end;return'fallback'end;b.grep_get_command=function(a5,a8)if a5=='rg'then return{'rg','--column','--line-number','--no-heading','--no-follow','--color=never','--',a8}end;if a5=='git'then local ap={'git','grep','--column','--line-number','--color=never','--',a8}if vim.o.ignorecase then table.insert(ap,6,'--ignore-case')end;return ap end;b.error([[Wrong 'tool' for `grep` builtin.]])end;b.grep_fallback_items=function(a8,dl)if vim.fn.has('nvim-0.9')==0 then b.error('Tool "fallback" of `grep` builtin needs Neovim>=0.9.')end;dl=dl or'.'local bj=b.poke_picker_throttle()local g=function()local dJ,dK={},{}for db,da in vim.fs.dir(dl,{depth=math.huge})do if not bj()then return end;local dL=string.format('%s/%s',dl,db)if da=='file'and b.is_file_text(dL)then table.insert(dJ,db)table.insert(dK,dL)end end;local j={}for C,db in ipairs(dK)do local dM=dJ[C]if not bj()then return end;for bE,x in ipairs(vim.fn.readfile(db))do local aL=string.find(x,a8)if aL~=nil then table.insert(j,string.format('%s:%d:%d:%s',dM,bE,aL,x))end end end;a.set_picker_items(j)end;vim.schedule(coroutine.wrap(g))end;b.schedule_resume_is_active=vim.schedule_wrap(function(aA)coroutine.resume(aA,a.is_picker_active())end)b.poke_picker_throttle=function(dN)if not a.is_picker_active()then return function()return true end end;local dO,dP=vim.loop.hrtime(),dN==nil;local dQ=1000000*b.get_config().delay.async;local dR=vim.loop.hrtime;local dS=a.poke_is_picker_active;return function()local dT=dR()if dT-dO<dQ then return true end;dO=dT;return dS()and(dP or dN==b.querytick)end end;b.error=function(dU)error(string.format('(mini.pick) %s',dU),0)end;b.is_valid_buf=function(t)return type(t)=='number'and vim.api.nvim_buf_is_valid(t)end;b.is_valid_win=function(ao)return type(ao)=='number'and vim.api.nvim_win_is_valid(ao)end;b.is_array_of=function(p,dV)if not vim.tbl_islist(p)then return false end;for C=1,#p do if type(p[C])~=dV then return false end end;return true end;b.create_scratch_buf=function()local t=vim.api.nvim_create_buf(false,true)vim.bo[t].matchpairs=''vim.b[t].minicursorword_disable=true;vim.b[t].miniindentscope_disable=true;return t end;b.get_first_valid_normal_window=function()for L,ao in ipairs(vim.api.nvim_tabpage_list_wins(0))do if vim.api.nvim_win_get_config(ao).relative==''then return ao end end end;b.set_buflines=function(t,v)pcall(vim.api.nvim_buf_set_lines,t,0,-1,false,v)end;b.set_winbuf=function(ao,t)vim.api.nvim_win_set_buf(ao,t)end;b.set_extmark=function(...)pcall(vim.api.nvim_buf_set_extmark,...)end;b.set_cursor=function(ao,bE,aL)pcall(vim.api.nvim_win_set_cursor,ao,{bE or 1,(aL or 1)-1})end;b.set_curwin=function(ao)if not b.is_valid_win(ao)then return end;local bG=vim.api.nvim_win_get_cursor(ao)vim.api.nvim_set_current_win(ao)b.set_cursor(ao,bG[1],bG[2]+1)end;b.clear_namespace=function(t,D)pcall(vim.api.nvim_buf_clear_namespace,t,D,0,-1)end;b.replace_termcodes=function(p)if p==nil then return nil end;return vim.api.nvim_replace_termcodes(p,true,true,true)end;b.expand_callable=function(p,...)if vim.is_callable(p)then return p(...)end;return p end;b.expandcmd=function(p)local dh,ap=pcall(vim.fn.expandcmd,p)return dh and ap or p end;b.redraw=function()vim.cmd('redraw')end;b.redraw_scheduled=vim.schedule_wrap(b.redraw)b.getcharstr=function(dW)b.timers.getcharstr:start(0,dW,b.redraw_scheduled)b.cache.is_in_getcharstr=true;local dh,b4=pcall(vim.fn.getcharstr)b.cache.is_in_getcharstr=nil;b.timers.getcharstr:stop()local dX;if b.pickers.active~=nil then dX=b.pickers.active.windows.main end;local dY=vim.v.mouse_winid~=0 and vim.v.mouse_winid~=dX;if not dh or b4==''or b4=='\3'or dY then return end;return b4 end;b.tolower=(function()local bi=vim.fn.tolower;return function(p)local dh,ap=pcall(bi,p)return dh and ap or string.lower(p)end end)()b.win_update_hl=function(ao,dZ,d_)if not b.is_valid_win(ao)then return end;local e0=dZ..':'..d_;local e1=string.format('(%s:[^,]*)',vim.pesc(dZ))local e2,e3=vim.wo[ao].winhighlight:gsub(e1,e0)if e3==0 then e2=e2 ..','..e0 end;pcall(function()vim.wo[ao].winhighlight=e2 end)end;b.win_trim_to_width=function(ao,e4)local b_=vim.api.nvim_win_get_width(ao)return vim.fn.strcharpart(e4,vim.fn.strchars(e4)-b_,b_)end;b.win_get_bottom_border=function(ao)local e5=vim.api.nvim_win_get_config(ao).border or{}return e5[6]or' 'end;b.seq_along=function(e6)if e6==nil then return nil end;local ap={}for C=1,#e6 do table.insert(ap,C)end;return ap end;b.get_next_char_bytecol=function(e7,aL)if type(e7)~='string'then return aL end;local e8=vim.str_utfindex(e7,math.min(e7:len(),aL))return vim.str_byteindex(e7,e8)end;b.is_file_text=function(db)local e9=vim.loop.fs_open(db,'r',1)local ea=vim.loop.fs_read(e9,1024):find('\0')==nil;vim.loop.fs_close(e9)return ea end;b.full_path=function(db)return vim.fn.fnamemodify(db,':p'):gsub('(.)/$','%1')end;return a
