local a=require('cmp_buffer.timer')local function b(c)for d in pairs(c)do c[d]=nil end end;local e={}e.GET_LINES_CHUNK_SIZE=1000;function e.new(f,g)local self=setmetatable({},{__index=e})self.bufnr=f;self.timer=a.new()self.closed=false;self.on_close_cb=nil;self.opts=g;self.regex=vim.regex(self.opts.keyword_pattern)self.lines_count=0;self.timer_current_line=-1;self.lines_words={}self.unique_words_curr_line={}self.unique_words_other_lines={}self.unique_words_curr_line_dirty=true;self.unique_words_other_lines_dirty=true;self.last_edit_first_line=0;self.last_edit_last_line=0;self.words_distances={}self.words_distances_dirty=true;self.words_distances_last_cursor_row=0;return self end;function e.close(self)self.closed=true;self:stop_indexing_timer()self.timer:close()self.timer=nil;self.lines_count=0;self.timer_current_line=-1;self.lines_words={}self.unique_words_curr_line={}self.unique_words_other_lines={}self.unique_words_curr_line_dirty=false;self.unique_words_other_lines_dirty=false;self.last_edit_first_line=0;self.last_edit_last_line=0;self.words_distances={}self.words_distances_dirty=false;self.words_distances_last_cursor_row=0;if self.on_close_cb then self.on_close_cb()end end;function e.stop_indexing_timer(self)self.timer:stop()self.timer_current_line=-1 end;function e.mark_all_lines_dirty(self)self.unique_words_curr_line_dirty=true;self.unique_words_other_lines_dirty=true;self.last_edit_first_line=0;self.last_edit_last_line=0;self.words_distances_dirty=true end;function e.safe_buf_call(self,h)if vim.api.nvim_get_current_buf()==self.bufnr then h()else vim.api.nvim_buf_call(self.bufnr,h)end end;function e.index_range(self,i,j,k)self:safe_buf_call(function()local l=self.GET_LINES_CHUNK_SIZE;local m=i;while m<j do local n=math.min(m+l,j)local o=vim.api.nvim_buf_get_lines(self.bufnr,m,n,true)for p,q in ipairs(o)do if not k or not self.lines_words[m+p]then self:index_line(m+p,q)end end;m=n end end)end;function e.start_indexing_timer(self)self.lines_count=vim.api.nvim_buf_line_count(self.bufnr)self.timer_current_line=0;local r=math.max(1,self.opts.indexing_interval)self.timer:start(0,r,function()if self.closed then self:stop_indexing_timer()return end;while self.lines_words[self.timer_current_line+1]do self.timer_current_line=self.timer_current_line+1 end;local s=self.timer_current_line;local t=self.opts.indexing_batch_size;local u=t>=1 and math.min(s+t,self.lines_count)or self.lines_count;if u>=self.lines_count then self:stop_indexing_timer()end;self.timer_current_line=u;self:mark_all_lines_dirty()self:index_range(s,u,true)end)end;function e.watch(self)self.lines_count=vim.api.nvim_buf_line_count(self.bufnr)vim.api.nvim_buf_attach(self.bufnr,false,{on_lines=function(v,v,v,w,x,y,v,v,v)if self.closed then return true end;if x==y and w==y then return end;local z=y-x;local A=self.lines_count;local B=A+z;if B==0 then B=1;for p=A,2,-1 do self.lines_words[p]=nil end;self.lines_words[1]={}elseif z>0 then for p=A+1,B do self.lines_words[p]=false end;for p=A,x+1,-1 do self.lines_words[p+z]=self.lines_words[p]end;for p=x+1,y do self.lines_words[p]={}end elseif z<0 then for p=x+1,A do self.lines_words[p+z]=self.lines_words[p]end;for p=A,B+1,-1 do self.lines_words[p]=nil end end;self.lines_count=B;if self.timer:is_active()then if w<=self.timer_current_line and self.timer_current_line<x then self.timer_current_line=y elseif self.timer_current_line>=x then self.timer_current_line=self.timer_current_line+z end end;if w==self.last_edit_first_line and x==self.last_edit_last_line and y==self.last_edit_last_line then self.unique_words_curr_line_dirty=true else self.unique_words_curr_line_dirty=true;self.unique_words_other_lines_dirty=true end;self.last_edit_first_line=w;self.last_edit_last_line=y;self.words_distances_dirty=true;self:index_range(w,y)end,on_reload=function(v,v)if self.closed then return true end;b(self.lines_words)self:stop_indexing_timer()self:start_indexing_timer()end,on_detach=function(v,v)if self.closed then return true end;self:close()end})end;function e.index_line(self,C,q)local D=self.lines_words[C]if not D then D={}self.lines_words[C]=D else b(D)end;local E=1;local F=q;if#F>self.opts.max_indexed_line_length then F=vim.fn.strcharpart(q,0,self.opts.max_indexed_line_length)end;while#F>0 do local G,H=self.regex:match_str(F)if G and H then local I=F:sub(G+1,H)if#I>=self.opts.keyword_length then D[E]=I;E=E+1 end;F=F:sub(H+1)else break end end end;function e.get_words(self)if self.unique_words_other_lines_dirty then b(self.unique_words_other_lines)self:rebuild_unique_words(self.unique_words_other_lines,0,self.last_edit_first_line)self:rebuild_unique_words(self.unique_words_other_lines,self.last_edit_last_line,self.lines_count)self.unique_words_other_lines_dirty=false end;if self.unique_words_curr_line_dirty then b(self.unique_words_curr_line)self:rebuild_unique_words(self.unique_words_curr_line,self.last_edit_first_line,self.last_edit_last_line)self.unique_words_curr_line_dirty=false end;return{self.unique_words_other_lines,self.unique_words_curr_line}end;function e.rebuild_unique_words(self,J,i,j)for p=i+1,j do for v,K in ipairs(self.lines_words[p]or{})do J[K]=true end end end;function e.get_words_distances(self,L)if self.words_distances_dirty or L~=self.words_distances_last_cursor_row then local M=self.words_distances;b(M)for p=1,self.lines_count do for v,K in ipairs(self.lines_words[p]or{})do local N=math.abs(L-p)M[K]=M[K]and math.min(M[K],N)or N end end;self.words_distances_last_cursor_row=L;self.words_distances_dirty=false end;return self.words_distances end;return e
