local a=require("which-key.tree")local b=require("which-key.util")local c=require("which-key.config")local d="Ãž"local e={}e.functions={}e.operators={}e.nowait={}e.blacklist={}function e.setup()local f=require("which-key.plugins.presets").operators;for g,h in pairs(f)do e.operators[g]=true end;local i={}for g,j in pairs(c.options.operators)do e.operators[g]=true;if f[g]then i[g]={name=j,i={name="inside"},a={name="around"}}end end;for h,k in pairs(c.options.triggers_nowait)do e.nowait[k]=true end;e.register(i,{mode="n",preset=true})e.register({i={name="inside"},a={name="around"}},{mode="v",preset=true})for l,m in pairs(c.options.triggers_blacklist)do for h,n in ipairs(m)do e.blacklist[l]=e.blacklist[l]or{}e.blacklist[l][n]=true end end end;function e.get_operator(o)for p,h in pairs(c.options.operators)do local q=b.t(p)if o:sub(1,#q)==q then return q,p end end end;function e.process_motions(r,l,o,s)local q,p="",""if l~="v"then q,p=e.get_operator(o)end;if(l=="n"or l=="v")and q then local t=o:sub(#q+1)local u=t:match("^(%d+)")if u=="0"then u=nil end;if c.options.motions.count==false then u=nil end;if u then t=t:sub(#u+1)end;local v=e.get_mappings("o",t,s)if not r.mapping and v.mapping then r.mapping=v.mapping;r.mapping.prefix=p..(u or"")..r.mapping.prefix;r.mapping.keys=b.parse_keys(r.mapping.prefix)end;for h,w in pairs(v.mappings)do w.prefix=p..(u or"")..w.prefix;w.keys=b.parse_keys(w.prefix)table.insert(r.mappings,w)end end end;function e.get_mappings(l,o,s)local r;r={mapping=nil,mappings={},mode=l,buf=s,prefix_i=o}local x=#b.parse_internal(o)local function y(z)if z then if z.mapping then r.mapping=vim.tbl_deep_extend("force",{},r.mapping or{},z.mapping)end;for A,B in pairs(z.children)do if B.mapping and B.mapping.label~="which_key_ignore"and B.mapping.desc~="which_key_ignore"then r.mappings[A]=vim.tbl_deep_extend("force",{},r.mappings[A]or{},B.mapping)end end end end;local C={buf=s,mode=l}y(e.get_tree(l).tree:get(o,nil,C))y(e.get_tree(l,s).tree:get(o,nil,C))e.process_motions(r,l,o,s)local D={}for h,E in pairs(r.mappings)do E.key=E.keys.notation[x+1]if c.options.key_labels[E.key]then E.key=c.options.key_labels[E.key]end;local F=not E.label and c.options.ignore_missing==true;if b.t(E.key)==b.t("<esc>")then F=true end;if not F then if E.group then E.label=E.label or"+prefix"E.label=E.label:gsub("^%+","")E.label=c.options.icons.group..E.label elseif not E.label then E.label=E.desc or E.cmd or""for h,G in ipairs(c.options.hidden)do E.label=E.label:gsub(G,"")end end;if E.value then E.value=vim.fn.strtrans(E.value)end;local H=false;for A,G in pairs(D)do if type(G)=="table"and G.key==E.key then D[A]=E;H=true;break end end;if not H then table.insert(D,E)end end end;table.sort(D,function(I,J)if I.order and J.order then return I.order<J.order end;if I.group==J.group then local K=(I.key or""):lower()local L=(J.key or""):lower()local M=K:match("[a-z]")and 1 or 0;local N=L:match("[a-z]")and 1 or 0;if M==N then return K<L end;return M<N else return(I.group and 1 or 0)<(J.group and 1 or 0)end end)r.mappings=D;return r end;e.mappings={}e.duplicates={}function e.map(l,n,O,s,P)local Q=vim.api.nvim_buf_call(s or 0,function()local r=vim.fn.maparg(n,l,false,true)return r and r.lhs and r.rhs and r.rhs~=O and r or nil end)if Q then table.insert(e.duplicates,{mode=l,prefix=n,cmd=O,buf=s,other=Q})end;if s~=nil then pcall(vim.api.nvim_buf_set_keymap,s,l,n,O,P)else pcall(vim.api.nvim_set_keymap,l,n,O,P)end end;function e.register(i,P)P=P or{}i=require("which-key.mappings").parse(i,P)local R={}for h,w in pairs(i)do if not R[w.mode]then R[w.mode]=true;e.get_tree(w.mode)end;if w.cmd~=nil then e.map(w.mode,w.prefix,w.cmd,w.buf,w.opts)end;e.get_tree(w.mode,w.buf).tree:add(w)end end;e.hooked={}function e.hook_id(n,l,s)return l..(s or"")..b.t(n)end;function e.is_hooked(n,l,s)return e.hooked[e.hook_id(n,l,s)]end;function e.hook_del(n,l,s)local S=e.hook_id(n,l,s)e.hooked[S]=nil;if s then pcall(vim.api.nvim_buf_del_keymap,s,l,n)pcall(vim.api.nvim_buf_del_keymap,s,l,n..d)else pcall(vim.api.nvim_del_keymap,l,n)pcall(vim.api.nvim_del_keymap,l,n..d)end end;function e.hook_add(n,l,s,T)if e.blacklist[l]and e.blacklist[l][n]then return end;if tonumber(n)then return end;if l=="i"and(n=="j"or n=="k")then return end;if l=="n"and n=="q"then return end;if l=="s"then return end;if l=="o"then return end;if b.t(n)==b.t("<esc>")then return end;if(l=="v"or l=="x")and e.operators[n]then return end;if type(c.options.triggers)=="string"and c.options.triggers~="auto"then if b.t(n)~=b.t(c.options.triggers)then return end end;if type(c.options.triggers)=="table"then local U=false;for h,V in pairs(c.options.triggers)do if b.t(V)==b.t(n)then U=true;break end end;if not U then return end end;local P={noremap=true,silent=true}local S=e.hook_id(n,l,s)local W=e.hook_id(n,l)if not e.hooked[S]and not e.hooked[W]then local O=[[<cmd>lua require("which-key").show(%q, {mode = %q, auto = true})<cr>]]O=string.format(O,b.t(n),l)local X=l=="v"and"x"or l;if T~=true then e.map(X,n,O,s,P)end;if not e.nowait[n]then e.map(X,n..d,"<nop>",s,P)end;e.hooked[S]=true end end;function e.update(s)for A,Y in pairs(e.mappings)do if Y.buf and not vim.api.nvim_buf_is_valid(Y.buf)then e.mappings[A]=nil elseif not s or not Y.buf or s==Y.buf then e.update_keymaps(Y.mode,Y.buf)e.add_hooks(Y.mode,Y.buf,Y.tree.root)end end end;function e.add_hooks(l,s,z,T)if not z.mapping then z.mapping={prefix=z.prefix_n,group=true,keys=b.parse_keys(z.prefix_n)}end;if z.prefix_n~=""and z.mapping.group==true and not z.mapping.cmd then e.hook_add(z.prefix_n,l,s,T)T=true end;for h,B in pairs(z.children)do e.add_hooks(l,s,B,T)end end;function e.dump()local U={}local Z={}for h,Y in pairs(e.mappings)do e.update_keymaps(Y.mode,Y.buf)Y.tree:walk(function(z)if z.mapping then if z.mapping.label then U[z.mapping.prefix]=true;Z[z.mapping.prefix]=nil elseif not U[z.mapping.prefix]then Z[z.mapping.prefix]={z.mapping.cmd or""}end end end)end;return Z end;function e.check_health()vim.health.report_start("WhichKey: checking conflicting keymaps")for h,Y in pairs(e.mappings)do e.update_keymaps(Y.mode,Y.buf)Y.tree:walk(function(z)local _=0;for h in pairs(z.children)do _=_+1 end;local a0=not z.mapping or z.mapping.group==true and not z.mapping.cmd;if z.prefix_i~=""and _>0 and not a0 then local a1=("conflicting keymap exists for mode **%q**, lhs: **%q**"):format(Y.mode,z.mapping.prefix)vim.health.report_warn(a1)local O=z.mapping.cmd or" "vim.health.report_info(("rhs: `%s`"):format(O))end end)end;for h,a2 in pairs(e.duplicates)do local a1=""if a2.buf==a2.other.buffer then a1="duplicate keymap"else a1="buffer-local keymap overriding global"end;a1=(a1 .." for mode **%q**, buf: %d, lhs: **%q**"):format(a2.mode,a2.buf or 0,a2.prefix)if a2.buf==a2.other.buffer then vim.health.report_error(a1)else vim.health.report_warn(a1)end;vim.health.report_info(("old rhs: `%s`"):format(a2.other.rhs or""))vim.health.report_info(("new rhs: `%s`"):format(a2.cmd or""))end end;function e.get_tree(l,s)if l=="s"or l=="x"then l="v"end;b.check_mode(l,s)local a3=l..(s or"")if not e.mappings[a3]then e.mappings[a3]={mode=l,buf=s,tree=a:new()}end;return e.mappings[a3]end;function e.is_hook(a4,O)local a5=a4:find(d)local a6=O and O:find("which%-key")and O:find("auto")or false;return a6 or a5 end;function e.update_keymaps(l,s)local a7=s and vim.api.nvim_buf_get_keymap(s,l)or vim.api.nvim_get_keymap(l)local Y=e.get_tree(l,s).tree;local function a8(a9)return not a9.callback and b.t(a9.rhs)==""end;for h,a9 in pairs(a7)do local F=e.is_hook(a9.lhs,a9.rhs)if a8(a9)then F=true end;if not F and b.t(a9.lhs)==b.t("<leader>")and l=="n"then if a8(a9)then F=true else b.warn(string.format("Your <leader> key for %q mode in buf %d is currently mapped to %q. ".."WhichKey automatically creates triggers, so please remove the mapping",l,s or 0,a9.rhs))end end;if not F then local w={id=b.t(a9.lhs),prefix=a9.lhs,cmd=a9.rhs,desc=a9.desc,keys=b.parse_keys(a9.lhs)}if w.keys.notation[1]:lower()~="<plug>"then Y:add(w)end end end end;return e
