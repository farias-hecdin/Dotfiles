local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.7')==0 then vim.notify('(mini.surround) Neovim<0.7 is soft deprecated (module works but not supported).'..' It will be deprecated after Neovim 0.9.0 release (module will not work).'..' Please update your Neovim version.')end;_G.MiniSurround=a;c=b.setup_config(c)b.apply_config(c)vim.api.nvim_exec('hi default link MiniSurround IncSearch',false)end;a.config={custom_surroundings=nil,highlight_duration=500,mappings={add='sa',delete='sd',find='sf',find_left='sF',highlight='sh',replace='sr',update_n_lines='sn',suffix_last='l',suffix_next='n'},n_lines=20,respect_selection_type=false,search_method='cover',silent=false}a.operator=function(d,e)if b.is_disabled()then return[[\<Esc>]]end;b.cache=e or{}vim.cmd(string.format('set operatorfunc=v:lua.MiniSurround.%s',d))return'g@'end;a.add=function(f)if b.is_disabled()then return'<Esc>'end;local g=b.get_marks_pos(f)local h;if f=='visual'then h=b.get_surround_spec('output',false)else h=b.get_surround_spec('output',true)end;if h==nil then return'<Esc>'end;local i=b.get_config().respect_selection_type;if not i or g.selection_type=='charwise'then b.region_replace({from={line=g.second.line,col=g.second.col+1}},h.right)b.region_replace({from=g.first},h.left)b.set_cursor(g.first.line,g.first.col+h.left:len())return end;if g.selection_type=='linewise'then local j,k=g.first.line,g.second.line;local l=b.get_range_indent(j,k)b.shift_indent('>',j,k)b.set_cursor_nonblank(j)vim.fn.append(k,l..h.right)vim.fn.append(j-1,l..h.left)return end;if g.selection_type=='blockwise'then local m,n=g.first.col,g.second.col;m,n=math.min(m,n),math.max(m,n)for o=g.first.line,g.second.line do b.region_replace({from={line=o,col=n+1}},h.right)b.region_replace({from={line=o,col=m}},h.left)end;b.set_cursor(g.first.line,m+h.left:len())return end end;a.delete=function()local p=b.find_surrounding(b.get_surround_spec('input',true))if p==nil then return'<Esc>'end;b.region_replace(p.right,{})b.region_replace(p.left,{})local q=p.left.from;b.set_cursor(q.line,q.col)if not b.get_config().respect_selection_type then return end;local j,k=p.left.from.line,p.right.from.line;local r=j<k and b.is_line_blank(j)and b.is_line_blank(k)if r then b.shift_indent('<',j,k)b.set_cursor_nonblank(j+1)local s=vim.api.nvim_get_current_buf()vim.fn.deletebufline(s,k)vim.fn.deletebufline(s,j)end end;a.replace=function()local p=b.find_surrounding(b.get_surround_spec('input',true))if p==nil then return'<Esc>'end;local t=b.get_surround_spec('output',true)if t==nil then return'<Esc>'end;b.region_replace(p.right,t.right)b.region_replace(p.left,t.left)local q=p.left.from;b.set_cursor(q.line,q.col+t.left:len())end;a.find=function()local p=b.find_surrounding(b.get_surround_spec('input',true))if p==nil then return'<Esc>'end;local u=b.surr_to_pos_array(p)local v=b.cache.direction or'right'b.cursor_cycle(u,v)vim.cmd('normal! zv')end;a.highlight=function()local p=b.find_surrounding(b.get_surround_spec('input',true))if p==nil then return'<Esc>'end;local c=b.get_config()local s=vim.api.nvim_get_current_buf()b.region_highlight(s,p.left)b.region_highlight(s,p.right)vim.defer_fn(function()b.region_unhighlight(s,p.left)b.region_unhighlight(s,p.right)end,c.highlight_duration)end;a.update_n_lines=function()if b.is_disabled()then return'<Esc>'end;local w=a.user_input('New number of neighbor lines',a.config.n_lines)w=math.floor(tonumber(w)or a.config.n_lines)a.config.n_lines=w end;a.user_input=function(x,y)local z=vim.on_key or vim.register_keystroke_callback;local A=false;z(function(B)if B==vim.api.nvim_replace_termcodes('<Esc>',true,true,true)then A=true end end,b.ns_id.input)local C={prompt='(mini.surround) '..x..': ',default=y or''}vim.cmd('echohl Question')local D,E=pcall(vim.fn.input,C)vim.cmd([[echohl None | echo '' | redraw]])z(nil,b.ns_id.input)if not D or A then return end;return E end;a.gen_spec={input={},output={}}a.gen_spec.input.treesitter=function(F,C)C=vim.tbl_deep_extend('force',{use_nvim_treesitter=true},C or{})F=b.prepare_captures(F)return function()local G,H=pcall(require,'nvim-treesitter')local I=G and C.use_nvim_treesitter and b.get_matched_node_pairs_plugin or b.get_matched_node_pairs_builtin;local J=I(F)return vim.tbl_map(function(K)local L,M,N,O=K.outer:range()local P={line=L+1,col=M+1}local Q={line=N+1,col=O}local R,S;if K.inner==nil then R=Q;S=b.pos_to_right(Q)Q=nil else local T,U,V,W=K.inner:range()R={line=T+1,col=U+1}S={line=V+1,col=W}R,S=b.pos_to_left(R),b.pos_to_right(S)end;return{left={from=P,to=R},right={from=S,to=Q}}end,J)end end;b.default_config=a.config;b.ns_id={highlight=vim.api.nvim_create_namespace('MiniSurroundHighlight'),input=vim.api.nvim_create_namespace('MiniSurroundInput')}b.builtin_surroundings={['(']={input={'%b()','^.%s*().-()%s*.$'},output={left='( ',right=' )'}},[')']={input={'%b()','^.().*().$'},output={left='(',right=')'}},['[']={input={'%b[]','^.%s*().-()%s*.$'},output={left='[ ',right=' ]'}},[']']={input={'%b[]','^.().*().$'},output={left='[',right=']'}},['{']={input={'%b{}','^.%s*().-()%s*.$'},output={left='{ ',right=' }'}},['}']={input={'%b{}','^.().*().$'},output={left='{',right='}'}},['<']={input={'%b<>','^.%s*().-()%s*.$'},output={left='< ',right=' >'}},['>']={input={'%b<>','^.().*().$'},output={left='<',right='>'}},['?']={input=function()local X=a.user_input('Left surrounding')if X==nil or X==''then return end;local Y=a.user_input('Right surrounding')if Y==nil or Y==''then return end;return{vim.pesc(X)..'().-()'..vim.pesc(Y)}end,output=function()local X=a.user_input('Left surrounding')if X==nil then return end;local Y=a.user_input('Right surrounding')if Y==nil then return end;return{left=X,right=Y}end},['b']={input={{'%b()','%b[]','%b{}'},'^.().*().$'},output={left='(',right=')'}},['f']={input={'%f[%w_%.][%w_%.]+%b()','^.-%(().*()%)$'},output=function()local Z=a.user_input('Function name')if Z==nil then return nil end;return{left=('%s('):format(Z),right=')'}end},['t']={input={'<(%w-)%f[^<%w][^<>]->.-</%1>','^<.->().*()</[^/]->$'},output=function()local _=a.user_input('Tag name')if _==nil then return nil end;local a0=_:match('^%S*')return{left='<'.._..'>',right='</'..a0 ..'>'}end},['q']={input={{"'.-'",'".-"','`.-`'},'^.().*().$'},output={left='"',right='"'}}}b.cache={}b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({custom_surroundings={c.custom_surroundings,'table',true},highlight_duration={c.highlight_duration,'number'},mappings={c.mappings,'table'},n_lines={c.n_lines,'number'},respect_selection_type={c.respect_selection_type,'boolean'},search_method={c.search_method,b.is_search_method},silent={c.silent,'boolean'}})vim.validate({['mappings.add']={c.mappings.add,'string'},['mappings.delete']={c.mappings.delete,'string'},['mappings.find']={c.mappings.find,'string'},['mappings.find_left']={c.mappings.find_left,'string'},['mappings.highlight']={c.mappings.highlight,'string'},['mappings.replace']={c.mappings.replace,'string'},['mappings.update_n_lines']={c.mappings.update_n_lines,'string'},['mappings.suffix_last']={c.mappings.suffix_last,'string'},['mappings.suffix_next']={c.mappings.suffix_next,'string'}})return c end;b.apply_config=function(c)a.config=c;local a1=function(a2,a3,a4)b.map('n',a2,a3,{expr=true,desc=a4})end;local a5=c.mappings;a1(a5.add,[[v:lua.MiniSurround.operator('add')]],'Add surrounding')a1(a5.delete,[[v:lua.MiniSurround.operator('delete') . ' ']],'Delete surrounding')a1(a5.replace,[[v:lua.MiniSurround.operator('replace') . ' ']],'Replace surrounding')a1(a5.find,[[v:lua.MiniSurround.operator('find', {'direction': 'right'}) . ' ']],'Find right surrounding')a1(a5.find_left,[[v:lua.MiniSurround.operator('find', {'direction': 'left'}) . ' ']],'Find left surrounding')a1(a5.highlight,[[v:lua.MiniSurround.operator('highlight') . ' ']],'Highlight surrounding')b.map('n',a5.update_n_lines,'<Cmd>lua MiniSurround.update_n_lines()<CR>',{desc='Update `MiniSurround.config.n_lines`'})b.map('x',a5.add,[[:<C-u>lua MiniSurround.add('visual')<CR>]],{desc='Add surrounding to selection'})local a6=function(a2,a7,a3,a4)if a2==''then return end;a1(a2 ..a7,a3,a4)end;if a5.suffix_last~=''then local a8=a5.suffix_last;a6(a5.delete,a8,[[v:lua.MiniSurround.operator('delete', {'search_method': 'prev'}) . ' ']],'Delete previous surrounding')a6(a5.replace,a8,[[v:lua.MiniSurround.operator('replace', {'search_method': 'prev'}) . ' ']],'Replace previous surrounding')a6(a5.find,a8,[[v:lua.MiniSurround.operator('find', {'direction': 'right', 'search_method': 'prev'}) . ' ']],'Find previous right surrounding')a6(a5.find_left,a8,[[v:lua.MiniSurround.operator('find', {'direction': 'left', 'search_method': 'prev'}) . ' ']],'Find previous left surrounding')a6(a5.highlight,a8,[[v:lua.MiniSurround.operator('highlight', {'search_method': 'prev'}) . ' ']],'Highlight previous surrounding')end;if a5.suffix_next~=''then local a8=a5.suffix_next;a6(a5.delete,a8,[[v:lua.MiniSurround.operator('delete', {'search_method': 'next'}) . ' ']],'Delete next surrounding')a6(a5.replace,a8,[[v:lua.MiniSurround.operator('replace', {'search_method': 'next'}) . ' ']],'Replace next surrounding')a6(a5.find,a8,[[v:lua.MiniSurround.operator('find', {'direction': 'right', 'search_method': 'next'}) . ' ']],'Find next right surrounding')a6(a5.find_left,a8,[[v:lua.MiniSurround.operator('find', {'direction': 'left', 'search_method': 'next'}) . ' ']],'Find next left surrounding')a6(a5.highlight,a8,[[v:lua.MiniSurround.operator('highlight', {'search_method': 'next'}) . ' ']],'Highlight next surrounding')end end;b.is_disabled=function()return vim.g.minisurround_disable==true or vim.b.minisurround_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minisurround_config or{},c or{})end;b.is_search_method=function(a9,aa)a9=a9 or b.get_config().search_method;aa=aa or'`config.search_method`'local ab=vim.tbl_keys(b.span_compare_methods)if vim.tbl_contains(ab,a9)then return true end;table.sort(ab)local ac=table.concat(vim.tbl_map(vim.inspect,ab),', ')local ad=([[%s should be one of %s.]]):format(aa,ac)return false,ad end;b.validate_search_method=function(a9,aa)local ae,ad=b.is_search_method(a9,aa)if not ae then b.error(ad)end end;b.get_surround_spec=function(af,ag)local E;if ag then E=b.cache[af]if E~=nil then return E end end;local ah=b.user_surround_id(af)if ah==nil then return nil end;E=b.make_surrounding_table()[ah][af]if vim.is_callable(E)then E=E()end;if not b.is_surrounding_info(E,af)then return nil end;if b.is_composed_pattern(E)then E=vim.tbl_map(b.wrap_callable_table,E)end;E=setmetatable(E,{__index={id=ah}})if ag then b.cache[af]=E end;return E end;b.make_surrounding_table=function()local ai=vim.tbl_deep_extend('force',b.builtin_surroundings,b.get_config().custom_surroundings or{})for ah,aj in pairs(ai)do local ak=b.get_default_surrounding_info(ah)ai[ah]=vim.tbl_deep_extend('force',ak,aj)end;return setmetatable(ai,{__index=function(H,B)return b.get_default_surrounding_info(B)end})end;b.get_default_surrounding_info=function(ah)local al=vim.pesc(ah)return{input={al..'().-()'..al},output={left=ah,right=ah}}end;b.is_surrounding_info=function(a9,af)if af=='input'then return b.is_composed_pattern(a9)or b.is_region_pair(a9)or b.is_region_pair_array(a9)elseif af=='output'then return type(a9)=='table'and type(a9.left)=='string'and type(a9.right)=='string'end end;b.is_region=function(a9)if type(a9)~='table'then return false end;local am=type(a9.from)=='table'and type(a9.from.line)=='number'and type(a9.from.col)=='number'local an=true;if a9.to~=nil then an=type(a9.to)=='table'and type(a9.to.line)=='number'and type(a9.to.col)=='number'end;return am and an end;b.is_region_pair=function(a9)if type(a9)~='table'then return false end;return b.is_region(a9.left)and b.is_region(a9.right)end;b.is_region_pair_array=function(a9)if not vim.tbl_islist(a9)then return false end;for H,ao in ipairs(a9)do if not b.is_region_pair(ao)then return false end end;return true end;b.is_composed_pattern=function(a9)if not(vim.tbl_islist(a9)and#a9>0)then return false end;for H,ap in ipairs(a9)do local aq=type(ap)if not(aq=='table'or aq=='string'or vim.is_callable(ap))then return false end end;return true end;b.find_surrounding=function(ar,C)if ar==nil then return end;if b.is_region_pair(ar)then return ar end;C=vim.tbl_deep_extend('force',b.get_default_opts(),C or{})b.validate_search_method(C.search_method,'search_method')local as=b.find_surrounding_region_pair(ar,C)if as==nil then local ad=([[No surrounding '%s%s' found within %d line%s and `config.search_method = '%s'`.]]):format(C.n_times>1 and C.n_times or'',ar.id,C.n_lines,C.n_lines>1 and's'or'',C.search_method)b.message(ad)end;return as end;b.find_surrounding_region_pair=function(ar,C)local at,au,w=C.reference_region,C.n_times,C.n_lines;if au==0 then return end;local av=b.get_neighborhood(at,0)local aw=av.region_to_span(at)local ax=function(ay)local E=b.find_best_match(av,ar,ay,C)if E.span==nil then if w==0 or av.n_neighbors>0 then return{}end;local az=av.span_to_region(ay)av=b.get_neighborhood(at,w)aw=av.region_to_span(at)ay=av.region_to_span(az)E=b.find_best_match(av,ar,ay,C)end;return E end;local aA={span=aw}for H=1,au do aA=ax(aA.span)if aA.span==nil then return end end;local aB=function(aC,aD)if type(aD)=='table'then return aD end;local aE=av['1d']:sub(aC.from,aC.to-1)local aF=b.extract_surr_spans(aE,aD)local aG=aC.from-1;local X,Y=aF.left,aF.right;return{left={from=X.from+aG,to=X.to+aG},right={from=Y.from+aG,to=Y.to+aG}}end;local aH=aB(aA.span,aA.extract_pattern)local aI={from=aH.left.from,to=aH.right.to}if b.is_span_covering(aw,aI)then aA=ax(aA.span)if aA.span==nil then return end;aH=aB(aA.span,aA.extract_pattern)aI={from=aH.left.from,to=aH.right.to}if b.is_span_covering(aw,aI)then return end end;return{left=av.span_to_region(aH.left),right=av.span_to_region(aH.right)}end;b.get_default_opts=function()local c=b.get_config()local aJ=vim.api.nvim_win_get_cursor(0)return{n_lines=c.n_lines,n_times=vim.v.count1,reference_region={from={line=aJ[1],col=aJ[2]+1}},search_method=b.cache.search_method or c.search_method}end;b.prepare_captures=function(F)local aK=function(a9)return type(a9)=='string'and a9:sub(1,1)=='@'end;if not(type(F)=='table'and aK(F.outer)and aK(F.inner))then b.error('Wrong format for `captures`. See `MiniSurround.gen_spec.input.treesitter()` for details.')end;return{outer=F.outer,inner=F.inner}end;b.get_matched_node_pairs_plugin=function(F)local aL=require('nvim-treesitter.query')local aM=require('nvim-treesitter.parsers')local aN={}local aO=aM.get_parser(0)if aO then aO:for_each_tree(function(aP,aQ)local aR=aQ:lang()local aS=aL.get_capture_matches(0,F.outer,'textobjects',aP:root(),aR)for H,a5 in pairs(aS)do a5.lang=aR end;vim.list_extend(aN,aS)end)end;return vim.tbl_map(function(aT)local aU=aT.node;local aV=aL.get_capture_matches(0,F.inner,'textobjects',aU,aT.lang)local aW=vim.tbl_map(function(a9)return a9.node end,aV)return{outer=aU,inner=b.get_biggest_node(aW)}end,aN)end;b.get_matched_node_pairs_builtin=function(F)local aR=vim.bo.filetype;local D,aO=pcall(vim.treesitter.get_parser,0,aR)if not D then b.error_treesitter('parser',aR)end;local aX=vim.treesitter.get_query(aR,'textobjects')if aX==nil then b.error_treesitter('query',aR)end;local aY,aZ=F.outer:sub(2),F.inner:sub(2)local a_={}for H,aP in ipairs(aO:trees())do vim.list_extend(a_,b.get_builtin_matched_nodes(aY,aP:root(),aX))end;return vim.tbl_map(function(aU)local aW=b.get_builtin_matched_nodes(aZ,aU,aX)return{outer=aU,inner=b.get_biggest_node(aW)}end,a_)end;b.get_builtin_matched_nodes=function(b0,b1,aX)local E={}for b2,b3,H in aX:iter_captures(b1,0)do if aX.captures[b2]==b0 then table.insert(E,b3)end end;return E end;b.get_biggest_node=function(b4)local b5,b6=nil,-math.huge;for H,b3 in ipairs(b4)do local H,H,b7=b3:start()local H,H,b8=b3:end_()local b9=b8-b7+1;if b6<b9 then b5,b6=b3,b9 end end;return b5 end;b.error_treesitter=function(ba,aR)local bb=vim.api.nvim_get_current_buf()local ad=string.format([[Can not get %s for buffer %d and language '%s'.]],ba,bb,aR)b.error(ad)end;b.find_best_match=function(bc,ar,aw,C)local bd,be,bf;local bg=function(aC)if b.is_better_span(aC,bd,aw,C)then bd=aC;be=bf end end;if b.is_region_pair_array(ar)then for H,as in ipairs(ar)do local bh={from=as.left.from,to=as.right.to or as.right.from}if bc.is_region_inside(bh)then bf={{left=bc.region_to_span(as.left),right=bc.region_to_span(as.right)}}bg(bc.region_to_span(bh))end end else for H,bi in ipairs(b.cartesian_product(ar))do bf=bi;b.iterate_matched_spans(bc['1d'],bi,bg)end end;local aD;if be~=nil then aD=be[#be]end;return{span=bd,extract_pattern=aD}end;b.iterate_matched_spans=function(bj,bi,bg)local bk=#bi;local bl={}local bm;bm=function(bn,bo,bp)local bq=bi[bn]local br=function(aE,bs)return b.string_find(aE,bq,bs)end;if vim.is_callable(bq)then br=bq end;local bt=type(bq)=='string'and bq:match('^%%b(.)%1$')~=nil;local bs=1;while bs<=bo:len()do local q,bu=br(bo,bs)if q==nil then break end;if bn==bk then local bv=b.new_span(q+bp,bu+bp)local bw=string.format('%s_%s',bv.from,bv.to)if not bl[bw]then bg(bv)bl[bw]=true end else local bx=bo:sub(q,bu)local by=bp+q-1;bm(bn+1,bx,by)end;bs=(bt and bu or q)+1 end end;bm(1,bj,0)end;b.new_span=function(q,bu)return{from=q,to=bu==nil and q or bu+1}end;b.is_better_span=function(bz,bA,bB,C)if b.is_span_covering(bB,bz)or b.is_span_equal(bz,bB)then return false end;return b.span_compare_methods[C.search_method](bz,bA,bB)end;b.span_compare_methods={cover=function(bz,bA,bB)local E=b.is_better_covering_span(bz,bA,bB)if E~=nil then return E end;return false end,cover_or_next=function(bz,bA,bB)local E=b.is_better_covering_span(bz,bA,bB)if E~=nil then return E end;if not b.is_span_on_left(bB,bz)then return false end;if bA==nil then return true end;local bC=b.span_distance.next;return bC(bz,bB)<bC(bA,bB)end,cover_or_prev=function(bz,bA,bB)local E=b.is_better_covering_span(bz,bA,bB)if E~=nil then return E end;if not b.is_span_on_left(bz,bB)then return false end;if bA==nil then return true end;local bC=b.span_distance.prev;return bC(bz,bB)<bC(bA,bB)end,cover_or_nearest=function(bz,bA,bB)local E=b.is_better_covering_span(bz,bA,bB)if E~=nil then return E end;if bA==nil then return true end;local bC=b.span_distance.near;return bC(bz,bB)<bC(bA,bB)end,next=function(bz,bA,bB)if b.is_span_covering(bz,bB)then return false end;if not b.is_span_on_left(bB,bz)then return false end;if bA==nil then return true end;local bC=b.span_distance.next;return bC(bz,bB)<bC(bA,bB)end,prev=function(bz,bA,bB)if b.is_span_covering(bz,bB)then return false end;if not b.is_span_on_left(bz,bB)then return false end;if bA==nil then return true end;local bC=b.span_distance.prev;return bC(bz,bB)<bC(bA,bB)end,nearest=function(bz,bA,bB)if b.is_span_covering(bz,bB)then return false end;if bA==nil then return true end;local bC=b.span_distance.near;return bC(bz,bB)<bC(bA,bB)end}b.span_distance={next=function(bD,bE)return math.abs(bD.from-bE.from)end,prev=function(bD,bE)return math.abs(bD.to-bE.to)end,near=function(bD,bE)return math.min(math.abs(bD.from-bE.from),math.abs(bD.to-bE.to))end}b.is_better_covering_span=function(bz,bA,bB)local bF=b.is_span_covering(bz,bB)local bG=b.is_span_covering(bA,bB)if bF and bG then return bz.to-bz.from<bA.to-bA.from end;if bF and not bG then return true end;if not bF and bG then return false end;return nil end;b.is_span_covering=function(aC,bH)if aC==nil or bH==nil then return false end;if aC.from==aC.to then return aC.from==bH.from and bH.to==aC.to end;if bH.from==bH.to then return aC.from<=bH.from and bH.to<aC.to end;return aC.from<=bH.from and bH.to<=aC.to end;b.is_span_equal=function(bD,bE)if bD==nil or bE==nil then return false end;return bD.from==bE.from and bD.to==bE.to end;b.is_span_on_left=function(bD,bE)if bD==nil or bE==nil then return false end;return bD.from<=bE.from and bD.to<=bE.to end;b.is_point_inside_spans=function(bI,bJ)for H,aC in ipairs(bJ)do if aC[1]<=bI and bI<=aC[2]then return true end end;return false end;b.get_marks_pos=function(f)local bK,bL;if f=='visual'then bK,bL='<','>'else bK,bL='[',']'end;local bM=vim.api.nvim_buf_get_mark(0,bK)local bN=vim.api.nvim_buf_get_mark(0,bL)local bO=b.get_selection_type(f)if bO=='linewise'then bM[2]=vim.fn.indent(bM[1])bN[2]=vim.fn.col({bN[1],'$'})-2 end;bM[2],bN[2]=bM[2]+1,bN[2]+1;local bP=vim.fn.getline(bN[1])if f=='visual'and vim.o.selection=='exclusive'then bN[2]=bN[2]-1 else local bQ=vim.str_utfindex(bP,math.min(#bP,bN[2]))bN[2]=vim.str_byteindex(bP,bQ)end;return{first={line=bM[1],col=bM[2]},second={line=bN[1],col=bN[2]},selection_type=bO}end;b.get_selection_type=function(f)if f=='char'or f=='visual'and vim.fn.visualmode()=='v'then return'charwise'end;if f=='line'or f=='visual'and vim.fn.visualmode()=='V'then return'linewise'end;if f=='block'or f=='visual'and vim.fn.visualmode()=='\22'then return'blockwise'end end;b.set_cursor=function(bj,bR)vim.api.nvim_win_set_cursor(0,{bj,bR-1})end;b.set_cursor_nonblank=function(bj)b.set_cursor(bj,1)vim.cmd('normal! ^')end;b.compare_pos=function(bM,bN)if bM.line<bN.line then return'<'end;if bM.line>bN.line then return'>'end;if bM.col<bN.col then return'<'end;if bM.col>bN.col then return'>'end;return'='end;b.cursor_cycle=function(u,v)local aJ=vim.api.nvim_win_get_cursor(0)aJ={line=aJ[1],col=aJ[2]+1}local bS,bT,bU,bV;for H,bW in pairs(u)do bS=b.compare_pos(aJ,bW)bT=bS=='>'and v=='left'bU=bV==nil and bS=='<'and v=='right'if bT or bU then bV=bW end end;bV=bV or(v=='right'and u[1]or u[#u])b.set_cursor(bV.line,bV.col)end;b.user_surround_id=function(af)local bX=true;vim.defer_fn(function()if not bX then return end;local ad=string.format('Enter %s surrounding identifier (single character) ',af)b.echo(ad)b.cache.msg_shown=true end,1000)local D,ah=pcall(vim.fn.getcharstr)bX=false;b.unecho()if not D or ah=='\27'then return nil end;if ah:find('^[%w%p%s]$')==nil then b.message('Input must be single character: alphanumeric, punctuation, or space.')return nil end;return ah end;b.pos_to_left=function(bW)if bW.line==1 and bW.col==1 then return{line=bW.line,col=bW.col}end;if bW.col==1 then return{line=bW.line-1,col=b.get_line_cols(bW.line-1)}end;return{line=bW.line,col=bW.col-1}end;b.pos_to_right=function(bW)local bY=b.get_line_cols(bW.line)if bW.line==vim.api.nvim_buf_line_count(0)and bW.col>bY then return{line=bW.line,col=bY}end;if bW.col>bY then return{line=bW.line+1,col=1}end;return{line=bW.line,col=bW.col+1}end;b.region_replace=function(bZ,y)local b_,c0=bZ.from.line-1,bZ.from.col-1;local c1,c2;if b.region_is_empty(bZ)then c1,c2=b_,c0 else c1,c2=bZ.to.line-1,bZ.to.col;if c1<vim.api.nvim_buf_line_count(0)and b.get_line_cols(c1+1)<c2 then c1,c2=c1+1,0 end end;if type(y)=='string'then y={y}end;if#y>0 then y=vim.split(table.concat(y,'\n'),'\n')end;pcall(vim.api.nvim_buf_set_text,0,b_,c0,c1,c2,y)end;b.surr_to_pos_array=function(p)local E={}local c3=function(bW,c4)if bW==nil then return end;if b.get_line_cols(bW.line)<bW.col and bW.col>1 then bW=c4=='left'and b.pos_to_left(bW)or b.pos_to_right(bW)end;local bj,bR=bW.line,bW.col;local c5=E[#E]if not(c5~=nil and c5.line==bj and c5.col==bR)then table.insert(E,{line=bj,col=bR})end end;if not b.region_is_empty(p.left)then c3(p.left.from,'right')c3(p.left.to,'right')end;if not b.region_is_empty(p.right)then c3(p.right.from,'left')c3(p.right.to,'left')end;return E end;b.region_highlight=function(s,bZ)if b.region_is_empty(bZ)then return end;local c6=b.ns_id.highlight;local j,m,k,n=bZ.from.line-1,bZ.from.col-1,bZ.to.line-1,bZ.to.col;vim.highlight.range(s,c6,'MiniSurround',{j,m},{k,n})end;b.region_unhighlight=function(s,bZ)local c6=b.ns_id.highlight;vim.api.nvim_buf_clear_namespace(s,c6,bZ.from.line-1,(bZ.to or bZ.from).line)end;b.region_is_empty=function(bZ)return bZ.to==nil end;b.get_range_indent=function(j,k)local c7,c8=math.huge,nil;local c9=vim.api.nvim_buf_get_lines(0,j-1,k,true)local ca,cb;for H,cc in ipairs(c9)do H,ca,cb=cc:find('^(%s*)')if ca<c7 and ca<cc:len()then c7,c8=ca,cb end end;return c8 or''end;b.shift_indent=function(cd,j,k)if k<j then return end;vim.cmd('silent '..j..','..k..cd)end;b.is_line_blank=function(ce)return vim.fn.nextnonblank(ce)~=ce end;b.extract_surr_spans=function(aE,aD)local cf={aE:match(aD)}local cg=true;for H,bW in ipairs(cf)do if type(bW)~='number'then cg=false end end;local ch=cg and(#cf==2 or#cf==4)if not ch then local ad='Could not extract proper positions (two or four empty captures) from '..string.format([[string '%s' with extraction pattern '%s'.]],aE,aD)b.error(ad)end;if#cf==2 then return{left=b.new_span(1,cf[1]-1),right=b.new_span(cf[2],aE:len())}end;return{left=b.new_span(cf[1],cf[2]-1),right=b.new_span(cf[3],cf[4]-1)}end;b.get_neighborhood=function(at,ci)local j,k=at.from.line,(at.to or at.from).line;local cj=math.max(1,j-ci)local ck=math.min(vim.api.nvim_buf_line_count(0),k+ci)local cl=vim.api.nvim_buf_get_lines(0,cj-1,ck,false)for cm,ao in pairs(cl)do cl[cm]=ao..'\n'end;local cn=table.concat(cl,'')local co=function(bW)if bW==nil then return nil end;local ce=cj;local cp=0;while ce<bW.line do cp=cp+cl[ce-cj+1]:len()ce=ce+1 end;return cp+bW.col end;local cq=function(cp)if cp==nil then return nil end;local ce=1;local cr=0;while ce<=#cl and cr+cl[ce]:len()<cp do cr=cr+cl[ce]:len()ce=ce+1 end;return{line=cj+ce-1,col=cp-cr}end;local cs=function(bZ)if bZ==nil then return nil end;local ct=bZ.to==nil;local bu=bZ.to or bZ.from;return{from=co(bZ.from),to=co(bu)+(ct and 0 or 1)}end;local cu=function(aC)if aC==nil then return nil end;local E={from=cq(aC.from)}if aC.from<aC.to then E.to=cq(aC.to-1)end;return E end;local cv=function(bZ)local E=cj<=bZ.from.line;if bZ.to~=nil then E=E and bZ.to.line<=ck end;return E end;return{n_neighbors=ci,region=at,['1d']=cn,['2d']=cl,pos_to_offset=co,offset_to_pos=cq,region_to_span=cs,span_to_region=cu,is_region_inside=cv}end;b.echo=function(ad,cw)if b.get_config().silent then return end;ad=type(ad)=='string'and{{ad}}or ad;table.insert(ad,1,{'(mini.surround) ','WarningMsg'})local cx=vim.o.columns*math.max(vim.o.cmdheight-1,0)+vim.v.echospace;local cy,cz={},0;for H,cA in ipairs(ad)do local cB={vim.fn.strcharpart(cA[1],0,cx-cz),cA[2]}table.insert(cy,cB)cz=cz+vim.fn.strdisplaywidth(cB[1])if cz>=cx then break end end;vim.cmd([[echo '' | redraw]])vim.api.nvim_echo(cy,cw,{})end;b.unecho=function()if b.cache.msg_shown then vim.cmd([[echo '' | redraw]])end end;b.message=function(ad)b.echo(ad,true)end;b.error=function(ad)error(string.format('(mini.surround) %s',ad))end;b.map=function(f,B,a3,C)if B==''then return end;C=vim.tbl_deep_extend('force',{noremap=true,silent=true},C or{})if vim.fn.has('nvim-0.7')==0 then C.desc=nil end;vim.api.nvim_set_keymap(f,B,a3,C)end;b.get_line_cols=function(ce)return vim.fn.getline(ce):len()end;b.string_find=function(aE,bq,bs)bs=bs or 1;if bq:sub(1,1)=='^'then if bs>1 then return nil end;return string.find(aE,bq)end;local cC,H,cD=string.find(bq,'(.)%.%-')local cE=cC~=nil and cD~='%'if not cE then return string.find(aE,bq,bs)end;local q,bu=string.find(aE,bq,bs)if q==nil then return end;local cF,cG=q,bu;while cG==bu do q,bu=cF,cG;cF,cG=string.find(aE,bq,cF+1)end;return q,bu end;b.cartesian_product=function(cH)if not(type(cH)=='table'and#cH>0)then return{}end;cH=vim.tbl_map(function(a9)return vim.tbl_islist(a9)and a9 or{a9}end,cH)local E,cI={},{}local bm;bm=function(bn)for o=1,#cH[bn]do table.insert(cI,cH[bn][o])if bn==#cH then table.insert(E,vim.tbl_flatten(cI))else bm(bn+1)end;table.remove(cI,#cI)end end;bm(1)return E end;b.wrap_callable_table=function(a9)if vim.is_callable(a9)and type(a9)=='table'then return function(...)return a9(...)end end;return a9 end;return a
