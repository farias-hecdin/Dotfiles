local a={}local b={}a.setup=function(c)if vim.fn.has('nvim-0.7')==0 then vim.notify('(mini.comment) Neovim<0.7 is soft deprecated (module works but not supported).'..' It will be deprecated after Neovim 0.9.0 release (module will not work).'..' Please update your Neovim version.')end;_G.MiniComment=a;c=b.setup_config(c)b.apply_config(c)end;a.config={options={ignore_blank_line=false,start_of_line=false,pad_comment_parts=true},mappings={comment='gc',comment_line='gcc',textobject='gc'},hooks={pre=function()end,post=function()end}}a.operator=function(d)if b.is_disabled()then return''end;if d==nil then vim.cmd('set operatorfunc=v:lua.MiniComment.operator')return'g@'end;local e,f='[',']'if d=='visual'then e,f='<','>'end;local g,h=unpack(vim.api.nvim_buf_get_mark(0,e))local i,j=unpack(vim.api.nvim_buf_get_mark(0,f))if g>i or g==i and h>j then return end;vim.cmd(string.format('lockmarks lua MiniComment.toggle_lines(%d, %d)',g,i))return''end;a.toggle_lines=function(k,l)if b.is_disabled()then return end;local m=vim.api.nvim_buf_line_count(0)if not(1<=k and k<=m and 1<=l and l<=m)then error(('(mini.comment) `line_start` and `line_end` should be within range [1; %s].'):format(m))end;if not(k<=l)then error('(mini.comment) `line_start` should be less than or equal to `line_end`.')end;local c=b.get_config()if c.hooks.pre()==false then return end;local n=b.make_comment_parts()local o=vim.api.nvim_buf_get_lines(0,k-1,l,false)local p,q=b.get_lines_info(o,n,b.get_config().options)local r;if q then r=b.make_uncomment_function(n)else r=b.make_comment_function(n,p)end;for s,t in pairs(o)do o[s]=r(t)end;vim.api.nvim_buf_set_lines(0,k-1,l,false,o)if c.hooks.post()==false then return end end;a.textobject=function()if b.is_disabled()then return end;local c=b.get_config()if c.hooks.pre()==false then return end;local n=b.make_comment_parts()local u=b.make_comment_check(n)local v=vim.api.nvim_win_get_cursor(0)[1]if u(vim.fn.getline(v))then local k=v;while k>=2 and u(vim.fn.getline(k-1))do k=k-1 end;local l=v;local m=vim.api.nvim_buf_line_count(0)while l<=m-1 and u(vim.fn.getline(l+1))do l=l+1 end;vim.cmd(string.format('normal! %dGV%dG',k,l))end;if c.hooks.post()==false then return end end;b.default_config=a.config;b.setup_config=function(c)vim.validate({config={c,'table',true}})c=vim.tbl_deep_extend('force',b.default_config,c or{})vim.validate({options={c.options,'table'},mappings={c.mappings,'table'},hooks={c.hooks,'table'}})vim.validate({['options.ignore_blank_line']={c.options.ignore_blank_line,'boolean'},['options.start_of_line']={c.options.start_of_line,'boolean'},['options.pad_comment_parts']={c.options.pad_comment_parts,'boolean'},['mappings.comment']={c.mappings.comment,'string'},['mappings.comment_line']={c.mappings.comment_line,'string'},['mappings.textobject']={c.mappings.textobject,'string'},['hooks.pre']={c.hooks.pre,'function'},['hooks.post']={c.hooks.post,'function'}})return c end;b.apply_config=function(c)a.config=c;b.map('n',c.mappings.comment,'v:lua.MiniComment.operator()',{expr=true,desc='Comment'})b.map('x',c.mappings.comment,[[:<c-u>lua MiniComment.operator('visual')<cr>]],{desc='Comment selection'})b.map('n',c.mappings.comment_line,'v:lua.MiniComment.operator() . "_"',{expr=true,desc='Comment line'})b.map('o',c.mappings.textobject,'<cmd>lua MiniComment.textobject()<cr>',{desc='Comment textobject'})end;b.is_disabled=function()return vim.g.minicomment_disable==true or vim.b.minicomment_disable==true end;b.get_config=function(c)return vim.tbl_deep_extend('force',a.config,vim.b.minicomment_config or{},c or{})end;b.make_comment_parts=function()local w=b.get_config().options;local x=vim.api.nvim_buf_get_option(0,'commentstring')if x==''then vim.api.nvim_echo({{'(mini.comment) ','WarningMsg'},{[[Option 'commentstring' is empty.]]}},true,{})return{left='',right=''}end;local y,z=x:match('^%s*(.*)%%s(.-)%s*$')if w.pad_comment_parts then y,z=vim.trim(y),vim.trim(z)end;return{left=y,right=z}end;b.make_comment_check=function(n)local t,A=n.left,n.right;local B=b.get_config().options.start_of_line and''or'%s-'local C='^'..B..vim.pesc(t)..'.*'..vim.pesc(A)..'%s-$'return function(D)return D:find(C)~=nil end end;b.get_lines_info=function(o,n,w)local E,F=math.huge,math.huge;local p,G;local q=true;local u=b.make_comment_check(n)local H=w.ignore_blank_line;for I,t in pairs(o)do I,F,G=t:find('^(%s*)')local J=F==t:len()if F<E and not J then E=F;p=G end;if not(H and J)then q=q and u(t)end end;return p or'',q end;b.make_comment_function=function(n,p)local w=b.get_config().options;local K=p:len()+1;local t,A=n.left,n.right;local L=w.pad_comment_parts and t~=''and' 'or''local M=w.pad_comment_parts and A~=''and' 'or''local N=p..t..A;local O,P=t:gsub('%%','%%%%'),A:gsub('%%','%%%%')local y=w.start_of_line and O..p or p..O;local Q=y..L..'%s'..M..P;local H=w.ignore_blank_line;return function(D)if D:find('^%s*$')~=nil then return H and D or N end;return string.format(Q,D:sub(K))end end;b.make_uncomment_function=function(n)local w=b.get_config().options;local t,A=n.left,n.right;local L=w.pad_comment_parts and t~=''and'[ ]?'or''local M=w.pad_comment_parts and A~=''and'[ ]?'or''local R=string.format('^(%%s*)%s%s(.-)%s%s%%s-$',vim.pesc(t),L,M,vim.pesc(A))return function(D)local p,S=string.match(D,R)if S==nil then return D end;if S==''then p=''end;return('%s%s'):format(p,S)end end;b.map=function(d,T,U,V)if T==''then return end;V=vim.tbl_deep_extend('force',{noremap=true,silent=true},V or{})if vim.fn.has('nvim-0.7')==0 then V.desc=nil end;vim.api.nvim_set_keymap(d,T,U,V)end;return a
