local a=require('gitsigns.signs').Sign;local b=require('gitsigns.status').StatusObj;local c=require('gitsigns.util')local d,e=math.min,math.max;local f={Node={},Hunk={},Hunk_Public={}}local g=f.Hunk;function f.create_hunk(h,i,j,k)return{removed={start=h,count=i,lines={}},added={start=j,count=k,lines={}},head=('@@ -%d%s +%d%s @@'):format(h,i>0 and','..i or'',j,k>0 and','..k or''),vend=j+math.max(k-1,0),type=k==0 and'delete'or i==0 and'add'or'change'}end;function f.create_partial_hunk(l,m,n)local o,p=m,n-m+1;for q,r in ipairs(l)do local s=r.added.count-r.removed.count;local t=0;if r.added.start>=m and r.vend<=n then t=s else local u=e(0,n+1-(r.added.start+r.removed.count))local v=e(0,m-(r.added.start+r.removed.count))if r.added.start>=m and r.added.start<=n then t=u elseif r.vend>=m and r.vend<=n then t=s-v;o=o-v elseif r.added.start<=m and r.vend>=n then t=u-v;o=o-v end;if m>r.vend then o=o-s end end;p=p-t end;if p==0 then o=o-1 end;return f.create_hunk(o,p,m,n-m+1)end;function f.patch_lines(w,x)local y={}for q,z in ipairs(w.removed.lines)do y[#y+1]='-'..z end;for q,z in ipairs(w.added.lines)do y[#y+1]='+'..z end;if x=='dos'then y=c.strip_cr(y)end;return y end;function f.parse_diff_line(A)local B=vim.trim(vim.split(A,'@@',true)[2])local C,D=unpack(vim.tbl_map(function(E)return vim.split(string.sub(E,2),',')end,vim.split(B,' ')))local w=f.create_hunk(tonumber(C[1]),tonumber(C[2])or 1,tonumber(D[1]),tonumber(D[2])or 1)w.head=A;return w end;local function F(w)if w.added.count==0 then return w.added.start elseif w.removed.count==0 then return w.added.start+w.added.count-1 else return w.added.start+d(w.added.count,w.removed.count)-1 end end;function f.calc_signs(w,G,H,I)assert(not I or w.type=='add')G=G or 1;H=H or math.huge;local J,K,L=w.added.start,w.added.count,w.removed.count;if w.type=='delete'and J==0 then if G<=1 then return{{type='topdelete',count=L,lnum=1}}else return{}end end;local M={}local N=F(w)for O=e(J,G),d(N,H)do local P=w.type=='change'and L>K and O==N;M[#M+1]={type=P and'changedelete'or I and'untracked'or w.type,count=O==J and(w.type=='add'and K or L),lnum=O}end;if w.type=="change"and K>L and w.vend>=G and N<=H then for O=e(N,G),d(w.vend,H)do M[#M+1]={type='add',count=O==w.vend and K-L,lnum=O}end end;return M end;function f.create_patch(Q,l,R,S)S=S or false;local T={string.format('diff --git a/%s b/%s',Q,Q),'index 000000..000000 '..R,'--- a/'..Q,'+++ b/'..Q}local U=0;for q,V in ipairs(l)do local J,W,X=V.removed.start,V.removed.count,V.added.count;if V.type=='add'then J=J+1 end;local Y=V.removed.lines;local Z=V.added.lines;if S then W,X=X,W;Y,Z=Z,Y end;table.insert(T,string.format('@@ -%s,%s +%s,%s @@',J,W,J+U,X))for q,z in ipairs(Y)do T[#T+1]='-'..z end;for q,z in ipairs(Z)do T[#T+1]='+'..z end;V.removed.start=J+U;U=U+X-W end;return T end;function f.get_summary(l)local _={added=0,changed=0,removed=0}for q,w in ipairs(l or{})do if w.type=='add'then _.added=_.added+w.added.count elseif w.type=='delete'then _.removed=_.removed+w.removed.count elseif w.type=='change'then local a0,a1=w.added.count,w.removed.count;local a2=d(a0,a1)_.changed=_.changed+a2;_.added=_.added+a0-a2;_.removed=_.removed+a1-a2 end end;return _ end;function f.find_hunk(O,l)for a3,w in ipairs(l)do if O==1 and w.added.start==0 and w.vend==0 then return w,a3 end;if w.added.start<=O and w.vend>=O then return w,a3 end end end;function f.find_nearest_hunk(O,l,a4,a5)local a6;local a7;if a4 then for a3=1,#l do local w=l[a3]if w.added.start>O then a6=w;a7=a3;break end end else for a3=#l,1,-1 do local w=l[a3]if w.vend<O then a6=w;a7=a3;break end end end;if not a6 and a5 then a7=a4 and 1 or#l;a6=l[a7]end;return a6,a7 end;function f.compare_heads(a8,a9)if a8==nil~=(a9==nil)then return true elseif a8 and#a8~=#a9 then return true end;for a3,aa in ipairs(a8 or{})do if a9[a3].head~=aa.head then return true end end;return false end;return f
